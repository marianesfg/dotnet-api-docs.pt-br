<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Socket.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac53e382a75359056b74e79a6c44021c6bb0b7e382c.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3e382a75359056b74e79a6c44021c6bb0b7e382c</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Implements the Berkeley sockets interface.</source>
          <target state="translated">Implementa a interface de soquetes Berkeley.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class provides a rich set of methods and properties for network communications.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> classe fornece um conjunto rico de métodos e propriedades para as comunicações de rede.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class allows you to perform both synchronous and asynchronous data transfer using any of the communication protocols listed in the <ph id="ph2">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> enumeration.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> classe permite que você execute ambos síncrona e transferência de dados assíncrona usando qualquer um dos protocolos de comunicação listados no <ph id="ph2">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> enumeração.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class follows the .NET Framework naming pattern for asynchronous methods.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> classe segue o padrão de nomenclatura do .NET Framework para métodos assíncronos.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>For example, the synchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method corresponds to the asynchronous <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> methods.</source>
          <target state="translated">Por exemplo, o síncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método corresponde à assíncrona <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> e <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If your application only requires one thread during execution, use the following methods, which are designed for synchronous operation mode.</source>
          <target state="translated">Se seu aplicativo requer apenas um thread durante a execução, use os métodos a seguir, que são projetados para o modo de operação síncrona.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you are using a connection-oriented protocol such as TCP, your server can listen for connections using the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão como TCP, o servidor pode escutar conexões usando o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method processes any incoming connection requests and returns a <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that you can use to communicate data with the remote host.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> processos de método solicitações de qualquer conexão de entrada e retorna um <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> que você pode usar para se comunicar dados com o host remoto.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Use this returned <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
          <target state="translated">Use este retornado <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> para chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method prior to calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method if you want to specify the local IP address and port number.</source>
          <target state="translated">Chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> método antes de chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> método se você deseja especificar o número de porta e endereço IP local.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Use a port number of zero if you want the underlying service provider to assign a free port for you.</source>
          <target state="translated">Use um número de porta de zero se quiser que o provedor de serviço subjacente para atribuir uma porta disponível para você.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you want to connect to a listening host, call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">Se você quiser se conectar a um host de escutando, chame o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>To communicate data, call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
          <target state="translated">Para se comunicar dados, chame o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you are using a connectionless protocol such as UDP, you do not need to listen for connections at all.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão como UDP, você não precisa escutar conexões em todos os.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method to accept any incoming datagrams.</source>
          <target state="translated">Chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método para aceitar a entrada datagramas.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method to send datagrams to a remote host.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> método enviar datagramas para um host remoto.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>To process communications using separate threads during execution, use the following methods, which are designed for asynchronous operation mode.</source>
          <target state="translated">Para processar comunicações usando threads separados durante a execução, use os métodos a seguir, que são projetados para o modo de operação assíncrona.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you are using a connection-oriented protocol such as TCP, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> methods to connect with a listening host.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão como TCP, use o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, e <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> métodos para se conectar com um host de escutando.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> methods to communicate data asynchronously.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> e <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> métodos para se comunicar dados de forma assíncrona.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Incoming connection requests can be processed using <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>.</source>
          <target state="translated">Solicitações de conexão de entrada podem ser processadas usando <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you are using a connectionless protocol such as UDP, you can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> to send datagrams, and <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> to receive datagrams.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão como UDP, você pode usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> para enviar datagramas, e <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> e <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> para receber datagramas.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you perform multiple asynchronous operations on a socket, they do not necessarily complete in the order in which they are started.</source>
          <target state="translated">Se você executar várias operações assíncronas em um soquete, não sejam necessariamente concluídas na ordem em que eles são iniciados.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>When you are finished sending and receiving data, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method to disable the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Quando tiver terminado de enviar e receber dados, use o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> método para desativar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>After calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method to release all resources associated with the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Depois de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, chame o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> método para liberar todos os recursos associados a <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class allows you to configure your <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> classe permite que você configure seu <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> usando o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Retrieve these settings using the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">Recuperar essas configurações usando o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you are writing a relatively simple application and do not require maximum performance, consider using <ph id="ph1">&lt;xref:System.Net.Sockets.TcpClient&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.TcpListener&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.UdpClient&gt;</ph>.</source>
          <target state="translated">Se você estiver escrevendo um aplicativo relativamente simples e não requerem desempenho máximo, considere o uso de <ph id="ph1">&lt;xref:System.Net.Sockets.TcpClient&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.TcpListener&gt;</ph>, e <ph id="ph3">&lt;xref:System.Net.Sockets.UdpClient&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>These classes provide a simpler and more user-friendly interface to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> communications.</source>
          <target state="translated">Essas classes fornecem uma interface simples e mais amigável para <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> comunicações.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>The following code example shows how the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class can be used to send data to an HTTP server and receive the response.</source>
          <target state="translated">O seguinte exemplo de código mostra como o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> classe pode ser usada para enviar dados para um servidor HTTP e receber a resposta.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>This example blocks until the entire page is received.</source>
          <target state="translated">Este exemplo bloqueia até que a página inteira seja recebida.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>To establish an outgoing connection or accept an incoming request.</source>
          <target state="translated">para estabelecer uma conexão de saída ou aceitar uma solicitação de entrada.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Instances of this class are thread safe.</source>
          <target state="translated">As instâncias dessa classe serão thread-safe.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)">
          <source>The socket information returned by <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /&gt;</ph>.</source>
          <target state="translated">As informações de soquete retornadas por <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class using the specified value returned from <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /&gt;</ph>.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, usando o valor especificado de <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)">
          <source>If you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>s with the same underlying socket.</source>
          <target state="translated">Se você chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph> construtor várias vezes com a mesma matriz de bytes como o argumento para cada chamada, você criará vários gerenciado <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>s com o mesmo soquete subjacente.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)">
          <source>This practice is strongly discouraged.</source>
          <target state="translated">Essa prática é altamente desaconselhável.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph> values.</source>
          <target state="translated">Um dos valores de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph> values.</source>
          <target state="translated">Um dos valores de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class using the specified socket type and protocol.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> usando o tipo de soquete e o protocolo especificados.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The <ph id="ph1">`socketType`</ph> parameter specifies the type of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class and the <ph id="ph3">`protocolType`</ph> parameter specifies the protocol used by <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">`socketType`</ph> parâmetro especifica o tipo do <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> classe e o <ph id="ph3">`protocolType`</ph> parâmetro especifica o protocolo usado pelo <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The two parameters are not independent.</source>
          <target state="translated">Os dois parâmetros não são independentes.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>Often the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type is implicit in the protocol.</source>
          <target state="translated">Geralmente o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> tipo está implícito no protocolo.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>If the combination of <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type and protocol type results in an invalid <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, this constructor throws a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se a combinação de <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> tipo e o protocolo digite resultados inválido <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, este construtor lança um <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>If this constructor throws a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se este construtor lança um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The combination of  <ph id="ph1">&lt;paramref name="socketType" /&gt;</ph> and <ph id="ph2">&lt;paramref name="protocolType" /&gt;</ph> results in an invalid socket.</source>
          <target state="translated">A combinação de <ph id="ph1">&lt;paramref name="socketType" /&gt;</ph> e <ph id="ph2">&lt;paramref name="protocolType" /&gt;</ph> resulta em um soquete inválido.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.AddressFamily" /&gt;</ph> values.</source>
          <target state="translated">Um dos valores de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.AddressFamily" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph> values.</source>
          <target state="translated">Um dos valores de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph> values.</source>
          <target state="translated">Um dos valores de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class using the specified address family, socket type and protocol.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> usando a família de endereços, o tipo de soquete e o protocolo especificados.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The <ph id="ph1">`addressFamily`</ph> parameter specifies the addressing scheme that the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class uses, the <ph id="ph3">`socketType`</ph> parameter specifies the type of the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class, and the <ph id="ph5">`protocolType`</ph> parameter specifies the protocol used by <ph id="ph6">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">`addressFamily`</ph> parâmetro especifica o esquema de endereçamento que o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> classe usos, o <ph id="ph3">`socketType`</ph> parâmetro especifica o tipo do <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> classe e o <ph id="ph5">`protocolType`</ph> parâmetro especifica o protocolo usado pelo <ph id="ph6">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The three parameters are not independent.</source>
          <target state="translated">Os três parâmetros não são independentes.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>Some address families restrict which protocols can be used with them, and often the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type is implicit in the protocol.</source>
          <target state="translated">Algumas famílias de endereço restringem quais protocolos podem ser usados com eles e geralmente o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> tipo está implícito no protocolo.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>If the combination of address family, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type, and protocol type results in an invalid <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, this constructor throws a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se a combinação de família de endereço, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> tipo e resultados de tipo inválido do protocolo <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, este construtor lança um <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>If this constructor throws a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se este construtor lança um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The following code example demonstrates how to create an instance of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class.</source>
          <target state="translated">O exemplo de código a seguir demonstra como criar uma instância do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The combination of <ph id="ph1">&lt;paramref name="addressFamily" /&gt;</ph>, <ph id="ph2">&lt;paramref name="socketType" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="protocolType" /&gt;</ph> results in an invalid socket.</source>
          <target state="translated">A combinação de <ph id="ph1">&lt;paramref name="addressFamily" /&gt;</ph>, <ph id="ph2">&lt;paramref name="socketType" /&gt;</ph> e <ph id="ph3">&lt;paramref name="protocolType" /&gt;</ph> resulta em um soquete inválido.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Accept">
          <source>Creates a new <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> for a newly created connection.</source>
          <target state="translated">Cria um novo <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> para uma conexão recém-criada.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Accept">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> for a newly created connection.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> para uma conexão recém-criada.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> synchronously extracts the first pending connection request from the connection request queue of the listening socket, and then creates and returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> modo síncrono extrai a primeira solicitação de conexão pendente da fila de solicitações de conexão de soquete de escuta e, em seguida, cria e retorna um novo <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>You cannot use this returned <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept any additional connections from the connection queue.</source>
          <target state="translated">Você não pode usar isso retornado <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> para aceitar conexões da fila de conexão adicionais.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>However, you can call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> method of the returned <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to identify the remote host's network address and port number.</source>
          <target state="translated">No entanto, você pode chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> método retornado <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> para identificar o número de porta e endereço de rede do host remoto.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>In blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> blocks until an incoming connection attempt is queued.</source>
          <target state="translated">No modo de bloqueio, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> bloqueia até que uma tentativa de conexão de entrada está na fila.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>Once a connection is accepted, the original <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> continues queuing incoming connection requests until you close it.</source>
          <target state="translated">Depois que uma conexão é aceita, o original <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> continua a conexão de enfileiramento de mensagens de entrada solicitações até que você feche-lo.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>If you call this method using a non-blocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, and no connection requests are queued, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> throws a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você chamar este método usando sem bloqueio <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>e nenhuma conexão solicitações são enfileiradas, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> lança um <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>Before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method, you must first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.</source>
          <target state="translated">Antes de chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> método, você deve primeiro chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> método para escutar e a fila de solicitações de conexão de entrada.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>The following code example accepts a simple <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection.</source>
          <target state="translated">O exemplo de código a seguir aceita um simples <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> conexão.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Accept">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Accept">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Accept">
          <source>The accepting socket is not listening for connections.</source>
          <target state="translated">O soquete de aceitação não está escutando conexões.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Accept">
          <source>You must call <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> before calling <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.Accept" /&gt;</ph>.</source>
          <target state="translated">É necessário chamar <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> e <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> antes de chamar <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.Accept" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> a ser usado nessa operação de soquete assíncrono.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins an asynchronous operation to accept an incoming connection attempt.</source>
          <target state="translated">Inicia uma operação assíncrona para aceitar uma tentativa de conexão de entrada.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">Retorna <ph id="ph1">&lt;see langword="true" /&gt;</ph> se a operação de E/S está pendente.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">O evento <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> no parâmetro <ph id="ph2">&lt;paramref name="e" /&gt;</ph> será acionado após a conclusão da operação.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">Retorna <ph id="ph1">&lt;see langword="false" /&gt;</ph> se a operação de E/S foi concluída de forma síncrona.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">O evento <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> no parâmetro <ph id="ph2">&lt;paramref name="e" /&gt;</ph> não será acionado e o objeto <ph id="ph3">&lt;paramref name="e" /&gt;</ph> passado como um parâmetro poderá ser examinado imediatamente depois que a chamada do método for retornada para recuperar o resultado da operação.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Connection-oriented protocols can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> method to asynchronously process incoming connection attempts.</source>
          <target state="translated">Protocolos orientados a Conexão podem usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> tentativas de método para processar a conexão de entrada de forma assíncrona.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</source>
          <target state="translated">Aceitando conexões de forma assíncrona fornece a capacidade de enviar e receber dados dentro de um thread de execução separado.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> method, you must call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.</source>
          <target state="translated">Antes de chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> método, você deve chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> método para escutar e a fila de solicitações de conexão de entrada.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>To be notified of completion, you must create a callback method that implements the EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs&gt; delegate and hook it to the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">Para ser notificado de conclusão, você deve criar um método de retorno de chamada que implementa EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs &gt; delegar e associá-lo para o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required:</source>
          <target state="translated">As seguintes propriedades e eventos no <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> objeto são necessárias:</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller can optionally specify an existing <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to use for the incoming connection by specifying the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to use with the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">O chamador pode especificar opcionalmente um existente <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> a ser usado para a conexão de entrada, especificando o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> para usar com o <ph id="ph3">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType&gt;</ph> property is null, a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is constructed with the same <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AddressFamily%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SocketType%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.ProtocolType%2A&gt;</ph> as the current <ph id="ph6">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and set as the <ph id="ph7">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Se o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType&gt;</ph> propriedade for nula, uma nova <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> é construído com o mesmo <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AddressFamily%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SocketType%2A&gt;</ph>, e <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.ProtocolType%2A&gt;</ph> atual <ph id="ph6">&lt;xref:System.Net.Sockets.Socket&gt;</ph> e defina como o <ph id="ph7">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">O chamador pode definir o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> propriedade para qualquer objeto de estado do usuário desejado antes de chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> método, para que as informações serão recuperáveis no método de retorno de chamada.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">Se o retorno de chamada precisa de mais informações do que um único objeto, uma pequena classe pode ser criada para manter as outras informações de estado necessárias como membros.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Optionally, a buffer may be provided in which to receive the initial block of data on the socket after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method succeeds.</source>
          <target state="translated">Opcionalmente, um buffer pode ser fornecido no qual deseja receber o bloco inicial de dados no soquete após o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> método for bem-sucedido.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> property needs to be set to the buffer containing the data to receive and the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> property needs to be set to the maximum number of bytes of data to receive in the buffer.</source>
          <target state="translated">Nesse caso, o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> propriedade deve ser definida para o buffer que contém os dados para receber e <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> propriedade precisa ser definido como o número máximo de bytes de dados para o buffer de recebimento.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>These properties can be set using the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Essas propriedades podem ser definidas usando o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Part of the buffer passed in will be consumed internally for use by the underlying Winsock AcceptEx call.</source>
          <target state="translated">Parte do buffer transmitido será consumido internamente para uso pela chamada de Winsock AcceptEx subjacente.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This means that the amount of data returned will always be less than the value of the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> property on the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> instance provided.</source>
          <target state="translated">Isso significa que a quantidade de dados retornados será sempre menor que o valor da <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> propriedade o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> instância fornecida.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The amount of the buffer used internally varies based on the address family of the socket.</source>
          <target state="translated">A quantidade de buffer usado internamente varia de acordo com a família de endereços do soquete.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The minimum buffer size required is 288 bytes.</source>
          <target state="translated">O tamanho de buffer mínimo necessário é 288 bytes.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If a larger buffer size is specified, then the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> will expect some extra data other than the address data received by the Winsock AcceptEx call and will wait until this extra data is received.</source>
          <target state="translated">Se um tamanho de buffer maior for especificado, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> esperam que alguns dados adicionais que não sejam os dados de endereço recebidos pela chamada Winsock AcceptEx e aguardará até que esses dados extras são recebidos.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If a timeout occurs, the connection is reset.</source>
          <target state="translated">Se ocorrer uma expiração, a conexão será redefinida.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>So if extra data is expected of  a specific amount, then the buffer size should be set to the minimum buffer size plus this amount.</source>
          <target state="translated">Então se dados extras esperados de um valor específico, o tamanho do buffer deve ser definido para o tamanho do buffer mínimo mais esse valor.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The completion callback method should examine the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> property to determine if the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> operation was successful.</source>
          <target state="translated">O método de retorno de chamada de conclusão deve examinar o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> para determinar se o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> a operação foi bem-sucedida.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event can occur in some cases when no connection has been accepted and cause the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> property to be set to <ph id="ph3">&lt;xref:System.Net.Sockets.SocketError.ConnectionReset&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> evento pode ocorrer em alguns casos, quando nenhuma conexão foi aceito e fazer com que o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> propriedade a ser definida <ph id="ph3">&lt;xref:System.Net.Sockets.SocketError.ConnectionReset&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This can occur as a result of port scanning using a half-open SYN type scan (a SYN -&gt; SYN-ACK -&gt; RST sequence).</source>
          <target state="translated">Isso pode ocorrer como resultado da verificação de portas com uma verificação de tipo entreaberto sin (um SYN -&gt; SYN ACK-&gt; sequência da primeira).</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Applications using the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> method should be prepared to handle this condition.</source>
          <target state="translated">Aplicativos que usam o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> método deve estar preparado para tratar essa condição.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An argument is not valid.</source>
          <target state="translated">Um argumento não é válido.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception occurs if the buffer provided is not large enough.</source>
          <target state="translated">Essa exceção ocorre se o buffer fornecido não for grande o suficiente.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The buffer must be at least 2 * (sizeof(SOCKADDR_STORAGE + 16) bytes.</source>
          <target state="translated">O buffer deve ter pelo menos 2 * (sizeof(SOCKADDR_STORAGE + 16) bytes.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception also occurs if multiple buffers are specified, the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> property is not null.</source>
          <target state="translated">Essa exceção também ocorre se vários buffers forem especificados e a propriedade <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> não for nula.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An argument is out of range.</source>
          <target state="translated">Um argumento está fora do intervalo.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The exception occurs if the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /&gt;</ph> is less than 0.</source>
          <target state="translated">A exceção ocorre se o <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /&gt;</ph> for menor que 0.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An invalid operation was requested.</source>
          <target state="translated">Uma operação inválida foi solicitada.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception occurs if the accepting <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is not listening for connections or the accepted socket is bound.</source>
          <target state="translated">Essa exceção ocorre se o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> aceito não estiver escutando conexões ou se o soquete aceito estiver associado.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>You must call the <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> method before calling the <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /&gt;</ph> method.</source>
          <target state="translated">Você deve chamar o método <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> e <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> antes de chamar o método <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception also occurs if the socket is already connected or a socket operation was already in progress using the specified <ph id="ph1">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated">Essa exceção também ocorre se o soquete já estiver conectado ou se uma operação de soquete já estivesse em andamento usando o parâmetro <ph id="ph1">&lt;paramref name="e" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">É necessário o Windows XP ou posterior para esse método.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.AddressFamily">
          <source>Gets the address family of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Obtém a família de endereços do <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.AddressFamily">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.AddressFamily" /&gt;</ph> values.</source>
          <target state="translated">Um dos valores de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.AddressFamily" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.AddressFamily">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> specifies the addressing scheme that an instance of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class can use.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> Especifica o esquema de endereçamento que uma instância do <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> pode usar a classe.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.AddressFamily">
          <source>This property is read-only and is set when the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is created.</source>
          <target state="translated">Essa propriedade é somente leitura e é definida quando o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> é criado.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.AddressFamily">
          <source>The following code example displays the <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> to the console.</source>
          <target state="translated">O código a seguir exemplo exibe o <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType&gt;</ph>, e <ph id="ph3">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> para o console.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Available">
          <source>Gets the amount of data that has been received from the network and is available to be read.</source>
          <target state="translated">Obtém a quantidade de dados recebidos da rede e disponíveis para leitura.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>The number of bytes of data received from the network and available to be read.</source>
          <target state="translated">O número de bytes de dados recebidos da rede e disponíveis para serem lidos.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>If you are using a non-blocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is a good way to determine whether data is queued for reading, before calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">Se você estiver usando sem bloqueio <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> é uma boa maneira de determinar se a dados está na fila para leitura, antes de chamar <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>The available data is the total amount of data queued in the network buffer for reading.</source>
          <target state="translated">Os dados disponíveis serão a quantidade total de dados no buffer de rede para leitura.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>If no data is queued in the network buffer, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> returns 0.</source>
          <target state="translated">Se nenhum dado é enfileirado no buffer de rede, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> retornará 0.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>If the remote host shuts down or closes the connection, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> can throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se o host remoto é desligado ou fecha a conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> pode lançar um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>The following code example compares the results of calling IOControl with FIONREAD and the Available property.</source>
          <target state="translated">O exemplo de código a seguir compara os resultados da chamada IOControl com FIONREAD e a propriedade disponível.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Available">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Available">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Begins an asynchronous operation to accept an incoming connection attempt.</source>
          <target state="translated">Inicia uma operação assíncrona para aceitar uma tentativa de conexão de entrada.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">O delegado <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Um objeto que contém informações de estado para essa solicitação.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous operation to accept an incoming connection attempt.</source>
          <target state="translated">Inicia uma operação assíncrona para aceitar uma tentativa de conexão de entrada.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> creation.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que faz referência à criação assíncrona do <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Connection-oriented protocols can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method to asynchronously process incoming connection attempts.</source>
          <target state="translated">Protocolos orientados a Conexão podem usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> tentativas de método para processar a conexão de entrada de forma assíncrona.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</source>
          <target state="translated">Aceitando conexões de forma assíncrona fornece a capacidade de enviar e receber dados dentro de um thread de execução separado.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, you must call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.</source>
          <target state="translated">Antes de chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método, você deve chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> método para escutar e a fila de solicitações de conexão de entrada.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>You must create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">Você deve criar um método de retorno de chamada que implementa o <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegar e passar o nome para o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, you must pass the listening <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> through the <ph id="ph3">`state`</ph> parameter.</source>
          <target state="translated">Para fazer isso, no mínimo, você deve passar a escuta <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> do objeto para <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> por meio de <ph id="ph3">`state`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">Se o retorno de chamada precisa de mais informações, você pode criar uma pequena classe para manter o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> e outras informações necessárias.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Passar uma instância dessa classe para o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método por meio de <ph id="ph2">`state`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method.</source>
          <target state="translated">O método de retorno de chamada deve chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, the system usually uses a separate thread to execute the specified callback method and blocks on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> until a pending connection is retrieved.</source>
          <target state="translated">Quando o aplicativo chama <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, geralmente, o sistema usa um thread separado para executar o método de retorno de chamada especificada e blocos em <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> até que uma conexão pendente seja recuperada.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> will return a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object that you can use to send and receive data with the remote host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> Retorna um novo <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> do objeto que você pode usar para enviar e receber dados com o host remoto.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>You cannot use this returned <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept any additional connections from the connection queue.</source>
          <target state="translated">Você não pode usar isso retornado <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> para aceitar conexões da fila de conexão adicionais.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se você quiser que o thread original para bloquear depois de chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Call the Set method on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Chame o método de conjunto em um <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> no método de retorno de chamada quando o thread original para continuar a executar.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The system may also use the calling thread to invoke the callback method.</source>
          <target state="translated">O sistema também pode usar o thread de chamada para invocar o método de retorno de chamada.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> property on the returned <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> will be set to indicate that the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method completed synchronously.</source>
          <target state="translated">Nesse caso, o <ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> propriedade retornado <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> será definida para indicar que o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método concluído de forma síncrona.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte <bpt id="p1">[</bpt>Marshaling de um delegado como um método de retorno de chamada<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Para cancelar uma chamada pendente para o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método, feche o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method is called.</source>
          <target state="translated">Quando o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> método é chamado durante uma operação assíncrona está em andamento, o retorno de chamada fornecido para o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método é chamado.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">Uma chamada subsequente para a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> método lançará um <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> para indicar que a operação foi cancelada.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> property of the returned <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to identify the remote host's network address and port number.</source>
          <target state="translated">Você pode usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> propriedade retornado <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> para identificar o número de porta e endereço de rede do host remoto.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a Windows Sockets versão 2 API documentação códigos de erro no MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Após o primeiro uso de um contexto específico (um determinado assíncrono <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> método, uma determinada <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The following code example attempts to receive an incoming connection asynchronously.</source>
          <target state="translated">O exemplo de código a seguir tenta receber uma conexão de entrada de forma assíncrona.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Windows NT is required for this method.</source>
          <target state="translated">Windows NT é necessário para esse método.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The accepting socket is not listening for connections.</source>
          <target state="translated">O soquete de aceitação não está escutando conexões.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>You must call <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> before calling <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          <target state="translated">É necessário chamar <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> e <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> antes de chamar <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The accepted socket is bound.</source>
          <target state="translated">O soquete aceito está associado.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="receiveSize" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="receiveSize" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The number of bytes to accept from the sender.</source>
          <target state="translated">O número de bytes a serem aceitos do remetente.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">O delegado <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Um objeto que contém informações de estado para essa solicitação.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous operation to accept an incoming connection attempt and receives the first block of data sent by the client application.</source>
          <target state="translated">Inicia uma operação assíncrona para aceitar uma tentativa de conexão de entrada e recebe o primeiro bloco de dados enviado pelo aplicativo cliente.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> creation.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que faz referência à criação assíncrona do <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Connection-oriented protocols can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method to asynchronously process incoming connection attempts.</source>
          <target state="translated">Protocolos orientados a Conexão podem usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> tentativas de método para processar a conexão de entrada de forma assíncrona.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Accepting connections asynchronously enables you to send and receive data within a separate execution thread.</source>
          <target state="translated">Aceitando conexões de forma assíncrona permite enviar e receber dados dentro de um thread de execução separado.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>This overload allows you to specify the number of bytes to accept in the initial transfer in the <ph id="ph1">`receiveSize`</ph> parameter.</source>
          <target state="translated">Essa sobrecarga permite que você especifique o número de bytes para aceitar a transferência inicial no <ph id="ph1">`receiveSize`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, you must call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.</source>
          <target state="translated">Antes de chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método, você deve chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> método para escutar e a fila de solicitações de conexão de entrada.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>You must create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">Você deve criar um método de retorno de chamada que implementa o <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegar e passar o nome para o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, you must pass the listening <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> through the <ph id="ph3">`state`</ph> parameter.</source>
          <target state="translated">Para fazer isso, no mínimo, você deve passar a escuta <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> do objeto para <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> por meio de <ph id="ph3">`state`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">Se o retorno de chamada precisa de mais informações, você pode criar uma pequena classe para manter o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> e outras informações necessárias.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Passar uma instância dessa classe para o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método por meio de <ph id="ph2">`state`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method.</source>
          <target state="translated">O método de retorno de chamada deve chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, the system usually uses a separate thread to execute the specified callback method and blocks on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> until a pending connection is retrieved.</source>
          <target state="translated">Quando o aplicativo chama <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, geralmente, o sistema usa um thread separado para executar o método de retorno de chamada especificada e blocos em <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> até que uma conexão pendente seja recuperada.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that you can use to send and receive data with the remote host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> Retorna um novo <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> que você pode usar para enviar e receber dados com o host remoto.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>You cannot use this returned <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept any additional connections from the connection queue.</source>
          <target state="translated">Você não pode usar isso retornado <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> para aceitar conexões da fila de conexão adicionais.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se você quiser que o thread original para bloquear depois de chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Chame o método de conjunto em um <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> no método de retorno de chamada quando o thread original para continuar a executar.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The system may also use the calling thread to invoke the callback method.</source>
          <target state="translated">O sistema também pode usar o thread de chamada para invocar o método de retorno de chamada.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> property on the returned <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> will be set to indicate that the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method completed synchronously.</source>
          <target state="translated">Nesse caso, o <ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> propriedade retornado <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> será definida para indicar que o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método concluído de forma síncrona.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte <bpt id="p1">[</bpt>Marshaling de um delegado como um método de retorno de chamada<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Para cancelar uma chamada pendente para o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método, feche o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method is called.</source>
          <target state="translated">Quando o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> método é chamado durante uma operação assíncrona está em andamento, o retorno de chamada fornecido para o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método é chamado.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">Uma chamada subsequente para a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> método lançará um <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> para indicar que a operação foi cancelada.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>You can call use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> property of the returned <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to identify the remote host's network address and port number.</source>
          <target state="translated">Você pode chamar o uso de <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> propriedade retornado <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> objeto para identificar o número de porta e endereço de rede do host remoto.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Após o primeiro uso de um contexto específico (um determinado assíncrono <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> método, uma determinada <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The following code example opens a socket and accepts an asynchronous connection.</source>
          <target state="translated">O exemplo de código a seguir abre um soquete e aceita uma conexão assíncrona.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>In this example, the socket accepts the initial 10 bytes of data.</source>
          <target state="translated">Neste exemplo, o soquete aceita inicias 10 bytes de dados.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The number of bytes received and the data are displayed on the console by the callback delegate.</source>
          <target state="translated">O número de bytes recebidos e os dados são exibidos no console, o representante de retorno de chamada.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>See <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> for a description of how the remaining data is received.</source>
          <target state="translated">Consulte <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> para obter uma descrição de como os dados restantes são recebidos.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Windows NT is required for this method.</source>
          <target state="translated">Windows NT é necessário para esse método.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The accepting socket is not listening for connections.</source>
          <target state="translated">O soquete de aceitação não está escutando conexões.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>You must call <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> before calling <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          <target state="translated">É necessário chamar <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> e <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> antes de chamar <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The accepted socket is bound.</source>
          <target state="translated">O soquete aceito está associado.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="receiveSize" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="receiveSize" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The accepted <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> aceito.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>This value may be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Este valor pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The maximum number of bytes to receive.</source>
          <target state="translated">O número máximo de bytes a serem recebidos.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">O delegado <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Um objeto que contém informações de estado para essa solicitação.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous operation to accept an incoming connection attempt from a specified socket and receives the first block of data sent by the client application.</source>
          <target state="translated">Inicia uma operação assíncrona para aceitar uma tentativa de conexão de entrada de um soquete especificado e recebe o primeiro bloco de dados enviado pelo aplicativo cliente.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that references the asynchronous <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object creation.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que faz referência à criação do objeto <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> assíncrono.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Connection-oriented protocols can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method to asynchronously process incoming connection attempts.</source>
          <target state="translated">Protocolos orientados a Conexão podem usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> tentativas de método para processar a conexão de entrada de forma assíncrona.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</source>
          <target state="translated">Aceitando conexões de forma assíncrona fornece a capacidade de enviar e receber dados dentro de um thread de execução separado.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>This overload allows you to specify the accepted socket in the <ph id="ph1">`acceptSocket`</ph> parameter.</source>
          <target state="translated">Essa sobrecarga permite que você especifique o soquete aceito o <ph id="ph1">`acceptSocket`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>If this parameter is <ph id="ph1">`null`</ph>, the accepted socket is created by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">Se esse parâmetro for <ph id="ph1">`null`</ph>, o soquete aceito é criado pelo <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>You can specify the number of bytes to accept in the initial transfer in the <ph id="ph1">`receiveSize`</ph> parameter.</source>
          <target state="translated">Você pode especificar o número de bytes para aceitar a transferência inicial no <ph id="ph1">`receiveSize`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, you must call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.</source>
          <target state="translated">Antes de chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método, você deve chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> método para escutar e a fila de solicitações de conexão de entrada.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>You must create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">Você deve criar um método de retorno de chamada que implementa o <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegar e passar o nome para o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, you must pass the listening <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> through the <ph id="ph3">`state`</ph> parameter.</source>
          <target state="translated">Para fazer isso, no mínimo, você deve passar a escuta <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> do objeto para <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> por meio de <ph id="ph3">`state`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">Se o retorno de chamada precisa de mais informações, você pode criar uma pequena classe para manter o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> e outras informações necessárias.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Passar uma instância dessa classe para o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método por meio de <ph id="ph2">`state`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method.</source>
          <target state="translated">O método de retorno de chamada deve chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, the system usually uses a separate thread to execute the specified callback method and blocks on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> until a pending connection is retrieved.</source>
          <target state="translated">Quando o aplicativo chama <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, geralmente, o sistema usa um thread separado para executar o método de retorno de chamada especificada e blocos em <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> até que uma conexão pendente seja recuperada.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object that you can use to send and receive data with the remote host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> Retorna um novo <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> do objeto que você pode usar para enviar e receber dados com o host remoto.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>You cannot use this returned <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept any additional connections from the connection queue.</source>
          <target state="translated">Você não pode usar isso retornado <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> para aceitar conexões da fila de conexão adicionais.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se você quiser que o thread original para bloquear depois de chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Chame o método de conjunto em um <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> no método de retorno de chamada quando o thread original para continuar a executar.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The system may also use the calling thread to invoke the callback method.</source>
          <target state="translated">O sistema também pode usar o thread de chamada para invocar o método de retorno de chamada.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> property on the returned <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> will be set to indicate that the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method completed synchronously.</source>
          <target state="translated">Nesse caso, o <ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> propriedade retornado <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> será definida para indicar que o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método concluído de forma síncrona.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods, see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte <bpt id="p1">[</bpt>Marshaling de um delegado como um método de retorno de chamada<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Para cancelar uma chamada pendente para o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método, feche o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method is called.</source>
          <target state="translated">Quando o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> método é chamado durante uma operação assíncrona está em andamento, o retorno de chamada fornecido para o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método é chamado.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">Uma chamada subsequente para a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> método lançará um <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> para indicar que a operação foi cancelada.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> property of the returned <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to identify the remote host's network address and port number.</source>
          <target state="translated">Você pode usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> propriedade retornado <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> objeto para identificar o número de porta e endereço de rede do host remoto.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Após o primeiro uso de um contexto específico (um determinado assíncrono <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> método, uma determinada <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The following code example opens a socket and accepts an asynchronous connection.</source>
          <target state="translated">O exemplo de código a seguir abre um soquete e aceita uma conexão assíncrona.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>In this example, the socket accepts the initial 10 bytes of data and the <ph id="ph1">`acceptSocket`</ph> parameter is <ph id="ph2">`null`</ph>, which forces the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method to create the accepted socket.</source>
          <target state="translated">Neste exemplo, o soquete aceita inicias 10 bytes de dados e o <ph id="ph1">`acceptSocket`</ph> parâmetro é <ph id="ph2">`null`</ph>, que força o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método para criar o soquete aceito.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The number of bytes received and the data are displayed on the console by the callback delegate.</source>
          <target state="translated">O número de bytes recebidos e os dados são exibidos no console, o representante de retorno de chamada.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>See <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> for a description of how the remaining data is received.</source>
          <target state="translated">Consulte <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> para obter uma descrição de como os dados restantes são recebidos.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Windows NT is required for this method.</source>
          <target state="translated">Windows NT é necessário para esse método.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The accepting socket is not listening for connections.</source>
          <target state="translated">O soquete de aceitação não está escutando conexões.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>You must call <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> before calling <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          <target state="translated">É necessário chamar <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> e <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> antes de chamar <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The accepted socket is bound.</source>
          <target state="translated">O soquete aceito está associado.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="receiveSize" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="receiveSize" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Begins an asynchronous request for a remote host connection.</source>
          <target state="translated">Inicia uma solicitação assíncrona para uma conexão de host remoto.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">O delegado <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Um objeto que contém informações de estado para essa solicitação.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous request for a remote host connection.</source>
          <target state="translated">Inicia uma solicitação assíncrona para uma conexão de host remoto.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous connection.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que faz referência à conexão assíncrona.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method starts an asynchronous request for a connection to the <ph id="ph2">`remoteEP`</ph> parameter.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> método inicia uma solicitação assíncrona para uma conexão para o <ph id="ph2">`remoteEP`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> establishes a default remote host.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> estabelece um host remoto padrão.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Connecting or setting the default remote host asynchronously gives you the ability to send and receive data within a separate execution thread.</source>
          <target state="translated">Conectar ou configurar o host remoto padrão assincronamente fornece a capacidade de enviar e receber dados dentro de um thread de execução separado.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method.</source>
          <target state="translated">Você pode criar um método de retorno de chamada que implementa o <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegar e passar o nome para o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>At the very minimum, you must pass the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> through the <ph id="ph3">`state`</ph> parameter.</source>
          <target state="translated">No mínimo, você deve passar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> para <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> por meio de <ph id="ph3">`state`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, and the other required information.</source>
          <target state="translated">Se o retorno de chamada precisa de mais informações, você pode criar uma pequena classe para manter o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>e as outras informações necessárias.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Passar uma instância dessa classe para o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> método por meio de <ph id="ph2">`state`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.</source>
          <target state="translated">O método de retorno de chamada deve chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connects successfully or throws an exception.</source>
          <target state="translated">Quando o aplicativo chama <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, o sistema usará um thread separado para executar o método de retorno de chamada especificada e bloqueará <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> até que o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> se conecta com êxito ou gera uma exceção.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>.</source>
          <target state="translated">Se você quiser que o thread original para bloquear depois de chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> método, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Chame o método de conjunto em um <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> no método de retorno de chamada quando o thread original para continuar a executar.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte <bpt id="p1">[</bpt>Marshaling de um delegado como um método de retorno de chamada<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão como UDP, você não precisa chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> antes de enviar e receber dados.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> to communicate with a remote host.</source>
          <target state="translated">Você pode usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> para se comunicar com um host remoto.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">Se você chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, datagramas que chegam de um endereço diferente do padrão especificado serão descartadas.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you wish to set your default remote host to a broadcast address, you must first call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> and set Broadcast to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Se você deseja definir seu host remoto padrão para um endereço de difusão, você deve primeiro chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> e defina a transmissão para <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you cannot, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se não for possível, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connection-oriented protocol and do not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão e não chame <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> antes de chamar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local mais adequado.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um protocolo sem conexão, o provedor de serviços não atribuirá um número de porta e endereço de rede local até que você chame o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you want to change the default remote host, call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method again with the desired endpoint.</source>
          <target state="translated">Se você quiser alterar o host remoto padrão, chame o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> método novamente com o ponto de extremidade desejado.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Para cancelar uma chamada pendente para o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> método, feche o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method is called.</source>
          <target state="translated">Quando o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> método é chamado durante uma operação assíncrona está em andamento, o retorno de chamada fornecido para o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> método é chamado.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">Uma chamada subsequente para a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> método lançará um <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> para indicar que a operação foi cancelada.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If this socket has previously been disconnected, then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> must be called on a thread that will not exit until the operation is complete.</source>
          <target state="translated">Se este soquete anteriormente foi desconectado, em seguida, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> deve ser chamado em um thread que não sairá até que a operação seja concluída.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">Essa é uma limitação do provedor subjacente.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Após o primeiro uso de um contexto específico (um determinado assíncrono <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> método, uma determinada <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The following code example initiates an asynchronous connection attempt.</source>
          <target state="translated">O exemplo de código a seguir inicia uma tentativa de conexão assíncrona.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">Um chamador mais alto na pilha de chamadas não tem permissão para a operação solicitada.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>, or an asynchronous operation is already in progress.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi colocado em um estado de escuta chamando <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> ou uma operação assíncrona já está em andamento.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> of the remote host.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> do host remoto.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The port number of the remote host.</source>
          <target state="translated">O número da porta do host remoto.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the connect operation.</source>
          <target state="translated">Um objeto definido pelo usuário que contém informações sobre a operação de conexão.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <bpt id="p1">&lt;c&gt;</bpt>requestCallback<ept id="p1">&lt;/c&gt;</ept> delegate when the operation is complete.</source>
          <target state="translated">Este objeto é passado para o delegado <bpt id="p1">&lt;c&gt;</bpt>requestCallback<ept id="p1">&lt;/c&gt;</ept> quando a operação é concluída.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous request for a remote host connection.</source>
          <target state="translated">Inicia uma solicitação assíncrona para uma conexão de host remoto.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The host is specified by an <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> and a port number.</source>
          <target state="translated">O host é especificado por um <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> e um número da porta.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous connection.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que faz referência à conexão assíncrona.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.</source>
          <target state="translated">O assíncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> operação deve ser concluída chamando o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`requestCallback`</ph> delegate.</source>
          <target state="translated">Normalmente, o método é invocado pelo <ph id="ph1">`requestCallback`</ph> delegate.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">Esse método não bloqueia até que a operação seja concluída.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method overloads, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>.</source>
          <target state="translated">Para bloquear até que a operação for concluída, use um do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> sobrecargas de método ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Para cancelar uma chamada pendente para o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> método, feche o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method is called.</source>
          <target state="translated">Quando o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> método é chamado durante uma operação assíncrona está em andamento, o retorno de chamada fornecido para o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> método é chamado.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">Uma chamada subsequente para a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> método lançará um <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> para indicar que a operação foi cancelada.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></source>
          <target state="translated">Para obter informações detalhadas sobre como usar o modelo de programação assíncrono, consulte <bpt id="p1">[</bpt>chamando métodos síncronos assincronamente<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>If this socket has previously been disconnected, then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> must be called on a thread that will not exit until the operation is complete.</source>
          <target state="translated">Se este soquete anteriormente foi desconectado, em seguida, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> deve ser chamado em um thread que não sairá até que a operação seja concluída.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">Essa é uma limitação do provedor subjacente.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>Also the <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> that is used must be different.</source>
          <target state="translated">Também o <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> que é usado deve ser diferente.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Após o primeiro uso de um contexto específico (um determinado assíncrono <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> método, uma determinada <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The following code example initiates an asynchronous connection attempt.</source>
          <target state="translated">O exemplo de código a seguir inicia uma tentativa de conexão assíncrona.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="address" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="address" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is not in the socket family.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> não está na família do soquete.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The port number is not valid.</source>
          <target state="translated">O número da porta é inválido.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The length of <ph id="ph1">&lt;paramref name="address" /&gt;</ph> is zero.</source>
          <target state="translated">O comprimento de <ph id="ph1">&lt;paramref name="address" /&gt;</ph> é zero.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>, or an asynchronous operation is already in progress.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi colocado em um estado de escuta chamando <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> ou uma operação assíncrona já está em andamento.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>At least one <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph>, designating the remote host.</source>
          <target state="translated">Pelo menos um <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph>, designando o host remoto.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The port number of the remote host.</source>
          <target state="translated">O número da porta do host remoto.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the connect operation.</source>
          <target state="translated">Um objeto definido pelo usuário que contém informações sobre a operação de conexão.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <bpt id="p1">&lt;c&gt;</bpt>requestCallback<ept id="p1">&lt;/c&gt;</ept> delegate when the operation is complete.</source>
          <target state="translated">Este objeto é passado para o delegado <bpt id="p1">&lt;c&gt;</bpt>requestCallback<ept id="p1">&lt;/c&gt;</ept> quando a operação é concluída.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous request for a remote host connection.</source>
          <target state="translated">Inicia uma solicitação assíncrona para uma conexão de host remoto.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The host is specified by an <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> array and a port number.</source>
          <target state="translated">O host é especificado por uma matriz <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> e um número da porta.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous connections.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que faz referência a conexões assíncronas.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.</source>
          <target state="translated">O assíncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> operação deve ser concluída chamando o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`requestCallback`</ph> delegate.</source>
          <target state="translated">Normalmente, o método é invocado pelo <ph id="ph1">`requestCallback`</ph> delegate.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">Esse método não bloqueia até que a operação seja concluída.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method overloads.</source>
          <target state="translated">Para bloquear até que a operação for concluída, use um do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> sobrecargas do método.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Para cancelar uma chamada pendente para o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> método, feche o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method is called.</source>
          <target state="translated">Quando o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> método é chamado durante uma operação assíncrona está em andamento, o retorno de chamada fornecido para o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> método é chamado.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">Uma chamada subsequente para a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> método lançará um <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> para indicar que a operação foi cancelada.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
          <target state="translated">Para obter informações detalhadas sobre como usar o modelo de programação assíncrono, consulte <bpt id="p1">[</bpt>chamando métodos síncronos assincronamente<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>If this socket has previously been disconnected, then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> must be called on a thread that will not exit until the operation is complete.</source>
          <target state="translated">Se este soquete anteriormente foi desconectado, em seguida, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> deve ser chamado em um thread que não sairá até que a operação seja concluída.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">Essa é uma limitação do provedor subjacente.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>Also the <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> that is used must be different.</source>
          <target state="translated">Também o <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> que é usado deve ser diferente.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Após o primeiro uso de um contexto específico (um determinado assíncrono <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> método, uma determinada <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The following code example initiates an asynchronous connection attempt.</source>
          <target state="translated">O exemplo de código a seguir inicia uma tentativa de conexão assíncrona.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="addresses" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="addresses" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>This method is valid for sockets that use <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph>.</source>
          <target state="translated">Este método é válido para soquetes que usam <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> ou <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The port number is not valid.</source>
          <target state="translated">O número da porta é inválido.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The length of <ph id="ph1">&lt;paramref name="address" /&gt;</ph> is zero.</source>
          <target state="translated">O comprimento de <ph id="ph1">&lt;paramref name="address" /&gt;</ph> é zero.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>, or an asynchronous operation is already in progress.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi colocado em um estado de escuta chamando <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> ou uma operação assíncrona já está em andamento.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The name of the remote host.</source>
          <target state="translated">O nome do host remoto.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The port number of the remote host.</source>
          <target state="translated">O número da porta do host remoto.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the connect operation.</source>
          <target state="translated">Um objeto definido pelo usuário que contém informações sobre a operação de conexão.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <bpt id="p1">&lt;c&gt;</bpt>requestCallback<ept id="p1">&lt;/c&gt;</ept> delegate when the operation is complete.</source>
          <target state="translated">Este objeto é passado para o delegado <bpt id="p1">&lt;c&gt;</bpt>requestCallback<ept id="p1">&lt;/c&gt;</ept> quando a operação é concluída.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous request for a remote host connection.</source>
          <target state="translated">Inicia uma solicitação assíncrona para uma conexão de host remoto.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The host is specified by a host name and a port number.</source>
          <target state="translated">O host é especificado por um nome do host e um número da porta.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous connection.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que faz referência à conexão assíncrona.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.</source>
          <target state="translated">O assíncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> operação deve ser concluída chamando o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`requestCallback`</ph> delegate.</source>
          <target state="translated">Normalmente, o método é invocado pelo <ph id="ph1">`requestCallback`</ph> delegate.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">Esse método não bloqueia até que a operação seja concluída.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method overloads.</source>
          <target state="translated">Para bloquear até que a operação for concluída, use um do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> sobrecargas do método.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the  <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Para cancelar uma chamada pendente para o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> método, feche o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method is called.</source>
          <target state="translated">Quando o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> método é chamado durante uma operação assíncrona está em andamento, o retorno de chamada fornecido para o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> método é chamado.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">Uma chamada subsequente para a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> método lançará um <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> para indicar que a operação foi cancelada.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></source>
          <target state="translated">Para obter informações detalhadas sobre como usar o modelo de programação assíncrono, consulte <bpt id="p1">[</bpt>chamando métodos síncronos assincronamente<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>If this socket has previously been disconnected, then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> must be called on a thread that will not exit until the operation is complete.</source>
          <target state="translated">Se este soquete anteriormente foi desconectado, em seguida, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> deve ser chamado em um thread que não sairá até que a operação seja concluída.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">Essa é uma limitação do provedor subjacente.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>Also the <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> that is used must be different.</source>
          <target state="translated">Também o <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> que é usado deve ser diferente.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Após o primeiro uso de um contexto específico (um determinado assíncrono <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> método, uma determinada <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The following code example initiates an asynchronous connection attempt.</source>
          <target state="translated">O exemplo de código a seguir inicia uma tentativa de conexão assíncrona.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="host" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="host" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>This method is valid for sockets in the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> families.</source>
          <target state="translated">Este método é válido para soquetes nas famílias <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> ou <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The port number is not valid.</source>
          <target state="translated">O número da porta é inválido.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>, or an asynchronous operation is already in progress.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi colocado em um estado de escuta chamando <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> ou uma operação assíncrona já está em andamento.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this socket can be reused after the connection is closed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o soquete puder ser reutilizado após a conexão ser fechada; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">O delegado <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Um objeto que contém informações de estado para essa solicitação.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous request to disconnect from a remote endpoint.</source>
          <target state="translated">Inicia uma solicitação assíncrona para se desconectar de um ponto de extremidade remoto.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that references the asynchronous operation.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que faz referência à operação assíncrona.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>If you are using a connection-oriented protocol, you can call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> method to request a disconnect from a remote endpoint.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, você pode chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> método para solicitar uma desconexão de um ponto de extremidade remoto.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>If <ph id="ph1">`reuseSocket`</ph> is <ph id="ph2">`true`</ph>, you can reuse the socket.</source>
          <target state="translated">Se <ph id="ph1">`reuseSocket`</ph> é <ph id="ph2">`true`</ph>, você pode reutilizar o soquete.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> method uses a separate thread to invoke the specified callback method.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> método usa um thread separado para invocar o método de retorno de chamada especificada.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> method blocks until the pending disconnect is complete.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> blocos de método até a desconexão pendente é concluída.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods, see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte <bpt id="p1">[</bpt>Marshaling de um delegado como um método de retorno de chamada<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exceção, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>The following code example creates a socket for asynchronous communication and sends some data to a remote host.</source>
          <target state="translated">O exemplo de código a seguir cria um soquete para comunicação assíncrona e envia alguns dados para um host remoto.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>When the data has been sent, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> is called to stop the send and receive activity.</source>
          <target state="translated">Quando os dados foram enviados, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> é chamado para parar o envio e a atividade de recebimento.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>Then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> is called to begin a disconnect request.</source>
          <target state="translated">Em seguida, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> é chamado para iniciar uma solicitação de desconexão.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>When the request completes, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property is queried to test whether the socket is disconnected.</source>
          <target state="translated">Quando a solicitação é concluída, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> propriedade será consultada para testar se o soquete está desconectado.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>The operating system is Windows 2000 or earlier, and this method requires Windows XP.</source>
          <target state="translated">O sistema operacional é o Windows 2000 ou anterior e esse método requer o Windows XP.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Begins to asynchronously receive data from a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Começa a receber de maneira assíncrona dados de um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> conectado.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que é o local de armazenamento dos dados recebidos.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Uma combinação bit a bit dos valores <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate that references the method to invoke when the operation is complete.</source>
          <target state="translated">Um delegado <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> que faz referência ao método a ser invocado quando a operação é concluída.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the receive operation.</source>
          <target state="translated">Um objeto definido pelo usuário que contém informações sobre a operação de recebimento.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> delegate when the operation is complete.</source>
          <target state="translated">Esse objeto é passado para o delegado <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> quando a operação é concluída.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Begins to asynchronously receive data from a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Começa a receber de maneira assíncrona dados de um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> conectado.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous read.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que faz referência à leitura assíncrona.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method.</source>
          <target state="translated">O assíncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operação deve ser concluída chamando o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`callback`</ph> delegate.</source>
          <target state="translated">Normalmente, o método é invocado pelo <ph id="ph1">`callback`</ph> delegate.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">Esse método não bloqueia até que a operação seja concluída.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method overloads.</source>
          <target state="translated">Para bloquear até que a operação for concluída, use um do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> sobrecargas do método.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">Para cancelar um pendente <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, chame o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
          <target state="translated">Para obter informações detalhadas sobre como usar o modelo de programação assíncrono, consulte <bpt id="p1">[</bpt>chamando métodos síncronos assincronamente<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">E/s iniciada por um determinado thread é cancelada quando que sai do thread.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> é uma instanciação de uma classe definida pelo usuário.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Após o primeiro uso de um contexto específico (um determinado assíncrono <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> método, uma determinada <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que é o local de armazenamento dos dados recebidos.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Uma combinação bit a bit dos valores <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> que armazena o erro de soquete.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate that references the method to invoke when the operation is complete.</source>
          <target state="translated">Um delegado <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> que faz referência ao método a ser invocado quando a operação é concluída.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the receive operation.</source>
          <target state="translated">Um objeto definido pelo usuário que contém informações sobre a operação de recebimento.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> delegate when the operation is complete.</source>
          <target state="translated">Esse objeto é passado para o delegado <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> quando a operação é concluída.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Begins to asynchronously receive data from a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Começa a receber de maneira assíncrona dados de um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> conectado.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous read.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que faz referência à leitura assíncrona.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method.</source>
          <target state="translated">O assíncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operação deve ser concluída chamando o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`callback`</ph> delegate.</source>
          <target state="translated">Normalmente, o método é invocado pelo <ph id="ph1">`callback`</ph> delegate.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">Esse método não bloqueia até que a operação seja concluída.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method overloads.</source>
          <target state="translated">Para bloquear até que a operação for concluída, use um do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> sobrecargas do método.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">Para cancelar um pendente <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, chame o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
          <target state="translated">Para obter informações detalhadas sobre como usar o modelo de programação assíncrono, consulte <bpt id="p1">[</bpt>chamando métodos síncronos assincronamente<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">E/s iniciada por um determinado thread é cancelada quando que sai do thread.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> é uma instanciação de uma classe definida pelo usuário.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Após o primeiro uso de um contexto específico (um determinado assíncrono <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> método, uma determinada <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que é o local de armazenamento dos dados recebidos.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The zero-based position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter at which to store the received data.</source>
          <target state="translated">A posição baseada em zero no parâmetro <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> no qual armazenar os dados recebidos.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The number of bytes to receive.</source>
          <target state="translated">O número de bytes a serem recebidos.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate that references the method to invoke when the operation is complete.</source>
          <target state="translated">Um delegado <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> que faz referência ao método a ser invocado quando a operação é concluída.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the receive operation.</source>
          <target state="translated">Um objeto definido pelo usuário que contém informações sobre a operação de recebimento.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> delegate when the operation is complete.</source>
          <target state="translated">Esse objeto é passado para o delegado <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> quando a operação é concluída.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Begins to asynchronously receive data from a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Começa a receber de maneira assíncrona dados de um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> conectado.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous read.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que faz referência à leitura assíncrona.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method.</source>
          <target state="translated">O assíncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operação deve ser concluída chamando o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`callback`</ph> delegate.</source>
          <target state="translated">Normalmente, o método é invocado pelo <ph id="ph1">`callback`</ph> delegate.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">Esse método não bloqueia até que a operação seja concluída.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method overloads.</source>
          <target state="translated">Para bloquear até que a operação for concluída, use um do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> sobrecargas do método.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">Para cancelar um pendente <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, chame o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
          <target state="translated">Para obter informações detalhadas sobre como usar o modelo de programação assíncrono, consulte <bpt id="p1">[</bpt>chamando métodos síncronos assincronamente<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">E/s iniciada por um determinado thread é cancelada quando que sai do thread.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> é uma instanciação de uma classe definida pelo usuário.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Após o primeiro uso de um contexto específico (um determinado assíncrono <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> método, uma determinada <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The following code example begins to asynchronously receive data from a connected <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir começa assincronamente receba dados de um conectado <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> é maior que o comprimento do <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é maior que o comprimento da subtração de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> e do valor do parâmetro <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que é o local de armazenamento dos dados recebidos.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The location in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> to store the received data.</source>
          <target state="translated">O local no <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> para armazenar os dados recebidos.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The number of bytes to receive.</source>
          <target state="translated">O número de bytes a serem recebidos.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate that references the method to invoke when the operation is complete.</source>
          <target state="translated">Um delegado <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> que faz referência ao método a ser invocado quando a operação é concluída.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the receive operation.</source>
          <target state="translated">Um objeto definido pelo usuário que contém informações sobre a operação de recebimento.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> delegate when the operation is complete.</source>
          <target state="translated">Esse objeto é passado para o delegado <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> quando a operação é concluída.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Begins to asynchronously receive data from a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Começa a receber de maneira assíncrona dados de um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> conectado.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous read.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que faz referência à leitura assíncrona.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method.</source>
          <target state="translated">O assíncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operação deve ser concluída chamando o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`callback`</ph> delegate.</source>
          <target state="translated">Normalmente, o método é invocado pelo <ph id="ph1">`callback`</ph> delegate.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">Esse método não bloqueia até que a operação seja concluída.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method overloads.</source>
          <target state="translated">Para bloquear até que a operação for concluída, use um do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> sobrecargas do método.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">Para cancelar um pendente <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, chame o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
          <target state="translated">Para obter informações detalhadas sobre como usar o modelo de programação assíncrono, consulte <bpt id="p1">[</bpt>chamando métodos síncronos assincronamente<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">E/s iniciada por um determinado thread é cancelada quando que sai do thread.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> é uma instanciação de uma classe definida pelo usuário.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Após o primeiro uso de um contexto específico (um determinado assíncrono <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> método, uma determinada <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> é maior que o comprimento do <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é maior que o comprimento da subtração de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> e do valor do parâmetro <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que é o local de armazenamento dos dados recebidos.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The zero-based position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter at which to store the data.</source>
          <target state="translated">A posição baseada em zero no parâmetro <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> no qual armazenar os dados.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The number of bytes to receive.</source>
          <target state="translated">O número de bytes a serem recebidos.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">O delegado <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Um objeto que contém informações de estado para essa solicitação.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Begins to asynchronously receive data from a specified network device.</source>
          <target state="translated">Começa a receber dados de um dispositivo de rede especificado de maneira assíncrona.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous read.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que faz referência à leitura assíncrona.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method starts asynchronously reading connectionless datagrams from a remote host.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> método inicia de forma assíncrona lendo datagramas sem conexão de um host remoto.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method gives you the ability to receive data within a separate execution thread.</source>
          <target state="translated">Chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> método lhe oferece a capacidade de receber dados dentro de um thread de execução separado.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Você pode criar um método de retorno de chamada que implementa o <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegar e passar o nome para o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
          <target state="translated">Para fazer isso, no mínimo, o <ph id="ph1">`state`</ph> parâmetro deve conter conectado ou padrão <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> que está sendo usada para comunicação.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">Se o retorno de chamada precisa de mais informações, você pode criar uma pequena classe para manter o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> e outras informações necessárias.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Passar uma instância dessa classe para o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> método por meio de <ph id="ph2">`state`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">O método de retorno de chamada deve chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and it will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> reads data or throws an exception.</source>
          <target state="translated">Quando o aplicativo chama <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, o sistema usará um thread separado para executar o método de retorno de chamada especificada e ela bloqueará <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> até que o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> lê os dados ou gera uma exceção.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se você quiser que o thread original para bloquear depois de chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> método, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Chame o método de conjunto em um t: System.Threading.ManualResetEvent no método de retorno de chamada quando o thread original para continuar a executar.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods, see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte <bpt id="p1">[</bpt>Marshaling de um delegado como um método de retorno de chamada<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, or <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> will throw a <ph id="ph5">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Antes de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, você deve associar explicitamente o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> para um ponto de extremidade local usando o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> método, ou <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> lançará um <ph id="ph5">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This method reads data into the <ph id="ph1">`buffer`</ph> parameter, and captures the remote host endpoint from which the data is sent.</source>
          <target state="translated">Esse método lê os dados para o <ph id="ph1">`buffer`</ph> parâmetro e capturas de ponto de extremidade do qual os dados são enviados de host remoto.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>For information on how to retrieve this endpoint, refer to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>.</source>
          <target state="translated">Para obter informações sobre como recuperar esse ponto de extremidade, consulte <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</source>
          <target state="translated">Esse método é mais útil se você pretende assincronamente receber datagramas sem conexão de um host desconhecido ou vários hosts.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>In these cases, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.</source>
          <target state="translated">Nesses casos, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> lerá o datagrama enfileiradas primeiro recebido no buffer de rede local.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If the datagram you receive is larger than the size of <ph id="ph1">`buffer`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method will fill <ph id="ph3">`buffer`</ph> with as much of the message as is possible, and throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se o datagrama receber é maior que o tamanho de <ph id="ph1">`buffer`</ph>, o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> método preencherá <ph id="ph3">`buffer`</ph> com tanta da mensagem como é possível e lançar um <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you are using an unreliable protocol, the excess data will be lost.</source>
          <target state="translated">Se você estiver usando um protocolo não confiável, o excesso de dados serão perdido.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method with a large enough buffer.</source>
          <target state="translated">Se você estiver usando um protocolo confiável, o excesso de dados será retido pelo provedor de serviço e você poderá recuperá-lo ao chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> método com um buffer grande o suficiente.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>To guarantee that the remote host endpoint is always returned, an application should explicitly bind the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method and then call the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method with the <ph id="ph4">`optionLevel`</ph> parameter set to <ph id="ph5">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph> or <ph id="ph6">&lt;xref:System.Net.Sockets.SocketOptionLevel.IPv6&gt;</ph> as appropriate, the <ph id="ph7">`optionName`</ph> parameter set to <ph id="ph8">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph>, and the <ph id="ph9">`optionValue`</ph> parameter to enable this option before calling the <ph id="ph10">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Para garantir que o ponto de extremidade do host remoto é sempre retornado, um aplicativo deve associar explicitamente o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> para um ponto de extremidade local usando o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> método e em seguida, chame o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> método com o <ph id="ph4">`optionLevel`</ph> parâmetro definido como <ph id="ph5">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph> ou <ph id="ph6">&lt;xref:System.Net.Sockets.SocketOptionLevel.IPv6&gt;</ph> conforme apropriado, o <ph id="ph7">`optionName`</ph> parâmetro definido como <ph id="ph8">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph>e o <ph id="ph9">`optionValue`</ph> parâmetro para habilitar essa opção antes de chamar o <ph id="ph10">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Otherwise, it is possible for the remote host endpoint to not be returned when the sender has sent a number of datagrams before the receiver has called the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Caso contrário, é possível que o ponto de extremidade do host remoto para não ser retornado quando o remetente enviou um número de datagramas antes que o destinatário tem o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Although <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</source>
          <target state="translated">Embora <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> destina-se para protocolos sem conexão, você pode usar um protocolo orientado a conexão também.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you choose to do so, you must first either establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph><ph id="ph2"> / </ph><ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method or accept an incoming connection request by calling the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">Se você optar por fazer isso, você deve primeiro estabelecer uma conexão de host remoto chamando o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> <ph id="ph2"> / </ph> <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> método ou aceitar uma solicitação de conexão de entrada ao chamar o <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method before establishing or accepting a connection, you will get a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> método antes de estabelecer ou aceitar uma conexão, você obterá um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Você também pode estabelecer um host remoto padrão para um protocolo sem-conexão antes de chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>In either of these cases, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.</source>
          <target state="translated">Em ambos os casos, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> método irá ignorar o <ph id="ph2">`remoteEP`</ph> parâmetro e recebam dados conectado ou host remoto padrão.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>With connection-oriented sockets, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> will read as much data as is available up to the number of bytes specified by the <ph id="ph2">`size`</ph> parameter.</source>
          <target state="translated">Com soquetes orientados a conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> lerá a quantidade de dados está disponível até o número de bytes especificado pelo <ph id="ph2">`size`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">Para cancelar um pendente <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, chame o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Após o primeiro uso de um contexto específico (um determinado assíncrono <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> método, uma determinada <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The following code example asynchronously receives connectionless datagrams from a remote host.</source>
          <target state="translated">O exemplo de código a seguir recebe de maneira assíncrona datagramas sem conexão de um host remoto.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> é maior que o comprimento do <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é maior que o comprimento da subtração de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> e do valor do parâmetro <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">Um chamador mais alto na pilha de chamadas não tem permissão para a operação solicitada.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que é o local de armazenamento dos dados recebidos.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The zero-based position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter at which to store the data.</source>
          <target state="translated">A posição baseada em zero no parâmetro <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> no qual armazenar os dados.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The number of bytes to receive.</source>
          <target state="translated">O número de bytes a serem recebidos.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Uma combinação bit a bit dos valores <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that represents the source of the data.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> que representa a fonte de dados.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">O delegado <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Um objeto que contém informações de estado para essa solicitação.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Begins to asynchronously receive the specified number of bytes of data into the specified location of the data buffer, using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>, and stores the endpoint and packet information..</source>
          <target state="translated">Inicia o recebimento de forma assíncrona do número especificado de bytes de dados no local especificado do buffer de dados, usando o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> especificado e armazena as informações de ponto de extremidade e de pacote.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous read.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que faz referência à leitura assíncrona.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The asynchronous receive operation must be completed by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A&gt;</ph> method.</source>
          <target state="translated">Operação de recebimento assíncronos devem ser concluídas por chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`asyncCallback`</ph> delegate.</source>
          <target state="translated">Normalmente, o método é invocado pelo <ph id="ph1">`asyncCallback`</ph> delegate.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation completes.</source>
          <target state="translated">Esse método não bloqueia até que a operação seja concluída.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>To block until the operation completes, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method.</source>
          <target state="translated">Para bloquear até a conclusão da operação, use o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">Para cancelar um pendente <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A&gt;</ph>, chame o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></source>
          <target state="translated">Para obter informações detalhadas sobre como usar o modelo de programação assíncrono, consulte <bpt id="p1">[</bpt>chamando métodos síncronos assincronamente<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This method reads data into the <ph id="ph1">`buffer`</ph> parameter, and captures the remote host endpoint from which the data is sent, as well as information about the received packet.</source>
          <target state="translated">Esse método lê os dados para o <ph id="ph1">`buffer`</ph> parâmetro e capturas de ponto de extremidade do qual os dados são enviados de host remoto, bem como informações sobre o pacote recebido.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>For information on how to retrieve this endpoint, refer to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>.</source>
          <target state="translated">Para obter informações sobre como recuperar esse ponto de extremidade, consulte <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</source>
          <target state="translated">Esse método é mais útil se você pretende assincronamente receber datagramas sem conexão de um host desconhecido ou vários hosts.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Após o primeiro uso de um contexto específico (um determinado assíncrono <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> método, uma determinada <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> é maior que o comprimento do <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é maior que o comprimento da subtração de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> e do valor do parâmetro <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The operating system is Windows 2000 or earlier, and this method requires Windows XP.</source>
          <target state="translated">O sistema operacional é o Windows 2000 ou anterior e esse método requer o Windows XP.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Envia dados de forma assíncrona para um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> conectado.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to send.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que contém os dados a serem enviados.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Uma combinação bit a bit dos valores <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">O delegado <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Um objeto que contém informações de estado para essa solicitação.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Envia dados de forma assíncrona para um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> conectado.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous send.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que faz referência ao envio assíncrono.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> método inicia uma operação de envio assíncrono para o host remoto estabelecida no <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> lançará uma exceção se você não chama primeiro <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">Chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> método lhe oferece a capacidade de enviar dados dentro de um thread de execução separado.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.</source>
          <target state="translated">Você pode criar um método de retorno de chamada que implementa o <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegar e passar o nome para o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
          <target state="translated">Para fazer isso, no mínimo, o <ph id="ph1">`state`</ph> parâmetro deve conter conectado ou padrão <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> que está sendo usada para comunicação.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">Se o retorno de chamada precisa de mais informações, você pode criar uma pequena classe ou estrutura para manter o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> e outras informações necessárias.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Passar uma instância dessa classe para o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> método por meio de <ph id="ph2">`state`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method.</source>
          <target state="translated">O método de retorno de chamada deve chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.</source>
          <target state="translated">Quando o aplicativo chama <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, o sistema usará um thread separado para executar o método de retorno de chamada especificada e bloqueará <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> até que o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> envia o número de bytes solicitado ou gera uma exceção.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Se você quiser que o thread original para bloquear depois de chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> método, use o <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Chame o método de conjunto em um t: System.Threading.ManualResetEvent no método de retorno de chamada quando o thread original para continuar a executar.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte <bpt id="p1">[</bpt>Marshaling de um delegado como um método de retorno de chamada<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">Embora destinado protocolos orientados a conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> também funciona para protocolos sem conexão, desde que você primeiro chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> método para estabelecer um host remoto padrão.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">É okey usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> mesmo depois de estabelecer um host remoto padrão com <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated">Você também pode alterar o host remoto padrão antes de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> fazendo outra chamada para <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Com protocolos sem conexão, você também deve ser-se de que o tamanho do buffer de não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se isso acontecer, o datagrama não será enviado e <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Se você especificar o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> sinalizador como o <ph id="ph2">`socketflags`</ph> parâmetro, os dados que você está enviando não serão roteadas.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">E/s iniciada por um determinado thread é cancelada quando que sai do thread.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> é uma instanciação de uma classe definida pelo usuário.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Após o primeiro uso de um contexto específico (um determinado assíncrono <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> método, uma determinada <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> está vazio.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>See remarks section below.</source>
          <target state="translated">Consulte a seção Comentários abaixo.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to send.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que contém os dados a serem enviados.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Uma combinação bit a bit dos valores <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> que armazena o erro de soquete.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">O delegado <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Um objeto que contém informações de estado para essa solicitação.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Envia dados de forma assíncrona para um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> conectado.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous send.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que faz referência ao envio assíncrono.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> método inicia uma operação de envio assíncrono para o host remoto estabelecida no <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> lançará uma exceção se você não chama primeiro <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">Chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> método lhe oferece a capacidade de enviar dados dentro de um thread de execução separado.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.</source>
          <target state="translated">Você pode criar um método de retorno de chamada que implementa o <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegar e passar o nome para o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
          <target state="translated">Para fazer isso, no mínimo, o <ph id="ph1">`state`</ph> parâmetro deve conter conectado ou padrão <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> que está sendo usada para comunicação.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">Se o retorno de chamada precisa de mais informações, você pode criar uma pequena classe ou estrutura para manter o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> e outras informações necessárias.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Passar uma instância dessa classe para o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> método por meio de <ph id="ph2">`state`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method.</source>
          <target state="translated">O método de retorno de chamada deve chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.</source>
          <target state="translated">Quando o aplicativo chama <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, o sistema usará um thread separado para executar o método de retorno de chamada especificada e bloqueará <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> até que o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> envia o número de bytes solicitado ou gera uma exceção.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Se você quiser que o thread original para bloquear depois de chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> método, use o <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Chame o método de conjunto em um <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> no método de retorno de chamada quando o thread original para continuar a executar.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte <bpt id="p1">[</bpt>Marshaling de um delegado como um método de retorno de chamada<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">Embora destinado protocolos orientados a conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> também funciona para protocolos sem conexão, desde que você primeiro chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> método para estabelecer um host remoto padrão.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">É okey usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> mesmo depois de estabelecer um host remoto padrão com <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated">Você também pode alterar o host remoto padrão antes de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> fazendo outra chamada para <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Com protocolos sem conexão, você também deve ser-se de que o tamanho do buffer de não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se isso acontecer, o datagrama não será enviado e <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Se você especificar o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> sinalizador como o <ph id="ph2">`socketflags`</ph> parâmetro, os dados que você está enviando não serão roteadas.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">E/s iniciada por um determinado thread é cancelada quando que sai do thread.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> é uma instanciação de uma classe definida pelo usuário.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Após o primeiro uso de um contexto específico (um determinado assíncrono <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> método, uma determinada <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> está vazio.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>See remarks section below.</source>
          <target state="translated">Consulte a seção Comentários abaixo.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to send.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que contém os dados a serem enviados.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The zero-based position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter at which to begin sending data.</source>
          <target state="translated">A posição baseada em zero no parâmetro <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> no qual começar a enviar dados.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The number of bytes to send.</source>
          <target state="translated">O número de bytes a serem enviados.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Uma combinação bit a bit dos valores <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> que armazena o erro de soquete.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">O delegado <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Um objeto que contém informações de estado para essa solicitação.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Envia dados de forma assíncrona para um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> conectado.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous send.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que faz referência ao envio assíncrono.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> método inicia uma operação de envio assíncrono para o host remoto estabelecida no <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> lançará uma exceção se você não chama primeiro <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">Chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> método lhe oferece a capacidade de enviar dados dentro de um thread de execução separado.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.</source>
          <target state="translated">Você pode criar um método de retorno de chamada que implementa o <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegar e passar o nome para o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
          <target state="translated">Para fazer isso, no mínimo, o <ph id="ph1">`state`</ph> parâmetro deve conter conectado ou padrão <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> que está sendo usada para comunicação.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">Se o retorno de chamada precisa de mais informações, você pode criar uma pequena classe ou estrutura para manter o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> e outras informações necessárias.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Passar uma instância dessa classe para o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> método por meio de <ph id="ph2">`state`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method.</source>
          <target state="translated">O método de retorno de chamada deve chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.</source>
          <target state="translated">Quando o aplicativo chama <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, o sistema usará um thread separado para executar o método de retorno de chamada especificada e bloqueará <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> até que o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> envia o número de bytes solicitado ou gera uma exceção.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Se você quiser que o thread original para bloquear depois de chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> método, use o <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Chame o método de conjunto em um t: System.Threading.ManualResetEvent no método de retorno de chamada quando o thread original para continuar a executar.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte <bpt id="p1">[</bpt>Marshaling de um delegado como um método de retorno de chamada<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">Embora destinado protocolos orientados a conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> também funciona para protocolos sem conexão, desde que você primeiro chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> método para estabelecer um host remoto padrão.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">É okey usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> mesmo depois de estabelecer um host remoto padrão com <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated">Você também pode alterar o host remoto padrão antes de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> fazendo outra chamada para <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Com protocolos sem conexão, você também deve ser-se de que o tamanho do buffer de não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se isso acontecer, o datagrama não será enviado e <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Se você especificar o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> sinalizador como o <ph id="ph2">`socketflags`</ph> parâmetro, os dados que você está enviando não serão roteadas.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">E/s iniciada por um determinado thread é cancelada quando que sai do thread.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> é uma instanciação de uma classe definida pelo usuário.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Após o primeiro uso de um contexto específico (um determinado assíncrono <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> método, uma determinada <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>See remarks section below.</source>
          <target state="translated">Consulte a seção Comentários abaixo.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> é menor que o tamanho de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é maior que o comprimento da subtração de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> e do valor do parâmetro <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to send.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que contém os dados a serem enviados.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The zero-based position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter at which to begin sending data.</source>
          <target state="translated">A posição baseada em zero no parâmetro <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> no qual começar a enviar dados.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The number of bytes to send.</source>
          <target state="translated">O número de bytes a serem enviados.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">O delegado <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Um objeto que contém informações de estado para essa solicitação.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Envia dados de forma assíncrona para um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> conectado.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous send.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que faz referência ao envio assíncrono.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> método inicia uma operação de envio assíncrono para o host remoto estabelecida no <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> lançará uma exceção se você não chama primeiro <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">Chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> método lhe oferece a capacidade de enviar dados dentro de um thread de execução separado.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.</source>
          <target state="translated">Você pode criar um método de retorno de chamada que implementa o <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegar e passar o nome para o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
          <target state="translated">Para fazer isso, no mínimo, o <ph id="ph1">`state`</ph> parâmetro deve conter conectado ou padrão <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> que está sendo usada para comunicação.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">Se o retorno de chamada precisa de mais informações, você pode criar uma pequena classe ou estrutura para manter o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> e outras informações necessárias.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Passar uma instância dessa classe para o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> método por meio de <ph id="ph2">`state`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method.</source>
          <target state="translated">O método de retorno de chamada deve chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.</source>
          <target state="translated">Quando o aplicativo chama <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, o sistema usará um thread separado para executar o método de retorno de chamada especificada e bloqueará <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> até que o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> envia o número de bytes solicitado ou gera uma exceção.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Se você quiser que o thread original para bloquear depois de chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> método, use o <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Chame o método de conjunto em um t: System.Threading.ManualResetEvent no método de retorno de chamada quando o thread original para continuar a executar.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte <bpt id="p1">[</bpt>Marshaling de um delegado como um método de retorno de chamada<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">Embora destinado protocolos orientados a conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> também funciona para protocolos sem conexão, desde que você primeiro chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> método para estabelecer um host remoto padrão.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">É okey usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> mesmo depois de estabelecer um host remoto padrão com <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated">Você também pode alterar o host remoto padrão antes de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> fazendo outra chamada para <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Com protocolos sem conexão, você também deve ser-se de que o tamanho do buffer de não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se isso acontecer, o datagrama não será enviado e <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Se você especificar o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> sinalizador como o <ph id="ph2">`socketflags`</ph> parâmetro, os dados que você está enviando não serão roteadas.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">E/s iniciada por um determinado thread é cancelada quando que sai do thread.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> é uma instanciação de uma classe definida pelo usuário.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Após o primeiro uso de um contexto específico (um determinado assíncrono <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> método, uma determinada <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The following code example begins asynchronously sending data to a remote host.</source>
          <target state="translated">O exemplo de código a seguir começa assincronamente enviar dados para um host remoto.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>See remarks section below.</source>
          <target state="translated">Consulte a seção Comentários abaixo.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> é menor que o tamanho de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é maior que o comprimento da subtração de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> e do valor do parâmetro <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sends a file asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object.</source>
          <target state="translated">Envia um arquivo de forma assíncrona para um objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> conectado.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>A string that contains the path and name of the file to send.</source>
          <target state="translated">Uma cadeia de caracteres que contém o caminho e o nome do arquivo a ser enviado.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Esse parâmetro pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">O delegado <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Um objeto que contém informações de estado para essa solicitação.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>Sends the file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> to a connected <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object using the <ph id="ph3">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /&gt;</ph> flag.</source>
          <target state="translated">Envia o arquivo <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> para um objeto <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> conectado usando o sinalizador <ph id="ph3">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that represents the asynchronous send.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que representa o envio assíncrono.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>This overload sends the file <ph id="ph1">`fileName`</ph> to the connected socket.</source>
          <target state="translated">Essa sobrecarga envia o arquivo <ph id="ph1">`fileName`</ph> para o soquete conectado.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>If <ph id="ph1">`fileName`</ph> is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</source>
          <target state="translated">Se <ph id="ph1">`fileName`</ph> está no diretório local, que pode ser identificado somente com o nome do arquivo; caso contrário, o caminho completo e nome do arquivo devem ser especificados.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>Wildcards ("..<ph id="ph1">\\</ph>\myfile.txt") and UNC share names ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared directory<ph id="ph5">\\</ph>\myfile.txt") are supported.</source>
          <target state="translated">Caracteres curinga ("... <ph id="ph1">\\</ph>\myfile.txt ") e nomes de compartilhamento de UNC ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared diretório<ph id="ph5">\\</ph>\myfile.txt ") são suportados.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>If the file is not found, the exception <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.</source>
          <target state="translated">Se o arquivo não for encontrado, a exceção <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> é lançada.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>This method uses the <ph id="ph1">`TransmitFile`</ph> function found in the Windows Sockets 2 API.</source>
          <target state="translated">Esse método usa o <ph id="ph1">`TransmitFile`</ph> encontrar a função na API do Windows Sockets 2.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>For more information about the <ph id="ph1">`TransmitFile`</ph> function and its flags, see the Windows Sockets documentation in the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre o <ph id="ph1">`TransmitFile`</ph> função e seus sinalizadores, consulte a documentação do Windows Sockets na biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>,<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> methods.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> método inicia uma operação de envio assíncrono para o host remoto estabelecida no <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>,<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> throws an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> gera uma exceção se você não chama primeiro <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method enables you to send a file within a separate execution thread.</source>
          <target state="translated">Chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> método permite que você envie um arquivo em um thread de execução separado.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>To complete the operation, you can create a callback method that is invoked by the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate parameter.</source>
          <target state="translated">Para concluir a operação, você pode criar um método de retorno de chamada é invocado pelo <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegar o parâmetro.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, the <ph id="ph1">`state`</ph> parameter must contain the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object being used for communication.</source>
          <target state="translated">Para fazer isso, no mínimo, o <ph id="ph1">`state`</ph> parâmetro deve conter o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> do objeto que está sendo usada para comunicação.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">Se o retorno de chamada precisa de mais informações, você pode criar uma classe ou estrutura para manter o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> e outras informações necessárias.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this custom object to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Passar uma instância do objeto personalizado para o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> método por meio de <ph id="ph2">`state`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>Your callback method must invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> method.</source>
          <target state="translated">O método de retorno de chamada deve chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>, the system uses a separate thread to execute the specified callback method, and blocks on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the entire file or throws an exception.</source>
          <target state="translated">Quando o aplicativo chama <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>, o sistema usa um thread separado para executar o método de retorno de chamada especificada e blocos em <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> até que o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> envia todo o arquivo ou gera uma exceção.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte <bpt id="p1">[</bpt>Marshaling de um delegado como um método de retorno de chamada<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">Embora destinado protocolos orientados a conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> também funciona para protocolos sem conexão, desde que você primeiro chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> método para estabelecer um host remoto padrão.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>With connectionless protocols, you must be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Com protocolos sem conexão, você deve ser-se de que o tamanho do arquivo não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram is not sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.</source>
          <target state="translated">Se isso acontecer, o datagrama não é enviado e <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> lança um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exceção.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exceção, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Após o primeiro uso de um contexto específico (um determinado assíncrono <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> método, uma determinada <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The following code example creates and connects a socket for asynchronous communication.</source>
          <target state="translated">O exemplo de código a seguir cria e se conecta a um soquete para comunicação assíncrona.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>First, the file "text.txt" is sent asynchronously to the remote host.</source>
          <target state="translated">Primeiro, o arquivo "Test.txt" é enviado de forma assíncrona ao host remoto.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The callback delegate calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> to complete the transmission.</source>
          <target state="translated">O retorno de chamada delegar chamadas <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> para concluir a transmissão.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The socket is not connected to a remote host.</source>
          <target state="translated">O soquete não está conectado a um host remoto.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> was not found.</source>
          <target state="translated">O arquivo <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> não foi encontrado.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>See remarks section below.</source>
          <target state="translated">Consulte a seção Comentários abaixo.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>A string that contains the path and name of the file to be sent.</source>
          <target state="translated">Uma cadeia de caracteres que contém o caminho e o nome do arquivo a ser enviado.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Esse parâmetro pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> array that contains data to be sent before the file is sent.</source>
          <target state="translated">Uma matriz <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que contém dados a serem enviados antes de o arquivo ser enviado.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Esse parâmetro pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> array that contains data to be sent after the file is sent.</source>
          <target state="translated">Uma matriz <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que contém dados a serem enviados depois de o arquivo ser enviado.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Esse parâmetro pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Net.Sockets.TransmitFileOptions" /&gt;</ph> values.</source>
          <target state="translated">Uma combinação bit a bit dos valores <ph id="ph1">&lt;see cref="T:System.Net.Sockets.TransmitFileOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate to be invoked when this operation completes.</source>
          <target state="translated">Um delegado <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> a ser invocado quando a operação for concluída.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Esse parâmetro pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains state information for this request.</source>
          <target state="translated">Um objeto definido pelo usuário que contém informações de estado para essa solicitação.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Esse parâmetro pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>Sends a file and buffers of data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object.</source>
          <target state="translated">Envia um arquivo e buffers de dados de forma assíncrona para um objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> conectado.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that represents the asynchronous operation.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que representa a operação assíncrona.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This overload requires the name of the file you want to send and a bitwise combination of <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> values.</source>
          <target state="translated">Essa sobrecarga requer o nome do arquivo que deseja enviar e uma combinação bit a bit de <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">`preBuffer`</ph> parameter contains any data you want to precede the file.</source>
          <target state="translated">O <ph id="ph1">`preBuffer`</ph> parâmetro contiver dados deve preceder o arquivo.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`postBuffer`</ph> contains data you want to follow the file.</source>
          <target state="translated"><ph id="ph1">`postBuffer`</ph> contém dados que você deseja que execute o arquivo.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>If <ph id="ph1">`fileName`</ph> is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</source>
          <target state="translated">Se <ph id="ph1">`fileName`</ph> está no diretório local, que pode ser identificado somente com o nome do arquivo; caso contrário, o caminho completo e nome do arquivo devem ser especificados.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>Wildcards ("..<ph id="ph1">\\</ph>\myfile.txt") and UNC share names ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared directory<ph id="ph5">\\</ph>\myfile.txt") are supported.</source>
          <target state="translated">Caracteres curinga ("... <ph id="ph1">\\</ph>\myfile.txt ") e nomes de compartilhamento de UNC ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared diretório<ph id="ph5">\\</ph>\myfile.txt ") são suportados.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>If the file is not found, the exception <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.</source>
          <target state="translated">Se o arquivo não for encontrado, a exceção <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> é lançada.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">`flags`</ph> parameter provides the Window Sockets service provider with additional information about the file transfer.</source>
          <target state="translated">O <ph id="ph1">`flags`</ph> parâmetro fornece o provedor de serviços de soquetes de janela com informações adicionais sobre a transferência de arquivos.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>For more information about how to use this parameter, see <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como usar esse parâmetro, consulte <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This method uses the <ph id="ph1">`TransmitFile`</ph> function found in the Windows Sockets 2 API.</source>
          <target state="translated">Esse método usa o <ph id="ph1">`TransmitFile`</ph> encontrar a função na API do Windows Sockets 2.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>For more information about the <ph id="ph1">`TransmitFile`</ph> function and its flags, see the Windows Sockets documentation in the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre o <ph id="ph1">`TransmitFile`</ph> função e seus sinalizadores, consulte a documentação do Windows Sockets na biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> methods.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> método inicia uma operação de envio assíncrono para o host remoto estabelecida no <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> throws an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> gera uma exceção se você não chama primeiro <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method gives you the ability to send a file within a separate execution thread.</source>
          <target state="translated">Chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> método lhe oferece a capacidade de enviar um arquivo em um thread de execução separado.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>To complete the operation, you can create a callback method that is invoked by the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate parameter.</source>
          <target state="translated">Para concluir a operação, você pode criar um método de retorno de chamada é invocado pelo <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegar o parâmetro.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, the <ph id="ph1">`state`</ph> parameter must contain the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object being used for communication.</source>
          <target state="translated">Para fazer isso, no mínimo, o <ph id="ph1">`state`</ph> parâmetro deve conter o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> do objeto que está sendo usada para comunicação.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">Se o retorno de chamada precisa de mais informações, você pode criar uma classe ou estrutura para manter o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> e outras informações necessárias.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this custom object to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Passar uma instância do objeto personalizado para o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> método por meio de <ph id="ph2">`state`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>Your callback method must invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> method.</source>
          <target state="translated">O método de retorno de chamada deve chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>, the system uses a separate thread to execute the specified callback method, and blocks on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the entire file or throws an exception.</source>
          <target state="translated">Quando o aplicativo chama <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>, o sistema usa um thread separado para executar o método de retorno de chamada especificada e blocos em <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> até que o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> envia todo o arquivo ou gera uma exceção.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte <bpt id="p1">[</bpt>Marshaling de um delegado como um método de retorno de chamada<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">Embora destinado protocolos orientados a conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> também funciona para protocolos sem conexão, desde que você primeiro chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> método para estabelecer um host remoto padrão.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Com protocolos sem conexão, você também deve ser-se de que o tamanho do arquivo não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram is not sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.</source>
          <target state="translated">Se isso acontecer, o datagrama não é enviado e <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> lança um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exceção.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exceção, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Após o primeiro uso de um contexto específico (um determinado assíncrono <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> método, uma determinada <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</source>
          <target state="translated">O exemplo de código a seguir cria e se conecta a um soquete para comunicação assíncrona e começa a enviar o arquivo "Test.txt" assincronamente para o host remoto.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>In this example, a <ph id="ph1">`preBuffer`</ph> and a <ph id="ph2">`postBuffer`</ph> of data is created to send with the file and the default <ph id="ph3">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> value is used.</source>
          <target state="translated">Neste exemplo, um <ph id="ph1">`preBuffer`</ph> e um <ph id="ph2">`postBuffer`</ph> de dados é criado para enviar o arquivo e o padrão <ph id="ph3">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> valor é usado.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The callback delegate calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> to complete the transmission.</source>
          <target state="translated">O retorno de chamada delegar chamadas <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> para concluir a transmissão.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>See remarks section below.</source>
          <target state="translated">Consulte a seção Comentários abaixo.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The operating system is not Windows NT or later.</source>
          <target state="translated">O sistema operacional não é o Windows NT ou posterior.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> ou -</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The socket is not connected to a remote host.</source>
          <target state="translated">O soquete não está conectado a um host remoto.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> was not found.</source>
          <target state="translated">O arquivo <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> não foi encontrado.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to send.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que contém os dados a serem enviados.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The zero-based position in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which to begin sending data.</source>
          <target state="translated">A posição baseada em zero no <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> em que se começa a enviar dados.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The number of bytes to send.</source>
          <target state="translated">O número de bytes a serem enviados.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">O delegado <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Um objeto que contém informações de estado para essa solicitação.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Sends data asynchronously to a specific remote host.</source>
          <target state="translated">Envia dados de maneira assíncrona para um host remoto específico.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous send.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que faz referência ao envio assíncrono.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method starts an asynchronous send operation to the remote host specified in the <ph id="ph2">`remoteEP`</ph> parameter.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> método inicia uma operação de envio assíncrono para o host remoto especificado no <ph id="ph2">`remoteEP`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">Chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> método lhe oferece a capacidade de enviar dados dentro de um thread de execução separado.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Although intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> works with both connectionless and connection-oriented protocols.</source>
          <target state="translated">Embora destinado protocolos sem conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> funciona com protocolos sem conexão e orientada a conexão.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method.</source>
          <target state="translated">Você pode criar um método de retorno de chamada que implementa o <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegar e passar o nome para o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
          <target state="translated">Para fazer isso, no mínimo, o <ph id="ph1">`state`</ph> parâmetro deve conter conectado ou padrão <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> que está sendo usada para comunicação.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, and the other required information.</source>
          <target state="translated">Se o retorno de chamada precisa de mais informações, você pode criar uma pequena classe para manter o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>e as outras informações necessárias.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Passar uma instância dessa classe para o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> método por meio de <ph id="ph2">`state`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> method.</source>
          <target state="translated">O método de retorno de chamada deve chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.</source>
          <target state="translated">Quando o aplicativo chama <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>, o sistema usará um thread separado para executar o método de retorno de chamada especificada e bloqueará <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> até que o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> envia o número de bytes solicitado ou gera uma exceção.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Se você quiser que o thread original para bloquear depois de chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> método, use o <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Chame o método de conjunto em um t: System.Threading.ManualResetEvent no método de retorno de chamada quando o thread original para continuar a executar.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>For additional information about writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte <bpt id="p1">[</bpt>Marshaling de um delegado como um método de retorno de chamada<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connection-oriented protocol, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> will throw a <ph id="ph6">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, você deve primeiro chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, ou <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método, ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> lançará um <ph id="ph6">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> will ignore the <ph id="ph2">`remoteEP`</ph> parameter and send data to the <ph id="ph3">&lt;xref:System.Net.EndPoint&gt;</ph> established in the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> ignorará a <ph id="ph2">`remoteEP`</ph> parâmetro e enviar dados para o <ph id="ph3">&lt;xref:System.Net.EndPoint&gt;</ph> estabelecido no <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, ou <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, você não precisa estabelecer um host remoto padrão com o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> método antes de chamar <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.</source>
          <target state="translated">Você só precisa fazer isso se você pretende chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id="ph4">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.</source>
          <target state="translated">Se você chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> método antes de chamar <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, o <ph id="ph4">`remoteEP`</ph> parâmetro substituirá o host remoto padrão especificado para que enviar apenas a operação.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">Também não é necessário chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>In this case, the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">Nesse caso, o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local mais adequado.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Use a port number of zero if you want the underlying service provider to select a free port.</source>
          <target state="translated">Use um número de porta de zero se quiser que o provedor de serviço subjacente para selecionar uma porta livre.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you need to identify the assigned local network address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> method successfully completes.</source>
          <target state="translated">Se for necessário identificar o número de porta e endereço de rede local atribuído, você pode usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> propriedade após o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> concluído com êxito.</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se você deseja enviar dados para um endereço de difusão, você deve primeiro chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> opção de método e defina o soquete para <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>-You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">-Você também deve ser-se de que o tamanho do buffer de não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se isso acontecer, o datagrama não será enviado e <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Se você especificar o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> sinalizador como o <ph id="ph2">`socketflags`</ph> parâmetro, os dados que você está enviando não serão roteadas.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Após o primeiro uso de um contexto específico (um determinado assíncrono <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> método, uma determinada <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The following code example asynchronously sends data to the specified remote host.</source>
          <target state="translated">O exemplo de código a seguir assincronamente envia dados para o host remoto especificado.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> é maior que o comprimento do <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é maior que o comprimento da subtração de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> e do valor do parâmetro <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">Um chamador mais alto na pilha de chamadas não tem permissão para a operação solicitada.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>The local <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> to associate with the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">O local <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> para associar ao <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>Associates a <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> with a local endpoint.</source>
          <target state="translated">Associa um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a um ponto de extremidade local.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method if you need to use a specific local endpoint.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> método se você precisa usar um ponto de extremidade local específico.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>You must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method.</source>
          <target state="translated">Você deve chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> antes de chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>You do not need to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method unless you need to use a specific local endpoint.</source>
          <target state="translated">Você não precisa chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> antes de usar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método, a menos que você precisa usar um ponto de extremidade local específico.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method on both connectionless and connection-oriented protocols.</source>
          <target state="translated">Você pode usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> método nos protocolos sem conexão e orientada a conexão.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>, you must first create the local <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> from which you intend to communicate data.</source>
          <target state="translated">Antes de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>, você deve primeiro criar o local <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> do qual você pretende comunicação de dados.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you do not care which local address is assigned, you can create an <ph id="ph1">&lt;xref:System.Net.IPEndPoint&gt;</ph> using <ph id="ph2">&lt;xref:System.Net.IPAddress.Any?displayProperty=nameWithType&gt;</ph> as the address parameter, and the underlying service provider will assign the most appropriate network address.</source>
          <target state="translated">Se você não fizer a qual o endereço local é atribuído, você pode criar um <ph id="ph1">&lt;xref:System.Net.IPEndPoint&gt;</ph> usando <ph id="ph2">&lt;xref:System.Net.IPAddress.Any?displayProperty=nameWithType&gt;</ph> como o parâmetro de endereço e o serviço subjacente provedor atribuirá o endereço de rede mais apropriado.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>This might help simplify your application if you have multiple network interfaces.</source>
          <target state="translated">Isso pode ajudar a simplificar seu aplicativo, se você tiver várias interfaces de rede.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you do not care which local port is used, you can create an <ph id="ph1">&lt;xref:System.Net.IPEndPoint&gt;</ph> using 0 for the port number.</source>
          <target state="translated">Se você não fizer a porta local é usada, você pode criar um <ph id="ph1">&lt;xref:System.Net.IPEndPoint&gt;</ph> usar 0 como o número da porta.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>In this case, the service provider will assign an available port number between 1024 and 5000.</source>
          <target state="translated">Nesse caso, o provedor de serviços atribuirá um número de porta entre 1024 e 5000.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you use the above approach, you can discover what local network address and port number has been assigned by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>.</source>
          <target state="translated">Se você usar a abordagem acima, você pode descobrir o número de porta e endereço de rede local foi atribuído ao chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> will not return the locally assigned network address until after you have made a call to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> não retornará o endereço de rede atribuído localmente até depois que você fez uma chamada para o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, you will not have access to this information until you have completed a send or receive.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, você não terá acesso a essas informações até que você concluiu um envio ou recebimento.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If a UDP socket wants to receive interface information on received packets,  the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method should be explicitly called with the socket option set to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> immediately after calling the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">Se um soquete UDP deseja receber informações de interface em pacotes recebidos, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> método deve ser chamado explicitamente com a opção de soquete definida como <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> imediatamente depois de chamar o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you intend to receive multicast datagrams, you must call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method with a multicast port number.</source>
          <target state="translated">Se você pretende receber datagramas multicast, você deve chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> método com um número de porta de multicast.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>You must call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method if you intend to receive connectionless datagrams using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Você deve chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> método se desejar receber datagramas sem conexão usando o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> when calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, use the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> ao chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> método, use o <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>The following code example binds a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> using the specified local endpoint.</source>
          <target state="translated">O código a seguir exemplo associa um <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> usando o ponto de extremidade local especificado.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="localEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="localEP" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">Um chamador mais alto na pilha de chamadas não tem permissão para a operação solicitada.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>for accepting connections from the host defined by <ph id="ph1">&lt;paramref name="localEP" /&gt;</ph>.</source>
          <target state="translated">para aceitar conexões de host definidos por <ph id="ph1">&lt;paramref name="localEP" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph></source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>Gets or sets a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is in blocking mode.</source>
          <target state="translated">Obtém ou define um valor que indica se o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> está no modo de bloqueio.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> will block; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> for bloqueado; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property indicates whether a <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is in blocking mode.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> propriedade indica se um <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> está no modo de bloqueio.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>If you are in blocking mode, and you make a method call which does not complete immediately, your application will block execution until the requested operation completes.</source>
          <target state="translated">Se você estiver no modo de bloqueio, e você faz com que um método de chamada que não for concluída imediatamente, seu aplicativo bloqueará a execução até que a operação solicitada seja concluída.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>If you want execution to continue even though the requested operation is not complete, change the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Se você deseja que a execução continuar mesmo que a operação solicitada não foi concluída, altere o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> propriedade <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property has no effect on asynchronous methods.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> propriedade não tem efeito sobre os métodos assíncronos.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>If you are sending and receiving data asynchronously and want to block execution, use the <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> class.</source>
          <target state="translated">Se você for enviar e receber dados de forma assíncrona e para bloquear a execução, use o <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object used to request the connection to the remote host by calling one of the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /&gt;</ph> methods.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> usado para solicitar a conexão com o host remoto chamando um dos métodos <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Cancels an asynchronous request for a remote host connection.</source>
          <target state="translated">Cancela uma solicitação assíncrona de uma conexão de host remoto.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.CancelConnectAsync%2A&gt;</ph> method cancels an asynchronous request for a remote host connection.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.CancelConnectAsync%2A&gt;</ph> método cancela uma solicitação assíncrona para uma conexão do host remoto.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;paramref name="e" /&gt;</ph> parameter cannot be null and the <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> cannot be null.</source>
          <target state="translated">O parâmetro <ph id="ph1">&lt;paramref name="e" /&gt;</ph> e o <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> não podem ser nulos.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">Um chamador mais alto na pilha de chamadas não tem permissão para a operação solicitada.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Closes the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connection and releases all associated resources.</source>
          <target state="translated">Fecha a conexão <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> e libera todos os recursos associados.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Close">
          <source>Closes the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connection and releases all associated resources.</source>
          <target state="translated">Fecha a conexão <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> e libera todos os recursos associados.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method closes the remote host connection and releases all managed and unmanaged resources associated with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> método fecha a conexão do host remoto e versões de todos os recursos gerenciados e associados a <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>Upon closing, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph>.</source>
          <target state="translated">No fechamento, a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> está definida como <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>For connection-oriented protocols, it is recommended that you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">Para protocolos orientados a conexão, é recomendável que você chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> antes de chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>This ensures that all data is sent and received on the connected socket before it is closed.</source>
          <target state="translated">Isso garante que todos os dados são enviadas e recebidas no soquete conectado antes de ser fechado.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>If you need to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> without first calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, you can ensure that data queued for outgoing transmission will be sent by setting the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph><ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option to <ph id="ph5">`false`</ph> and specifying a non-zero time-out interval.</source>
          <target state="translated">Se você precisar chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> sem primeiro chamar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, você pode garantir que dados na fila de transmissão de saída será enviada, definindo o <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> opção para <ph id="ph5">`false`</ph> e especificando um intervalo de tempo-limite diferente de zero.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> will then block until this data is sent or until the specified time-out expires.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> em seguida, bloqueia até que esses dados são enviados ou expira o tempo limite especificado.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>If you set <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> to <ph id="ph2">`false`</ph> and specify a zero time-out interval, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> releases the connection and automatically discards outgoing queued data.</source>
          <target state="translated">Se você definir <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> para <ph id="ph2">`false`</ph> e especificar um zero intervalo de tempo limite, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> libera a conexão e descarta automaticamente os dados na fila de saída.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>To set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> socket option to <ph id="ph2">`false`</ph>, create a <ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>, set the enabled property to <ph id="ph4">`true`</ph>, and set the <ph id="ph5">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> property to the desired time out period.</source>
          <target state="translated">Para definir o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> soquete opção para <ph id="ph2">`false`</ph>, criar um <ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>, defina a propriedade enabled como <ph id="ph4">`true`</ph>e defina o <ph id="ph5">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> propriedade para o período de tempo limite desejado.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>Use this <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> along with the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> socket option to call the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">Use este <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> juntamente com o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> soquete opção para chamar o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>The following code example closes a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">O código a seguir exemplo fecha um <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>Wait up to <bpt id="p1">&lt;c&gt;</bpt>timeout<ept id="p1">&lt;/c&gt;</ept> seconds to send any remaining data, then close the socket.</source>
          <target state="translated">Aguarde até o <bpt id="p1">&lt;c&gt;</bpt>tempo limite<ept id="p1">&lt;/c&gt;</ept> em segundos para enviar quaisquer dados restantes e, em seguida, feche o soquete.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>Closes the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connection and releases all associated resources with a specified timeout to allow queued data to be sent.</source>
          <target state="translated">Fecha a conexão de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> e libera todos os recursos associados com um tempo limite especificado para permitir que os dados em fila sejam enviados.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method closes the remote host connection and releases all managed and unmanaged resources associated with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> método fecha a conexão do host remoto e versões de todos os recursos gerenciados e associados a <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>Upon closing, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph>.</source>
          <target state="translated">No fechamento, a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> está definida como <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>For connection-oriented protocols, it is recommended that you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>.</source>
          <target state="translated">Para protocolos orientados a conexão, é recomendável que você chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> antes de chamar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>This ensures that all data is sent and received on the connected socket before it is closed.</source>
          <target state="translated">Isso garante que todos os dados são enviadas e recebidas no soquete conectado antes de ser fechado.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>If you need to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> without first calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, you can ensure that data queued for outgoing transmission will be sent by setting the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> option to <ph id="ph4">`false`</ph> and specifying a non-zero time-out interval.</source>
          <target state="translated">Se você precisar chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> sem primeiro chamar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, você pode garantir que dados na fila de transmissão de saída será enviada, definindo o <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> opção para <ph id="ph4">`false`</ph> e especificando um intervalo de tempo-limite diferente de zero.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> will then block until this data is sent or until the specified time-out expires.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> em seguida, bloqueia até que esses dados são enviados ou expira o tempo limite especificado.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>If you set <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> to <ph id="ph2">`false`</ph> and specify a zero time-out interval, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> releases the connection and automatically discards outgoing queued data.</source>
          <target state="translated">Se você definir <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> para <ph id="ph2">`false`</ph> e especificar um zero intervalo de tempo limite, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> libera a conexão e descarta automaticamente os dados na fila de saída.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>To set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> socket option to <ph id="ph2">`false`</ph>, create a <ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>, set the enabled property to <ph id="ph4">`true`</ph>, and set the <ph id="ph5">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> property to the desired time-out period.</source>
          <target state="translated">Para definir o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> soquete opção para <ph id="ph2">`false`</ph>, criar um <ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>, defina a propriedade enabled como <ph id="ph4">`true`</ph>e defina o <ph id="ph5">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> propriedade para o período de tempo limite desejado.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>Use this <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> along with the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> socket option to call the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">Use este <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> juntamente com o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> soquete opção para chamar o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>The following code example demonstrates how to close a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir demonstra como fechar uma <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Establishes a connection to a remote host.</source>
          <target state="translated">Estabelece uma conexão com o host remoto.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that represents the remote device.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> que representa o dispositivo remoto.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>Establishes a connection to a remote host.</source>
          <target state="translated">Estabelece uma conexão com o host remoto.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol such as TCP, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method synchronously establishes a network connection between <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> and the specified remote endpoint.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão como TCP, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método sincronicamente estabelece uma conexão de rede entre <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> e o ponto de extremidade remoto especificado.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> establishes a default remote host.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> estabelece um host remoto padrão.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>After you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, you can send data to the remote device with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method, or receive data from the remote device with the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
          <target state="translated">Depois de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, você pode enviar dados para o dispositivo remoto com o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> método, ou receber dados do dispositivo remoto com o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão como UDP, você não precisa chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> antes de enviar e receber dados.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> to synchronously communicate with a remote host.</source>
          <target state="translated">Você pode usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> para se comunicar de forma síncrona com um host remoto.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">Se você chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, datagramas que chegam de um endereço diferente do padrão especificado serão descartadas.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you want to set your default remote host to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você quiser definir seu host remoto padrão para um endereço de difusão, você deve primeiro chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> opção de método e defina o soquete para <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> lançará um <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method will block, unless you specifically set the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id="ph3">`false`</ph> prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método será bloqueada, a menos que você defina especificamente o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> propriedade <ph id="ph3">`false`</ph> antes de chamar <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol like TCP and you do disable blocking, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> because it needs time to make the connection.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão como TCP e você desativar o bloqueio, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> porque ele precisa de tempo para fazer a conexão.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>Connectionless protocols will not throw an exception because they simply establish a default remote host.</source>
          <target state="translated">Sem conexão protocolos não lançará uma exceção porque eles simplesmente estabelecer um host remoto padrão.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> to obtain the specific error code.</source>
          <target state="translated">Você pode usar <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, but has not yet completed successfully.</source>
          <target state="translated">Se o erro retornado WSAEWOULDBLOCK, a conexão do host remoto foi iniciada por uma conexão orientada <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, mas ainda não foi concluído com êxito.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method to determine when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is finished connecting.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> método para determinar quando o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> for concluído se conectar.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol and did not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the underlying service provider will assign the local network address and port number.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão e não chamou <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> antes de chamar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</source>
          <target state="translated">Se você estiver usando um protocolo sem conexão, o provedor de serviços não atribuirá um número de porta e endereço de rede local até você concluir um envio ou operação de recebimento.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you want to change the default remote host, call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> again with the desired endpoint.</source>
          <target state="translated">Se você quiser alterar o host remoto padrão, chame <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> novamente com o ponto de extremidade desejado.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If the socket has been previously disconnected, then you cannot use this method to restore the connection.</source>
          <target state="translated">Se o soquete foi desconectado anteriormente, você não pode usar esse método para restaurar a conexão.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>Use one of the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> methods to reconnect.</source>
          <target state="translated">Use um dos assíncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> métodos para se reconectar.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">Essa é uma limitação do provedor subjacente.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>The following code example connects to a remote endpoint and then verifies the connection.</source>
          <target state="translated">O exemplo de código a seguir se conecta a um ponto de extremidade remoto e, em seguida, verifica a conexão.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">Um chamador mais alto na pilha de chamadas não tem permissão para a operação solicitada.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi colocado em um estado de escuta chamando <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>for connecting to the remote host.</source>
          <target state="translated">para conectar-se ao host remoto.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Connect" /&gt;</ph></source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Connect" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The IP address of the remote host.</source>
          <target state="translated">O endereço IP do host remoto.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The port number of the remote host.</source>
          <target state="translated">O número da porta do host remoto.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>Establishes a connection to a remote host.</source>
          <target state="translated">Estabelece uma conexão com o host remoto.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The host is specified by an IP address and a port number.</source>
          <target state="translated">O host é especificado por um endereço IP e um número da porta.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you are using a connection-oriented protocol such as TCP, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method synchronously establishes a network connection between <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> and the specified remote endpoint.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão como TCP, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método sincronicamente estabelece uma conexão de rede entre <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> e o ponto de extremidade remoto especificado.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> establishes a default remote host.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> estabelece um host remoto padrão.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>After you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> you can send data to the remote device with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method, or receive data from the remote device with the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
          <target state="translated">Depois de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> você pode enviar dados para o dispositivo remoto com o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> método, ou receber dados do dispositivo remoto com o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão como UDP, você não precisa chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> antes de enviar e receber dados.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> to synchronously communicate with a remote host.</source>
          <target state="translated">Você pode usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> para se comunicar de forma síncrona com um host remoto.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">Se você chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> datagramas que chegam de um endereço diferente do padrão especificado serão descartadas.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you want to set your default remote host to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você quiser definir seu host remoto padrão para um endereço de difusão, você deve primeiro chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> opção de método e defina o soquete para <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> lançará um <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method will block, unless you specifically set the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id="ph3">`false`</ph> prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método será bloqueada, a menos que você defina especificamente o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> propriedade <ph id="ph3">`false`</ph> antes de chamar <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you are using a connection-oriented protocol like TCP and you do disable blocking, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> because it needs time to make the connection.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão como TCP e você desativar o bloqueio, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> porque ele precisa de tempo para fazer a conexão.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>Connectionless protocols will not throw an exception because they simply establish a default remote host.</source>
          <target state="translated">Sem conexão protocolos não lançará uma exceção porque eles simplesmente estabelecer um host remoto padrão.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> to obtain the specific error code.</source>
          <target state="translated">Você pode usar <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, but has not yet completed successfully.</source>
          <target state="translated">Se o erro retornado WSAEWOULDBLOCK, a conexão do host remoto foi iniciada por uma conexão orientada <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, mas ainda não foi concluído com êxito.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method to determine when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is finished connecting.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> método para determinar quando o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> for concluído se conectar.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you are using a connection-oriented protocol and did not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the underlying service provider will assign the local network address and port number.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão e não chamou <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> antes de chamar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</source>
          <target state="translated">Se você estiver usando um protocolo sem conexão, o provedor de serviços não atribuirá um número de porta e endereço de rede local até você concluir um envio ou operação de recebimento.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you want to change the default remote host, call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> again with the desired endpoint.</source>
          <target state="translated">Se você quiser alterar o host remoto padrão, chame <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> novamente com o ponto de extremidade desejado.</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If the socket has been previously disconnected, then you cannot use this method to restore the connection.</source>
          <target state="translated">Se o soquete foi desconectado anteriormente, você não pode usar esse método para restaurar a conexão.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>Use one of the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> methods to reconnect.</source>
          <target state="translated">Use um dos assíncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> métodos para se reconectar.</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">Essa é uma limitação do provedor subjacente.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The following code example connects to a remote endpoint and then verifies the connection.</source>
          <target state="translated">O exemplo de código a seguir se conecta a um ponto de extremidade remoto e, em seguida, verifica a conexão.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="address" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="address" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The port number is not valid.</source>
          <target state="translated">O número da porta é inválido.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>This method is valid for sockets in the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> families.</source>
          <target state="translated">Este método é válido para soquetes nas famílias <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> ou <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The length of <ph id="ph1">&lt;paramref name="address" /&gt;</ph> is zero.</source>
          <target state="translated">O comprimento de <ph id="ph1">&lt;paramref name="address" /&gt;</ph> é zero.</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi colocado em um estado de escuta chamando <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The IP addresses of the remote host.</source>
          <target state="translated">Os endereços IP do host remoto.</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The port number of the remote host.</source>
          <target state="translated">O número da porta do host remoto.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>Establishes a connection to a remote host.</source>
          <target state="translated">Estabelece uma conexão com o host remoto.</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The host is specified by an array of IP addresses and a port number.</source>
          <target state="translated">O host é especificado por uma matriz de endereços IP e um número da porta.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>This method is typically used immediately after a call to <ph id="ph1">&lt;xref:System.Net.Dns.GetHostAddresses%2A&gt;</ph>, which can return multiple IP addresses for a single host.</source>
          <target state="translated">Esse método é geralmente usado imediatamente após uma chamada para <ph id="ph1">&lt;xref:System.Net.Dns.GetHostAddresses%2A&gt;</ph>, que pode retornar vários endereços IP para um único host.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you are using a connection-oriented protocol such as TCP, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method synchronously establishes a network connection between <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> and the specified remote endpoint.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão como TCP, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método sincronicamente estabelece uma conexão de rede entre <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> e o ponto de extremidade remoto especificado.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> establishes a default remote host.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> estabelece um host remoto padrão.</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>After you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> you can send data to the remote device with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method, or receive data from the remote device with the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
          <target state="translated">Depois de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> você pode enviar dados para o dispositivo remoto com o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> método, ou receber dados do dispositivo remoto com o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão como UDP, você não precisa chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> antes de enviar e receber dados.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> to synchronously communicate with a remote host.</source>
          <target state="translated">Você pode usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> para se comunicar de forma síncrona com um host remoto.</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">Se você chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> datagramas que chegam de um endereço diferente do padrão especificado serão descartadas.</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you want to set your default remote host to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você quiser definir seu host remoto padrão para um endereço de difusão, você deve primeiro chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> opção de método e defina o soquete para <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> lançará um <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method will block, unless you specifically set the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id="ph3">`false`</ph> prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método será bloqueada, a menos que você defina especificamente o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> propriedade <ph id="ph3">`false`</ph> antes de chamar <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you are using a connection-oriented protocol like TCP and you do disable blocking, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> because it needs time to make the connection.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão como TCP e você desativar o bloqueio, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> porque ele precisa de tempo para fazer a conexão.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>Connectionless protocols will not throw an exception because they simply establish a default remote host.</source>
          <target state="translated">Sem conexão protocolos não lançará uma exceção porque eles simplesmente estabelecer um host remoto padrão.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> to obtain the specific error code.</source>
          <target state="translated">Você pode usar <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, but has not yet completed successfully.</source>
          <target state="translated">Se o erro retornado WSAEWOULDBLOCK, a conexão do host remoto foi iniciada por uma conexão orientada <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, mas ainda não foi concluído com êxito.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method to determine when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is finished connecting.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> método para determinar quando o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> for concluído se conectar.</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you are using a connection-oriented protocol and did not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the underlying service provider will assign the local network address and port number.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão e não chamou <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> antes de chamar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</source>
          <target state="translated">Se você estiver usando um protocolo sem conexão, o provedor de serviços não atribuirá um número de porta e endereço de rede local até você concluir um envio ou operação de recebimento.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you want to change the default remote host, call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> again with the desired endpoint.</source>
          <target state="translated">Se você quiser alterar o host remoto padrão, chame <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> novamente com o ponto de extremidade desejado.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If the socket has been previously disconnected, then you cannot use this method to restore the connection.</source>
          <target state="translated">Se o soquete foi desconectado anteriormente, você não pode usar esse método para restaurar a conexão.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>Use one of the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> methods to reconnect.</source>
          <target state="translated">Use um dos assíncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> métodos para se reconectar.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">Essa é uma limitação do provedor subjacente.</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The following code example connects to a remote endpoint and then verifies the connection.</source>
          <target state="translated">O exemplo de código a seguir se conecta a um ponto de extremidade remoto e, em seguida, verifica a conexão.</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="addresses" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="addresses" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The port number is not valid.</source>
          <target state="translated">O número da porta é inválido.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>This method is valid for sockets in the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> families.</source>
          <target state="translated">Este método é válido para soquetes nas famílias <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> ou <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The length of <ph id="ph1">&lt;paramref name="address" /&gt;</ph> is zero.</source>
          <target state="translated">O comprimento de <ph id="ph1">&lt;paramref name="address" /&gt;</ph> é zero.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi colocado em um estado de escuta chamando <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The name of the remote host.</source>
          <target state="translated">O nome do host remoto.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The port number of the remote host.</source>
          <target state="translated">O número da porta do host remoto.</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>Establishes a connection to a remote host.</source>
          <target state="translated">Estabelece uma conexão com o host remoto.</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The host is specified by a host name and a port number.</source>
          <target state="translated">O host é especificado por um nome do host e um número da porta.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you are using a connection-oriented protocol such as TCP, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method synchronously establishes a network connection between <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> and the specified remote host.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão como TCP, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método sincronicamente estabelece uma conexão de rede entre <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> e o host remoto especificado.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> establishes a default remote host.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> estabelece um host remoto padrão.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>After you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> you can send data to the remote device with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method, or receive data from the remote device with the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
          <target state="translated">Depois de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> você pode enviar dados para o dispositivo remoto com o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> método, ou receber dados do dispositivo remoto com o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão como UDP, você não precisa chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> antes de enviar e receber dados.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> to synchronously communicate with a remote host.</source>
          <target state="translated">Você pode usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> para se comunicar de forma síncrona com um host remoto.</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">Se você chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> datagramas que chegam de um endereço diferente do padrão especificado serão descartadas.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you want to set your default remote host to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você quiser definir seu host remoto padrão para um endereço de difusão, você deve primeiro chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> opção de método e defina o soquete para <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> lançará um <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method will block, unless you specifically set the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id="ph3">`false`</ph> prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método será bloqueada, a menos que você defina especificamente o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> propriedade <ph id="ph3">`false`</ph> antes de chamar <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you are using a connection-oriented protocol like TCP and you do disable blocking, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> because it needs time to make the connection.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão como TCP e você desativar o bloqueio, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> porque ele precisa de tempo para fazer a conexão.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>Connectionless protocols will not throw an exception because they simply establish a default remote host.</source>
          <target state="translated">Sem conexão protocolos não lançará uma exceção porque eles simplesmente estabelecer um host remoto padrão.</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> to obtain the specific error code.</source>
          <target state="translated">Você pode usar <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, but has not yet completed successfully.</source>
          <target state="translated">Se o erro retornado WSAEWOULDBLOCK, a conexão do host remoto foi iniciada por uma conexão orientada <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, mas ainda não foi concluído com êxito.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method to determine when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is finished connecting.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> método para determinar quando o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> for concluído se conectar.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If IPv6 is enabled and the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29&gt;</ph> method is called to connect to a host that resolves to both IPv6 and IPv4 addresses, the connection to the IPv6 address will be attempted first before the IPv4 address.</source>
          <target state="translated">Se o IPv6 estiver habilitado e o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29&gt;</ph> método é chamado para se conectar a um host que resolve para ambos IPv6 e endereços IPv4, a conexão do IPv6 endereço será tentada primeiro antes do endereço IPv4.</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>This may have the effect of delaying the time to establish the connection if the host is not listening on the IPv6 address.</source>
          <target state="translated">Isso pode ter o efeito do atraso de tempo para estabelecer a conexão, se o host não está escutando no endereço IPv6.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you are using a connection-oriented protocol and did not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the underlying service provider will assign the local network address and port number.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão e não chamou <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> antes de chamar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</source>
          <target state="translated">Se você estiver usando um protocolo sem conexão, o provedor de serviços não atribuirá um número de porta e endereço de rede local até você concluir um envio ou operação de recebimento.</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you want to change the default remote host, call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> again with the desired endpoint.</source>
          <target state="translated">Se você quiser alterar o host remoto padrão, chame <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> novamente com o ponto de extremidade desejado.</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If the socket has been previously disconnected, then you cannot use this method to restore the connection.</source>
          <target state="translated">Se o soquete foi desconectado anteriormente, você não pode usar esse método para restaurar a conexão.</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>Use one of the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> methods to reconnect.</source>
          <target state="translated">Use um dos assíncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> métodos para se reconectar.</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">Essa é uma limitação do provedor subjacente.</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The following code example connects to a remote endpoint and then verifies the connection.</source>
          <target state="translated">O exemplo de código a seguir se conecta a um ponto de extremidade remoto e, em seguida, verifica a conexão.</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="host" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="host" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The port number is not valid.</source>
          <target state="translated">O número da porta é inválido.</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>This method is valid for sockets in the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> families.</source>
          <target state="translated">Este método é válido para soquetes nas famílias <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> ou <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi colocado em um estado de escuta chamando <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Begins an asynchronous request for a connection to a remote host.</source>
          <target state="translated">Inicia uma solicitação assíncrona para uma conexão com um host remoto.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> a ser usado nessa operação de soquete assíncrono.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins an asynchronous request for a connection to a remote host.</source>
          <target state="translated">Inicia uma solicitação assíncrona para uma conexão com um host remoto.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">Retorna <ph id="ph1">&lt;see langword="true" /&gt;</ph> se a operação de E/S está pendente.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">O evento <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> no parâmetro <ph id="ph2">&lt;paramref name="e" /&gt;</ph> será acionado após a conclusão da operação.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">Retorna <ph id="ph1">&lt;see langword="false" /&gt;</ph> se a operação de E/S foi concluída de forma síncrona.</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">Nesse caso, o evento <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> no parâmetro <ph id="ph2">&lt;paramref name="e" /&gt;</ph> não será gerado e o objeto <ph id="ph3">&lt;paramref name="e" /&gt;</ph> passado como um parâmetro poderá ser examinado imediatamente depois que a chamada do método for retornada para recuperar o resultado da operação.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method starts an asynchronous request for a connection to the remote host.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> método inicia uma solicitação assíncrona para uma conexão com o host remoto.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> establishes a default remote host.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> estabelece um host remoto padrão.</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>To be notified of completion, you must create a callback method that implements the EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs&gt; delegate and attach the callback to the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">Para ser notificado de conclusão, você deve criar um método de retorno de chamada que implementa EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs &gt; delegar e anexe o retorno de chamada para o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller must set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property to the <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> of the remote host to connect to.</source>
          <target state="translated">O chamador deverá definir a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> propriedade para o <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> do host remoto para se conectar ao.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">O chamador pode definir o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> propriedade para qualquer objeto de estado do usuário desejado antes de chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> método, para que as informações serão recuperáveis no método de retorno de chamada.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">Se o retorno de chamada precisa de mais informações do que um único objeto, uma pequena classe pode ser criada para manter as outras informações de estado necessárias como membros.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão como UDP, você não precisa chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> antes de enviar e receber dados.</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> to communicate with a remote host.</source>
          <target state="translated">Você pode usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> para se comunicar com um host remoto.</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">Se você chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, datagramas que chegam de um endereço diferente do padrão especificado serão descartadas.</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you want to change the default remote host, call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method again with the desired endpoint.</source>
          <target state="translated">Se você quiser alterar o host remoto padrão, chame o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> método novamente com o ponto de extremidade desejado.</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you wish to set the default remote host to a broadcast address, you must first call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> and set Broadcast to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Se você deseja definir o host remoto padrão para um endereço de difusão, você deve primeiro chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> e defina a transmissão para <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If this is not done, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se isso não for feito, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> método lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required:</source>
          <target state="translated">As seguintes propriedades e eventos no <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> objeto são necessárias:</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Optionally, a buffer may be provided which will atomically be sent on the socket after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method succeeds.</source>
          <target state="translated">Opcionalmente, um buffer pode ser fornecido que será enviado atomicamente no soquete após o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> método for bem-sucedido.</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> property needs to be set to the buffer containing the data to send and the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> property needs to be set to the number of bytes of data to send from the buffer.</source>
          <target state="translated">Nesse caso, o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> propriedade deve ser definida para o buffer que contém os dados para enviar e <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> propriedade precisa ser definido como o número de bytes de dados para enviar do buffer.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Once a connection is established, this buffer of data is sent.</source>
          <target state="translated">Quando uma conexão é estabelecida, esse buffer de dados é enviada.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connection-oriented protocol and do not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão e não chame <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> antes de chamar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local mais adequado.</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> methods.</source>
          <target state="translated">Se você estiver usando um protocolo sem conexão, o provedor de serviços não atribuirá um número de porta e endereço IP do local de rede até que você chame o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method throws <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> if the address family of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the <ph id="ph4">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> are not the same address family.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> método lança <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> se a família de endereços do <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> e <ph id="ph4">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> não são da mesma família de endereço.</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> when calling this method, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> ao chamar esse método, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An argument is not valid.</source>
          <target state="translated">Um argumento não é válido.</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception occurs if multiple buffers are specified, the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> property is not null.</source>
          <target state="translated">Essa exceção ocorrerá se vários buffers forem especificados e a propriedade <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> não for nula.</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;paramref name="e" /&gt;</ph> parameter cannot be null and the <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> cannot be null.</source>
          <target state="translated">O parâmetro <ph id="ph1">&lt;paramref name="e" /&gt;</ph> e o <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> não podem ser nulos.</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is listening or a socket operation was already in progress using the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> está escutando ou uma operação de soquete já estava em andamento usando o objeto <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> especificado no parâmetro <ph id="ph3">&lt;paramref name="e" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">É necessário o Windows XP ou posterior para esse método.</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception also occurs if the local endpoint and the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> are not the same address family.</source>
          <target state="translated">Essa exceção também ocorrerá se o ponto de extremidade local e o <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> não forem da mesma família de endereços.</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">Um chamador mais alto na pilha de chamadas não tem permissão para a operação solicitada.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph> values.</source>
          <target state="translated">Um dos valores de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph> values.</source>
          <target state="translated">Um dos valores de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> a ser usado nessa operação de soquete assíncrono.</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins an asynchronous request for a connection to a remote host.</source>
          <target state="translated">Inicia uma solicitação assíncrona para uma conexão com um host remoto.</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">Retorna <ph id="ph1">&lt;see langword="true" /&gt;</ph> se a operação de E/S está pendente.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">O evento <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> no parâmetro <ph id="ph2">&lt;paramref name="e" /&gt;</ph> será acionado após a conclusão da operação.</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">Retorna <ph id="ph1">&lt;see langword="false" /&gt;</ph> se a operação de E/S foi concluída de forma síncrona.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">Nesse caso, o evento <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> no parâmetro <ph id="ph2">&lt;paramref name="e" /&gt;</ph> não será gerado e o objeto <ph id="ph3">&lt;paramref name="e" /&gt;</ph> passado como um parâmetro poderá ser examinado imediatamente depois que a chamada do método for retornada para recuperar o resultado da operação.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connection-oriented protocol, the M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) method starts an asynchronous request for a connection to the remote host.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, o método M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) inicia uma solicitação assíncrona para uma conexão com o host remoto.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> establishes a default remote host specified by the <ph id="ph2">`socketType`</ph> and <ph id="ph3">`protocolType`</ph> parameters.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> estabelece um host remoto padrão especificado pelo <ph id="ph2">`socketType`</ph> e <ph id="ph3">`protocolType`</ph> parâmetros.</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>To be notified of completion, you must create a callback method that implements the EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs&gt; delegate and attach the callback to the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">Para ser notificado de conclusão, você deve criar um método de retorno de chamada que implementa EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs &gt; delegar e anexe o retorno de chamada para o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller must set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property to the <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> of the remote host to connect to.</source>
          <target state="translated">O chamador deverá definir a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> propriedade para o <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> do host remoto para se conectar ao.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">O chamador pode definir o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> propriedade para qualquer objeto de estado do usuário desejado antes de chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> método, para que as informações serão recuperáveis no método de retorno de chamada.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">Se o retorno de chamada precisa de mais informações do que um único objeto, uma pequena classe pode ser criada para manter as outras informações de estado necessárias como membros.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão como UDP, você não precisa chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> antes de enviar e receber dados.</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> to communicate with a remote host.</source>
          <target state="translated">Você pode usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> para se comunicar com um host remoto.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">Se você chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, datagramas que chegam de um endereço diferente do padrão especificado serão descartadas.</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you want to change the default remote host, call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method again with the desired endpoint.</source>
          <target state="translated">Se você quiser alterar o host remoto padrão, chame o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> método novamente com o ponto de extremidade desejado.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you wish to set the default remote host to a broadcast address, you must first call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> and set Broadcast to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Se você deseja definir o host remoto padrão para um endereço de difusão, você deve primeiro chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> e defina a transmissão para <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If this is not done, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se isso não for feito, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> método lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required:</source>
          <target state="translated">As seguintes propriedades e eventos no <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> objeto são necessárias:</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Optionally, a buffer may be provided which will atomically be sent on the socket after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method succeeds.</source>
          <target state="translated">Opcionalmente, um buffer pode ser fornecido que será enviado atomicamente no soquete após o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> método for bem-sucedido.</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> property needs to be set to the buffer containing the data to send and the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> property needs to be set to the number of bytes of data to send from the buffer.</source>
          <target state="translated">Nesse caso, o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> propriedade deve ser definida para o buffer que contém os dados para enviar e <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> propriedade precisa ser definido como o número de bytes de dados para enviar do buffer.</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Once a connection is established, this buffer of data is sent.</source>
          <target state="translated">Quando uma conexão é estabelecida, esse buffer de dados é enviada.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connection-oriented protocol and do not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão e não chame <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> antes de chamar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local mais adequado.</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> methods.</source>
          <target state="translated">Se você estiver usando um protocolo sem conexão, o provedor de serviços não atribuirá um número de porta e endereço IP do local de rede até que você chame o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method throws <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> if the address family of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the <ph id="ph4">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> are not the same address family.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> método lança <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> se a família de endereços do <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> e <ph id="ph4">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> não são da mesma família de endereço.</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> when calling this method, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> ao chamar esse método, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An argument is not valid.</source>
          <target state="translated">Um argumento não é válido.</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception occurs if multiple buffers are specified, the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> property is not null.</source>
          <target state="translated">Essa exceção ocorrerá se vários buffers forem especificados e a propriedade <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> não for nula.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;paramref name="e" /&gt;</ph> parameter cannot be null and the <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> cannot be null.</source>
          <target state="translated">O parâmetro <ph id="ph1">&lt;paramref name="e" /&gt;</ph> e o <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> não podem ser nulos.</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is listening or a socket operation was already in progress using the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> está escutando ou uma operação de soquete já estava em andamento usando o objeto <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> especificado no parâmetro <ph id="ph3">&lt;paramref name="e" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">É necessário o Windows XP ou posterior para esse método.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception also occurs if the local endpoint and the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> are not the same address family.</source>
          <target state="translated">Essa exceção também ocorrerá se o ponto de extremidade local e o <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> não forem da mesma família de endereços.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">Um chamador mais alto na pilha de chamadas não tem permissão para a operação solicitada.</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Connected">
          <source>Gets a value that indicates whether a <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is connected to a remote host as of the last <ph id="ph2">&lt;see cref="Overload:System.Net.Sockets.Socket.Send" /&gt;</ph> or <ph id="ph3">&lt;see cref="Overload:System.Net.Sockets.Socket.Receive" /&gt;</ph> operation.</source>
          <target state="translated">Obtém um valor que indica se um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> está conectado a um host remoto desde a última operação <ph id="ph2">&lt;see cref="Overload:System.Net.Sockets.Socket.Send" /&gt;</ph> ou <ph id="ph3">&lt;see cref="Overload:System.Net.Sockets.Socket.Receive" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> was connected to a remote resource as of the most recent operation; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> tiver sido conectado a um recurso remoto desde a operação mais recente; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>The <ph id="ph1">`Connected`</ph> property gets the connection state of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> as of the last I/O operation.</source>
          <target state="translated">O <ph id="ph1">`Connected`</ph> propriedade obtém o estado de conexão do <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> desde a última operação de e/s.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>When it returns <ph id="ph1">`false`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> was either never connected, or is no longer connected.</source>
          <target state="translated">Quando ele retorna <ph id="ph1">`false`</ph>, o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> nunca foi conectado ou não está mais conectado.</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>The value of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property reflects the state of the connection as of the most recent operation.</source>
          <target state="translated">O valor de <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> propriedade reflete o estado da conexão a partir da operação mais recente.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>If you need to determine the current state of the connection, make a nonblocking, zero-byte Send call.</source>
          <target state="translated">Se você precisar determinar o estado atual da conexão, fazer com que um envio sem bloqueio, zero bytes chamada.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>If the call returns successfully or throws a WAEWOULDBLOCK error code (10035), then the socket is still connected; otherwise, the socket is no longer connected.</source>
          <target state="translated">Se a chamada retorna com êxito ou gera um código de erro WAEWOULDBLOCK (10035), o soquete ainda está conectado; Caso contrário, o soquete não está mais conectado.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>If you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> on a User Datagram Protocol (UDP) socket, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property always returns <ph id="ph3">`true`</ph>; however, this action does not change the inherent connectionless nature of UDP.</source>
          <target state="translated">Se você chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> em um soquete do protocolo UDP (User Datagram), o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> propriedade sempre retorna <ph id="ph3">`true`</ph>; no entanto, essa ação não altera a natureza sem-conexão inerente de UDP.</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>The following code example connects to a remote endpoint, checks the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property, and checks the current state of the connection.</source>
          <target state="translated">O exemplo de código a seguir se conecta a um ponto de extremidade remoto, as verificações de <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> propriedade e verifica o estado atual da conexão.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this socket can be reused after the current connection is closed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o soquete puder ser reutilizado após a conexão atual ser fechada; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>Closes the socket connection and allows reuse of the socket.</source>
          <target state="translated">Fecha a conexão de soquete e permite a reutilização do soquete.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>If you are using a connection-oriented protocol, you can use this method to close the socket.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, você pode usar esse método para fechar o soquete.</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>This method ends the connection and sets the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property to <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Este termina de método de conexão e os conjuntos de <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> propriedade para <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>However, if <ph id="ph1">`reuseSocket`</ph> is <ph id="ph2">`true`</ph>, you can reuse the socket.</source>
          <target state="translated">No entanto, se <ph id="ph1">`reuseSocket`</ph> é <ph id="ph2">`true`</ph>, você pode reutilizar o soquete.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>To ensure that all data is sent and received before the socket is closed, you should call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> method.</source>
          <target state="translated">Para garantir que todos os dados são enviadas e recebidas antes do fechamento de soquete, você deve chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> antes de chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>If you need to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> without first calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, you can set the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph><ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option to <ph id="ph5">`false`</ph> and specify a nonzero time-out interval to ensure that data queued for outgoing transmission is sent.</source>
          <target state="translated">Se você precisar chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> sem primeiro chamar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, você pode definir o <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> opção para <ph id="ph5">`false`</ph> e especificar um intervalo de tempo limite diferente de zero para garantir que dados na fila de transmissão de saída é enviada.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> then blocks until the data is sent or until the specified time-out expires.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> em seguida, bloqueia até que os dados são enviados ou expira o tempo limite especificado.</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>If you set <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> to <ph id="ph2">`false`</ph> and specify a zero time-out interval, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> releases the connection and automatically discards outgoing queued data.</source>
          <target state="translated">Se você definir <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> para <ph id="ph2">`false`</ph> e especificar um zero intervalo de tempo limite, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> libera a conexão e descarta automaticamente os dados na fila de saída.</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>The following code example creates a socket for synchronous communication and sends some data to a remote host.</source>
          <target state="translated">O exemplo de código a seguir cria um soquete para comunicação síncrona e envia alguns dados para um host remoto.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>It then calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, to stop the send and receive activity, and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph>, to close the socket connection.</source>
          <target state="translated">Depois, ele chama <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, para parar o envio e recebimento de atividade, e <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph>para fechar a conexão de soquete.</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>This method requires Windows 2000 or earlier, or the exception will be thrown.</source>
          <target state="translated">Esse método requer o Windows 2000 ou anterior, ou a exceção será gerada.</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> a ser usado nessa operação de soquete assíncrono.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins an asynchronous request to disconnect from a remote endpoint.</source>
          <target state="translated">Inicia uma solicitação assíncrona para se desconectar de um ponto de extremidade remoto.</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">Retorna <ph id="ph1">&lt;see langword="true" /&gt;</ph> se a operação de E/S está pendente.</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">O evento <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> no parâmetro <ph id="ph2">&lt;paramref name="e" /&gt;</ph> será acionado após a conclusão da operação.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">Retorna <ph id="ph1">&lt;see langword="false" /&gt;</ph> se a operação de E/S foi concluída de forma síncrona.</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">Nesse caso, o evento <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> no parâmetro <ph id="ph2">&lt;paramref name="e" /&gt;</ph> não será gerado e o objeto <ph id="ph3">&lt;paramref name="e" /&gt;</ph> passado como um parâmetro poderá ser examinado imediatamente depois que a chamada do método for retornada para recuperar o resultado da operação.</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>When using a connection-oriented protocol, calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DisconnectAsync%2A&gt;</ph> method requests a disconnect from a remote endpoint.</source>
          <target state="translated">Ao usar um protocolo orientado a conexão, chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DisconnectAsync%2A&gt;</ph> método solicita uma desconexão de um ponto de extremidade remoto.</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you set <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType&gt;</ph> to <ph id="ph2">`true`</ph> in the <ph id="ph3">`e`</ph> parameter, the socket can be reused.</source>
          <target state="translated">Se você definir <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType&gt;</ph> para <ph id="ph2">`true`</ph> no <ph id="ph3">`e`</ph> parâmetro, o soquete pode ser reutilizado.</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;paramref name="e" /&gt;</ph> parameter cannot be null.</source>
          <target state="translated">O parâmetro <ph id="ph1">&lt;paramref name="e" /&gt;</ph> não pode ser nulo.</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated">Uma operação de soquete já estava em andamento com o objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> especificado no parâmetro <ph id="ph2">&lt;paramref name="e" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">É necessário o Windows XP ou posterior para esse método.</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class.</source>
          <target state="translated">Libera todos os recursos usados pela instância atual da classe <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class.</source>
          <target state="translated">Libera todos os recursos usados pela instância atual da classe <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>Call <ph id="ph1">`Dispose`</ph> when you are finished using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Chamar <ph id="ph1">`Dispose`</ph> quando tiver terminado de usar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>The <ph id="ph1">`Dispose`</ph> method leaves the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> in an unusable state.</source>
          <target state="translated">O <ph id="ph1">`Dispose`</ph> método deixa o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> em um estado inutilizável.</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>After calling <ph id="ph1">`Dispose`</ph>, you must release all references to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> so the garbage collector can reclaim the memory that the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> was occupying.</source>
          <target state="translated">Depois de chamar <ph id="ph1">`Dispose`</ph>, você deve liberar todas as referências para o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> para o coletor de lixo possa recuperar a memória que o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> estava ocupando.</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>For more information, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> and <bpt id="p2">[</bpt>Implementing a Dispose Method<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>limpeza de recursos não gerenciados<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> e <bpt id="p2">[</bpt>implementar um método Dispose<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>Always call <ph id="ph1">`Dispose`</ph> before you release your last reference to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Sempre chamar <ph id="ph1">`Dispose`</ph> antes de liberar sua última referência para o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>Otherwise, the resources it is using will not be freed until the garbage collector calls the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object's <ph id="ph2">`Finalize`</ph> method.</source>
          <target state="translated">Caso contrário, os recursos que está usando não serão liberados até que o coletor de lixo chame o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> do objeto <ph id="ph2">`Finalize`</ph> método.</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to release both managed and unmanaged resources; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to releases only unmanaged resources.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para liberar recursos gerenciados e não gerenciados; <ph id="ph2">&lt;see langword="false" /&gt;</ph> para liberar apenas recursos não gerenciados.</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>Releases the unmanaged resources used by the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, and optionally disposes of the managed resources.</source>
          <target state="translated">Libera os recursos não gerenciados usados pelo <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> e, opcionalmente, descarta os recursos gerenciados.</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>This method is called by the public <ph id="ph1">`Dispose()`</ph> method and the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">Este método é chamado pelo método público <ph id="ph1">`Dispose()`</ph> e pelo método <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source><ph id="ph1">`Dispose()`</ph> invokes the protected <ph id="ph2">`Dispose(Boolean)`</ph> method with the <ph id="ph3">`disposing`</ph> parameter set to <ph id="ph4">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">`Dispose()`</ph> invoca o método <ph id="ph2">`Dispose(Boolean)`</ph> protegido com o parâmetro <ph id="ph3">`disposing`</ph> definido como <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> invokes <ph id="ph2">`Dispose`</ph> with <ph id="ph3">`disposing`</ph> set to <ph id="ph4">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> invoca <ph id="ph2">`Dispose`</ph> com <ph id="ph3">`disposing`</ph> definido como <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>When the <ph id="ph1">`disposing`</ph> parameter is <ph id="ph2">`true`</ph>, this method releases all resources held by any managed objects that this <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> references.</source>
          <target state="translated">Quando o <ph id="ph1">`disposing`</ph> parâmetro é <ph id="ph2">`true`</ph>, esse método libera todos os recursos mantidos por qualquer objeto gerenciado que este <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> referências.</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>This method invokes the <ph id="ph1">`Dispose()`</ph> method of each referenced object.</source>
          <target state="translated">Este método invoca o método <ph id="ph1">`Dispose()`</ph> de cada objeto referenciado.</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> can be called multiple times by other objects.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> pode ser chamado várias vezes por outros objetos.</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>When overriding <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /&gt;</ph>, be careful not to reference objects that have been previously disposed of in an earlier call to <ph id="ph2">&lt;see langword="Dispose" /&gt;</ph>.</source>
          <target state="translated">Ao substituir <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /&gt;</ph>, tome cuidado para não referenciar objetos que tenham sido descartados anteriormente em uma chamada anterior para <ph id="ph2">&lt;see langword="Dispose" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>For more information about how to implement <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /&gt;</ph>, see <bpt id="p1">[</bpt>Implementing a Dispose Method<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre como implementar <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /&gt;</ph>, consulte <bpt id="p1">[</bpt>implementar um método Dispose<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>For more information about <ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Object.Finalize" /&gt;</ph>, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> and <bpt id="p2">[</bpt>Overriding the Finalize Method<ept id="p2">](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)</ept>.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> e <ph id="ph2">&lt;see cref="M:System.Object.Finalize" /&gt;</ph>, consulte <bpt id="p1">[</bpt>limpeza de recursos não gerenciados<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> e <bpt id="p2">[</bpt>substituindo o método Finalize<ept id="p2">](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)</ept>.</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> value that specifies whether the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> allows Internet Protocol (IP) datagrams to be fragmented.</source>
          <target state="translated">Obtém ou define um valor <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> que especifica se o <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> permite que datagramas de protocolo IP sejam fragmentados.</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> allows datagram fragmentation; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> permite a fragmentação de datagramas; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>Datagrams require fragmentation when their size exceeds the Maximum Transfer Unit (MTU) of the transmission medium.</source>
          <target state="translated">Datagramas requerem fragmentação quando seu tamanho excede a transferência de unidade máxima (MTU) da mídia de transmissão.</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>Datagrams may be fragmented by the sending host (all Internet Protocol versions) or an intermediate router (Internet Protocol Version 4 only).</source>
          <target state="translated">Datagramas podem ser fragmentadas, o host de envio (todas as versões de protocolo de Internet) ou um roteador intermediário (protocolo IP versão 4 somente).</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>If a datagram must be fragmented, and the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DontFragment%2A&gt;</ph> option is set, the datagram is discarded, and an Internet Control Message Protocol (ICMP) error message is sent back to the sender of the datagram.</source>
          <target state="translated">Se um datagrama deve ser fragmentado e o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DontFragment%2A&gt;</ph> opção for definida, o datagrama é descartado e uma mensagem de erro de protocolo de mensagem de controle da Internet (ICMP) é enviada para o remetente do datagrama.</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</source>
          <target state="translated">A definição dessa propriedade em um soquete do protocolo de controle de transmissão (TCP) não terá efeito.</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DontFragment%2A&gt;</ph> property.</source>
          <target state="translated">O exemplo de código a seguir demonstra o uso do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DontFragment%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>This property can be set only for sockets in the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> families.</source>
          <target state="translated">Essa propriedade pode ser definida apenas para soquetes nas famílias <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> ou <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.DualMode">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> value that specifies whether the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is a dual-mode socket used for both IPv4 and IPv6.</source>
          <target state="translated">Obtém ou define um valor de <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> que especifica se o <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> é um soquete de modo duplo, usado para IPv4 e IPv6.</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DualMode">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is a  dual-mode socket; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> for um soquete de modo duplo; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DualMode">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>The ID of the target process where a duplicate of the socket reference is created.</source>
          <target state="translated">A ID do processo de destino em que uma duplicata da referência de soquete é criada.</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>Duplicates the socket reference for the target process, and closes the socket for this process.</source>
          <target state="translated">Duplica a referência de soquete para o processo de destino e fecha o soquete para esse processo.</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>The socket reference to be passed to the target process.</source>
          <target state="translated">A referência de soquete a ser passada para o processo de destino.</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>The target process should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph> to create the duplicate socket instance.</source>
          <target state="translated">O processo de destino deve usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph> para criar a instância de soquete duplicada.</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>If you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instances with the same underlying socket.</source>
          <target state="translated">Se você chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph> construtor várias vezes com a mesma matriz de bytes como o argumento para cada chamada, você criará vários gerenciado <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instâncias com o mesmo soquete subjacente.</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>This practice is strongly discouraged.</source>
          <target state="translated">Essa prática é altamente desaconselhável.</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>If the process creating the socket uses asynchronous methods (<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>), the process must first set the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A&gt;</ph> property to true; otherwise, the socket is bound to the completion port of the creating process, which may cause an <ph id="ph4">&lt;xref:System.ArgumentNullException&gt;</ph> to be thrown on the target process.</source>
          <target state="translated">Se o processo de criar o soquete usa métodos assíncronos (<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>), o processo deve primeiro definir a <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A&gt;</ph> propriedade como true; caso contrário, o soquete está associado à porta de conclusão do processo de criação, que pode causar um <ph id="ph4">&lt;xref:System.ArgumentNullException&gt;</ph> seja gerada no processo de destino.</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="targetProcessID" /&gt;</ph> is not a valid process id.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="targetProcessID" /&gt;</ph> não é uma ID de processo válida.</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>Duplication of the socket reference failed.</source>
          <target state="translated">Falha na duplicação de referência do soquete.</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> value that specifies whether the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> can send or receive broadcast packets.</source>
          <target state="translated">Obtém ou define um valor <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> que especifica se o <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> pode enviar ou receber pacotes de difusão.</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> allows broadcast packets; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> permitir pacotes de difusão; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>Broadcasting is limited to a specific subnet, and must use User Datagram Protocol (UDP.) For Internet Protocol version 4, you can broadcast to your local subnet by sending a packet to 255.255.255.255; or you can use the directed broadcast address, which is the network portion of an Internet Protocol (IP) address with all bits set in the host portion.</source>
          <target state="translated">Difusão é limitada a uma sub-rede específica e deve usar o protocolo de datagrama de usuário (UDP). Protocolo IP versão 4, você pode transmitir a sua sub-rede local, enviando um pacote para 255.255.255.255; ou você pode usar o endereço de difusão direcionado, o que é a parte da rede de um endereço IP (Internet Protocol) com todos os bits definidos na parte do host.</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>For example, if your IP address is 192.168.1.40 (a Class C address, with a netmask of 255.255.255.0 -- the network portion is the first three octets, and the host portion is the last octet), your directed broadcast address is 192.168.1.255.</source>
          <target state="translated">Por exemplo, se seu endereço IP é 192.168.1.40 (um endereço de classe C, com uma máscara de rede de 255.255.255.0 – a parte de rede tem os três primeiros octetos e a parte do host é o último octeto), seu endereço de difusão direcionado é 192.168.1.255.</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</source>
          <target state="translated">A definição dessa propriedade em um soquete do protocolo de controle de transmissão (TCP) não terá efeito.</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EnableBroadcast%2A&gt;</ph> property.</source>
          <target state="translated">O exemplo de código a seguir demonstra o uso do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EnableBroadcast%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>This option is valid for a datagram socket only.</source>
          <target state="translated">Essa opção é válida apenas para um soquete de datagrama.</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Asynchronously accepts an incoming connection attempt.</source>
          <target state="translated">Aceita de forma assíncrono uma tentativa de conexão de entrada.</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the bytes transferred.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que contém os bytes transferidos.</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that stores state information for this asynchronous operation as well as any user defined data.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que armazena as informações de estado dessa operação assíncrona, bem como os dados definidos pelo usuário.</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>Asynchronously accepts an incoming connection attempt and creates a new <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object to handle remote host communication.</source>
          <target state="translated">Aceita de forma assíncrona uma tentativa de conexão de entrada e cria um novo objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> para manipular as comunicações de host remoto.</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>This method returns a buffer that contains the initial data transferred.</source>
          <target state="translated">Esse método retorna um buffer que contém os dados iniciais transferidos.</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object to handle communication with the remote host.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> para manipular as comunicações com o host remoto.</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> completes a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> conclui uma chamada para <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, you need to create a callback method that is invoked by the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Antes de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, você precisa criar um método de retorno de chamada é invocado pelo <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>This callback method executes in a separate thread, and is called by the system after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method returns.</source>
          <target state="translated">Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método retorna.</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">`asyncResult`</ph> parameter to obtain the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> on which the connection attempt is being made.</source>
          <target state="translated">Dentro do método de retorno de chamada, chame o <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> método o <ph id="ph2">`asyncResult`</ph> parâmetro para obter o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> no qual a tentativa de conexão está sendo feita.</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method to successfully complete the connection attempt.</source>
          <target state="translated">Depois de obter o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, você pode chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> método concluído com êxito a tentativa de conexão.</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The <ph id="ph1">`buffer`</ph> parameter of this overload contains the data that was received in the call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> and the <ph id="ph3">`bytesTransferred`</ph> parameter contains the number of bytes that were transferred in the call.</source>
          <target state="translated">O <ph id="ph1">`buffer`</ph> parâmetro essa sobrecarga contém os dados que foram recebidos na chamada para <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> e <ph id="ph3">`bytesTransferred`</ph> parâmetro contém o número de bytes que foram transferidos na chamada.</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method blocks until a connection is pending in the incoming connection queue.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> método bloqueia até que uma conexão está pendente na fila de conexão de entrada.</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method accepts the incoming connection and returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that can be used to send data to and receive data from the remote host.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> método aceita a conexão de entrada e retorna um novo <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> que pode ser usado para enviar e receber dados do host remoto.</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The following code example uses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> to create and connect a socket and accept the initial 10 bytes of data.</source>
          <target state="translated">O seguinte exemplo de código usa <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> para criar e conectar-se a um soquete e aceitar inicias 10 bytes de dados.</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The callback delegate calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> to end the asynchronous request.</source>
          <target state="translated">O retorno de chamada delegar chamadas <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> para encerrar a solicitação assíncrona.</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The number of bytes transmitted and the data are returned in the <ph id="ph1">`buffer`</ph> and <ph id="ph2">`bytesTransferred`</ph> parameters of this method and are displayed on the console.</source>
          <target state="translated">O número de bytes transmitidos e os dados são retornados no <ph id="ph1">`buffer`</ph> e <ph id="ph2">`bytesTransferred`</ph> parâmetros desse método e são exibidos no console.</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>Windows NT is required for this method.</source>
          <target state="translated">Windows NT é necessário para esse método.</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> está vazio.</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not created by a call to <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> não foi criado por uma chamada a <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /&gt;</ph> method was previously called.</source>
          <target state="translated">O método <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /&gt;</ph> foi chamado anteriormente.</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>An error occurred when attempting to access the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph></source>
          <target state="translated">Ocorreu um erro ao tentar acessar o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>Asynchronously accepts an incoming connection attempt and creates a new <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> to handle remote host communication.</source>
          <target state="translated">Aceita de forma assíncrona uma tentativa de conexão de entrada e cria um novo <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> para manipular as comunicações com o host remoto.</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> to handle communication with the remote host.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> para manipular as comunicações com o host remoto.</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> completes a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> conclui uma chamada para <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Antes de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, você precisa criar um método de retorno de chamada que implementa o <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>This callback method executes in a separate thread, and is called by the system after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method returns.</source>
          <target state="translated">Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método retorna.</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>It must accept the <ph id="ph1">`asyncResult`</ph> parameter returned from the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">Ele deve aceitar o <ph id="ph1">`asyncResult`</ph> parâmetro retornado do <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">`asyncResult`</ph> parameter to obtain the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> on which the connection attempt is being made.</source>
          <target state="translated">Dentro do método de retorno de chamada, chame o <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> método o <ph id="ph2">`asyncResult`</ph> parâmetro para obter o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> no qual a tentativa de conexão está sendo feita.</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method to successfully complete the connection attempt.</source>
          <target state="translated">Depois de obter o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, você pode chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> método concluído com êxito a tentativa de conexão.</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method blocks until a connection is pending in the incoming connection queue.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> método bloqueia até que uma conexão está pendente na fila de conexão de entrada.</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method accepts the incoming connection and returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that can be used to send data to and receive data from the remote host.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> método aceita a conexão de entrada e retorna um novo <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> que pode ser usado para enviar e receber dados do host remoto.</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>The following code example ends an asynchronous request and creates a new <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept an incoming connection request.</source>
          <target state="translated">O exemplo de código a seguir encerra uma solicitação assíncrona e cria um novo <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> para aceitar uma solicitação de conexão de entrada.</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>For a complete example that demonstrates asynchronous communications with sockets, see <bpt id="p1">[</bpt>Socket Code Examples<ept id="p1">](~/docs/framework/network-programming/socket-code-examples.md)</ept>.</source>
          <target state="translated">Para obter um exemplo completo que demonstra a comunicação assíncrona com soquetes, consulte <bpt id="p1">[</bpt>exemplos de código do soquete<ept id="p1">](~/docs/framework/network-programming/socket-code-examples.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not created by a call to <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> não foi criado por uma chamada para <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>See the Remarks section for more information.</source>
          <target state="translated">Consulte a seção Comentários para obter mais informações.</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /&gt;</ph> method was previously called.</source>
          <target state="translated">O método <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /&gt;</ph> foi chamado anteriormente.</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>Windows NT is required for this method.</source>
          <target state="translated">Windows NT é necessário para esse método.</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the bytes transferred.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que contém os bytes transferidos.</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The number of bytes transferred.</source>
          <target state="translated">O número de bytes transferidos.</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that stores state information for this asynchronous operation as well as any user defined data.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que armazena as informações de estado dessa operação assíncrona, bem como os dados definidos pelo usuário.</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>Asynchronously accepts an incoming connection attempt and creates a new <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object to handle remote host communication.</source>
          <target state="translated">Aceita de forma assíncrona uma tentativa de conexão de entrada e cria um novo objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> para manipular as comunicações de host remoto.</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>This method returns a buffer that contains the initial data and the number of bytes transferred.</source>
          <target state="translated">Esse método retorna um buffer que contém os dados iniciais e o número de bytes transferidos.</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object to handle communication with the remote host.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> para manipular as comunicações com o host remoto.</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> completes a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> conclui uma chamada para <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, you need to create a callback method that is invoked by the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Antes de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, você precisa criar um método de retorno de chamada é invocado pelo <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>This callback method executes in a separate thread, and is called by the system after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method returns.</source>
          <target state="translated">Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método retorna.</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>It must accept the <ph id="ph1">`asyncResult`</ph> parameter returned from the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">Ele deve aceitar o <ph id="ph1">`asyncResult`</ph> parâmetro retornado do <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">`asyncResult`</ph> parameter to obtain the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> on which the connection attempt is being made.</source>
          <target state="translated">Dentro do método de retorno de chamada, chame o <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> método o <ph id="ph2">`asyncResult`</ph> parâmetro para obter o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> no qual a tentativa de conexão está sendo feita.</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method to successfully complete the connection attempt.</source>
          <target state="translated">Depois de obter o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, você pode chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> método concluído com êxito a tentativa de conexão.</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The <ph id="ph1">`buffer`</ph> parameter of this overload contains the data that was received in the call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> and the <ph id="ph3">`bytesTransferred`</ph> parameter contains the number of bytes that were transferred in the call.</source>
          <target state="translated">O <ph id="ph1">`buffer`</ph> parâmetro essa sobrecarga contém os dados que foram recebidos na chamada para <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> e <ph id="ph3">`bytesTransferred`</ph> parâmetro contém o número de bytes que foram transferidos na chamada.</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method blocks until a connection is pending in the incoming connection queue.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> método bloqueia até que uma conexão está pendente na fila de conexão de entrada.</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method accepts the incoming connection and returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that can be used to send data to and receive data from the remote host.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> método aceita a conexão de entrada e retorna um novo <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> que pode ser usado para enviar e receber dados do host remoto.</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The following code example uses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> to create and connect a socket and accept the initial 10 bytes of data.</source>
          <target state="translated">O seguinte exemplo de código usa <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> para criar e conectar-se a um soquete e aceitar inicias 10 bytes de dados.</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The callback delegate calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> to end the asynchronous request.</source>
          <target state="translated">O retorno de chamada delegar chamadas <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> para encerrar a solicitação assíncrona.</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The number of bytes transmitted and the data are returned in the <ph id="ph1">`buffer`</ph> and <ph id="ph2">`bytesTransferred`</ph> parameters of this method and are displayed on the console.</source>
          <target state="translated">O número de bytes transmitidos e os dados são retornados no <ph id="ph1">`buffer`</ph> e <ph id="ph2">`bytesTransferred`</ph> parâmetros desse método e são exibidos no console.</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>Windows NT is required for this method.</source>
          <target state="translated">Windows NT é necessário para esse método.</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> está vazio.</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not created by a call to <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> não foi criado por uma chamada a <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /&gt;</ph> method was previously called.</source>
          <target state="translated">O método <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /&gt;</ph> foi chamado anteriormente.</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>An error occurred when attempting to access the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>Ends a pending asynchronous connection request.</source>
          <target state="translated">Encerra uma solicitação de conexão assíncrona pendente.</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> is a blocking method that completes the asynchronous remote host connection request started in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> é um método de bloqueio que conclui a solicitação de conexão do host remoto assíncrono iniciado no <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Antes de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, você precisa criar um método de retorno de chamada que implementa o <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> returns.</source>
          <target state="translated">Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> retorna.</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">O método de retorno de chamada deve aceitar o <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> retornado pelo <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> método como um parâmetro.</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> on which the connection attempt is being made.</source>
          <target state="translated">Dentro do método de retorno de chamada, chame o <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> método o <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parâmetro para obter o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> no qual a tentativa de conexão está sendo feita.</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method to successfully complete the connection attempt.</source>
          <target state="translated">Depois de obter o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, você pode chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> método concluído com êxito a tentativa de conexão.</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>The following code example ends the asynchronous connection attempt.</source>
          <target state="translated">O exemplo de código a seguir encerra a tentativa de conexão assíncrona.</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>For a complete example that demonstrates asynchronous communications with sockets, see <bpt id="p1">[</bpt>Socket Code Examples<ept id="p1">](~/docs/framework/network-programming/socket-code-examples.md)</ept>.</source>
          <target state="translated">Para obter um exemplo completo que demonstra a comunicação assíncrona com soquetes, consulte <bpt id="p1">[</bpt>exemplos de código do soquete<ept id="p1">](~/docs/framework/network-programming/socket-code-examples.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> não foi retornado por uma chamada ao método <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous connection.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /&gt;</ph> foi chamado anteriormente para a conexão assíncrona.</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that stores state information and any user-defined data for this asynchronous operation.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que armazena as informações de estado e os dados definidos pelo usuário para esta operação assíncrona.</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>Ends a pending asynchronous disconnect request.</source>
          <target state="translated">Encerra uma solicitação de desconexão assíncrona pendente.</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> completes a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> conclui uma chamada para <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> method blocks until the disconnect completes.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> método bloqueia até que seja concluída a desconexão.</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>For information about asynchronous operations, see the Asynchronous Programming Overview topic in the MSDN library.</source>
          <target state="translated">Para obter informações sobre as operações assíncronas, consulte o tópico de visão de geral de programação assíncrona na biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>The following code example creates a socket for asynchronous communication and sends some data to a remote host.</source>
          <target state="translated">O exemplo de código a seguir cria um soquete para comunicação assíncrona e envia alguns dados para um host remoto.</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>When the data has been sent, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> is called to stop the send and receive activity.</source>
          <target state="translated">Quando os dados foram enviados, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> é chamado para parar o envio e a atividade de recebimento.</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>Then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> is called to begin a disconnect request.</source>
          <target state="translated">Em seguida, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> é chamado para iniciar uma solicitação de desconexão.</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>The callback delegate calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> to end the asynchronous request.</source>
          <target state="translated">O retorno de chamada delegar chamadas <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> para encerrar a solicitação assíncrona.</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>When the request completes, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property is queried to test whether the socket is disconnected.</source>
          <target state="translated">Quando a solicitação é concluída, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> propriedade será consultada para testar se o soquete está desconectado.</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>The operating system is Windows 2000 or earlier, and this method requires Windows XP.</source>
          <target state="translated">O sistema operacional é o Windows 2000 ou anterior e esse método requer o Windows XP.</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> não foi retornado por uma chamada ao método <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous connection.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /&gt;</ph> foi chamado anteriormente para a conexão assíncrona.</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>The disconnect request has timed out.</source>
          <target state="translated">A solicitação de desconexão atingiu o tempo limite.</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Ends a pending asynchronous read.</source>
          <target state="translated">Encerra uma leitura assíncrona pendente.</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>Ends a pending asynchronous read.</source>
          <target state="translated">Encerra uma leitura assíncrona pendente.</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>The number of bytes received.</source>
          <target state="translated">O número de bytes recebidos.</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method completes the asynchronous read operation started in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> a operação de leitura assíncrona iniciada conclusão do método de <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Antes de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, você precisa criar um método de retorno de chamada que implementa o <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> returns.</source>
          <target state="translated">Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> retorna.</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">O método de retorno de chamada deve aceitar o <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> retornado pelo <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> método como um parâmetro.</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to obtain the state object passed to the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
          <target state="translated">Dentro do método de retorno de chamada, chame o <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> método o <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> para obter o objeto de estado passado para o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>Extract the receiving <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> from this state object.</source>
          <target state="translated">Extrair o recebimento <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> deste objeto de estado.</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method to successfully complete the read operation and return the number of bytes read.</source>
          <target state="translated">Depois de obter o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, você pode chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> método para concluir a operação de leitura e retornar o número de bytes lidos com êxito.</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> método será bloqueado até que os dados estão disponíveis.</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> will read the first enqueued datagram available in the incoming network buffer.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> lerá o datagrama enfileiradas primeiro disponível no buffer de entrada de rede.</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will read as much data as is available up to the number of bytes you specified in the <ph id="ph2">`size`</ph> parameter of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> método lerá a quantidade de dados está disponível até o número de bytes especificado no <ph id="ph2">`size`</ph> parâmetro o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Se o host remoto é desligado o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> conexão com o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> método e todos os dados disponíveis foi recebida, o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> método será concluída imediatamente e retornará zero bytes.</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>To obtain the received data, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>, and extract the buffer contained in the resulting state object.</source>
          <target state="translated">Para obter os dados recebidos, chame o <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> método o <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>e extraia o buffer contido no objeto de estado resultante.</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">Para cancelar um pendente <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, chame o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">E/s iniciada por um determinado thread é cancelada quando que sai do thread.</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>The following code example ends a pending asynchronous read.</source>
          <target state="translated">O exemplo de código a seguir encerra uma leitura assíncrona pendente.</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>For a complete example that demonstrates asynchronous communications with sockets, see <bpt id="p1">[</bpt>Socket Code Examples<ept id="p1">](~/docs/framework/network-programming/socket-code-examples.md)</ept>.</source>
          <target state="translated">Para obter um exemplo completo que demonstra a comunicação assíncrona com soquetes, consulte <bpt id="p1">[</bpt>exemplos de código do soquete<ept id="p1">](~/docs/framework/network-programming/socket-code-examples.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> não foi retornado por uma chamada ao método <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous read.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> foi chamado anteriormente para a leitura assíncrona.</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that stores state information and any user defined data for this asynchronous operation.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que armazena informações de estado e dados definidos pelo usuário para essa operação assíncrona.</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> que armazena o erro de soquete.</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Ends a pending asynchronous read.</source>
          <target state="translated">Encerra uma leitura assíncrona pendente.</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The number of bytes received.</source>
          <target state="translated">O número de bytes recebidos.</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method completes the asynchronous read operation started in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> a operação de leitura assíncrona iniciada conclusão do método de <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Antes de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, você precisa criar um método de retorno de chamada que implementa o <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> returns.</source>
          <target state="translated">Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> retorna.</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">O método de retorno de chamada deve aceitar o <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> retornado pelo <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> método como um parâmetro.</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to obtain the state object passed to the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
          <target state="translated">Dentro do método de retorno de chamada, chame o <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> método o <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> para obter o objeto de estado passado para o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Extract the receiving <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> from this state object.</source>
          <target state="translated">Extrair o recebimento <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> deste objeto de estado.</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method to successfully complete the read operation and return the number of bytes read.</source>
          <target state="translated">Depois de obter o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, você pode chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> método para concluir a operação de leitura e retornar o número de bytes lidos com êxito.</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> método será bloqueado até que os dados estão disponíveis.</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> will read the first enqueued datagram available in the incoming network buffer.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> lerá o datagrama enfileiradas primeiro disponível no buffer de entrada de rede.</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will read as much data as is available up to the number of bytes you specified in the <ph id="ph2">`size`</ph> parameter of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> método lerá a quantidade de dados está disponível até o número de bytes especificado no <ph id="ph2">`size`</ph> parâmetro o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Se o host remoto é desligado o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> conexão com o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> método e todos os dados disponíveis foi recebida, o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> método será concluída imediatamente e retornará zero bytes.</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>To obtain the received data, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>, and extract the buffer contained in the resulting state object.</source>
          <target state="translated">Para obter os dados recebidos, chame o <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> método o <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>e extraia o buffer contido no objeto de estado resultante.</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">E/s iniciada por um determinado thread é cancelada quando que sai do thread.</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> não foi retornado por uma chamada ao método <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous read.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> foi chamado anteriormente para a leitura assíncrona.</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>Ends a pending asynchronous read from a specific endpoint.</source>
          <target state="translated">Termina uma leitura assíncrona pendente de um ponto de extremidade específico.</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>If successful, the number of bytes received.</source>
          <target state="translated">Se tiver êxito, o número de bytes recebidos.</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>If unsuccessful, returns 0.</source>
          <target state="translated">Caso contrário, retornará 0.</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method completes the asynchronous read operation started in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> a operação de leitura assíncrona iniciada conclusão do método de <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Antes de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, você precisa criar um método de retorno de chamada que implementa o <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> returns.</source>
          <target state="translated">Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> retorna.</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">O método de retorno de chamada deve aceitar o <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> retornado pelo <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> método como um parâmetro.</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to obtain the state object passed to the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Dentro do método de retorno de chamada, chame o <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> método o <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> para obter o objeto de estado passado para o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>Extract the receiving <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> from this state object.</source>
          <target state="translated">Extrair o recebimento <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> deste objeto de estado.</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method to successfully complete the read operation and return the number of bytes read.</source>
          <target state="translated">Depois de obter o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, você pode chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> método para concluir a operação de leitura e retornar o número de bytes lidos com êxito.</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> método será bloqueado até que os dados estão disponíveis.</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> will read the first enqueued datagram available in the incoming network buffer.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> lerá o datagrama enfileiradas primeiro disponível no buffer de entrada de rede.</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method will read as much data as is available up to the number of bytes you specified in the <ph id="ph2">`size`</ph> parameter of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> método lerá a quantidade de dados está disponível até o número de bytes especificado no <ph id="ph2">`size`</ph> parâmetro o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Se o host remoto é desligado o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> conexão com o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> método e todos os dados disponíveis foi recebida, o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> método será concluída imediatamente e retornará zero bytes.</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>To obtain the received data, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> object, and extract the buffer contained in the resulting state object.</source>
          <target state="translated">Para obter os dados recebidos, chame o <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> método o <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> objeto e, em seguida, extrair o buffer contido no objeto de estado resultante.</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>To identify the originating host, extract the <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> and cast it to an <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph>.</source>
          <target state="translated">Para identificar o host de origem, extrair o <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> e convertê-lo para um <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType&gt;</ph> method to obtain the IP address and the <ph id="ph2">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType&gt;</ph> method to obtain the port number.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType&gt;</ph> método para obter o endereço IP e o <ph id="ph2">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType&gt;</ph> método para obter o número da porta.</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>The following code example ends a pending asynchronous read from a specific <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir encerra uma leitura assíncrona pendente de um determinado <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> não foi retornado por uma chamada ao método <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /&gt;</ph> was previously called for the asynchronous read.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /&gt;</ph> foi chamado anteriormente para a leitura assíncrona.</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that stores state information and any user defined data for this asynchronous operation.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que armazena informações de estado e dados definidos pelo usuário para essa operação assíncrona.</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values for the received packet.</source>
          <target state="translated">Uma combinação bit a bit dos valores <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> para o pacote recebido.</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The source <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>.</source>
          <target state="translated">A fonte de <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> and interface of the received packet.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> e a interface do pacote recebido.</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>Ends a pending asynchronous read from a specific endpoint.</source>
          <target state="translated">Termina uma leitura assíncrona pendente de um ponto de extremidade específico.</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>This method also reveals more information about the packet than <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /&gt;</ph>.</source>
          <target state="translated">Esse método também revela mais informações sobre o pacote que <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>If successful, the number of bytes received.</source>
          <target state="translated">Se tiver êxito, o número de bytes recebidos.</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>If unsuccessful, returns 0.</source>
          <target state="translated">Caso contrário, retornará 0.</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>If the operation has not completed, this method blocks until it does.</source>
          <target state="translated">Se a operação não foi concluída, esse método bloqueia até que ele faz.</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>To perform this operation synchronously, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method.</source>
          <target state="translated">Para executar esta operação síncrona, use o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>Examine <ph id="ph1">`ipPacketInformation`</ph> if you need to know if the datagram was sent using a unicast, multicast, or broadcast address.</source>
          <target state="translated">Examine <ph id="ph1">`ipPacketInformation`</ph> se você precisa saber se o datagrama foi enviado por meio de uma unicast, o endereço de difusão ou multicast.</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="endPoint" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="endPoint" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> não foi retornado por uma chamada ao método <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /&gt;</ph> was previously called for the asynchronous read.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /&gt;</ph> foi chamado anteriormente para a leitura assíncrona.</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Ends a pending asynchronous send.</source>
          <target state="translated">Encerra um envio assíncrono pendente.</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>Ends a pending asynchronous send.</source>
          <target state="translated">Encerra um envio assíncrono pendente.</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>If successful, the number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>; otherwise, an invalid <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> error.</source>
          <target state="translated">Se for bem-sucedido, o número de bytes enviados para o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>; caso contrário, um erro <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> inválido.</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> completes the asynchronous send operation started in <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> conclui a operação de envio assíncrono iniciada em <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Antes de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, você precisa criar um método de retorno de chamada que implementa o <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> returns.</source>
          <target state="translated">Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> retorna.</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">O método de retorno de chamada deve aceitar o <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> retornado pelo <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> método como um parâmetro.</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the sending <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Dentro do método de retorno de chamada, chame o <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> método o <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parâmetro para obter o envio <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method to successfully complete the send operation and return the number of bytes sent.</source>
          <target state="translated">Depois de obter o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, você pode chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> método para concluir a operação de envio e retornar o número de bytes enviados com êxito.</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> será bloqueada até que o datagrama seja enviado.</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> will block until some of the buffer was sent.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> será bloqueado até que algumas do buffer foi enviada.</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>If the return value from <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> indicates that the buffer was not completely sent, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method again, modifying the buffer to hold the unsent data.</source>
          <target state="translated">Se o valor de retorno de <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> indica que o buffer não foi completamente enviadas, chame o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> método novamente, modificando o buffer para armazenar os dados não enviados.</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada.</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Uma execução bem-sucedida do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">E/s iniciada por um determinado thread é cancelada quando que sai do thread.</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito.</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>The following code example ends a pending asynchronous send.</source>
          <target state="translated">O exemplo de código a seguir encerra um envio assíncrono pendente.</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> não foi retornado por uma chamada ao método <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous send.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /&gt;</ph> foi chamado anteriormente para o envio assíncrono.</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that stores state information for this asynchronous operation.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que armazena as informações de estado dessa operação assíncrona.</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> que armazena o erro de soquete.</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Ends a pending asynchronous send.</source>
          <target state="translated">Encerra um envio assíncrono pendente.</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If successful, the number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>; otherwise, an invalid <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> error.</source>
          <target state="translated">Se for bem-sucedido, o número de bytes enviados para o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>; caso contrário, um erro <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> inválido.</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> completes the asynchronous send operation started in <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> conclui a operação de envio assíncrono iniciada em <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Antes de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, você precisa criar um método de retorno de chamada que implementa o <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> returns.</source>
          <target state="translated">Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> retorna.</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">O método de retorno de chamada deve aceitar o <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> retornado pelo <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> método como um parâmetro.</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the sending <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Dentro do método de retorno de chamada, chame o <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> método o <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parâmetro para obter o envio <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method to successfully complete the send operation and return the number of bytes sent.</source>
          <target state="translated">Depois de obter o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, você pode chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> método para concluir a operação de envio e retornar o número de bytes enviados com êxito.</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> será bloqueada até que o datagrama seja enviado.</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> will block until some of the buffer was sent.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> será bloqueado até que algumas do buffer foi enviada.</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If the return value from <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> indicates that the buffer was not completely sent, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method again, modifying the buffer to hold the unsent data.</source>
          <target state="translated">Se o valor de retorno de <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> indica que o buffer não foi completamente enviadas, chame o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> método novamente, modificando o buffer para armazenar os dados não enviados.</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada.</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Uma execução bem-sucedida do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">E/s iniciada por um determinado thread é cancelada quando que sai do thread.</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito.</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> não foi retornado por uma chamada ao método <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous send.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /&gt;</ph> foi chamado anteriormente para o envio assíncrono.</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that stores state information for this asynchronous operation.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> que armazena informações de estado para essa operação assíncrona.</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>Ends a pending asynchronous send of a file.</source>
          <target state="translated">Encerra um envio assíncrono pendente de um arquivo.</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> completes the asynchronous send operation started in <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> conclui a operação de envio assíncrono iniciada em <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>, you must create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Antes de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>, você deve criar um método de retorno de chamada que implementa o <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> returns.</source>
          <target state="translated">Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> retorna.</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> object returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">O método de retorno de chamada deve aceitar o <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> objeto retornado pelo <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> método como um parâmetro.</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the sending <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Dentro do método de retorno de chamada, chame o <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> método o <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parâmetro para obter o envio <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> method to successfully complete the send operation.</source>
          <target state="translated">Depois de obter o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, você pode chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> método concluído com êxito a operação de envio.</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> blocks until the datagram is sent.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> bloqueia até que o datagrama seja enviado.</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> blocks until the entire file is sent.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> bloqueia até que o arquivo inteiro seja enviado.</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada.</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Uma execução bem-sucedida do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</source>
          <target state="translated">O exemplo de código a seguir cria e se conecta a um soquete para comunicação assíncrona e começa a enviar o arquivo "Test.txt" assincronamente para o host remoto.</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>The callback delegate calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> to complete the transmission.</source>
          <target state="translated">O retorno de chamada delegar chamadas <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> para concluir a transmissão.</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>Windows NT is required for this method.</source>
          <target state="translated">Windows NT é necessário para esse método.</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> está vazio.</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> não foi retornado por uma chamada ao método <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /&gt;</ph> foi chamado anteriormente para o <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /&gt;</ph> assíncrono.</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>See remarks section below.</source>
          <target state="translated">Consulte a seção Comentários abaixo.</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>Ends a pending asynchronous send to a specific location.</source>
          <target state="translated">Encerra um envio assíncrono pendente para um local específico.</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>If successful, the number of bytes sent; otherwise, an invalid <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> error.</source>
          <target state="translated">Se for bem-sucedido, o número de bytes enviados; caso contrário, um erro <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> inválido.</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> completes the asynchronous send operation started in <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> conclui a operação de envio assíncrono iniciada em <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Antes de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>, você precisa criar um método de retorno de chamada que implementa o <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> returns.</source>
          <target state="translated">Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> retorna.</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">O método de retorno de chamada deve aceitar o <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> retornado pelo <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> método como um parâmetro.</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the sending <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Dentro do método de retorno de chamada, chame o <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> método o <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parâmetro para obter o envio <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> method to successfully complete the send operation and return the number of bytes sent.</source>
          <target state="translated">Depois de obter o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, você pode chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> método para concluir a operação de envio e retornar o número de bytes enviados com êxito.</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> será bloqueada até que o datagrama seja enviado.</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> will block until the requested number of bytes are sent.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> será bloqueado até que o número solicitado de bytes é enviado.</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada.</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Uma execução bem-sucedida do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>The following code example ends an asynchronous send to a specific location.</source>
          <target state="translated">O exemplo de código a seguir encerra um envio assíncrono para um local específico.</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> não foi retornado por uma chamada ao método <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous send.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /&gt;</ph> foi chamado anteriormente para o envio assíncrono.</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> value that specifies whether the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> allows only one process to bind to a port.</source>
          <target state="translated">Obtém ou define um valor <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> que especifica se o <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> permite que um único processo se associe a uma porta.</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> allows only one socket to bind to a specific port; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> permitir que apenas um soquete se associe a uma porta específica; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph> for Windows Server 2003 and Windows XP Service Pack 2, and <ph id="ph2">&lt;see langword="false" /&gt;</ph> for all other versions.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="true" /&gt;</ph> para Windows Server 2003 e Windows XP Service Pack 2, e <ph id="ph2">&lt;see langword="false" /&gt;</ph> para todas as outras versões.</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>If <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph> is <ph id="ph2">`false`</ph>, multiple sockets can use the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method to bind to a specific port; however only one of the sockets can perform operations on the network traffic sent to the port.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph> é <ph id="ph2">`false`</ph>, vários soquetes podem usar o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> método para vincular a uma porta específica; no entanto, somente um dos soquetes de pode executar operações em que o tráfego de rede enviado para a porta.</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>If more than one socket attempts to use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29&gt;</ph> method to bind to a particular port, then the one with the more specific IP address will handle the network traffic sent to that port.</source>
          <target state="translated">Se mais de um soquete tenta usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29&gt;</ph> método para vincular a uma porta específica, em seguida, um com o endereço IP mais específico manipulará o tráfego de rede enviado a essa porta.</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>If <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph> is <ph id="ph2">`true`</ph>, the first use of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method to attempt to bind to a particular port, regardless of Internet Protocol (IP) address, will succeed; all subsequent uses of the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method to attempt to bind to that port will fail until the original bound socket is destroyed.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph> é <ph id="ph2">`true`</ph>, o primeiro uso do <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> método para tentar associar a uma porta específica, independentemente do endereço IP (Internet Protocol), será bem-sucedida; usos subsequentes do <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> método para tentar associar a porta falharão até que o original associado soquete é destruído.</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>This property must be set before <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> is called; otherwise an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown.</source>
          <target state="translated">Essa propriedade deve ser definida antes de <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> é chamado; caso contrário, um <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> será lançada.</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph> property.</source>
          <target state="translated">O exemplo de código a seguir demonstra o uso do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> has been called for this <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> foi chamado para este <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Finalize">
          <source>Frees resources used by the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class.</source>
          <target state="translated">Libera os recursos usados pela classe <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class finalizer calls the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method to close the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and free resources associated with the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> classe finalizador chamadas a <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> método para fechar o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> e liberar recursos associados a <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Returns the value of a <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option.</source>
          <target state="translated">Retorna o valor de uma opção <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          <target state="translated">Um dos valores de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          <target state="translated">Um dos valores de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>Returns the value of a specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option, represented as an object.</source>
          <target state="translated">Retorna o valor de uma opção <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> especificada, representada como um objeto.</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>An object that represents the value of the option.</source>
          <target state="translated">Um objeto que representa o valor da opção.</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>When the <ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> parameter is set to <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.Linger" /&gt;</ph> the return value is an instance of the <ph id="ph3">&lt;see cref="T:System.Net.Sockets.LingerOption" /&gt;</ph> class.</source>
          <target state="translated">Quando o parâmetro <ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> for definido como <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.Linger" /&gt;</ph>, o valor retornado é uma instância da classe <ph id="ph3">&lt;see cref="T:System.Net.Sockets.LingerOption" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>When <ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" /&gt;</ph>, the return value is an instance of the <ph id="ph4">&lt;see cref="T:System.Net.Sockets.MulticastOption" /&gt;</ph> class.</source>
          <target state="translated">Quando <ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> for definido como <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /&gt;</ph> ou <ph id="ph3">&lt;see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" /&gt;</ph>, o valor retornado é uma instância da classe <ph id="ph4">&lt;see cref="T:System.Net.Sockets.MulticastOption" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>When <ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> is any other value, the return value is an integer.</source>
          <target state="translated">Quando <ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> for qualquer outro valor, o valor retornado é um inteiro.</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> opções determinam o comportamento do atual <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>Use this overload to get the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph><ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options.</source>
          <target state="translated">Use essa sobrecarga para obter o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph>, e <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph> <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> opções.</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>For the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph> option, use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> for the <ph id="ph3">`optionLevel`</ph> parameter.</source>
          <target state="translated">Para o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph> opção, use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> para o <ph id="ph3">`optionLevel`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>For <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph>, use <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph>.</source>
          <target state="translated">Para <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph> e <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph>, use <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>If you want to set the value of any of the options listed above, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">Se você deseja definir o valor de qualquer uma das opções listadas acima, use o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>The following code example retrieves the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> time-out values and displays them to the console.</source>
          <target state="translated">O seguinte código de exemplo recupera o <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> e <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> valores de tempo limite e exibe-as no console.</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source><ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> was set to the unsupported value <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> foi definido para o valor sem suporte <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          <target state="translated">Um dos valores de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          <target state="translated">Um dos valores de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is to receive the option setting.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que receberá a configuração da opção.</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>Returns the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option setting, represented as a byte array.</source>
          <target state="translated">Retorna a opção da configuração <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> especificada, representada como uma matriz de bytes.</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> opções determinam o comportamento do atual <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>Upon successful completion of this method, the array specified by the <ph id="ph1">`optionValue`</ph> parameter contains the value of the specified <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option.</source>
          <target state="translated">Após a conclusão bem-sucedida desse método, a matriz especificada pelo <ph id="ph1">`optionValue`</ph> parâmetro contém o valor especificado <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> opção.</target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>When the length of the <ph id="ph1">`optionValue`</ph> array is smaller than the number of bytes required to store the value of the specified <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Quando o comprimento do <ph id="ph1">`optionValue`</ph> matriz é menor do que o número de bytes necessários para armazenar o valor especificado <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> opção <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> lançará um <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>Use this overload for any sockets that are represented by Boolean values or integers.</source>
          <target state="translated">Use essa sobrecarga para qualquer soquetes que são representados por valores boolianos ou inteiros.</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>The following code example retrieves the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> time-out values and displays them to the console.</source>
          <target state="translated">O seguinte código de exemplo recupera o <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> e <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> valores de tempo limite e exibe-as no console.</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> ou -</target>       </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</source>
          <target state="translated">Em aplicativos do .NET Compact Framework, o espaço do buffer padrão do Windows CE é definido como 32768 bytes.</target>       </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>You can change the per socket buffer space by calling <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /&gt;</ph>.</source>
          <target state="translated">É possível alterar o espaço do buffer por soquete chamando <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          <target state="translated">Um dos valores de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          <target state="translated">Um dos valores de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The length, in bytes, of the expected return value.</source>
          <target state="translated">O comprimento, em bytes, do valor retornado esperado.</target>       </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>Returns the value of the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option in an array.</source>
          <target state="translated">Retorna o valor da opção <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> especificada em uma matriz.</target>       </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the value of the socket option.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que contém o valor da opção de soquete.</target>       </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The <ph id="ph1">`optionLength`</ph> parameter sets the maximum size of the returned byte array.</source>
          <target state="translated">O <ph id="ph1">`optionLength`</ph> parâmetro define o tamanho máximo da matriz de bytes retornada.</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>If the option value requires fewer bytes, the array will contain only that many bytes.</source>
          <target state="translated">Se o valor da opção requer menos bytes, a matriz conterá apenas que número de bytes.</target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>If the option value requires more bytes, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se o valor da opção requer mais bytes, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>Use this overload for any sockets that are represented by Boolean values or integers.</source>
          <target state="translated">Use essa sobrecarga para qualquer soquetes que são representados por valores boolianos ou inteiros.</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The following code example retrieves the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> time-out values and displays them to the console.</source>
          <target state="translated">O seguinte código de exemplo recupera o <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> e <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> valores de tempo limite e exibe-as no console.</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> ou -</target>       </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</source>
          <target state="translated">Em aplicativos do .NET Compact Framework, o espaço do buffer padrão do Windows CE é definido como 32768 bytes.</target>       </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>You can change the per socket buffer space by calling <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /&gt;</ph>.</source>
          <target state="translated">É possível alterar o espaço do buffer por soquete chamando <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Handle">
          <source>Gets the operating system handle for the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Obtém o identificador de sistema operacional do <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Handle">
          <source>An <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> that represents the operating system handle for the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> que representa o identificador de sistema operacional do <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sets low-level operating modes for the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Define os modos de operação de nível baixo para o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>An <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value that specifies the control code of the operation to perform.</source>
          <target state="translated">Um valor <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> que especifica o código de controle da operação a ser executado.</target>       </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> array that contains the input data required by the operation.</source>
          <target state="translated">Uma matriz <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que contém os dados de entrada necessários para a operação.</target>       </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> array that contains the output data returned by the operation.</source>
          <target state="translated">Uma matriz <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que contém os dados de saída retornados para a operação.</target>       </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>Sets low-level operating modes for the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> using numerical control codes.</source>
          <target state="translated">Define os modos de operação de nível inferior do <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> usando códigos de controle numéricos.</target>       </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>The number of bytes in the <ph id="ph1">&lt;paramref name="optionOutValue" /&gt;</ph> parameter.</source>
          <target state="translated">O número de bytes no parâmetro <ph id="ph1">&lt;paramref name="optionOutValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.IOControl%2A&gt;</ph> method provides low-level access to the operating system <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> underlying the current instance of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.IOControl%2A&gt;</ph> método fornece acesso de baixo nível para o sistema operacional <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> subjacente a instância atual do <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>For more information, see the WSAIoctl documentation in the MSDN library.</source>
          <target state="translated">Para obter mais informações, consulte a documentação de WSAIoctl na biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>The following code example compares the results of FIONREAD and the Available property.</source>
          <target state="translated">O exemplo de código a seguir compara os resultados de FIONREAD e a propriedade disponível.</target>       </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>An attempt was made to change the blocking mode without using the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.Blocking" /&gt;</ph> property.</source>
          <target state="translated">Foi feita uma tentativa de alterar o modo de bloqueio sem usar a propriedade <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.Blocking" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">Um chamador na pilha de chamadas não tem as permissões necessárias.</target>       </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>to execute unmanaged code.</source>
          <target state="translated">para executar código não gerenciado.</target>       </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.IOControlCode" /&gt;</ph> value that specifies the control code of the operation to perform.</source>
          <target state="translated">Um valor <ph id="ph1">&lt;see cref="T:System.Net.Sockets.IOControlCode" /&gt;</ph> que especifica o código de controle da operação a ser executada.</target>       </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the input data required by the operation.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que contém os dados de entrada necessários para a operação.</target>       </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the output data returned by the operation.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que contém os dados de saída retornados pela operação.</target>       </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>Sets low-level operating modes for the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> using the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.IOControlCode" /&gt;</ph> enumeration to specify control codes.</source>
          <target state="translated">Define modos de operação de nível inferior do <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> usando a enumeração <ph id="ph2">&lt;see cref="T:System.Net.Sockets.IOControlCode" /&gt;</ph> para especificar códigos de controle.</target>       </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>The number of bytes in the <ph id="ph1">&lt;paramref name="optionOutValue" /&gt;</ph> parameter.</source>
          <target state="translated">O número de bytes no parâmetro <ph id="ph1">&lt;paramref name="optionOutValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>This method provides low-level access to the operating system <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> underlying the current instance of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class.</source>
          <target state="translated">Esse método fornece acesso de baixo nível para o sistema operacional <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> subjacente a instância atual do <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>For more, see the WSAIoctl documentation in the MSDN library.</source>
          <target state="translated">Para obter mais informações, consulte a documentação de WSAIoctl na biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>The following code example compares the results of calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.IOControl%2A&gt;</ph> with <ph id="ph2">&lt;xref:System.Net.Sockets.IOControlCode.DataToRead&gt;</ph> and the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property.</source>
          <target state="translated">O exemplo de código a seguir compara os resultados da chamada <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.IOControl%2A&gt;</ph> com <ph id="ph2">&lt;xref:System.Net.Sockets.IOControlCode.DataToRead&gt;</ph> e <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>An attempt was made to change the blocking mode without using the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.Blocking" /&gt;</ph> property.</source>
          <target state="translated">Foi feita uma tentativa de alterar o modo de bloqueio sem usar a propriedade <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.Blocking" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>to execute unmanaged code.</source>
          <target state="translated">para executar código não gerenciado.</target>       </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.IsBound">
          <source>Gets a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is bound to a specific local port.</source>
          <target state="translated">Obtém um valor que indica se o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> está associado a uma porta local específica.</target>       </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.IsBound">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is bound to a local port; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> e o <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> for associado a uma porta local; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.IsBound">
          <source>A socket is considered bound to a local port if it is explicitly bound by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, or implicitly bound by calling members like <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, which use an ephemeral local port (a free port greater than 1024, selected by the operating system.) Servers use the <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method to bind to a well-known port so that clients may connect to them.</source>
          <target state="translated">Um soquete é considerado associada a uma porta local se ele está vinculado explicitamente chamando o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> método, ou implicitamente associada chamando membros como <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, ou <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, que usa uma porta efêmera local (uma porta livre maior do que 1024, selecionados pelo sistema operacional.) Os servidores usam o <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> método para vincular a uma porta conhecida para que os clientes podem se conectar a eles.</target>       </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.IsBound">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.IsBound%2A&gt;</ph> property.</source>
          <target state="translated">O exemplo de código a seguir demonstra o uso do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.IsBound%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>Gets or sets a value that specifies whether the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> will delay closing a socket in an attempt to send all pending data.</source>
          <target state="translated">Obtém ou define um valor que especifica se o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> atrasará ao fechar um soquete em uma tentativa de enviar todos os dados pendentes.</target>       </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.LingerOption" /&gt;</ph> that specifies how to linger while closing a socket.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.LingerOption" /&gt;</ph> que especifica como perdurar ao fechar um soquete.</target>       </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property changes the way <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method behaves.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> propriedade altera o modo como <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> método se comporta.</target>       </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>This property when set modifies the conditions under which the connection can be reset by Winsock.</source>
          <target state="translated">Essa propriedade ao conjunto modifica as condições sob as quais a conexão pode ser redefinido com Winsock.</target>       </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>Connection resets can still occur based on the IP protocol behavior.</source>
          <target state="translated">Redefinições de Conexão ainda podem ocorrer com base no comportamento de protocolo IP.</target>       </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>This property controls the length of time that a connection-oriented connection will remain open after a call to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> when data remains to be sent.</source>
          <target state="translated">Essa propriedade controla o período de tempo que uma conexão orientado a conexão permanecerá aberta após uma chamada para <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> quando os dados permanecem para serem enviadas.</target>       </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>When you call methods to send data to a peer, this data is placed in the outgoing network buffer.</source>
          <target state="translated">Quando você chamar métodos para enviar dados para uma ponto a ponto, esses dados são colocados no buffer de saída de rede.</target>       </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>This property can be used to ensure that this data is sent to the remote host before the <ph id="ph1">&lt;xref:System.Net.Sockets.TcpClient.Close%2A&gt;</ph> method drops the connection.</source>
          <target state="translated">Essa propriedade pode ser usada para garantir que esses dados são enviados ao host remoto antes do <ph id="ph1">&lt;xref:System.Net.Sockets.TcpClient.Close%2A&gt;</ph> método descarta a conexão.</target>       </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>To enable lingering, create a <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> instance containing the desired values, and set the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property to this instance.</source>
          <target state="translated">Para habilitar remanescentes, crie um <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> instância que contém os valores desejados e defina o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> propriedade para essa instância.</target>       </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>The following table describes the behavior of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method for the possible values of the <ph id="ph2">&lt;xref:System.Net.Sockets.LingerOption.Enabled%2A&gt;</ph> property and the <ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> property stored in the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property.</source>
          <target state="translated">A tabela a seguir descreve o comportamento do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> método para os valores possíveis do <ph id="ph2">&lt;xref:System.Net.Sockets.LingerOption.Enabled%2A&gt;</ph> propriedade e o <ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> propriedade armazenada no <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>LingerState.Enabled</source>
          <target state="translated">LingerState.Enabled</target>       </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>LingerState.LingerTime</source>
          <target state="translated">LingerState.LingerTime</target>       </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>Behavior</source>
          <target state="translated">Comportamento</target>       </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source><ph id="ph1">`false`</ph> (disabled), the default value</source>
          <target state="translated"><ph id="ph1">`false`</ph> (desabilitado), o valor padrão</target>       </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>The time-out is not applicable, (default).</source>
          <target state="translated">O tempo limite não é aplicável, (padrão).</target>       </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>Attempts to send pending data until the default IP protocol time-out expires.</source>
          <target state="translated">Tentativas de enviar dados pendentes até expira o tempo limite de protocolo IP padrão.</target>       </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source><ph id="ph1">`true`</ph> (enabled)</source>
          <target state="translated"><ph id="ph1">`true`</ph> (habilitado)</target>       </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>A nonzero time-out</source>
          <target state="translated">Um tempo limite diferente de zero</target>       </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>Attempts to send pending data until the specified time-out expires, and if the attempt fails, then Winsock resets the connection.</source>
          <target state="translated">Tentativas de enviar dados pendentes até expira o tempo limite especificado, e se a tentativa falhar, o Winsock redefine a conexão.</target>       </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source><ph id="ph1">`true`</ph> (enabled)</source>
          <target state="translated"><ph id="ph1">`true`</ph> (habilitado)</target>       </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>A zero timeout.</source>
          <target state="translated">Um zero tempo limite.</target>       </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>Discards any pending data.</source>
          <target state="translated">Descarta qualquer dados pendentes.</target>       </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>For connection-oriented socket (TCP, for example), Winsock resets the connection.</source>
          <target state="translated">Para o soquete orientado a conexão (por exemplo, TCP), Winsock redefine a conexão.</target>       </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>The IP stack computes the default IP protocol time-out period to use based on the round trip time of the connection.</source>
          <target state="translated">A pilha de IP calcula o período de tempo limite de protocolo IP padrão para usar com base no tempo de ida e volta da conexão.</target>       </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>In most cases, the time-out computed by the stack is more relevant than one defined by an application.</source>
          <target state="translated">Na maioria dos casos, o tempo de limite calculado pela pilha é mais relevante do que um definido por um aplicativo.</target>       </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>This is the default behavior for a socket when the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property is not set.</source>
          <target state="translated">Esse é o comportamento padrão para um soquete quando o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> propriedade não está definida.</target>       </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> property stored in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property is set greater than the default IP protocol time-out, the default IP protocol time-out will still apply and override.</source>
          <target state="translated">Quando o <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> propriedade armazenada no <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> propriedade é definida maior que o tempo limite de protocolo IP padrão, o tempo limite de protocolo IP padrão ainda se aplicam e substituir.</target>       </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property.</source>
          <target state="translated">O exemplo de código a seguir demonstra o uso do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>The maximum length of the pending connections queue.</source>
          <target state="translated">O comprimento máximo da fila de conexões pendentes.</target>       </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>Places a <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> in a listening state.</source>
          <target state="translated">Coloca um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> em um estado de escuta.</target>       </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> causes a connection-oriented <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to listen for incoming connection attempts.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> faz com que uma conexão orientada <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> para escutar as tentativas de conexão de entrada.</target>       </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>The <ph id="ph1">`backlog`</ph> parameter specifies the number of incoming connections that can be queued for acceptance.</source>
          <target state="translated">O <ph id="ph1">`backlog`</ph> parâmetro especifica o número de conexões de entrada que podem ser enfileirados para aceitação.</target>       </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>To determine the maximum number of connections you can specify, retrieve the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.MaxConnections&gt;</ph> value.</source>
          <target state="translated">Para determinar o número máximo de conexões que você pode especificar, recuperar o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.MaxConnections&gt;</ph> valor.</target>       </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> does not block.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> não bloquear.</target>       </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>Use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> to accept a connection from the queue.</source>
          <target state="translated">Use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> para aceitar uma conexão da fila.</target>       </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>You must call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Você deve chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> método antes de chamar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> lançará um <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>The backlog parameter is limited to different values depending on the Operating System.</source>
          <target state="translated">O parâmetro de lista de pendências é limitado a valores diferentes dependendo do sistema operacional.</target>       </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>You may specify a higher value, but the backlog will be limited based on the Operating System.</source>
          <target state="translated">Você pode especificar um valor mais alto, mas a lista de pendências será limitada com base no sistema operacional.</target>       </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>The following code example uses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to listen for incoming connections.</source>
          <target state="translated">O seguinte exemplo de código usa <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> para escutar conexões de entrada.</target>       </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>Gets the local endpoint.</source>
          <target state="translated">Obtém o ponto de extremidade local.</target>       </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is using for communications.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> que o <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> está usando para comunicações.</target>       </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property gets an <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> that contains the local IP address and port number to which your <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is bound.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> propriedade obtém um <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> que contém o local IP endereço e número da porta para o qual seu <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> está associado.</target>       </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>You must cast this <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> to an <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> before retrieving any information.</source>
          <target state="translated">Você deve converter isso <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> para um <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> antes de recuperar todas as informações.</target>       </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>You can then call the <ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType&gt;</ph> method to retrieve the local <ph id="ph2">&lt;xref:System.Net.IPAddress&gt;</ph>, and the <ph id="ph3">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType&gt;</ph> method to retrieve the local port number.</source>
          <target state="translated">Em seguida, você pode chamar o <ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType&gt;</ph> método para recuperar o local <ph id="ph2">&lt;xref:System.Net.IPAddress&gt;</ph>e o <ph id="ph3">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType&gt;</ph> método para recuperar o número de porta local.</target>       </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property is usually set after you make a call to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> propriedade normalmente é definida depois de fazer uma chamada para o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>If you allow the system to assign your socket's local IP address and port number, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property will be set after the first I/O operation.</source>
          <target state="translated">Se você permitir que o sistema atribuir o endereço IP do soquete local e o número da porta, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> propriedade será definida após a primeira operação de e/s.</target>       </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>For connection-oriented protocols, the first I/O operation would be a call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Para protocolos orientados a conexão, a primeira operação de e/s seria uma chamada para o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>For connectionless protocols, the first I/O operation would be any of the send or receive calls.</source>
          <target state="translated">Para protocolos sem conexão, a primeira operação de e/s deve ser qualquer enviar ou receber chamadas.</target>       </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>The following code example retrieves and displays the local and remote endpoints.</source>
          <target state="translated">O exemplo de código a seguir recupera e exibe os pontos de extremidade locais e remotos.</target>       </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>Gets or sets a value that specifies whether outgoing multicast packets are delivered to the sending application.</source>
          <target state="translated">Obtém ou define um valor que especifica se os pacotes de multicast de saída são entregues para o aplicativo de envio.</target>       </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> receives outgoing multicast packets; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> receber pacotes de multicast de saída; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>Multicast is a scalable method for many-to-many communication on the Internet.</source>
          <target state="translated">Multicast é um método escalonável para muitos-para-muitos comunicação na Internet.</target>       </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>A process subscribes to a multicast address; then, any packets sent by a subscribed process are received by every other process subscribed to the multicast address.</source>
          <target state="translated">Um processo se inscreve para um endereço de multicast; em seguida, todos os pacotes enviados por um processo assinado são recebidos por todos os outros processos assinado ao endereço de multicast.</target>       </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</source>
          <target state="translated">A definição dessa propriedade em um soquete do protocolo de controle de transmissão (TCP) não terá efeito.</target>       </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.MulticastLoopback%2A&gt;</ph> property.</source>
          <target state="translated">O exemplo de código a seguir demonstra o uso do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.MulticastLoopback%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> value that specifies whether the stream <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is using the Nagle algorithm.</source>
          <target state="translated">Obtém ou define um valor <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> que especifica se o <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> do fluxo está usando o Algoritmo de Nagle.</target>       </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> uses the Nagle algorithm; otherwise, <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph> se o <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> usa o algoritmo de Nagle; caso contrário, <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>The Nagle algorithm is designed to reduce network traffic by causing the socket to buffer small packets and then combine and send them in one packet under certain circumstances.</source>
          <target state="translated">O algoritmo Nagle foi projetado para reduzir o tráfego de rede, fazendo com que o soquete para o buffer de pacotes pequenos e, em seguida, combinar e enviá-los em um pacote em determinadas circunstâncias.</target>       </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>A TCP packet consists of 40 bytes of header plus the data being sent.</source>
          <target state="translated">Um pacote TCP consiste em 40 bytes de cabeçalho mais os dados sendo enviados.</target>       </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>When small packets of data are sent with TCP, the overhead resulting from the TCP header can become a significant part of the network traffic.On heavily loaded networks, the congestion resulting from this overhead can result in lost datagrams and retransmissions, as well as excessive propagation time caused by congestion.</source>
          <target state="translated">Quando pacotes pequenos de dados são enviados com o TCP, a sobrecarga resultante do cabeçalho TCP pode se tornar uma parte significativa do tráfego de rede. Em redes extremamente carregados, congestionamento resultante dessa sobrecarga pode resultar em datagramas perdidas e retransmissões, bem como tempo de propagação excessiva causada pelo congestionamento.</target>       </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>The Nagle algorithm inhibits the sending of new TCP segmentswhen new outgoing data arrives from the user if any previouslytransmitted data on the connection remains unacknowledged.</source>
          <target state="translated">O algoritmo Nagle não permite o envio de novos segmentswhen TCP novos dados de saída chega do usuário, se os dados previouslytransmitted a conexão permanecem não confirmados.</target>       </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>The majority of network applications should use the Nagle algorithm.</source>
          <target state="translated">A maioria dos aplicativos de rede deve usar o algoritmo Nagle.</target>       </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>Setting this property on a User Datagram Protocol (UDP) socket will have no effect.</source>
          <target state="translated">A definição dessa propriedade em um soquete do protocolo UDP (User Datagram) não terá efeito.</target>       </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.NoDelay%2A&gt;</ph> property.</source>
          <target state="translated">O exemplo de código a seguir demonstra o uso do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.NoDelay%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>An error occurred when attempting to access the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.OSSupportsIPv4">
          <source>Indicates whether the underlying operating system and network adaptors support Internet Protocol version 4 (IPv4).</source>
          <target state="translated">Indica se o sistema operacional subjacente e os adaptadores de rede dão suporte ao IPv4 (protocolo IP versão 4).</target>       </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.OSSupportsIPv4">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operating system and network adaptors support the IPv4 protocol; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o sistema operacional e os adaptadores de rede derem suporte ao protocolo IPv4; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.OSSupportsIPv4">
          <source>The operating system may support both IPv4 and IPv6 protocols.</source>
          <target state="translated">O sistema operacional pode oferecer suporte a protocolos IPv4 e IPv6.</target>       </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.OSSupportsIPv6">
          <source>Indicates whether the underlying operating system and network adaptors support Internet Protocol version 6 (IPv6).</source>
          <target state="translated">Indica se o sistema operacional subjacente e os adaptadores de rede dão suporte ao IPv6 (protocolo IP versão 6).</target>       </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.OSSupportsIPv6">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operating system and network adaptors support the IPv6 protocol; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o sistema operacional e os adaptadores de rede derem suporte ao protocolo IPv6; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.OSSupportsIPv6">
          <source>The operating system may support both IPv4 and IPv6 protocols.</source>
          <target state="translated">O sistema operacional pode oferecer suporte a protocolos IPv4 e IPv6.</target>       </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>The time to wait for a response, in microseconds.</source>
          <target state="translated">O tempo de espera por uma resposta, em microssegundos.</target>       </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SelectMode" /&gt;</ph> values.</source>
          <target state="translated">Um dos valores de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SelectMode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>Determines the status of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Determina o status do <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>The status of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> based on the polling mode value passed in the <ph id="ph2">&lt;paramref name="mode" /&gt;</ph> parameter.</source>
          <target state="translated">O status do <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> com base no valor de modo de sondagem passado no parâmetro <ph id="ph2">&lt;paramref name="mode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Mode</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Modo</target>       </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Return Value</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Valor Retornado</target>       </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="F:System.Net.Sockets.SelectMode.SelectRead" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph><ph id="ph6">&lt;see langword="true" /&gt;</ph> if <ph id="ph7">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> has been called and a connection is pending;</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="F:System.Net.Sockets.SelectMode.SelectRead" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph><ph id="ph6">&lt;see langword="true" /&gt;</ph> se <ph id="ph7">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> foi chamado e uma conexão está pendente;</target>       </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if data is available for reading;</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se os dados estiverem disponíveis para leitura;</target>       </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the connection has been closed, reset, or terminated;</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se a conexão foi fechada, redefinida ou terminada;</target>       </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>otherwise, returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">caso contrário, retornará <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph><ph id="ph6">&lt;see langword="true" /&gt;</ph>, if processing a <ph id="ph7">&lt;see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /&gt;</ph>, and the connection has succeeded;</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph><ph id="ph6">&lt;see langword="true" /&gt;</ph>, se houver processamento de um <ph id="ph7">&lt;see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /&gt;</ph> e a conexão foi bem-sucedida;</target>       </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if data can be sent;</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se for possível enviar os dados;</target>       </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>otherwise, returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">caso contrário, retornará <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="F:System.Net.Sockets.SelectMode.SelectError" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph><ph id="ph6">&lt;see langword="true" /&gt;</ph> if processing a <ph id="ph7">&lt;see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /&gt;</ph> that does not block, and the connection has failed;</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="F:System.Net.Sockets.SelectMode.SelectError" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph><ph id="ph6">&lt;see langword="true" /&gt;</ph> se houver processamento de um <ph id="ph7">&lt;see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /&gt;</ph> que não bloqueia e a conexão falhou;</target>       </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /&gt;</ph> is not set and out-of-band data is available;</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /&gt;</ph> não estiver definido e dados fora de banda estiverem disponíveis;</target>       </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>otherwise, returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">caso contrário, retornará <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method will check the state of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> método verificará o estado do <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>Specify <ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType&gt;</ph> for the <ph id="ph2">`selectMode`</ph> parameter to determine if the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is readable.</source>
          <target state="translated">Especifique <ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType&gt;</ph> para o <ph id="ph2">`selectMode`</ph> parâmetro para determinar se o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> é legível.</target>       </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>Specify <ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType&gt;</ph> to determine if the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is writable.</source>
          <target state="translated">Especifique <ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType&gt;</ph> para determinar se o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> é gravável.</target>       </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>Use <ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType&gt;</ph> to detect an error condition.</source>
          <target state="translated">Use <ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType&gt;</ph> para detectar uma condição de erro.</target>       </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> will block execution until the specified time period, measured in <ph id="ph2">`microseconds`</ph>, elapses.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> bloqueará a execução até que o período de tempo especificado, medida em <ph id="ph2">`microseconds`</ph>, expira.</target>       </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>Set the <ph id="ph1">`microSeconds`</ph> parameter to a negative integer if you would like to wait indefinitely for a response.</source>
          <target state="translated">Definir o <ph id="ph1">`microSeconds`</ph> parâmetro para um inteiro negativo se você gostaria de esperar indefinidamente por uma resposta.</target>       </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>If you want to check the status of multiple sockets, you might prefer to use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> method.</source>
          <target state="translated">Se você quiser verificar o status de vários soquetes, talvez você prefira usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</source>
          <target state="translated">Este método não pode detectar determinados tipos de problemas de conexão, como um cabo de rede interrompido, ou que o host remoto foi desligado maneira brusca.</target>       </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>You must attempt to send or receive data to detect these kinds of errors.</source>
          <target state="translated">Você deve tentar enviar ou receber dados para detectar esses tipos de erros.</target>       </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>The following code example creates a socket, connects to a server, and uses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> to check the status of the socket.</source>
          <target state="translated">O exemplo de código a seguir cria um soquete, se conecta a um servidor e usa <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> para verificar o status do soquete.</target>       </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>The <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> parameter is not one of the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SelectMode" /&gt;</ph> values.</source>
          <target state="translated">O parâmetro <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> não é um dos valores <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SelectMode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>See remarks below.</source>
          <target state="translated">Consulte os comentários abaixo.</target>       </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ProtocolType">
          <source>Gets the protocol type of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Obtém o tipo de protocolo do <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ProtocolType">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph> values.</source>
          <target state="translated">Um dos valores de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ProtocolType">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ProtocolType%2A&gt;</ph> property is set when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is created, and specifies the protocol used by that <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ProtocolType%2A&gt;</ph> propriedade é definida quando o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> é criado e especifica o protocolo usado pelo <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ProtocolType">
          <source>The following code example displays the <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> to the console.</source>
          <target state="translated">O código a seguir exemplo exibe o <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType&gt;</ph>, e <ph id="ph3">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> para o console.</target>       </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Recebe dados de um limite <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que é o local de armazenamento dos dados recebidos.</target>       </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into a receive buffer.</source>
          <target state="translated">Recebe dados de um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> associado em um buffer de recepção.</target>       </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>The number of bytes received.</source>
          <target state="translated">O número de bytes recebidos.</target>       </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the buffer parameter and returns the number of bytes successfully read.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método lê dados para o parâmetro de buffer e retorna o número de bytes lidos com êxito.</target>       </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>You can call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.</source>
          <target state="translated">Você pode chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> de soquetes orientado por conexão e sem conexão.</target>       </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>This overload only requires you to provide a receive buffer.</source>
          <target state="translated">Essa sobrecarga exige somente que você forneça um buffer de recebimento.</target>       </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</source>
          <target state="translated">Deslocamento de buffer padrão é 0, o tamanho padrão é o comprimento do parâmetro buffer e o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> valor padrão é <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, você deve chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> para estabelecer uma conexão de host remoto, ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> para aceitar uma conexão de entrada antes de chamar <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método apenas lê os dados que chega a partir do host remoto estabelecido no <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, você também pode usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> permitirá que você receba dados recebidos de qualquer host.</target>       </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se nenhum dado está disponível para leitura, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método será bloqueada até que os dados estejam disponíveis, a menos que um valor de tempo limite foi definido usando <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se o valor de tempo limite foi excedido, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> chamada lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método será concluída imediatamente e lançar um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Você pode usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> para determinar se os dados estão disponíveis para leitura.</target>       </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">Quando <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> é diferente de zero, repita a operação de recebimento.</target>       </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the size of the buffer.</source>
          <target state="translated">Se você estiver usando uma conexão orientada <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método lerá a quantidade de dados estiver disponível, até o tamanho do buffer.</target>       </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Se o host remoto é desligado o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> conexão com o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> método e todos os dados disponíveis foi recebida, o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método será concluída imediatamente e retornará zero bytes.</target>       </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um sem-conexão <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> lerá o datagrama em fila primeiro o endereço de destino que você especificar o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffer`</ph> parameter, <ph id="ph2">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">Se o datagrama receber é maior do que o tamanho do <ph id="ph1">`buffer`</ph> parâmetro <ph id="ph2">`buffer`</ph> é preenchida com a primeira parte da mensagem, o excesso de dados é perdido e um <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> é gerada.</target>       </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>The following code example receives data on a connected <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir recebe dados sobre conectada <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">Um chamador na pilha de chamadas não tem as permissões necessárias.</target>       </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>for accepting connections from the network.</source>
          <target state="translated">para aceitar conexões de rede.</target>       </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>A list of <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s of type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the received data.</source>
          <target state="translated">Uma lista de <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s do tipo <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> que contém os dados recebidos.</target>       </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into the list of receive buffers.</source>
          <target state="translated">Recebe dados de um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> associado na lista de buffers de recepção.</target>       </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The number of bytes received.</source>
          <target state="translated">O número de bytes recebidos.</target>       </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>This method reads data into the buffers parameter and returns the number of bytes successfully read.</source>
          <target state="translated">Esse método lê dados para o parâmetro de buffers e retorna o número de bytes lidos com êxito.</target>       </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>You can call from both connection-oriented and connectionless sockets.</source>
          <target state="translated">Você pode chamar de soquetes orientado por conexão e sem conexão.</target>       </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>This overload requires you to provide one or more receive buffers.</source>
          <target state="translated">Essa sobrecarga exige que você forneça um ou mais buffers de recepção.</target>       </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, você deve chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> para estabelecer uma conexão de host remoto, ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> para aceitar uma conexão de entrada antes de chamar <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host connection established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método lerá apenas dados que chega da conexão do host remoto estabelecida no <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, você também pode usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> permitirá que você receba dados recebidos de qualquer host.</target>       </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se nenhum dado está disponível para leitura, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método será bloqueada até que os dados estejam disponíveis, a menos que um valor de tempo limite foi definido usando <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se o valor de tempo limite foi excedido, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> chamada lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método será concluída imediatamente e lançar um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Você pode usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> para determinar se os dados estão disponíveis para leitura.</target>       </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">Quando <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> é diferente de zero, repita a operação de recebimento.</target>       </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the size of the buffer.</source>
          <target state="translated">Se você estiver usando uma conexão orientada <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método lerá a quantidade de dados estiver disponível, até o tamanho do buffer.</target>       </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Se o host remoto é desligado o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> conexão com o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> método e todos os dados disponíveis foi recebida, o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método será concluída imediatamente e retornará zero bytes.</target>       </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first enqueued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um sem-conexão <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> lerá o datagrama enfileiradas primeiro o endereço de destino que você especificar o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffers`</ph> parameter, <ph id="ph2">`buffers`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">Se o datagrama receber é maior do que o tamanho do <ph id="ph1">`buffers`</ph> parâmetro <ph id="ph2">`buffers`</ph> é preenchida com a primeira parte da mensagem, o excesso de dados é perdido e um <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> é gerada.</target>       </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated"><bpt id="p1">**</bpt>Observação<ept id="p1">**</ept> esse membro gera informações de rastreamento, quando você habilita o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The <ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O parâmetro <ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>An error occurred while attempting to access the socket.</source>
          <target state="translated">Erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que é o local de armazenamento dos dados recebidos.</target>       </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Uma combinação bit a bit dos valores <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into a receive buffer, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Recebe dados de um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> associado em um buffer de recepção, usando o <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The number of bytes received.</source>
          <target state="translated">O número de bytes recebidos.</target>       </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the buffer parameter and returns the number of bytes successfully read.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método lê dados para o parâmetro de buffer e retorna o número de bytes lidos com êxito.</target>       </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>You can call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.</source>
          <target state="translated">Você pode chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> de soquetes orientado por conexão e sem conexão.</target>       </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>This overload only requires you to provide a receive buffer and the necessary <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
          <target state="translated">Essa sobrecarga exige somente que você fornecer um buffer de recebimento e necessários <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The buffer offset defaults to 0, and the size defaults to the length of the byte parameter.</source>
          <target state="translated">Deslocamento de buffer padrão é 0 e o tamanho padrão é o comprimento do parâmetro bytes.</target>       </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, você deve chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> para estabelecer uma conexão de host remoto, ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> para aceitar uma conexão de entrada antes de chamar <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método apenas lê os dados que chega a partir do host remoto estabelecido no <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, você também pode usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> permitirá que você receba dados recebidos de qualquer host.</target>       </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">Se nenhum dado está disponível para leitura, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método será bloqueado até que os dados estão disponíveis.</target>       </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are in non-blocking mode, and there is no data available in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você estiver no modo sem bloqueio, e nenhum dado está disponível no buffer de pilha de protocolo, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método será concluída imediatamente e lançar um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Você pode usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> para determinar se os dados estão disponíveis para leitura.</target>       </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry your receive operation.</source>
          <target state="translated">Quando <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> é diferente de zero, repita a operação de recebimento.</target>       </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available up to the size of the buffer.</source>
          <target state="translated">Se você estiver usando uma conexão orientada <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método lerá a quantidade de dados está disponível até o tamanho do buffer.</target>       </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Se o host remoto é desligado o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> conexão com o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> método e todos os dados disponíveis foi recebida, o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método será concluída imediatamente e retornará zero bytes.</target>       </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first enqueued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um sem-conexão <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> lerá o datagrama enfileiradas primeiro o endereço de destino que você especificar o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffer`</ph> parameter, <ph id="ph2">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">Se o datagrama receber é maior do que o tamanho do <ph id="ph1">`buffer`</ph> parâmetro <ph id="ph2">`buffer`</ph> é preenchida com a primeira parte da mensagem, o excesso de dados é perdido e um <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> é gerada.</target>       </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The following code example specifies a data buffer, and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> for receiving data on a connected <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir especifica um buffer de dados, e <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> para receber dados em um conectado <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">Um chamador na pilha de chamadas não tem as permissões necessárias.</target>       </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>for accepting connections from the network.</source>
          <target state="translated">para aceitar conexões de rede.</target>       </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>A list of <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s of type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the received data.</source>
          <target state="translated">Uma lista de <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s do tipo <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> que contém os dados recebidos.</target>       </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Uma combinação bit a bit dos valores <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into the list of receive buffers, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Recebe dados de um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> associado na lista de buffers de recepção, usando o <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The number of bytes received.</source>
          <target state="translated">O número de bytes recebidos.</target>       </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>This method reads data into the <ph id="ph1">`buffers`</ph> parameter and returns the number of bytes successfully read.</source>
          <target state="translated">Esse método lê os dados para o <ph id="ph1">`buffers`</ph> parâmetro e retorna o número de bytes lidos com êxito.</target>       </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>You can call from both connection-oriented and connectionless sockets.</source>
          <target state="translated">Você pode chamar de soquetes orientado por conexão e sem conexão.</target>       </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>This overload requires you to provide one or more receive buffers.</source>
          <target state="translated">Essa sobrecarga exige que você forneça um ou mais buffers de recepção.</target>       </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> valor padrão é <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, você deve chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> para estabelecer uma conexão de host remoto, ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> para aceitar uma conexão de entrada antes de chamar <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host connection established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método lerá apenas dados que chega da conexão do host remoto estabelecida no <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, você também pode usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> permitirá que você receba dados recebidos de qualquer host.</target>       </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se nenhum dado está disponível para leitura, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método será bloqueada até que os dados estejam disponíveis, a menos que um valor de tempo limite foi definido usando <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se o valor de tempo limite foi excedido, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> chamar lança um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método será concluída imediatamente e lançar um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Você pode usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> para determinar se os dados estão disponíveis para leitura.</target>       </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">Quando <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> é diferente de zero, repita a operação de recebimento.</target>       </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the size of the buffer.</source>
          <target state="translated">Se você estiver usando uma conexão orientada <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método lerá a quantidade de dados estiver disponível, até o tamanho do buffer.</target>       </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Se o host remoto é desligado o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> conexão com o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> método e todos os dados disponíveis foi recebida, o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método será concluída imediatamente e retornará zero bytes.</target>       </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first enqueued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um sem-conexão <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> lerá o datagrama enfileiradas primeiro o endereço de destino que você especificar o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffers`</ph> parameter, <ph id="ph2">`buffers`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">Se o datagrama receber é maior do que o tamanho do <ph id="ph1">`buffers`</ph> parâmetro <ph id="ph2">`buffers`</ph> é preenchida com a primeira parte da mensagem, o excesso de dados é perdido e um <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> é gerada.</target>       </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The following code example demonstrates how to receive data on a connected <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir demonstra como receber dados em um conectado <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph>.Count is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph>.Count é zero.</target>       </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>An error occurred while attempting to access the socket.</source>
          <target state="translated">Erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>for accepting connections from the network.</source>
          <target state="translated">para aceitar conexões de rede.</target>       </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que é o local de armazenamento dos dados recebidos.</target>       </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes to receive.</source>
          <target state="translated">O número de bytes a serem recebidos.</target>       </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Uma combinação bit a bit dos valores <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>Receives the specified number of bytes of data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into a receive buffer, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Recebe o número de bytes especificado de dados de um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> associado em um buffer de recepção, usando o <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes received.</source>
          <target state="translated">O número de bytes recebidos.</target>       </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter and returns the number of bytes successfully read.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método lê os dados para o <ph id="ph2">`buffer`</ph> parâmetro e retorna o número de bytes lidos com êxito.</target>       </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.</source>
          <target state="translated">Você pode chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> de soquetes orientado por conexão e sem conexão.</target>       </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>This overload only requires you to provide a receive buffer, the number of bytes you want to receive, and the necessary <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
          <target state="translated">Essa sobrecarga exige somente que você forneça um buffer de recepção, o número de bytes que você deseja receber e necessários <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, você deve chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> para estabelecer uma conexão de host remoto, ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> para aceitar uma conexão de entrada antes de chamar <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método apenas lê os dados que chega a partir do host remoto estabelecido no <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, você também pode usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> permitirá que você receba dados recebidos de qualquer host.</target>       </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se nenhum dado está disponível para leitura, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método será bloqueada até que os dados estejam disponíveis, a menos que um valor de tempo limite foi definido usando <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se o valor de tempo limite foi excedido, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> chamada lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método será concluída imediatamente e lançar um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Você pode usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> para determinar se os dados estão disponíveis para leitura.</target>       </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry your receive operation.</source>
          <target state="translated">Quando <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> é diferente de zero, repita a operação de recebimento.</target>       </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the number of bytes specified by the <ph id="ph3">`size`</ph> parameter.</source>
          <target state="translated">Se você estiver usando uma conexão orientada <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método lerá a quantidade de dados estiver disponível, até o número de bytes especificado pelo <ph id="ph3">`size`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Se o host remoto é desligado o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> conexão com o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> método e todos os dados disponíveis foi recebida, o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método será concluída imediatamente e retornará zero bytes.</target>       </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um sem-conexão <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> lerá o datagrama em fila primeiro o endereço de destino que você especificar o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffer`</ph> parameter, <ph id="ph2">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">Se o datagrama receber é maior do que o tamanho do <ph id="ph1">`buffer`</ph> parâmetro <ph id="ph2">`buffer`</ph> é preenchida com a primeira parte da mensagem, o excesso de dados é perdido e um <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> é gerada.</target>       </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The following receives the data found into <ph id="ph1">`buffer`</ph>, and specifies <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph> for <ph id="ph3">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
          <target state="translated">A seguir recebe os dados encontrados em <ph id="ph1">`buffer`</ph>e especifica <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph> para <ph id="ph3">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> exceeds the size of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> excede o tamanho de <ph id="ph1">&lt;paramref name="size" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">Um chamador na pilha de chamadas não tem as permissões necessárias.</target>       </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>for accepting connections from the network.</source>
          <target state="translated">para aceitar conexões de rede.</target>       </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A list of <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s of type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the received data.</source>
          <target state="translated">Uma lista de <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s do tipo <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> que contém os dados recebidos.</target>       </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Uma combinação bit a bit dos valores <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> que armazena o erro de soquete.</target>       </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into the list of receive buffers, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Recebe dados de um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> associado na lista de buffers de recepção, usando o <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The number of bytes received.</source>
          <target state="translated">O número de bytes recebidos.</target>       </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This method reads data into the <ph id="ph1">`buffers`</ph> parameter and returns the number of bytes successfully read.</source>
          <target state="translated">Esse método lê os dados para o <ph id="ph1">`buffers`</ph> parâmetro e retorna o número de bytes lidos com êxito.</target>       </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can call from both connection-oriented and connectionless sockets.</source>
          <target state="translated">Você pode chamar de soquetes orientado por conexão e sem conexão.</target>       </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This overload requires you to provide one or more receive buffers.</source>
          <target state="translated">Essa sobrecarga exige que você forneça um ou mais buffers de recepção.</target>       </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> valor padrão é <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, você deve chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> para estabelecer uma conexão de host remoto, ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> para aceitar uma conexão de entrada antes de chamar <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host connection established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método lerá apenas dados que chega da conexão do host remoto estabelecida no <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, você também pode usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> permitirá que você receba dados recebidos de qualquer host.</target>       </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se nenhum dado está disponível para leitura, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método será bloqueada até que os dados estejam disponíveis, a menos que um valor de tempo limite foi definido usando <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se o valor de tempo limite foi excedido, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> chamar lança um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método será concluída imediatamente e lançar um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Você pode usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> para determinar se os dados estão disponíveis para leitura.</target>       </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">Quando <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> é diferente de zero, repita a operação de recebimento.</target>       </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the size of the buffer.</source>
          <target state="translated">Se você estiver usando uma conexão orientada <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método lerá a quantidade de dados estiver disponível, até o tamanho do buffer.</target>       </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Se o host remoto é desligado o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> conexão com o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> método e todos os dados disponíveis foi recebida, o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método será concluída imediatamente e retornará zero bytes.</target>       </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>,<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um sem-conexão <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>,<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> lerá o datagrama em fila primeiro o endereço de destino que você especificar o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffers`</ph> parameter, <ph id="ph2">`buffers`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">Se o datagrama receber é maior do que o tamanho do <ph id="ph1">`buffers`</ph> parâmetro <ph id="ph2">`buffers`</ph> é preenchida com a primeira parte da mensagem, o excesso de dados é perdido e um <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> é gerada.</target>       </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph>.Count is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph>.Count é zero.</target>       </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An error occurred while attempting to access the socket.</source>
          <target state="translated">Erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">para aceitar conexões de rede.</target>       </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for received data.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que é o local de armazenamento dos dados recebidos.</target>       </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The location in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> to store the received data.</source>
          <target state="translated">O local no <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> para armazenar os dados recebidos.</target>       </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes to receive.</source>
          <target state="translated">O número de bytes a serem recebidos.</target>       </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Uma combinação bit a bit dos valores <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>Receives the specified number of bytes from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into the specified offset position of the receive buffer, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Recebe o número de bytes especificado de um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> associado na posição de deslocamento especificada do buffer de recepção usando o <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes received.</source>
          <target state="translated">O número de bytes recebidos.</target>       </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the buffer parameter and returns the number of bytes successfully read.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método lê dados para o parâmetro de buffer e retorna o número de bytes lidos com êxito.</target>       </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.</source>
          <target state="translated">Você pode chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> de soquetes orientado por conexão e sem conexão.</target>       </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, você deve chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> para estabelecer uma conexão de host remoto, ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> para aceitar uma conexão de entrada antes de chamar <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método apenas lê os dados que chega a partir do host remoto estabelecido no <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, você também pode usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> permitirá que você receba dados recebidos de qualquer host.</target>       </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se nenhum dado está disponível para leitura, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método será bloqueada até que os dados estejam disponíveis, a menos que um valor de tempo limite foi definido usando <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se o valor de tempo limite foi excedido, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> chamada lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método será concluída imediatamente e lançar um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>See Remarks below.</source>
          <target state="translated">Consulte os comentários abaixo.</target>       </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Você pode usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> para determinar se os dados estão disponíveis para leitura.</target>       </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">Quando <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> é diferente de zero, repita a operação de recebimento.</target>       </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the number of bytes specified by the size parameter.</source>
          <target state="translated">Se você estiver usando uma conexão orientada <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método lerá a quantidade de dados estiver disponível, até o número de bytes especificado pelo parâmetro de tamanho.</target>       </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Se o host remoto é desligado o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> conexão com o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> método e todos os dados disponíveis foi recebida, o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método será concluída imediatamente e retornará zero bytes.</target>       </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um sem-conexão <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> lerá o datagrama em fila primeiro o endereço de destino que você especificar o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffer`</ph> parameter, <ph id="ph2">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">Se o datagrama receber é maior do que o tamanho do <ph id="ph1">`buffer`</ph> parâmetro <ph id="ph2">`buffer`</ph> é preenchida com a primeira parte da mensagem, o excesso de dados é perdido e um <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> é gerada.</target>       </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The following code example specifies a data buffer, an offset, a size, and a socket flag before receiving data on a connected <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir especifica um buffer de dados, um deslocamento, um tamanho e um sinalizador de soquete antes de receber os dados em um conectado <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> é maior que o comprimento do <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é maior que o comprimento da subtração de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> e do valor do parâmetro <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> não é uma combinação válida de valores.</target>       </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> property was not set.</source>
          <target state="translated">A propriedade <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> não foi definida.</target>       </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Ocorre um erro de sistema operacional ao acessar o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">Um chamador na pilha de chamadas não tem as permissões necessárias.</target>       </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>for accepting connections from the network.</source>
          <target state="translated">para aceitar conexões de rede.</target>       </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que é o local de armazenamento dos dados recebidos.</target>       </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter to store the received data.</source>
          <target state="translated">A posição no parâmetro <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> para armazenar os dados recebidos.</target>       </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The number of bytes to receive.</source>
          <target state="translated">O número de bytes a serem recebidos.</target>       </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Uma combinação bit a bit dos valores <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> que armazena o erro de soquete.</target>       </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into a receive buffer, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Recebe dados de um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> associado em um buffer de recepção, usando o <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The number of bytes received.</source>
          <target state="translated">O número de bytes recebidos.</target>       </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the buffer parameter and returns the number of bytes successfully read.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método lê dados para o parâmetro de buffer e retorna o número de bytes lidos com êxito.</target>       </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.</source>
          <target state="translated">Você pode chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> de soquetes orientado por conexão e sem conexão.</target>       </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, você deve chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> para estabelecer uma conexão de host remoto, ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> para aceitar uma conexão de entrada antes de chamar <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método apenas lê os dados que chega a partir do host remoto estabelecido no <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, você também pode usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> permitirá que você receba dados recebidos de qualquer host.</target>       </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se nenhum dado está disponível para leitura, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método será bloqueada até que os dados estejam disponíveis, a menos que um valor de tempo limite foi definido usando <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se o valor de tempo limite foi excedido, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> chamada lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método será concluída imediatamente e lançar um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>See Remarks below.</source>
          <target state="translated">Consulte os comentários abaixo.</target>       </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Você pode usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> para determinar se os dados estão disponíveis para leitura.</target>       </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">Quando <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> é diferente de zero, repita a operação de recebimento.</target>       </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the number of bytes specified by the size parameter.</source>
          <target state="translated">Se você estiver usando uma conexão orientada <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método lerá a quantidade de dados estiver disponível, até o número de bytes especificado pelo parâmetro de tamanho.</target>       </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Se o host remoto é desligado o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> conexão com o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> método e todos os dados disponíveis foi recebida, o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método será concluída imediatamente e retornará zero bytes.</target>       </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um sem-conexão <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> lerá o datagrama em fila primeiro o endereço de destino que você especificar o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffer`</ph> parameter, <ph id="ph2">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">Se o datagrama receber é maior do que o tamanho do <ph id="ph1">`buffer`</ph> parâmetro <ph id="ph2">`buffer`</ph> é preenchida com a primeira parte da mensagem, o excesso de dados é perdido e um <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> é gerada.</target>       </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> é maior que o comprimento do <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é maior que o comprimento da subtração de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> e do valor do parâmetro <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> não é uma combinação válida de valores.</target>       </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> property is not set.</source>
          <target state="translated">A propriedade <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> não foi definida.</target>       </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Ocorre um erro de sistema operacional ao acessar o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">Um chamador na pilha de chamadas não tem as permissões necessárias.</target>       </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">para aceitar conexões de rede.</target>       </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> a ser usado nessa operação de soquete assíncrono.</target>       </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins an asynchronous request to receive data from a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object.</source>
          <target state="translated">Inicia uma solicitação assíncrona para receber dados de um objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> conectado.</target>       </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">Retorna <ph id="ph1">&lt;see langword="true" /&gt;</ph> se a operação de E/S está pendente.</target>       </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">O evento <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> no parâmetro <ph id="ph2">&lt;paramref name="e" /&gt;</ph> será acionado após a conclusão da operação.</target>       </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">Retorna <ph id="ph1">&lt;see langword="false" /&gt;</ph> se a operação de E/S foi concluída de forma síncrona.</target>       </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">Nesse caso, o evento <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> no parâmetro <ph id="ph2">&lt;paramref name="e" /&gt;</ph> não será gerado e o objeto <ph id="ph3">&lt;paramref name="e" /&gt;</ph> passado como um parâmetro poderá ser examinado imediatamente depois que a chamada do método for retornada para recuperar o resultado da operação.</target>       </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> method is used on connected sockets or bound connectionless sockets and is used to read incoming data.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> método é usado em conectado soquetes ou vinculados soquetes sem conexão e é usado para ler os dados de entrada.</target>       </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The socket's local address must be known.</source>
          <target state="translated">Endereço local do soquete deve ser conhecido.</target>       </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For bound connectionless sockets, this function restricts the addresses from which received messages are accepted.</source>
          <target state="translated">Para soquetes sem conexão associadas, esta função restringe os endereços de onde as mensagens recebidas são aceitas.</target>       </trans-unit>
        <trans-unit id="2317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The function only returns messages from the remote address specified in the connection.</source>
          <target state="translated">A função retorna apenas as mensagens do endereço remoto especificado na conexão.</target>       </trans-unit>
        <trans-unit id="2318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Messages from other addresses are silently discarded.</source>
          <target state="translated">Mensagens de outros endereços são descartadas silenciosamente.</target>       </trans-unit>
        <trans-unit id="2319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType&gt;</ph> property on the <ph id="ph2">`e`</ph> parameter provides the Window Sockets service provider with additional information about the read request.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType&gt;</ph> propriedade o <ph id="ph2">`e`</ph> parâmetro fornece o provedor de serviços de soquetes de janela com informações adicionais sobre a solicitação de leitura.</target>       </trans-unit>
        <trans-unit id="2320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For more information about how to use this parameter, see <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como usar esse parâmetro, consulte <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required to successfully call this method:</source>
          <target state="translated">As seguintes propriedades e eventos no <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> objeto são necessárias para chamar com êxito este método:</target>       </trans-unit>
        <trans-unit id="2322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> ou <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="2323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> if <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> is set</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> Se <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> está definido</target>       </trans-unit>
        <trans-unit id="2324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> if <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> is set</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> Se <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> está definido</target>       </trans-unit>
        <trans-unit id="2325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">O chamador pode definir o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> propriedade para qualquer objeto de estado do usuário desejado antes de chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> método, para que as informações serão recuperáveis no método de retorno de chamada.</target>       </trans-unit>
        <trans-unit id="2326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">Se o retorno de chamada precisa de mais informações do que um único objeto, uma pequena classe pode ser criada para manter as outras informações de estado necessárias como membros.</target>       </trans-unit>
        <trans-unit id="2327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For byte stream-style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</source>
          <target state="translated">Para soquetes do estilo de fluxo de bytes, os dados de entrada são colocados no buffer até que o buffer é preenchido, a conexão é fechada ou os dados armazenados em buffer internamente são esgotados.</target>       </trans-unit>
        <trans-unit id="2328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer associated with the <ph id="ph1">`e`</ph> parameter.</source>
          <target state="translated">Para soquetes orientado a mensagens, uma mensagem de entrada é colocada no buffer até o tamanho total do buffer associado a <ph id="ph1">`e`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="2329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the message is larger than the buffer, the buffer is filled with the first part of the message.</source>
          <target state="translated">Se a mensagem for maior do que o buffer, o buffer é preenchido com a primeira parte da mensagem.</target>       </trans-unit>
        <trans-unit id="2330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For connection-oriented sockets, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> method can indicate the graceful termination of the virtual circuit in one of two ways that depend on whether the socket is byte stream or message oriented.</source>
          <target state="translated">Para soquetes orientados a conexão, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> método pode indicar que o encerramento amigável do circuito virtual em uma das duas maneiras que dependem de se o soquete é orientado a mensagem ou fluxo de bytes.</target>       </trans-unit>
        <trans-unit id="2331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For byte streams, zero bytes having been read indicates graceful closure and that no more bytes will ever be read.</source>
          <target state="translated">Para fluxos de byte zero bytes foi lidos indica fechamento normal e que não há mais bytes nunca serão lidos.</target>       </trans-unit>
        <trans-unit id="2332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For message-oriented sockets, where a zero byte message is often allowable, a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> with the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> set to the native Winsock WSAEDISCON error code (10101) is used to indicate graceful closure.</source>
          <target state="translated">Para soquetes orientado a mensagens, em que uma mensagem de zero bytes geralmente é permitida, um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> com o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> definido como o código de erro nativo do Winsock WSAEDISCON (10101) é usado para indicar o encerramento normal.</target>       </trans-unit>
        <trans-unit id="2333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In any case, a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> with the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> set to the native Winsock WSAECONNRESET error code (10054) indicates an abortive close has occurred.</source>
          <target state="translated">Em qualquer caso, um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> com o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> definido para o nativo WSAECONNRESET Winsock o código de erro (10054) indica um fechamento por anulação ocorreu.</target>       </trans-unit>
        <trans-unit id="2334" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An argument was invalid.</source>
          <target state="translated">Um argumento era inválido.</target>       </trans-unit>
        <trans-unit id="2335" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /&gt;</ph> or <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> properties on the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> parameter must reference valid buffers.</source>
          <target state="translated">As propriedades <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /&gt;</ph> ou <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> no parâmetro <ph id="ph3">&lt;paramref name="e" /&gt;</ph> devem referenciar buffers válidos.</target>       </trans-unit>
        <trans-unit id="2336" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>One or the other of these properties may be set, but not both at the same time.</source>
          <target state="translated">Uma ou a outra dessas propriedades poderá ser definida, mas não ambas ao mesmo tempo.</target>       </trans-unit>
        <trans-unit id="2337" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated">Uma operação de soquete já estava em andamento com o objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> especificado no parâmetro <ph id="ph2">&lt;paramref name="e" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2338" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">É necessário o Windows XP ou posterior para esse método.</target>       </trans-unit>
        <trans-unit id="2339" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="2340" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="2341" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>Gets or sets a value that specifies the size of the receive buffer of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Obtém ou define um valor que especifica o tamanho do buffer de recepção do <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2342" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>An <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> that contains the size, in bytes, of the receive buffer.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> que contém o tamanho, em bytes, do buffer de recepção.</target>       </trans-unit>
        <trans-unit id="2343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>The default is 8192.</source>
          <target state="translated">O padrão é 8192.</target>       </trans-unit>
        <trans-unit id="2344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>A larger buffer size potentially reduces the number of empty acknowledgements (TCP packets with no data portion), but might also delay the recognition of connection difficulties.</source>
          <target state="translated">Potencialmente, um tamanho de buffer maior reduz o número de confirmações vazios (pacotes TCP com nenhuma parte de dados), mas também pode atrasar o reconhecimento de problemas de conexão.</target>       </trans-unit>
        <trans-unit id="2345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</source>
          <target state="translated">Considere aumentar o tamanho do buffer se estiver transferindo arquivos grandes ou se você estiver usando a largura de banda alta, a conexão de alta latência (como um satélite provedor de banda larga.)</target>       </trans-unit>
        <trans-unit id="2346" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A&gt;</ph> property.</source>
          <target state="translated">O exemplo de código a seguir demonstra o uso do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="2347" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="2348" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="2349" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>The value specified for a set operation is less than 0.</source>
          <target state="translated">O valor especificado para uma operação de definição é menor que 0.</target>       </trans-unit>
        <trans-unit id="2350" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Receives a datagram and stores the source endpoint.</source>
          <target state="translated">Recebe um datagrama e armazena o ponto de extremidade de origem.</target>       </trans-unit>
        <trans-unit id="2351" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for received data.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que é o local de armazenamento dos dados recebidos.</target>       </trans-unit>
        <trans-unit id="2352" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passed by reference, that represents the remote server.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passado por referência, que representa o servidor remoto.</target>       </trans-unit>
        <trans-unit id="2353" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>Receives a datagram into the data buffer and stores the endpoint.</source>
          <target state="translated">Recebe um datagrama no buffer de dados e armazena o ponto de extremidade.</target>       </trans-unit>
        <trans-unit id="2354" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The number of bytes received.</source>
          <target state="translated">O número de bytes recebidos.</target>       </trans-unit>
        <trans-unit id="2355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método lê os dados para o <ph id="ph2">`buffer`</ph> parâmetro, retorna o número de bytes lidos com êxito e captura o ponto de extremidade do host remoto do qual os dados foram enviados.</target>       </trans-unit>
        <trans-unit id="2356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</source>
          <target state="translated">Esse método é útil se você pretende receber datagramas sem conexão de um host desconhecido ou vários hosts.</target>       </trans-unit>
        <trans-unit id="2357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>This overload only requires you to provide a receive <ph id="ph1">`buffer`</ph>, and an <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> that represents the remote host.</source>
          <target state="translated">Essa sobrecarga exige somente que você fornecer um recebimento <ph id="ph1">`buffer`</ph>e um <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> que representa o host remoto.</target>       </trans-unit>
        <trans-unit id="2358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The buffer offset defaults to 0.</source>
          <target state="translated">Deslocamento de buffer padrão é 0.</target>       </trans-unit>
        <trans-unit id="2359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The size defaults to the length of the <ph id="ph1">`buffer`</ph> parameter and the <ph id="ph2">`socketFlags`</ph> value defaults to <ph id="ph3">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</source>
          <target state="translated">O tamanho padrão é o comprimento do <ph id="ph1">`buffer`</ph> parâmetro e o <ph id="ph2">`socketFlags`</ph> valor padrão é <ph id="ph3">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">Antes de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, você deve associar explicitamente o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> para um ponto de extremidade local usando o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you do not, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você não fizer isso, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>With connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.</source>
          <target state="translated">Com protocolos sem conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> lerá o datagrama enfileiradas primeiro recebido no buffer de rede local.</target>       </trans-unit>
        <trans-unit id="2363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If the datagram you receive is larger than the size of <ph id="ph1">`buffer`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will fill <ph id="ph3">`buffer`</ph> with as much of the message as is possible, and throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se o datagrama receber é maior que o tamanho de <ph id="ph1">`buffer`</ph>, o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método preencherá <ph id="ph3">`buffer`</ph> com tanta da mensagem como é possível e lançar um <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you are using an unreliable protocol, the excess data will be lost.</source>
          <target state="translated">Se você estiver usando um protocolo não confiável, o excesso de dados serão perdido.</target>       </trans-unit>
        <trans-unit id="2365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method with a large enough buffer.</source>
          <target state="translated">Se você estiver usando um protocolo confiável, o excesso de dados será retido pelo provedor de serviço e você poderá recuperá-lo ao chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método com um buffer grande o suficiente.</target>       </trans-unit>
        <trans-unit id="2366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">Se nenhum dado está disponível para leitura, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método será bloqueado até que os dados estão disponíveis.</target>       </trans-unit>
        <trans-unit id="2367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método será concluída imediatamente e lançar um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Você pode usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> para determinar se os dados estão disponíveis para leitura.</target>       </trans-unit>
        <trans-unit id="2369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">Quando <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> é diferente de zero, repita a operação de recebimento.</target>       </trans-unit>
        <trans-unit id="2370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>Although <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</source>
          <target state="translated">Embora <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> destina-se para protocolos sem conexão, você pode usar um protocolo orientado a conexão também.</target>       </trans-unit>
        <trans-unit id="2371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you choose to do so, you must first either establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming remote host connection by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Se você optar por fazer isso, você deve primeiro estabelecer uma conexão de host remoto chamando o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método ou aceitar uma entrada remota hospedar conexão chamando o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you do not establish or accept a connection before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method, you will get a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você não estabelecer ou aceitar uma conexão antes de chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método, você obterá um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Você também pode estabelecer um host remoto padrão para um protocolo sem-conexão antes de chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>In either of these cases, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.</source>
          <target state="translated">Em ambos os casos, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método irá ignorar o <ph id="ph2">`remoteEP`</ph> parâmetro e recebam dados conectado ou host remoto padrão.</target>       </trans-unit>
        <trans-unit id="2375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>With connection-oriented sockets, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read as much data as is available up to the size of <ph id="ph2">`buffer`</ph>.</source>
          <target state="translated">Com soquetes orientados a conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> lerá a quantidade de dados está disponível até o tamanho de <ph id="ph2">`buffer`</ph>.</target>       </trans-unit>
        <trans-unit id="2376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Se o host remoto é desligado o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> conexão com o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> método e todos os dados disponíveis foi recebida, o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método será concluída imediatamente e retornará zero bytes.</target>       </trans-unit>
        <trans-unit id="2377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="2378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="2379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> do <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> usados em <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> deve corresponder a <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> do <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> usados em <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="2381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The following code example receives a connectionless datagram from a remote host.</source>
          <target state="translated">O exemplo de código a seguir recebe um datagrama sem conexão de um host remoto.</target>       </trans-unit>
        <trans-unit id="2383" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2384" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2385" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2386" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="2387" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="2388" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">Um chamador na pilha de chamadas não tem as permissões necessárias.</target>       </trans-unit>
        <trans-unit id="2389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">para aceitar conexões de rede.</target>       </trans-unit>
        <trans-unit id="2390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2391" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que é o local de armazenamento dos dados recebidos.</target>       </trans-unit>
        <trans-unit id="2392" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Uma combinação bit a bit dos valores <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2393" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passed by reference, that represents the remote server.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passado por referência, que representa o servidor remoto.</target>       </trans-unit>
        <trans-unit id="2394" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Receives a datagram into the data buffer, using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>, and stores the endpoint.</source>
          <target state="translated">Recebe um datagrama no buffer de dados, usando o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> especificado e armazena o ponto de extremidade.</target>       </trans-unit>
        <trans-unit id="2395" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The number of bytes received.</source>
          <target state="translated">O número de bytes recebidos.</target>       </trans-unit>
        <trans-unit id="2396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método lê os dados para o <ph id="ph2">`buffer`</ph> parâmetro, retorna o número de bytes lidos com êxito e captura o ponto de extremidade do host remoto do qual os dados foram enviados.</target>       </trans-unit>
        <trans-unit id="2397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</source>
          <target state="translated">Esse método é útil se você pretende receber datagramas sem conexão de um host desconhecido ou vários hosts.</target>       </trans-unit>
        <trans-unit id="2398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This overload only requires you to provide a receive buffer, the necessary <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>, and an <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> that represents the remote host.</source>
          <target state="translated">Essa sobrecarga exige somente que você forneça um buffer de recepção, o necessário <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>e um <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> que representa o host remoto.</target>       </trans-unit>
        <trans-unit id="2399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The offset defaults to 0 and the size defaults to the length of the buffer parameter.</source>
          <target state="translated">O deslocamento padrão é 0 e o tamanho padrão é o comprimento do parâmetro de buffer.</target>       </trans-unit>
        <trans-unit id="2400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">Antes de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, você deve associar explicitamente o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> para um ponto de extremidade local usando o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you do not, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você não fizer isso, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>With connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.</source>
          <target state="translated">Com protocolos sem conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> lerá o datagrama enfileiradas primeiro recebido no buffer de rede local.</target>       </trans-unit>
        <trans-unit id="2403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If the datagram you receive is larger than the size of <ph id="ph1">`buffer`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will fill <ph id="ph3">`buffer`</ph> with as much of the message as is possible, and throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se o datagrama receber é maior que o tamanho de <ph id="ph1">`buffer`</ph>, o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método preencherá <ph id="ph3">`buffer`</ph> com tanta da mensagem como é possível e lançar um <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are using an unreliable protocol, the excess data will be lost.</source>
          <target state="translated">Se você estiver usando um protocolo não confiável, o excesso de dados serão perdido.</target>       </trans-unit>
        <trans-unit id="2405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method with a large enough buffer.</source>
          <target state="translated">Se você estiver usando um protocolo confiável, o excesso de dados será retido pelo provedor de serviço e você poderá recuperá-lo ao chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método com um buffer grande o suficiente.</target>       </trans-unit>
        <trans-unit id="2406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">Se nenhum dado está disponível para leitura, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método será bloqueado até que os dados estão disponíveis.</target>       </trans-unit>
        <trans-unit id="2407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método será concluída imediatamente e lançar um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Você pode usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> para determinar se os dados estão disponíveis para leitura.</target>       </trans-unit>
        <trans-unit id="2409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">Quando <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> é diferente de zero, repita a operação de recebimento.</target>       </trans-unit>
        <trans-unit id="2410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Although <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</source>
          <target state="translated">Embora <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> destina-se para protocolos sem conexão, você pode usar um protocolo orientado a conexão também.</target>       </trans-unit>
        <trans-unit id="2411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you choose to do so, you must first either establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming remote host connection by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Se você optar por fazer isso, você deve primeiro estabelecer uma conexão de host remoto chamando o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método ou aceitar uma entrada remota hospedar conexão chamando o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you do not establish or accept a connection before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method, you will get a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você não estabelecer ou aceitar uma conexão antes de chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método, você obterá um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Você também pode estabelecer um host remoto padrão para um protocolo sem-conexão antes de chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>In either of these cases, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.</source>
          <target state="translated">Em ambos os casos, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método irá ignorar o <ph id="ph2">`remoteEP`</ph> parâmetro e recebam dados conectado ou host remoto padrão.</target>       </trans-unit>
        <trans-unit id="2415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>With connection-oriented sockets, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read as much data as is available up to the size of <ph id="ph2">`buffer`</ph>.</source>
          <target state="translated">Com soquetes orientados a conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> lerá a quantidade de dados está disponível até o tamanho de <ph id="ph2">`buffer`</ph>.</target>       </trans-unit>
        <trans-unit id="2416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been Received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Se o host remoto é desligado o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> conexão com o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> método e todos os dados disponíveis foi recebida, o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método será concluída imediatamente e retornará zero bytes.</target>       </trans-unit>
        <trans-unit id="2417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="2418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="2419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> do <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> usados em <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> deve corresponder a <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> do <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> usados em <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="2421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The following code example receives a connectionless datagram from a remote host.</source>
          <target state="translated">O exemplo de código a seguir recebe um datagrama sem conexão de um host remoto.</target>       </trans-unit>
        <trans-unit id="2423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> are passed to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> são passados para o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2424" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2425" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2426" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2427" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="2428" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="2429" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">Um chamador na pilha de chamadas não tem as permissões necessárias.</target>       </trans-unit>
        <trans-unit id="2430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">para aceitar conexões de rede.</target>       </trans-unit>
        <trans-unit id="2431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2432" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for received data.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que é o local de armazenamento dos dados recebidos.</target>       </trans-unit>
        <trans-unit id="2433" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The number of bytes to receive.</source>
          <target state="translated">O número de bytes a serem recebidos.</target>       </trans-unit>
        <trans-unit id="2434" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Uma combinação bit a bit dos valores <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2435" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passed by reference, that represents the remote server.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passado por referência, que representa o servidor remoto.</target>       </trans-unit>
        <trans-unit id="2436" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Receives the specified number of bytes into the data buffer, using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>, and stores the endpoint.</source>
          <target state="translated">Recebe o número especificado de bytes no buffer de dados usando o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> especificado e armazena o ponto de extremidade.</target>       </trans-unit>
        <trans-unit id="2437" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The number of bytes received.</source>
          <target state="translated">O número de bytes recebidos.</target>       </trans-unit>
        <trans-unit id="2438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método lê os dados para o <ph id="ph2">`buffer`</ph> parâmetro, retorna o número de bytes lidos com êxito e captura o ponto de extremidade do host remoto do qual os dados foram enviados.</target>       </trans-unit>
        <trans-unit id="2439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</source>
          <target state="translated">Esse método é útil se você pretende receber datagramas sem conexão de um host desconhecido ou vários hosts.</target>       </trans-unit>
        <trans-unit id="2440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This overload only requires you to provide a receive buffer, the number of bytes you want to receive, the necessary <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>, and an <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> that represents the remote host.</source>
          <target state="translated">Essa sobrecarga exige somente que você forneça um buffer de recepção, o número de bytes que você deseja receber as necessárias <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>e um <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> que representa o host remoto.</target>       </trans-unit>
        <trans-unit id="2441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The buffer offset defaults to 0.</source>
          <target state="translated">Deslocamento de buffer padrão é 0.</target>       </trans-unit>
        <trans-unit id="2442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>With connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.</source>
          <target state="translated">Com protocolos sem conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> lerá o datagrama enfileiradas primeiro recebido no buffer de rede local.</target>       </trans-unit>
        <trans-unit id="2443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If the datagram you receive is larger than the size of <ph id="ph1">`buffer`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will fill <ph id="ph3">`buffer`</ph> with as much of the message as is possible, and throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se o datagrama receber é maior que o tamanho de <ph id="ph1">`buffer`</ph>, o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método preencherá <ph id="ph3">`buffer`</ph> com tanta da mensagem como é possível e lançar um <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are using an unreliable protocol, the excess data will be lost.</source>
          <target state="translated">Se você estiver usando um protocolo não confiável, o excesso de dados serão perdido.</target>       </trans-unit>
        <trans-unit id="2445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method with a large enough buffer.</source>
          <target state="translated">Se você estiver usando um protocolo confiável, o excesso de dados será retido pelo provedor de serviço e você poderá recuperá-lo ao chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método com um buffer grande o suficiente.</target>       </trans-unit>
        <trans-unit id="2446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">Se nenhum dado está disponível para leitura, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método será bloqueado até que os dados estão disponíveis.</target>       </trans-unit>
        <trans-unit id="2447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método será concluída imediatamente e lançar um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Você pode usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> para determinar se os dados estão disponíveis para leitura.</target>       </trans-unit>
        <trans-unit id="2449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">Quando <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> é diferente de zero, repita a operação de recebimento.</target>       </trans-unit>
        <trans-unit id="2450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Although <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</source>
          <target state="translated">Embora <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> destina-se para protocolos sem conexão, você pode usar um protocolo orientado a conexão também.</target>       </trans-unit>
        <trans-unit id="2451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you choose to do so, you must first either establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming remote host connection by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Se você optar por fazer isso, você deve primeiro estabelecer uma conexão de host remoto chamando o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método ou aceitar uma entrada remota hospedar conexão chamando o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you do not establish or accept a connection before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method, you will get a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você não estabelecer ou aceitar uma conexão antes de chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método, você obterá um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Você também pode estabelecer um host remoto padrão para um protocolo sem-conexão antes de chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>In either of these cases, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.</source>
          <target state="translated">Em ambos os casos, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método irá ignorar o <ph id="ph2">`remoteEP`</ph> parâmetro e recebam dados conectado ou host remoto padrão.</target>       </trans-unit>
        <trans-unit id="2455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>With connection-oriented sockets, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read as much data as is available up to the number of bytes specified by the <ph id="ph2">`size`</ph> parameter.</source>
          <target state="translated">Com soquetes orientados a conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> lerá a quantidade de dados está disponível até o número de bytes especificado pelo <ph id="ph2">`size`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="2456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Se o host remoto é desligado o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> conexão com o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> método e todos os dados disponíveis foi recebida, o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método será concluída imediatamente e retornará zero bytes.</target>       </trans-unit>
        <trans-unit id="2457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">Antes de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, você deve associar explicitamente o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> para um ponto de extremidade local usando o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you do not, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você não fizer isso, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="2460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="2461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> do <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> usados em <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> deve corresponder a <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> do <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> usados em <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="2463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The following code example receives a connectionless datagram from a remote host.</source>
          <target state="translated">O exemplo de código a seguir recebe um datagrama sem conexão de um host remoto.</target>       </trans-unit>
        <trans-unit id="2465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The buffer size, and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> are passed to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">O tamanho do buffer e <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> são passados para o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2466" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2467" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2468" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2469" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="2470" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2471" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é maior que o comprimento do <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2472" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> não é uma combinação válida de valores.</target>       </trans-unit>
        <trans-unit id="2473" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2474" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> property was not set.</source>
          <target state="translated">A propriedade <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> não foi definida.</target>       </trans-unit>
        <trans-unit id="2475" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2476" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Ocorre um erro de sistema operacional ao acessar o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2477" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="2478" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">Um chamador na pilha de chamadas não tem as permissões necessárias.</target>       </trans-unit>
        <trans-unit id="2479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">para aceitar conexões de rede.</target>       </trans-unit>
        <trans-unit id="2480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2481" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for received data.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que é o local de armazenamento dos dados recebidos.</target>       </trans-unit>
        <trans-unit id="2482" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter to store the received data.</source>
          <target state="translated">A posição no parâmetro <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> para armazenar os dados recebidos.</target>       </trans-unit>
        <trans-unit id="2483" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The number of bytes to receive.</source>
          <target state="translated">O número de bytes a serem recebidos.</target>       </trans-unit>
        <trans-unit id="2484" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Uma combinação bit a bit dos valores <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2485" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passed by reference, that represents the remote server.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passado por referência, que representa o servidor remoto.</target>       </trans-unit>
        <trans-unit id="2486" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>, and stores the endpoint.</source>
          <target state="translated">Recebe o número de bytes de dados no local especificado no buffer de dados usando o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> especificado e armazena o ponto de extremidade.</target>       </trans-unit>
        <trans-unit id="2487" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The number of bytes received.</source>
          <target state="translated">O número de bytes recebidos.</target>       </trans-unit>
        <trans-unit id="2488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método lê os dados para o <ph id="ph2">`buffer`</ph> parâmetro, retorna o número de bytes lidos com êxito e captura o ponto de extremidade do host remoto do qual os dados foram enviados.</target>       </trans-unit>
        <trans-unit id="2489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</source>
          <target state="translated">Esse método é útil se você pretende receber datagramas sem conexão de um host desconhecido ou vários hosts.</target>       </trans-unit>
        <trans-unit id="2490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>With connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.</source>
          <target state="translated">Com protocolos sem conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> lerá o datagrama enfileiradas primeiro recebido no buffer de rede local.</target>       </trans-unit>
        <trans-unit id="2491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If the datagram you receive is larger than the size of <ph id="ph1">`buffer`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will fill <ph id="ph3">`buffer`</ph> with as much of the message as is possible, and throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se o datagrama receber é maior que o tamanho de <ph id="ph1">`buffer`</ph>, o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método preencherá <ph id="ph3">`buffer`</ph> com tanta da mensagem como é possível e lançar um <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are using an unreliable protocol, the excess data will be lost.</source>
          <target state="translated">Se você estiver usando um protocolo não confiável, o excesso de dados serão perdido.</target>       </trans-unit>
        <trans-unit id="2493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method with a large enough buffer.</source>
          <target state="translated">Se você estiver usando um protocolo confiável, o excesso de dados será retido pelo provedor de serviço e você poderá recuperá-lo ao chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método com um buffer grande o suficiente.</target>       </trans-unit>
        <trans-unit id="2494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">Se nenhum dado está disponível para leitura, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método será bloqueado até que os dados estão disponíveis.</target>       </trans-unit>
        <trans-unit id="2495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método será concluída imediatamente e lançar um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Você pode usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> para determinar se os dados estão disponíveis para leitura.</target>       </trans-unit>
        <trans-unit id="2497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">Quando <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> é diferente de zero, repita a operação de recebimento.</target>       </trans-unit>
        <trans-unit id="2498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Although <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</source>
          <target state="translated">Embora <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> destina-se para protocolos sem conexão, você pode usar um protocolo orientado a conexão também.</target>       </trans-unit>
        <trans-unit id="2499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you choose to do so, you must first either establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming remote host connection by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Se você optar por fazer isso, você deve primeiro estabelecer uma conexão de host remoto chamando o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método ou aceitar uma entrada remota hospedar conexão chamando o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you do not establish or accept a connection before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method, you will get a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você não estabelecer ou aceitar uma conexão antes de chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método, você obterá um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Você também pode estabelecer um host remoto padrão para um protocolo sem-conexão antes de chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>In either of these cases, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.</source>
          <target state="translated">Em ambos os casos, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método irá ignorar o <ph id="ph2">`remoteEP`</ph> parâmetro e recebam dados conectado ou host remoto padrão.</target>       </trans-unit>
        <trans-unit id="2503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>With connection-oriented sockets, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read as much data as is available up to the amount of bytes specified by the <ph id="ph2">`size`</ph> parameter.</source>
          <target state="translated">Com soquetes orientados a conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> lerá a quantidade de dados está disponível até a quantidade de bytes especificados pelo <ph id="ph2">`size`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="2504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been Received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Se o host remoto é desligado o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> conexão com o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> método e todos os dados disponíveis foi recebida, o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método será concluída imediatamente e retornará zero bytes.</target>       </trans-unit>
        <trans-unit id="2505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">Antes de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, você deve associar explicitamente o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> para um ponto de extremidade local usando o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you do not, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você não fizer isso, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="2508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="2509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> do <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> usados em <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> deve corresponder a <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> do <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> usados em <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="2511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The following code example receives a connectionless datagram from a remote host.</source>
          <target state="translated">O exemplo de código a seguir recebe um datagrama sem conexão de um host remoto.</target>       </trans-unit>
        <trans-unit id="2513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The offset, buffer size, and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> are passed to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">O deslocamento, o tamanho do buffer, e <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> são passados para o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2514" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2515" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2516" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2517" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="2518" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2519" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> é maior que o comprimento do <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2520" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2521" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="2522" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2523" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of the <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the offset parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é maior que o comprimento de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> menos o valor do parâmetro de deslocamento.</target>       </trans-unit>
        <trans-unit id="2524" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> não é uma combinação válida de valores.</target>       </trans-unit>
        <trans-unit id="2525" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2526" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> property was not set.</source>
          <target state="translated">A propriedade <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> não foi definida.</target>       </trans-unit>
        <trans-unit id="2527" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2528" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="2529" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="2530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">para aceitar conexões de rede.</target>       </trans-unit>
        <trans-unit id="2531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2532" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> a ser usado nessa operação de soquete assíncrono.</target>       </trans-unit>
        <trans-unit id="2533" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins to asynchronously receive data from a specified network device.</source>
          <target state="translated">Começa a receber dados de um dispositivo de rede especificado de maneira assíncrona.</target>       </trans-unit>
        <trans-unit id="2534" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">Retorna <ph id="ph1">&lt;see langword="true" /&gt;</ph> se a operação de E/S está pendente.</target>       </trans-unit>
        <trans-unit id="2535" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">O evento <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> no parâmetro <ph id="ph2">&lt;paramref name="e" /&gt;</ph> será acionado após a conclusão da operação.</target>       </trans-unit>
        <trans-unit id="2536" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">Retorna <ph id="ph1">&lt;see langword="false" /&gt;</ph> se a operação de E/S foi concluída de forma síncrona.</target>       </trans-unit>
        <trans-unit id="2537" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">Nesse caso, o evento <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> no parâmetro <ph id="ph2">&lt;paramref name="e" /&gt;</ph> não será gerado e o objeto <ph id="ph3">&lt;paramref name="e" /&gt;</ph> passado como um parâmetro poderá ser examinado imediatamente depois que a chamada do método for retornada para recuperar o resultado da operação.</target>       </trans-unit>
        <trans-unit id="2538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> method is used primarily to receive data on a connectionless socket.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> método é usado principalmente para receber dados em um soquete sem conexão.</target>       </trans-unit>
        <trans-unit id="2539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The socket's local address must be known.</source>
          <target state="translated">Endereço local do soquete deve ser conhecido.</target>       </trans-unit>
        <trans-unit id="2540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller must set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property to the <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> of the remote host from which the data is to be received.</source>
          <target state="translated">O chamador deverá definir a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> propriedade para o <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> do host remoto do qual os dados são a ser recebida.</target>       </trans-unit>
        <trans-unit id="2541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType&gt;</ph> property on the <ph id="ph2">`e`</ph> parameter provides the Window Sockets service provider with additional information about the read request.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType&gt;</ph> propriedade o <ph id="ph2">`e`</ph> parâmetro fornece o provedor de serviços de soquetes de janela com informações adicionais sobre a solicitação de leitura.</target>       </trans-unit>
        <trans-unit id="2542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For more information about how to use this parameter, see <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como usar esse parâmetro, consulte <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required to successfully call this method:</source>
          <target state="translated">As seguintes propriedades e eventos no <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> objeto são necessárias para chamar com êxito este método:</target>       </trans-unit>
        <trans-unit id="2544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">O chamador pode definir o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> propriedade para qualquer objeto de estado do usuário desejado antes de chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> método, para que as informações serão recuperáveis no método de retorno de chamada.</target>       </trans-unit>
        <trans-unit id="2545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">Se o retorno de chamada precisa de mais informações do que um único objeto, uma pequena classe pode ser criada para manter as outras informações de estado necessárias como membros.</target>       </trans-unit>
        <trans-unit id="2546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</source>
          <target state="translated">Para soquetes orientado a mensagens, uma mensagem de entrada é colocada no buffer até o tamanho total do buffer.</target>       </trans-unit>
        <trans-unit id="2547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> properties determine where in the buffer the data is placed and the amount of data.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> propriedades determinam onde o buffer de dados são colocados e a quantidade de dados.</target>       </trans-unit>
        <trans-unit id="2548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For byte stream–style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</source>
          <target state="translated">Para soquetes de fluxo estilo bytes, os dados de entrada são colocados no buffer até que o buffer é preenchido, a conexão é fechada ou os dados armazenados em buffer internamente são esgotados.</target>       </trans-unit>
        <trans-unit id="2549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> properties determine where in the buffer the data is placed and the amount of data.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> propriedades determinam onde o buffer de dados são colocados e a quantidade de dados.</target>       </trans-unit>
        <trans-unit id="2550" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> cannot be null.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> não pode ser nulo.</target>       </trans-unit>
        <trans-unit id="2551" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated">Uma operação de soquete já estava em andamento com o objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> especificado no parâmetro <ph id="ph2">&lt;paramref name="e" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2552" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">É necessário o Windows XP ou posterior para esse método.</target>       </trans-unit>
        <trans-unit id="2553" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="2554" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="2555" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for received data.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que é o local de armazenamento dos dados recebidos.</target>       </trans-unit>
        <trans-unit id="2556" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter to store the received data.</source>
          <target state="translated">A posição no parâmetro <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> para armazenar os dados recebidos.</target>       </trans-unit>
        <trans-unit id="2557" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The number of bytes to receive.</source>
          <target state="translated">O número de bytes a serem recebidos.</target>       </trans-unit>
        <trans-unit id="2558" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Uma combinação bit a bit dos valores <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2559" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passed by reference, that represents the remote server.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passado por referência, que representa o servidor remoto.</target>       </trans-unit>
        <trans-unit id="2560" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.Sockets.IPPacketInformation" /&gt;</ph> holding address and interface information.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.IPPacketInformation" /&gt;</ph> que contém informações de endereço e de interface.</target>       </trans-unit>
        <trans-unit id="2561" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>, and stores the endpoint and packet information.</source>
          <target state="translated">Recebe o número de bytes de dados no local especificado no buffer de dados usando o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> especificado e armazena as informações de ponto de extremidade e pacote.</target>       </trans-unit>
        <trans-unit id="2562" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The number of bytes received.</source>
          <target state="translated">O número de bytes recebidos.</target>       </trans-unit>
        <trans-unit id="2563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent, as well as information about the received packet.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> método lê os dados para o <ph id="ph2">`buffer`</ph> parâmetro, retorna o número de bytes lidos com êxito e captura o ponto de extremidade do host remoto do qual os dados foram enviados, bem como informações sobre o pacote recebido.</target>       </trans-unit>
        <trans-unit id="2564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method is used primarily to receive message data on a connectionless socket.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> método é usado principalmente para receber dados de mensagem em um soquete sem conexão.</target>       </trans-unit>
        <trans-unit id="2565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The socket's local address must be known.</source>
          <target state="translated">Endereço local do soquete deve ser conhecido.</target>       </trans-unit>
        <trans-unit id="2566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>This method can only be used with datagram and raw sockets.</source>
          <target state="translated">Esse método só pode ser usado com o datagrama e soquetes brutos.</target>       </trans-unit>
        <trans-unit id="2567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The socket must be initialized with the socket type set to <ph id="ph1">&lt;xref:System.Net.Sockets.SocketType.Dgram&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType.Raw&gt;</ph> before calling this method.</source>
          <target state="translated">O soquete deve ser inicializado com o tipo de soquete definido como <ph id="ph1">&lt;xref:System.Net.Sockets.SocketType.Dgram&gt;</ph> ou <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType.Raw&gt;</ph> antes de chamar esse método.</target>       </trans-unit>
        <trans-unit id="2568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>This can be done when the socket is constructed using <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph>.</source>
          <target state="translated">Isso pode ser feito quando o soquete é construído usando <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>For message-oriented sockets, an incoming message is placed into the <ph id="ph1">`buffer`</ph> parameter up to the total size specified in the <ph id="ph2">`size`</ph> parameter.</source>
          <target state="translated">Para soquetes orientado a mensagens, uma mensagem de entrada é colocada no <ph id="ph1">`buffer`</ph> parâmetro até o tamanho total especificado no <ph id="ph2">`size`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="2570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">`offset`</ph> parameter determines where in the <ph id="ph2">`buffer`</ph> the data is placed.</source>
          <target state="translated">O <ph id="ph1">`offset`</ph> parâmetro determina onde no <ph id="ph2">`buffer`</ph> os dados são colocados.</target>       </trans-unit>
        <trans-unit id="2571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The actual amount of data placed into the <ph id="ph1">`buffer`</ph> is returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method.</source>
          <target state="translated">A quantidade real de dados colocados no <ph id="ph1">`buffer`</ph> é retornado pelo <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method automatically method sets the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> socket option to <ph id="ph3">`true`</ph> the first time it is called for a given <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> método define automaticamente um método de <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> soquete opção para <ph id="ph3">`true`</ph> na primeira vez que ele é chamado para um determinado <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>However, the returned <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> object will only be valid for packets which arrive at the local computer after the socket option has been set.</source>
          <target state="translated">No entanto, retornado <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objeto será válido apenas para pacotes que chegam ao computador local depois que a opção de soquete foi definida.</target>       </trans-unit>
        <trans-unit id="2574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>If a socket is sent packets between when it is bound to a local endpoint (explicitly by the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method or implicitly by one of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> methods) and its first call to the <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method, calls to <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method will return invalid <ph id="ph8">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects for these packets.</source>
          <target state="translated">Se um soquete é enviado pacotes entre quando ele está associado a um ponto de extremidade local (explicitamente, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> método ou implicitamente por uma da <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> métodos) e sua primeira chamada para o <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> chamadas de método, a <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> método retornará inválido <ph id="ph8">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objetos para esses pacotes.</target>       </trans-unit>
        <trans-unit id="2575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>To ensure that all <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects are valid, an application should set the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> socket option to <ph id="ph3">`true`</ph> before it is bound to a local endpoint using the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29&gt;</ph> method.</source>
          <target state="translated">Para garantir que todos os <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objetos sejam válidos, um aplicativo deve definir o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> soquete opção para <ph id="ph3">`true`</ph> antes que ele está associado a um ponto de extremidade local usando o <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An application can examine the <ph id="ph1">`ipPacketInformation`</ph> parameter if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</source>
          <target state="translated">Um aplicativo pode examinar o <ph id="ph1">`ipPacketInformation`</ph> parâmetro se ele precisa saber se o datagrama foi enviado por meio de uma unicast, o endereço de difusão ou multicast.</target>       </trans-unit>
        <trans-unit id="2577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> do <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> usados em <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> deve corresponder a <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> do <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> usados em <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="2579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2580" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2581" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">\-</ph> or-</source>
          <target state="translated"><ph id="ph1">\-</ph> ou-</target>       </trans-unit>
        <trans-unit id="2582" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2583" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="2584" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2585" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> é maior que o comprimento do <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2586" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2587" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="2588" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2589" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of the <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the offset parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é maior que o comprimento de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> menos o valor do parâmetro de deslocamento.</target>       </trans-unit>
        <trans-unit id="2590" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> não é uma combinação válida de valores.</target>       </trans-unit>
        <trans-unit id="2591" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2592" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> property was not set.</source>
          <target state="translated">A propriedade <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> não foi definida.</target>       </trans-unit>
        <trans-unit id="2593" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2594" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The .NET Framework is running on an AMD 64-bit processor.</source>
          <target state="translated">O .NET Framework está em execução em um processador AMD 64 bits.</target>       </trans-unit>
        <trans-unit id="2595" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2596" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="2597" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="2598" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The operating system is Windows 2000 or earlier, and this method requires Windows XP.</source>
          <target state="translated">O sistema operacional é o Windows 2000 ou anterior e esse método requer o Windows XP.</target>       </trans-unit>
        <trans-unit id="2599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">para aceitar conexões de rede.</target>       </trans-unit>
        <trans-unit id="2600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2601" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> a ser usado nessa operação de soquete assíncrono.</target>       </trans-unit>
        <trans-unit id="2602" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins to asynchronously receive the specified number of bytes of data into the specified location in the data buffer, using the specified <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /&gt;</ph>, and stores the endpoint and packet information.</source>
          <target state="translated">Inicia o recebimento de forma assíncrona do número especificado de bytes de dados no local especificado do buffer de dados, usando o <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /&gt;</ph> especificado e armazena as informações de ponto de extremidade e de pacote.</target>       </trans-unit>
        <trans-unit id="2603" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">Retorna <ph id="ph1">&lt;see langword="true" /&gt;</ph> se a operação de E/S está pendente.</target>       </trans-unit>
        <trans-unit id="2604" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">O evento <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> no parâmetro <ph id="ph2">&lt;paramref name="e" /&gt;</ph> será acionado após a conclusão da operação.</target>       </trans-unit>
        <trans-unit id="2605" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">Retorna <ph id="ph1">&lt;see langword="false" /&gt;</ph> se a operação de E/S foi concluída de forma síncrona.</target>       </trans-unit>
        <trans-unit id="2606" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">Nesse caso, o evento <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> no parâmetro <ph id="ph2">&lt;paramref name="e" /&gt;</ph> não será gerado e o objeto <ph id="ph3">&lt;paramref name="e" /&gt;</ph> passado como um parâmetro poderá ser examinado imediatamente depois que a chamada do método for retornada para recuperar o resultado da operação.</target>       </trans-unit>
        <trans-unit id="2607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method is used primarily to receive message data on a connectionless socket.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> método é usado principalmente para receber dados de mensagem em um soquete sem conexão.</target>       </trans-unit>
        <trans-unit id="2608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The socket's local address must be known.</source>
          <target state="translated">Endereço local do soquete deve ser conhecido.</target>       </trans-unit>
        <trans-unit id="2609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This method can only be used with datagram and raw sockets.</source>
          <target state="translated">Esse método só pode ser usado com o datagrama e soquetes brutos.</target>       </trans-unit>
        <trans-unit id="2610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The socket must be initialized with the socket type set to <ph id="ph1">&lt;xref:System.Net.Sockets.SocketType.Dgram&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType.Raw&gt;</ph> before calling this method.</source>
          <target state="translated">O soquete deve ser inicializado com o tipo de soquete definido como <ph id="ph1">&lt;xref:System.Net.Sockets.SocketType.Dgram&gt;</ph> ou <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType.Raw&gt;</ph> antes de chamar esse método.</target>       </trans-unit>
        <trans-unit id="2611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This can be done when the socket is constructed using <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph>.</source>
          <target state="translated">Isso pode ser feito quando o soquete é construído usando <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller must set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property to the <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> of the remote host from which the data is to be received.</source>
          <target state="translated">O chamador deverá definir a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> propriedade para o <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> do host remoto do qual os dados são a ser recebida.</target>       </trans-unit>
        <trans-unit id="2613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required to successfully call this method:</source>
          <target state="translated">As seguintes propriedades e eventos no <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> objeto são necessárias para chamar com êxito este método:</target>       </trans-unit>
        <trans-unit id="2614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">O chamador pode definir o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> propriedade para qualquer objeto de estado do usuário desejado antes de chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> método, para que as informações serão recuperáveis no método de retorno de chamada.</target>       </trans-unit>
        <trans-unit id="2615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">Se o retorno de chamada precisa de mais informações do que um único objeto, uma pequena classe pode ser criada para manter as outras informações de estado necessárias como membros.</target>       </trans-unit>
        <trans-unit id="2616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</source>
          <target state="translated">Para soquetes orientado a mensagens, uma mensagem de entrada é colocada no buffer até o tamanho total do buffer.</target>       </trans-unit>
        <trans-unit id="2617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> properties determine where in the buffer the data is placed and the amount of data.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> propriedades determinam onde o buffer de dados são colocados e a quantidade de dados.</target>       </trans-unit>
        <trans-unit id="2618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method automatically sets the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> socket option to <ph id="ph3">`true`</ph> the first time it is called for a given <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> método define automaticamente o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> soquete opção para <ph id="ph3">`true`</ph> na primeira vez que ele é chamado para um determinado <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>However, the <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> object will only be valid for packets which arrive at the local computer after the socket option has been set.</source>
          <target state="translated">No entanto, o <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objeto será válido apenas para pacotes que chegam ao computador local depois que a opção de soquete foi definida.</target>       </trans-unit>
        <trans-unit id="2620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If a socket is sent packets between when the socket is bound to a local endpoint (explicitly by the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method or implicitly by one of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> methods) and the first call to the <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method, calls to <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method will result in invalid <ph id="ph8">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects for these packets.</source>
          <target state="translated">Se um soquete é enviado pacotes entre quando o soquete está associado a um ponto de extremidade local (explicitamente, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> método ou implicitamente por uma da <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> métodos) e a primeira chamada para o <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> chamadas de método, para <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> método resultará em inválido <ph id="ph8">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objetos para esses pacotes.</target>       </trans-unit>
        <trans-unit id="2621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>To ensure that all <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects are valid, an application should set the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> socket option to<ph id="ph3">`true`</ph> before it is bound to a local endpoint using the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29&gt;</ph> method.</source>
          <target state="translated">Para garantir que todos os <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objetos sejam válidos, um aplicativo deve definir o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> soquete opção para<ph id="ph3">`true`</ph> antes que ele está associado a um ponto de extremidade local usando o <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An application can examine the resulting <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</source>
          <target state="translated">Um aplicativo pode examinar resultante <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objetos se ele precisa saber se o datagrama foi enviado por meio de uma unicast, o endereço de difusão ou multicast.</target>       </trans-unit>
        <trans-unit id="2623" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> cannot be null.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> não pode ser nulo.</target>       </trans-unit>
        <trans-unit id="2624" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">É necessário o Windows XP ou posterior para esse método.</target>       </trans-unit>
        <trans-unit id="2625" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="2626" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="2627" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>Gets or sets a value that specifies the amount of time after which a synchronous <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.Receive" /&gt;</ph> call will time out.</source>
          <target state="translated">Obtém ou define um valor que especifica o tempo após o qual uma chamada <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.Receive" /&gt;</ph> síncrona atingirá o tempo limite.</target>       </trans-unit>
        <trans-unit id="2628" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>The time-out value, in milliseconds.</source>
          <target state="translated">O valor de tempo limite, em milissegundos.</target>       </trans-unit>
        <trans-unit id="2629" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>The default value is 0, which indicates an infinite time-out period.</source>
          <target state="translated">O valor padrão é 0, que indica um período de tempo limite infinito.</target>       </trans-unit>
        <trans-unit id="2630" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>Specifying -1 also indicates an infinite time-out period.</source>
          <target state="translated">Especificar -1 também indica um período de tempo limite infinito.</target>       </trans-unit>
        <trans-unit id="2631" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>This option applies to synchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> calls only.</source>
          <target state="translated">Essa opção se aplica a síncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> chama somente.</target>       </trans-unit>
        <trans-unit id="2632" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>If the time-out period is exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se o período de tempo limite for excedido, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> método lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2633" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A&gt;</ph> property.</source>
          <target state="translated">O exemplo de código a seguir demonstra o uso do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="2634" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="2635" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="2636" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>The value specified for a set operation is less than -1.</source>
          <target state="translated">O valor especificado para uma operação de definição é menor que -1.</target>       </trans-unit>
        <trans-unit id="2637" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>Gets the remote endpoint.</source>
          <target state="translated">Obtém o ponto de extremidade remoto.</target>       </trans-unit>
        <trans-unit id="2638" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> with which the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is communicating.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> com o qual o <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> está se comunicando.</target>       </trans-unit>
        <trans-unit id="2639" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> property gets the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> that contains the remote IP address and port number to which the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is connected.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> propriedade obtém o <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> que contém o remoto IP endereço e número da porta para o qual o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> está conectado.</target>       </trans-unit>
        <trans-unit id="2640" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> contains the default remote IP address and port number with which the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> will communicate.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> contém o padrão de endereço IP remoto e a porta número com o qual o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> se comunicará.</target>       </trans-unit>
        <trans-unit id="2641" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>You must cast this <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> to an <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> before retrieving any information.</source>
          <target state="translated">Você deve converter isso <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> para um <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> antes de recuperar todas as informações.</target>       </trans-unit>
        <trans-unit id="2642" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>You can then call the <ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType&gt;</ph> method to retrieve the remote <ph id="ph2">&lt;xref:System.Net.IPAddress&gt;</ph>, and the <ph id="ph3">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType&gt;</ph> method to retrieve the remote port number.</source>
          <target state="translated">Em seguida, você pode chamar o <ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType&gt;</ph> método para recuperar o controle remoto <ph id="ph2">&lt;xref:System.Net.IPAddress&gt;</ph>e o <ph id="ph3">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType&gt;</ph> método para recuperar o número de porta remota.</target>       </trans-unit>
        <trans-unit id="2643" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> is set after a call to either <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> é definido após uma chamada para a <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2644" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>If you try to access this property earlier, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você tentar acessar essa propriedade anterior, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2645" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="2646" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="2647" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="2648" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2649" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>The following code example retrieves and displays the local and remote endpoints.</source>
          <target state="translated">O exemplo de código a seguir recupera e exibe os pontos de extremidade locais e remotos.</target>       </trans-unit>
        <trans-unit id="2650" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="2651" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="2652" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> instances to check for readability.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> de instâncias <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a serem verificadas quanto à legibilidade.</target>       </trans-unit>
        <trans-unit id="2653" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> instances to check for writability.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> de instâncias <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a serem verificadas quanto à capacidade de gravação.</target>       </trans-unit>
        <trans-unit id="2654" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> instances to check for errors.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> de instâncias <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> a serem verificadas quanto a erros.</target>       </trans-unit>
        <trans-unit id="2655" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>The time-out value, in microseconds.</source>
          <target state="translated">O valor de tempo limite, em microssegundos.</target>       </trans-unit>
        <trans-unit id="2656" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>A -1 value indicates an infinite time-out.</source>
          <target state="translated">Um valor de -1 indica um tempo limite infinito.</target>       </trans-unit>
        <trans-unit id="2657" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>Determines the status of one or more sockets.</source>
          <target state="translated">Determina o status de um ou mais soquetes.</target>       </trans-unit>
        <trans-unit id="2658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> is a static method that determines the status of one or more <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instances.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> é um método estático que determina o status de um ou mais <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instâncias.</target>       </trans-unit>
        <trans-unit id="2659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>You must place one or more sockets into an <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> before you can use the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> method.</source>
          <target state="translated">Você deve colocar um ou mais soquetes em um <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> antes de usar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>Check for readability by calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> with the <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> as the <ph id="ph3">`checkRead`</ph> parameter.</source>
          <target state="translated">Verificar para facilitar a leitura chamando <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> com o <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> como o <ph id="ph3">`checkRead`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="2661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>To check your sockets for writability, use the <ph id="ph1">`checkWrite`</ph> parameter.</source>
          <target state="translated">Para verificar seu soquetes para gravabilidade, use o <ph id="ph1">`checkWrite`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="2662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>For detecting error conditions, use <ph id="ph1">`checkError`</ph>.</source>
          <target state="translated">Para detectar condições de erro, use <ph id="ph1">`checkError`</ph>.</target>       </trans-unit>
        <trans-unit id="2663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>After calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph>, the <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> will be filled with only those sockets that satisfy the conditions.</source>
          <target state="translated">Depois de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph>, o <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> será preenchido com apenas esses soquetes que atendem às condições.</target>       </trans-unit>
        <trans-unit id="2664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>If you are in a listening state, readability means that a call to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> will succeed without blocking.</source>
          <target state="translated">Se você estiver em um estado de escuta, legibilidade significa que uma chamada para <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> terá êxito sem bloqueio.</target>       </trans-unit>
        <trans-unit id="2665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>If you have already accepted the connection, readability means that data is available for reading.</source>
          <target state="translated">Se você já aceitou a conexão, a legibilidade significa que os dados estão disponíveis para leitura.</target>       </trans-unit>
        <trans-unit id="2666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>In these cases, all receive operations will succeed without blocking.</source>
          <target state="translated">Nesses casos, todas as operações de recebimento terá êxito sem bloqueio.</target>       </trans-unit>
        <trans-unit id="2667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>Readability can also indicate whether the remote <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> has shut down the connection; in that case a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will return immediately, with zero bytes returned.</source>
          <target state="translated">Legibilidade também pode indicar se o computador remoto <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> foi encerrado para a conexão; nesse caso uma chamada para <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> retornará imediatamente, com zero bytes retornados.</target>       </trans-unit>
        <trans-unit id="2668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> returns when at least one of the sockets of interest (the sockets in the <ph id="ph2">`checkRead`</ph>, <ph id="ph3">`checkWrite`</ph>, and <ph id="ph4">`checkError`</ph> lists) meets its specified criteria, or the <ph id="ph5">`microSeconds`</ph> parameter is exceeded, whichever comes first.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> Retorna quando pelo menos um dos soquetes de interesse (soquetes do <ph id="ph2">`checkRead`</ph>, <ph id="ph3">`checkWrite`</ph>, e <ph id="ph4">`checkError`</ph> lista) atenda aos critérios especificados, ou o <ph id="ph5">`microSeconds`</ph> parâmetro for excedido, o que ocorrer primeiro.</target>       </trans-unit>
        <trans-unit id="2669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>Setting <ph id="ph1">`microSeconds`</ph> to -1 specifies an infinite time-out.</source>
          <target state="translated">Definindo <ph id="ph1">`microSeconds`</ph> como -1 especifica um tempo limite infinito.</target>       </trans-unit>
        <trans-unit id="2670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>If you make a nonblocking call to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, writability means that you have connected successfully.</source>
          <target state="translated">Se você fizer uma chamada sem bloqueio para <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, gravabilidade significa que você se conectou com êxito.</target>       </trans-unit>
        <trans-unit id="2671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>If you already have a connection established, writability means that all send operations will succeed without blocking.</source>
          <target state="translated">Se você já tiver uma conexão estabelecida, gravabilidade significa que todos os enviem operações terão êxito sem bloqueio.</target>       </trans-unit>
        <trans-unit id="2672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>If you have made a non-blocking call to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the <ph id="ph2">`checkerror`</ph> parameter identifies sockets that have not connected successfully.</source>
          <target state="translated">Se você fez uma chamada sem-bloqueio para <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, o <ph id="ph2">`checkerror`</ph> parâmetro identifica que não tenha se conectado com êxito.</target>       </trans-unit>
        <trans-unit id="2673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method if you only want to determine the status of a single <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> método se você quiser determinar o status de um único <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</source>
          <target state="translated">Este método não pode detectar determinados tipos de problemas de conexão, como um cabo de rede interrompido, ou que o host remoto foi desligado maneira brusca.</target>       </trans-unit>
        <trans-unit id="2675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>You must attempt to send or receive data to detect these kinds of errors.</source>
          <target state="translated">Você deve tentar enviar ou receber dados para detectar esses tipos de erros.</target>       </trans-unit>
        <trans-unit id="2676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="2677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="2678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>The following code example uses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> to determine which listening sockets have a connection request.</source>
          <target state="translated">O seguinte exemplo de código usa <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> para determinar quais soquetes escuta tem uma solicitação de conexão.</target>       </trans-unit>
        <trans-unit id="2679" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="checkRead" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or empty.</source>
          <target state="translated">O parâmetro <ph id="ph1">&lt;paramref name="checkRead" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph> ou está vazio.</target>       </trans-unit>
        <trans-unit id="2680" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="2681" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="checkWrite" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or empty</source>
          <target state="translated">O parâmetro <ph id="ph1">&lt;paramref name="checkWrite" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph> ou está vazio</target>       </trans-unit>
        <trans-unit id="2682" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>-and-</source>
          <target state="translated">-e-</target>       </trans-unit>
        <trans-unit id="2683" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="checkError" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or empty.</source>
          <target state="translated">O parâmetro <ph id="ph1">&lt;paramref name="checkError" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph> ou está vazio.</target>       </trans-unit>
        <trans-unit id="2684" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="2685" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sends data to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Envia dados para um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> conectado.</target>       </trans-unit>
        <trans-unit id="2686" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que contém os dados a serem enviados.</target>       </trans-unit>
        <trans-unit id="2687" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>Sends data to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Envia dados para um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> conectado.</target>       </trans-unit>
        <trans-unit id="2688" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">O número de bytes enviados para o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> envia dados de forma síncrona para o host remoto especificado no <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> método e retorna o número de bytes enviados com êxito.</target>       </trans-unit>
        <trans-unit id="2690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> pode ser usado para protocolos e orientada a conexão e sem conexão.</target>       </trans-unit>
        <trans-unit id="2691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>This overload requires a buffer that contains the data you want to send.</source>
          <target state="translated">Essa sobrecarga requer um buffer que contém os dados que você deseja enviar.</target>       </trans-unit>
        <trans-unit id="2692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> o valor padrão é 0, deslocamento de buffer padrão é 0 e o número de bytes a enviar os padrões para o tamanho do buffer.</target>       </trans-unit>
        <trans-unit id="2693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, você deve chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> antes de chamar esse método, ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> lançará um <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, você deve usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> para estabelecer uma conexão de host remoto ou usar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> para aceitar uma conexão de entrada.</target>       </trans-unit>
        <trans-unit id="2695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">Se você não usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> método, você terá que chamar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> antes de cada chamada para <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Você pode usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> mesmo depois de estabelecer um host remoto padrão com <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Você também pode alterar o host remoto padrão antes de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> fazendo outra chamada para <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> será bloqueado até que todos os bytes no buffer são enviados, a menos que um tempo limite foi definido usando <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se o valor de tempo limite foi excedido, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> chamada lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.</source>
          <target state="translated">No modo sem bloqueio, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> pode ser concluído com êxito mesmo que ele envia menor do que o número de bytes no buffer.</target>       </trans-unit>
        <trans-unit id="2702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</source>
          <target state="translated">É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envia os bytes no buffer.</target>       </trans-unit>
        <trans-unit id="2703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</target>       </trans-unit>
        <trans-unit id="2704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada.</target>       </trans-unit>
        <trans-unit id="2705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Uma execução bem-sucedida do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</target>       </trans-unit>
        <trans-unit id="2706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="2707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="2708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito.</target>       </trans-unit>
        <trans-unit id="2709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.</target>       </trans-unit>
        <trans-unit id="2710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="2711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>The following code example demonstrates sending data on a connected <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir demonstra o envio de dados em um conectado <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2713" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2714" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="2715" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="2716" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>A list of <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s of type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Uma lista de <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s do tipo <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> que contém os dados a serem enviados.</target>       </trans-unit>
        <trans-unit id="2717" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>Sends the set of buffers in the list to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Envia o conjunto de buffers na lista para um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> conectado.</target>       </trans-unit>
        <trans-unit id="2718" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">O número de bytes enviados para o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> pode ser usado para protocolos e orientada a conexão e sem conexão.</target>       </trans-unit>
        <trans-unit id="2720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>This overload requires at least one buffer that contains the data you want to send.</source>
          <target state="translated">Essa sobrecarga requer pelo menos um buffer que contém os dados que você deseja enviar.</target>       </trans-unit>
        <trans-unit id="2721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, você deve chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> antes de chamar esse método, ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> lançará um <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, você deve usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> para estabelecer uma conexão de host remoto ou usar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> para aceitar uma conexão de entrada.</target>       </trans-unit>
        <trans-unit id="2723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">Se você não usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> método, você terá que chamar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> antes de cada chamada para <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Você pode usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> mesmo depois de estabelecer um host remoto padrão com <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Você também pode alterar o host remoto padrão antes de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> fazendo outra chamada para <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> será bloqueado até que todos os bytes no buffer são enviados, a menos que um tempo limite foi definido usando <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se o valor de tempo limite foi excedido, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> chamada lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.</source>
          <target state="translated">No modo sem bloqueio, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> pode ser concluído com êxito mesmo que ele envia menor do que o número de bytes no buffer.</target>       </trans-unit>
        <trans-unit id="2730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</source>
          <target state="translated">É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envia os bytes no buffer.</target>       </trans-unit>
        <trans-unit id="2731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</target>       </trans-unit>
        <trans-unit id="2732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada.</target>       </trans-unit>
        <trans-unit id="2733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Uma execução bem-sucedida do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</target>       </trans-unit>
        <trans-unit id="2734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="2735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="2736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito.</target>       </trans-unit>
        <trans-unit id="2737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.</target>       </trans-unit>
        <trans-unit id="2738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="2739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2740" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2741" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> está vazio.</target>       </trans-unit>
        <trans-unit id="2742" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="2743" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>See remarks section below.</source>
          <target state="translated">Consulte a seção Comentários abaixo.</target>       </trans-unit>
        <trans-unit id="2744" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="2745" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que contém os dados a serem enviados.</target>       </trans-unit>
        <trans-unit id="2746" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Uma combinação bit a bit dos valores <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2747" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>Sends data to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Envia dados para um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> conectado usando o <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="2748" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">O número de bytes enviados para o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> envia dados de forma síncrona ao host remoto estabelecido no <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> método e retorna o número de bytes enviados com êxito.</target>       </trans-unit>
        <trans-unit id="2750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method can be used for both connection-oriented and connectionless protocols.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> método pode ser usado para protocolos e orientada a conexão e sem conexão.</target>       </trans-unit>
        <trans-unit id="2751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>This overload requires a buffer that contains the data you want to send and a bitwise combination of <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
          <target state="translated">Essa sobrecarga requer um buffer que contém os dados que você deseja enviar e uma combinação bit a bit de <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</source>
          <target state="translated">O buffer de deslocamento padrão é 0 e o número de bytes a enviar os padrões para o tamanho do buffer.</target>       </trans-unit>
        <trans-unit id="2753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter value, the data you are sending will not be routed.</source>
          <target state="translated">Se você especificar o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> sinalizador como o <ph id="ph2">`socketflags`</ph> o valor do parâmetro, os dados que você está enviando não serão roteadas.</target>       </trans-unit>
        <trans-unit id="2754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, você deve chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> antes de chamar esse método, ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> lançará um <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, você deve usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> para estabelecer uma conexão de host remoto ou usar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> para aceitar uma conexão de entrada.</target>       </trans-unit>
        <trans-unit id="2756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">Se você não usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> método, você terá que chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método antes de cada chamada para <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Você pode usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> mesmo depois de estabelecer um host remoto padrão com <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Você também pode alterar o host remoto padrão antes de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> fazendo outra chamada para <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> será bloqueado até que todos os bytes no buffer são enviados, a menos que um tempo limite foi definido usando <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se o valor de tempo limite foi excedido, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> chamada lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.</source>
          <target state="translated">No modo sem bloqueio, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> pode ser concluído com êxito mesmo que ele envia menor do que o número de bytes no buffer.</target>       </trans-unit>
        <trans-unit id="2763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
          <target state="translated">É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envia o número solicitado de bytes.</target>       </trans-unit>
        <trans-unit id="2764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</target>       </trans-unit>
        <trans-unit id="2765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada.</target>       </trans-unit>
        <trans-unit id="2766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Uma execução bem-sucedida do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</target>       </trans-unit>
        <trans-unit id="2767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>You must ensure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Certifique-se de que o tamanho do buffer de não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</target>       </trans-unit>
        <trans-unit id="2768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se isso acontecer, o datagrama não será enviado e <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="2770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="2771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito.</target>       </trans-unit>
        <trans-unit id="2772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.</target>       </trans-unit>
        <trans-unit id="2773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="2774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>For more information, see<bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte<bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The following code example demonstrates sending data on a connected <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir demonstra o envio de dados em um conectado <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2776" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2777" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="2778" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="2779" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>A list of <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s of type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Uma lista de <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s do tipo <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> que contém os dados a serem enviados.</target>       </trans-unit>
        <trans-unit id="2780" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Uma combinação bit a bit dos valores <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2781" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>Sends the set of buffers in the list to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Envia o conjunto de buffers na lista para um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> conectado, usando o <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="2782" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">O número de bytes enviados para o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>This overload requires at least one buffer that contains the data you want to send.</source>
          <target state="translated">Essa sobrecarga requer pelo menos um buffer que contém os dados que você deseja enviar.</target>       </trans-unit>
        <trans-unit id="2784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to 0.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> valor padrão é 0.</target>       </trans-unit>
        <trans-unit id="2785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketFlags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Se você especificar o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> sinalizador como o <ph id="ph2">`socketFlags`</ph> parâmetro, os dados que você está enviando não serão roteadas.</target>       </trans-unit>
        <trans-unit id="2786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, você deve chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> antes de chamar esse método, ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> lançará um <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, você deve usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> para estabelecer uma conexão de host remoto ou usar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> para aceitar uma conexão de entrada.</target>       </trans-unit>
        <trans-unit id="2788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">Se você não usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> método, você terá que chamar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> antes de cada chamada para <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Você pode usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> mesmo depois de estabelecer um host remoto padrão com <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Você também pode alterar o host remoto padrão antes de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> fazendo outra chamada para <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> será bloqueado até que todos os bytes no buffer são enviados, a menos que um tempo limite foi definido usando <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se o valor de tempo limite foi excedido, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> chamada lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>In non-blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.</source>
          <target state="translated">No modo sem bloqueio, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> pode ser concluído com êxito mesmo que ele envia menor do que o número de bytes no buffer.</target>       </trans-unit>
        <trans-unit id="2795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</source>
          <target state="translated">É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envia os bytes no buffer.</target>       </trans-unit>
        <trans-unit id="2796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</target>       </trans-unit>
        <trans-unit id="2797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada.</target>       </trans-unit>
        <trans-unit id="2798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Uma execução bem-sucedida do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</target>       </trans-unit>
        <trans-unit id="2799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="2800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="2801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito.</target>       </trans-unit>
        <trans-unit id="2802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.</target>       </trans-unit>
        <trans-unit id="2803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="2804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2805" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2806" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> está vazio.</target>       </trans-unit>
        <trans-unit id="2807" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="2808" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="2809" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que contém os dados a serem enviados.</target>       </trans-unit>
        <trans-unit id="2810" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes to send.</source>
          <target state="translated">O número de bytes a serem enviados.</target>       </trans-unit>
        <trans-unit id="2811" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Uma combinação bit a bit dos valores <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2812" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>Sends the specified number of bytes of data to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Envia o número especificado de bytes de dados para um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> conectado, usando o <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="2813" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">O número de bytes enviados para o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> envia dados de forma síncrona ao host remoto estabelecido no <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> método e retorna o número de bytes enviados com êxito.</target>       </trans-unit>
        <trans-unit id="2815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> pode ser usado para protocolos e orientada a conexão e sem conexão.</target>       </trans-unit>
        <trans-unit id="2816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>This overload requires a buffer that contains the data you want to send, the number of bytes you want to send, and a bitwise combination of any <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
          <target state="translated">Essa sobrecarga requer um buffer que contém os dados que você deseja enviar, o número de bytes que você deseja enviar e uma combinação bit a bit de qualquer <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Se você especificar o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> sinalizador como o <ph id="ph2">`socketflags`</ph> parâmetro, os dados que você está enviando não serão roteadas.</target>       </trans-unit>
        <trans-unit id="2818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, você deve chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> antes de chamar esse método, ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> lançará um <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, você deve usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> para estabelecer uma conexão de host remoto ou usar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> para aceitar uma conexão de entrada.</target>       </trans-unit>
        <trans-unit id="2820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method before each call to the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.</source>
          <target state="translated">Se você não usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> método, você terá que chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método antes de cada chamada para o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Você pode usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> mesmo depois de estabelecer um host remoto padrão com <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Você também pode alterar o host remoto padrão antes de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> fazendo outra chamada para <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>With a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until the requested number of bytes are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Com um protocolo orientado a conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> será bloqueado até que o número solicitado de bytes é enviado, a menos que um tempo limite foi definido usando <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se o valor de tempo limite foi excedido, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> chamada lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes you request.</source>
          <target state="translated">No modo sem bloqueio, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> pode ser concluído com êxito mesmo que ele envia menor do que o número de bytes que você solicitar.</target>       </trans-unit>
        <trans-unit id="2827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
          <target state="translated">É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envia o número solicitado de bytes.</target>       </trans-unit>
        <trans-unit id="2828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</target>       </trans-unit>
        <trans-unit id="2829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada.</target>       </trans-unit>
        <trans-unit id="2830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Uma execução bem-sucedida do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</target>       </trans-unit>
        <trans-unit id="2831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You must ensure that the size does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Certifique-se de que o tamanho não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</target>       </trans-unit>
        <trans-unit id="2832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se isso acontecer, o datagrama não será enviado e <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="2834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="2835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito.</target>       </trans-unit>
        <trans-unit id="2836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.</target>       </trans-unit>
        <trans-unit id="2837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="2838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The following code example sends the data found in buffer, and specifies <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph> for <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir envia os dados encontrados no buffer e especifica <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph> para <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2840" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2841" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0 or exceeds the size of the buffer.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é menor que 0 ou excede o tamanho do buffer.</target>       </trans-unit>
        <trans-unit id="2842" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> não é uma combinação válida de valores.</target>       </trans-unit>
        <trans-unit id="2843" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2844" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An operating system error occurs while accessing the socket.</source>
          <target state="translated">Ocorre um erro de sistema operacional ao acessar o soquete.</target>       </trans-unit>
        <trans-unit id="2845" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="2846" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A list of <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s of type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Uma lista de <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s do tipo <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> que contém os dados a serem enviados.</target>       </trans-unit>
        <trans-unit id="2847" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Uma combinação bit a bit dos valores <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2848" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> que armazena o erro de soquete.</target>       </trans-unit>
        <trans-unit id="2849" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>Sends the set of buffers in the list to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Envia o conjunto de buffers na lista para um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> conectado, usando o <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="2850" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">O número de bytes enviados para o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This overload requires at least one buffer that contains the data you want to send.</source>
          <target state="translated">Essa sobrecarga requer pelo menos um buffer que contém os dados que você deseja enviar.</target>       </trans-unit>
        <trans-unit id="2852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to 0.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> valor padrão é 0.</target>       </trans-unit>
        <trans-unit id="2853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketFlags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Se você especificar o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> sinalizador como o <ph id="ph2">`socketFlags`</ph> parâmetro, os dados que você está enviando não serão roteadas.</target>       </trans-unit>
        <trans-unit id="2854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, você deve chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> antes de chamar esse método, ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> lançará um <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, você deve usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> para estabelecer uma conexão de host remoto ou usar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> para aceitar uma conexão de entrada.</target>       </trans-unit>
        <trans-unit id="2856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">Se você não usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> método, você terá que chamar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> antes de cada chamada para <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Você pode usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> mesmo depois de estabelecer um host remoto padrão com <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Você também pode alterar o host remoto padrão antes de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> fazendo outra chamada para <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> será bloqueado até que todos os bytes no buffer são enviados, a menos que um tempo limite foi definido usando <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se o valor de tempo limite foi excedido, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> chamada lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>In non-blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.</source>
          <target state="translated">No modo sem bloqueio, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> pode ser concluído com êxito mesmo que ele envia menor do que o número de bytes no buffer.</target>       </trans-unit>
        <trans-unit id="2863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</source>
          <target state="translated">É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envia os bytes no buffer.</target>       </trans-unit>
        <trans-unit id="2864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</target>       </trans-unit>
        <trans-unit id="2865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada.</target>       </trans-unit>
        <trans-unit id="2866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Uma execução bem-sucedida do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</target>       </trans-unit>
        <trans-unit id="2867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="2868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="2869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito.</target>       </trans-unit>
        <trans-unit id="2870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.</target>       </trans-unit>
        <trans-unit id="2871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="2872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2873" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2874" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> está vazio.</target>       </trans-unit>
        <trans-unit id="2875" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="2876" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="2877" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que contém os dados a serem enviados.</target>       </trans-unit>
        <trans-unit id="2878" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The position in the data buffer at which to begin sending data.</source>
          <target state="translated">A posição no buffer de dados na qual o envio de dados deve começar.</target>       </trans-unit>
        <trans-unit id="2879" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes to send.</source>
          <target state="translated">O número de bytes a serem enviados.</target>       </trans-unit>
        <trans-unit id="2880" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Uma combinação bit a bit dos valores <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2881" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>Sends the specified number of bytes of data to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, starting at the specified offset, and using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Envia o número especificado de bytes de dados para um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> conectado, começando no deslocamento especificado e usando os <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> especificados.</target>       </trans-unit>
        <trans-unit id="2882" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">O número de bytes enviados para o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> envia dados de forma síncrona para o host remoto especificado no <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> método e retorna o número de bytes enviados com êxito.</target>       </trans-unit>
        <trans-unit id="2884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> pode ser usado para protocolos e orientada a conexão e sem conexão.</target>       </trans-unit>
        <trans-unit id="2885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>In this overload, if you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Essa sobrecarga, se você especificar o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> sinalizador como o <ph id="ph2">`socketflags`</ph> parâmetro, os dados que você está enviando não serão roteadas.</target>       </trans-unit>
        <trans-unit id="2886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, você deve chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> antes de chamar este método ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> lançará um <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, você deve usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> para estabelecer uma conexão de host remoto ou usar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> para aceitar uma conexão de entrada.</target>       </trans-unit>
        <trans-unit id="2888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you do not use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">Se você não usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, você terá que chamar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> antes de cada chamada para <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">É okey usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> mesmo depois de estabelecer um host remoto padrão com <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Você também pode alterar o host remoto padrão antes de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> fazendo outra chamada para <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Você também deve ser-se de que o tamanho não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</target>       </trans-unit>
        <trans-unit id="2893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se isso acontecer, o datagrama não será enviado e <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until the requested number of bytes are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> será bloqueado até que o número solicitado de bytes é enviado, a menos que um tempo limite foi definido usando <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se o valor de tempo limite foi excedido, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> chamada lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes you request.</source>
          <target state="translated">No modo sem bloqueio, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> pode ser concluído com êxito mesmo que ele envia menor do que o número de bytes que você solicitar.</target>       </trans-unit>
        <trans-unit id="2897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
          <target state="translated">É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envia o número solicitado de bytes.</target>       </trans-unit>
        <trans-unit id="2898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</target>       </trans-unit>
        <trans-unit id="2899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada.</target>       </trans-unit>
        <trans-unit id="2900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Uma execução bem-sucedida do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</target>       </trans-unit>
        <trans-unit id="2901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="2902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="2903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito.</target>       </trans-unit>
        <trans-unit id="2904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.</target>       </trans-unit>
        <trans-unit id="2905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="2906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The following code example specifies the data buffer, an offset, a size, and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> for sending data to a connected <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir especifica o buffer de dados, um deslocamento, um tamanho, e <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> para enviar dados para um conectado <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2908" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2909" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="2910" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2911" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> é maior que o comprimento do <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2912" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2913" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="2914" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2915" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é maior que o comprimento da subtração de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> e do valor do parâmetro <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2916" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> não é uma combinação válida de valores.</target>       </trans-unit>
        <trans-unit id="2917" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2918" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Ocorre um erro de sistema operacional ao acessar o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2919" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="2920" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que contém os dados a serem enviados.</target>       </trans-unit>
        <trans-unit id="2921" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The position in the data buffer at which to begin sending data.</source>
          <target state="translated">A posição no buffer de dados na qual o envio de dados deve começar.</target>       </trans-unit>
        <trans-unit id="2922" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The number of bytes to send.</source>
          <target state="translated">O número de bytes a serem enviados.</target>       </trans-unit>
        <trans-unit id="2923" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Uma combinação bit a bit dos valores <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2924" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> que armazena o erro de soquete.</target>       </trans-unit>
        <trans-unit id="2925" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>Sends the specified number of bytes of data to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, starting at the specified offset, and using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph></source>
          <target state="translated">Envia o número especificado de bytes de dados a um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> conectado, iniciando no deslocamento especificado e usando o <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> especificado</target>       </trans-unit>
        <trans-unit id="2926" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">O número de bytes enviados para o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> envia dados de forma síncrona para o host remoto especificado no <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> método e retorna o número de bytes enviados com êxito.</target>       </trans-unit>
        <trans-unit id="2928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> pode ser usado para protocolos e orientada a conexão e sem conexão.</target>       </trans-unit>
        <trans-unit id="2929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>In this overload, if you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Essa sobrecarga, se você especificar o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> sinalizador como o <ph id="ph2">`socketflags`</ph> parâmetro, os dados que você está enviando não serão roteadas.</target>       </trans-unit>
        <trans-unit id="2930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, você deve chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> antes de chamar este método ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> lançará um <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, você deve usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> para estabelecer uma conexão de host remoto ou usar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> para aceitar uma conexão de entrada.</target>       </trans-unit>
        <trans-unit id="2932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you do not use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">Se você não usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, você terá que chamar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> antes de cada chamada para <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">É okey usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> mesmo depois de estabelecer um host remoto padrão com <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Você também pode alterar o host remoto padrão antes de chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> fazendo outra chamada para <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Você também deve ser-se de que o tamanho não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</target>       </trans-unit>
        <trans-unit id="2937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se isso acontecer, o datagrama não será enviado e <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until the requested number of bytes are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> será bloqueado até que o número solicitado de bytes é enviado, a menos que um tempo limite foi definido usando <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se o valor de tempo limite foi excedido, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> chamada lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes you request.</source>
          <target state="translated">No modo sem bloqueio, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> pode ser concluído com êxito mesmo que ele envia menor do que o número de bytes que você solicitar.</target>       </trans-unit>
        <trans-unit id="2941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
          <target state="translated">É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envia o número solicitado de bytes.</target>       </trans-unit>
        <trans-unit id="2942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</target>       </trans-unit>
        <trans-unit id="2943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada.</target>       </trans-unit>
        <trans-unit id="2944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Uma execução bem-sucedida do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</target>       </trans-unit>
        <trans-unit id="2945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="2946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="2947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito.</target>       </trans-unit>
        <trans-unit id="2948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.</target>       </trans-unit>
        <trans-unit id="2949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="2950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>For more information, see<bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte<bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The following code example specifies the data buffer, an offset, a size, and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> for sending data to a connected <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">O exemplo de código a seguir especifica o buffer de dados, um deslocamento, um tamanho, e <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> para enviar dados para um conectado <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2952" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2953" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="2954" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2955" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> é maior que o comprimento do <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2956" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2957" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="2958" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2959" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é maior que o comprimento da subtração de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> e do valor do parâmetro <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2960" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> não é uma combinação válida de valores.</target>       </trans-unit>
        <trans-unit id="2961" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="2962" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Ocorre um erro de sistema operacional ao acessar o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2963" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="2964" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> a ser usado nessa operação de soquete assíncrono.</target>       </trans-unit>
        <trans-unit id="2965" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object.</source>
          <target state="translated">Envia dados de forma assíncrona para um objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> conectado.</target>       </trans-unit>
        <trans-unit id="2966" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">Retorna <ph id="ph1">&lt;see langword="true" /&gt;</ph> se a operação de E/S está pendente.</target>       </trans-unit>
        <trans-unit id="2967" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">O evento <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> no parâmetro <ph id="ph2">&lt;paramref name="e" /&gt;</ph> será acionado após a conclusão da operação.</target>       </trans-unit>
        <trans-unit id="2968" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">Retorna <ph id="ph1">&lt;see langword="false" /&gt;</ph> se a operação de E/S foi concluída de forma síncrona.</target>       </trans-unit>
        <trans-unit id="2969" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">Nesse caso, o evento <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> no parâmetro <ph id="ph2">&lt;paramref name="e" /&gt;</ph> não será gerado e o objeto <ph id="ph3">&lt;paramref name="e" /&gt;</ph> passado como um parâmetro poderá ser examinado imediatamente depois que a chamada do método for retornada para recuperar o resultado da operação.</target>       </trans-unit>
        <trans-unit id="2970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method is used to write outgoing data from one or more buffers on a connection-oriented socket.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> método é usado para gravar dados de saída de um ou mais buffers em um soquete orientado a conexão.</target>       </trans-unit>
        <trans-unit id="2971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This method can also be used, however, on connectionless sockets that have specified a remote host on a connect operation.</source>
          <target state="translated">Esse método também pode ser usado, no entanto, em soquetes sem conexão que especificou um host remoto em uma operação de conexão.</target>       </trans-unit>
        <trans-unit id="2972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> método inicia uma operação de envio assíncrono para o host remoto estabelecida no <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, ou <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="2973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required to successfully call this method:</source>
          <target state="translated">As seguintes propriedades e eventos no <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> objeto são necessárias para chamar com êxito este método:</target>       </trans-unit>
        <trans-unit id="2974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> ou <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="2975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> if <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> is set</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> Se <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> está definido</target>       </trans-unit>
        <trans-unit id="2976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> if <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> is set</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> Se <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> está definido</target>       </trans-unit>
        <trans-unit id="2977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">O chamador pode definir o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> propriedade para qualquer objeto de estado do usuário desejado antes de chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> método, para que as informações serão recuperáveis no método de retorno de chamada.</target>       </trans-unit>
        <trans-unit id="2978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">Se o retorno de chamada precisa de mais informações do que um único objeto, uma pequena classe pode ser criada para manter as outras informações de estado necessárias como membros.</target>       </trans-unit>
        <trans-unit id="2979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method will throw an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph><ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> método lançará uma exceção se você não chama primeiro <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, ou <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">Chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> método lhe oferece a capacidade de enviar dados dentro de um thread de execução separado.</target>       </trans-unit>
        <trans-unit id="2981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For message-oriented sockets, do not exceed the maximum message size of the underlying Windows sockets service provider.</source>
          <target state="translated">Para soquetes orientado a mensagens, não exceda o tamanho máximo da mensagem do provedor de serviços de soquetes do Windows subjacente.</target>       </trans-unit>
        <trans-unit id="2982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the data is too long to pass atomically through the underlying service provider, no data is transmitted and the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> with the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> set to the native Winsock WSAEMSGSIZE error code (10040).</source>
          <target state="translated">Se os dados são muito longos para passar o provedor de serviço subjacente atomicamente, nenhum dado é transmitido e <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> método lança um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> com o <ph id="ph3">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> definido como o código de erro de Winsock WSAEMSGSIZE nativo (10040).</target>       </trans-unit>
        <trans-unit id="2983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Note that the successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method does not indicate that the data was successfully delivered.</source>
          <target state="translated">Observe que a conclusão bem-sucedida do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> método não indica que os dados foi entregue com êxito.</target>       </trans-unit>
        <trans-unit id="2984" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /&gt;</ph> or <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> properties on the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> parameter must reference valid buffers.</source>
          <target state="translated">As propriedades <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /&gt;</ph> ou <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> no parâmetro <ph id="ph3">&lt;paramref name="e" /&gt;</ph> devem referenciar buffers válidos.</target>       </trans-unit>
        <trans-unit id="2985" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>One or the other of these properties may be set, but not both at the same time.</source>
          <target state="translated">Uma ou a outra dessas propriedades poderá ser definida, mas não ambas ao mesmo tempo.</target>       </trans-unit>
        <trans-unit id="2986" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated">Uma operação de soquete já estava em andamento com o objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> especificado no parâmetro <ph id="ph2">&lt;paramref name="e" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2987" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">É necessário o Windows XP ou posterior para esse método.</target>       </trans-unit>
        <trans-unit id="2988" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="2989" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is not yet connected or was not obtained via an <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Accept" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /&gt;</ph>,or <ph id="ph4">&lt;see cref="Overload:System.Net.Sockets.Socket.BeginAccept" /&gt;</ph>, method.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> ainda não está conectado ou não foi obtido por meio de um método <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Accept" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /&gt;</ph> ou <ph id="ph4">&lt;see cref="Overload:System.Net.Sockets.Socket.BeginAccept" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2990" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>Gets or sets a value that specifies the size of the send buffer of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Obtém ou define um valor que especifica o tamanho do buffer de envio do <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2991" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>An <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> that contains the size, in bytes, of the send buffer.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> que contém o tamanho, em bytes, do buffer de envio.</target>       </trans-unit>
        <trans-unit id="2992" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>The default is 8192.</source>
          <target state="translated">O padrão é 8192.</target>       </trans-unit>
        <trans-unit id="2993" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>A larger buffer size might delay the recognition of connection difficulties.</source>
          <target state="translated">Um tamanho de buffer maior pode atrasar o reconhecimento de problemas de conexão.</target>       </trans-unit>
        <trans-unit id="2994" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</source>
          <target state="translated">Considere aumentar o tamanho do buffer se estiver transferindo arquivos grandes ou se você estiver usando a largura de banda alta, a conexão de alta latência (como um satélite provedor de banda larga.)</target>       </trans-unit>
        <trans-unit id="2995" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendBufferSize%2A&gt;</ph> property.</source>
          <target state="translated">O exemplo de código a seguir demonstra o uso do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendBufferSize%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="2996" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="2997" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="2998" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>The value specified for a set operation is less than 0.</source>
          <target state="translated">O valor especificado para uma operação de definição é menor que 0.</target>       </trans-unit>
        <trans-unit id="2999" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sends a file and optional data synchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Envia um arquivo e dados opcionais de forma síncrona para um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> conectado.</target>       </trans-unit>
        <trans-unit id="3000" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that contains the path and name of the file to be sent.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> que contém o caminho e o nome do arquivo a ser enviado.</target>       </trans-unit>
        <trans-unit id="3001" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Esse parâmetro pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3002" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>Sends the file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> to a connected <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object with the <ph id="ph3">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /&gt;</ph> transmit flag.</source>
          <target state="translated">Envia o arquivo <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> para um objeto <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> conectado com o sinalizador de transmissão <ph id="ph3">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>This overload sends the file <ph id="ph1">`fileName`</ph> to the connected socket.</source>
          <target state="translated">Essa sobrecarga envia o arquivo <ph id="ph1">`fileName`</ph> para o soquete conectado.</target>       </trans-unit>
        <trans-unit id="3004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The <ph id="ph1">`flags`</ph> parameter defaults to <ph id="ph2">&lt;xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread&gt;</ph> (0), and the <ph id="ph3">`preBuffer`</ph> and <ph id="ph4">`postBuffer`</ph> parameters default to <ph id="ph5">`null`</ph>.</source>
          <target state="translated">O <ph id="ph1">`flags`</ph> parâmetro padrão <ph id="ph2">&lt;xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread&gt;</ph> (0) e o <ph id="ph3">`preBuffer`</ph> e <ph id="ph4">`postBuffer`</ph> parâmetros padrão para <ph id="ph5">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="3005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>If <ph id="ph1">`fileName`</ph> is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</source>
          <target state="translated">Se <ph id="ph1">`fileName`</ph> está no diretório local, que pode ser identificado somente com o nome do arquivo; caso contrário, o caminho completo e nome do arquivo devem ser especificados.</target>       </trans-unit>
        <trans-unit id="3006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>Wildcards ("..<ph id="ph1">\\</ph>\myfile.txt") and UNC share names ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared directory<ph id="ph5">\\</ph>\myfile.txt") are supported.</source>
          <target state="translated">Caracteres curinga ("... <ph id="ph1">\\</ph>\myfile.txt ") e nomes de compartilhamento de UNC ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared diretório<ph id="ph5">\\</ph>\myfile.txt ") são suportados.</target>       </trans-unit>
        <trans-unit id="3007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>If the file is not found, the exception <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.</source>
          <target state="translated">Se o arquivo não for encontrado, a exceção <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> é lançada.</target>       </trans-unit>
        <trans-unit id="3008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>This method uses the <ph id="ph1">`TransmitFile`</ph> function found in the Windows Sockets 2 API.</source>
          <target state="translated">Esse método usa o <ph id="ph1">`TransmitFile`</ph> encontrar a função na API do Windows Sockets 2.</target>       </trans-unit>
        <trans-unit id="3009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>For more information about the <ph id="ph1">`TransmitFile`</ph> function and its flags, see the Windows Sockets documentation in the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre o <ph id="ph1">`TransmitFile`</ph> função e seus sinalizadores, consulte a documentação do Windows Sockets na biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="3010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> synchronously sends a file to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> envia um arquivo de forma síncrona para o host remoto especificado no <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> can be used for both connection-oriented and for connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> pode ser usado para ambos orientado a conexão e protocolos sem conexão.</target>       </trans-unit>
        <trans-unit id="3012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, otherwise <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> throws a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, você deve chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> antes de chamar esse método, caso contrário, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> lança um <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exceção.</target>       </trans-unit>
        <trans-unit id="3013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, você deve usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> para estabelecer uma conexão de host remoto ou usar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> para aceitar uma conexão de entrada.</target>       </trans-unit>
        <trans-unit id="3014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> blocks until the file is sent.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> bloqueia até que o arquivo é enviado.</target>       </trans-unit>
        <trans-unit id="3015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> may complete successfully before the entire file has been sent.</source>
          <target state="translated">No modo sem bloqueio, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> pode ser concluído com êxito antes do arquivo inteiro foi enviado.</target>       </trans-unit>
        <trans-unit id="3016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</target>       </trans-unit>
        <trans-unit id="3017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada.</target>       </trans-unit>
        <trans-unit id="3018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Uma execução bem-sucedida do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</target>       </trans-unit>
        <trans-unit id="3019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="3020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="3021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="3022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The following code example creates and connects a socket and then sends a file to the remote host.</source>
          <target state="translated">O exemplo de código a seguir cria e se conecta a um soquete e, em seguida, envia um arquivo para o host remoto.</target>       </trans-unit>
        <trans-unit id="3024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The file "test.txt" is located in the root directory of the local machine.</source>
          <target state="translated">O arquivo "test.txt" está localizado no diretório raiz da máquina local.</target>       </trans-unit>
        <trans-unit id="3025" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The socket is not connected to a remote host.</source>
          <target state="translated">O soquete não está conectado a um host remoto.</target>       </trans-unit>
        <trans-unit id="3026" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="3027" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object is not in blocking mode and cannot accept this synchronous call.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> não está no modo de bloqueio e não pode aceitar essa chamada síncrona.</target>       </trans-unit>
        <trans-unit id="3028" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> was not found.</source>
          <target state="translated">O arquivo <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> não foi encontrado.</target>       </trans-unit>
        <trans-unit id="3029" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="3030" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that contains the path and name of the file to be sent.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> que contém o caminho e o nome do arquivo a ser enviado.</target>       </trans-unit>
        <trans-unit id="3031" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Esse parâmetro pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3032" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> array that contains data to be sent before the file is sent.</source>
          <target state="translated">Uma matriz <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que contém dados a serem enviados antes de o arquivo ser enviado.</target>       </trans-unit>
        <trans-unit id="3033" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Esse parâmetro pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3034" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> array that contains data to be sent after the file is sent.</source>
          <target state="translated">Uma matriz <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que contém dados a serem enviados depois de o arquivo ser enviado.</target>       </trans-unit>
        <trans-unit id="3035" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Esse parâmetro pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3036" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>One or more of <ph id="ph1">&lt;see cref="T:System.Net.Sockets.TransmitFileOptions" /&gt;</ph> values.</source>
          <target state="translated">Um ou mais valores <ph id="ph1">&lt;see cref="T:System.Net.Sockets.TransmitFileOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3037" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>Sends the file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> and buffers of data to a connected <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object using the specified <ph id="ph3">&lt;see cref="T:System.Net.Sockets.TransmitFileOptions" /&gt;</ph> value.</source>
          <target state="translated">Envia o arquivo <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> e buffers de dados a um <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> conectado usando o valor <ph id="ph3">&lt;see cref="T:System.Net.Sockets.TransmitFileOptions" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="3038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>This overload requires the name of the file you want to send and a bitwise combination of <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> values.</source>
          <target state="translated">Essa sobrecarga requer o nome do arquivo que deseja enviar e uma combinação bit a bit de <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="3039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The <ph id="ph1">`preBuffer`</ph> parameter contains any data you want to precede the file.</source>
          <target state="translated">O <ph id="ph1">`preBuffer`</ph> parâmetro contiver dados deve preceder o arquivo.</target>       </trans-unit>
        <trans-unit id="3040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source><ph id="ph1">`postBuffer`</ph> contains data you want to follow the file.</source>
          <target state="translated"><ph id="ph1">`postBuffer`</ph> contém dados que você deseja que execute o arquivo.</target>       </trans-unit>
        <trans-unit id="3041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>If <ph id="ph1">`fileName`</ph> is in the current working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</source>
          <target state="translated">Se <ph id="ph1">`fileName`</ph> está no diretório de trabalho atual, que pode ser identificado somente com o nome do arquivo; caso contrário, o caminho completo e nome do arquivo devem ser especificados.</target>       </trans-unit>
        <trans-unit id="3042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>Wildcards ("..<ph id="ph1">\\</ph>\myfile.txt") and UNC share names ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared directory<ph id="ph5">\\</ph>\myfile.txt") are supported.</source>
          <target state="translated">Caracteres curinga ("... <ph id="ph1">\\</ph>\myfile.txt ") e nomes de compartilhamento de UNC ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared diretório<ph id="ph5">\\</ph>\myfile.txt ") são suportados.</target>       </trans-unit>
        <trans-unit id="3043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The <ph id="ph1">`flags`</ph> parameter provides the Window Sockets service provider with additional information about the file transfer.</source>
          <target state="translated">O <ph id="ph1">`flags`</ph> parâmetro fornece o provedor de serviços de soquetes de janela com informações adicionais sobre a transferência de arquivos.</target>       </trans-unit>
        <trans-unit id="3044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>For more information about how to use this parameter, see <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como usar esse parâmetro, consulte <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>This method uses the <ph id="ph1">`TransmitFile`</ph> function found in the Windows Sockets 2 API.</source>
          <target state="translated">Esse método usa o <ph id="ph1">`TransmitFile`</ph> encontrar a função na API do Windows Sockets 2.</target>       </trans-unit>
        <trans-unit id="3046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>For more information about the <ph id="ph1">`TransmitFile`</ph> function and its flags, see the Windows Sockets documentation in the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre o <ph id="ph1">`TransmitFile`</ph> função e seus sinalizadores, consulte a documentação do Windows Sockets na biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="3047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> synchronously sends a file to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> envia um arquivo de forma síncrona para o host remoto especificado no <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> can be used for both connection-oriented and for connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> pode ser usado para ambos orientado a conexão e protocolos sem conexão.</target>       </trans-unit>
        <trans-unit id="3049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method; otherwise <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> throws a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, você deve chamar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> antes de chamar esse método; caso contrário, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> lança um <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, você deve usar <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> para estabelecer uma conexão de host remoto ou usar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> para aceitar uma conexão de entrada.</target>       </trans-unit>
        <trans-unit id="3051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> blocks until the entire file is sent.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> bloqueia até que o arquivo inteiro seja enviado.</target>       </trans-unit>
        <trans-unit id="3052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> may complete successfully before the entire file has been sent.</source>
          <target state="translated">No modo sem bloqueio, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> pode ser concluído com êxito antes do arquivo inteiro foi enviado.</target>       </trans-unit>
        <trans-unit id="3053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</target>       </trans-unit>
        <trans-unit id="3054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada.</target>       </trans-unit>
        <trans-unit id="3055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Uma execução bem-sucedida do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</target>       </trans-unit>
        <trans-unit id="3056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="3057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="3058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="3059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The following code example creates and connects a socket.</source>
          <target state="translated">O exemplo de código a seguir cria e se conecta a um soquete.</target>       </trans-unit>
        <trans-unit id="3061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The file "test.txt" is located in the root directory of the local machine.</source>
          <target state="translated">O arquivo "test.txt" está localizado no diretório raiz da máquina local.</target>       </trans-unit>
        <trans-unit id="3062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>In this example, we create a prebuffer and postbuffer of data and send them to the remote host with the file.</source>
          <target state="translated">Neste exemplo, criamos um prebuffer e postbuffer de dados e enviá-los ao host remoto com o arquivo.</target>       </trans-unit>
        <trans-unit id="3063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The default <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> are used.</source>
          <target state="translated">O padrão <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> são usados.</target>       </trans-unit>
        <trans-unit id="3064" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The operating system is not Windows NT or later.</source>
          <target state="translated">O sistema operacional não é o Windows NT ou posterior.</target>       </trans-unit>
        <trans-unit id="3065" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> ou -</target>       </trans-unit>
        <trans-unit id="3066" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The socket is not connected to a remote host.</source>
          <target state="translated">O soquete não está conectado a um host remoto.</target>       </trans-unit>
        <trans-unit id="3067" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="3068" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object is not in blocking mode and cannot accept this synchronous call.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> não está no modo de bloqueio e não pode aceitar essa chamada síncrona.</target>       </trans-unit>
        <trans-unit id="3069" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> was not found.</source>
          <target state="translated">O arquivo <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> não foi encontrado.</target>       </trans-unit>
        <trans-unit id="3070" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="3071" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> a ser usado nessa operação de soquete assíncrono.</target>       </trans-unit>
        <trans-unit id="3072" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Sends a collection of files or in memory data buffers asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object.</source>
          <target state="translated">Envia uma coleção de arquivos ou buffers de dados na memória assincronamente para um objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> conectado.</target>       </trans-unit>
        <trans-unit id="3073" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">Retorna <ph id="ph1">&lt;see langword="true" /&gt;</ph> se a operação de E/S está pendente.</target>       </trans-unit>
        <trans-unit id="3074" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">O evento <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> no parâmetro <ph id="ph2">&lt;paramref name="e" /&gt;</ph> será acionado após a conclusão da operação.</target>       </trans-unit>
        <trans-unit id="3075" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">Retorna <ph id="ph1">&lt;see langword="false" /&gt;</ph> se a operação de E/S foi concluída de forma síncrona.</target>       </trans-unit>
        <trans-unit id="3076" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">Nesse caso, o evento <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> no parâmetro <ph id="ph2">&lt;paramref name="e" /&gt;</ph> não será gerado e o objeto <ph id="ph3">&lt;paramref name="e" /&gt;</ph> passado como um parâmetro poderá ser examinado imediatamente depois que a chamada do método for retornada para recuperar o resultado da operação.</target>       </trans-unit>
        <trans-unit id="3077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method is used to send a collection of files or in memory data buffers to remote host.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> método é usado para enviar uma coleção de arquivos ou na memória buffers de dados para o host remoto.</target>       </trans-unit>
        <trans-unit id="3078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> must already be connected to the remote host.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> já deve estar conectado ao host remoto.</target>       </trans-unit>
        <trans-unit id="3079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If a <ph id="ph1">&lt;xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType&gt;</ph> references a file in the working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</source>
          <target state="translated">Se um <ph id="ph1">&lt;xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType&gt;</ph> faz referência a um arquivo no diretório de trabalho, que pode ser identificado pelo nome do arquivo; caso contrário, o caminho completo e nome do arquivo devem ser especificados.</target>       </trans-unit>
        <trans-unit id="3080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Wildcards and UNC share names are supported.</source>
          <target state="translated">Há suporte para curingas e nomes de compartilhamento UNC.</target>       </trans-unit>
        <trans-unit id="3081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the file is not found, <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.</source>
          <target state="translated">Se o arquivo não for encontrado, <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> é gerada.</target>       </trans-unit>
        <trans-unit id="3082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>To be notified of completion, you must create a callback method that implements the EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs&gt; delegate and attach the callback to the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">Para ser notificado de conclusão, você deve criar um método de retorno de chamada que implementa EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs &gt; delegar e anexe o retorno de chamada para o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="3083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType&gt;</ph> property on the <ph id="ph2">`e`</ph> parameter provides the Window Sockets service provider with additional information about the file transfer.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType&gt;</ph> propriedade o <ph id="ph2">`e`</ph> parâmetro fornece o provedor de serviços de soquetes de janela com informações adicionais sobre a transferência de arquivos.</target>       </trans-unit>
        <trans-unit id="3084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For more information about how to use this parameter, see <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre como usar esse parâmetro, consulte <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required to successfully call this method:</source>
          <target state="translated">As seguintes propriedades e eventos no <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> objeto são necessárias para chamar com êxito este método:</target>       </trans-unit>
        <trans-unit id="3086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">O chamador pode definir o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> propriedade para qualquer objeto de estado do usuário desejado antes de chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> método, para que as informações serão recuperáveis no método de retorno de chamada.</target>       </trans-unit>
        <trans-unit id="3087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">Se o retorno de chamada precisa de mais informações do que um único objeto, uma pequena classe pode ser criada para manter as outras informações de estado necessárias como membros.</target>       </trans-unit>
        <trans-unit id="3088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This method uses the TransmitPackets function found in the Windows Sockets 2 API.</source>
          <target state="translated">Esse método usa a função TransmitPackets encontrada na API do Windows Sockets 2.</target>       </trans-unit>
        <trans-unit id="3089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For more information about the TransmitPackets function and its flags, see the Windows Sockets documentation in the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre a função TransmitPackets e seus sinalizadores, consulte a documentação do Windows Sockets na biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="3090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Although intended for connection-oriented protocols, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">Embora destinado protocolos orientados a conexão, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> método também funciona para protocolos sem conexão, desde que você primeiro chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, ou <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> método para estabelecer um host remoto padrão.</target>       </trans-unit>
        <trans-unit id="3091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Com protocolos sem conexão, você também deve ser-se de que o tamanho do arquivo não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</target>       </trans-unit>
        <trans-unit id="3092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If it does, the datagram is not sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.</source>
          <target state="translated">Se isso acontecer, o datagrama não é enviado e <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> lança um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exceção.</target>       </trans-unit>
        <trans-unit id="3093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method is optimized according to the operating system on which it is used.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> método é otimizado de acordo com o sistema operacional no qual ele é usado.</target>       </trans-unit>
        <trans-unit id="3094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>On Windows server editions, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method is optimized for high performance.</source>
          <target state="translated">Em edições do Windows server, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> método é otimizado para alto desempenho.</target>       </trans-unit>
        <trans-unit id="3095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>On Windows client editions, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method is optimized for minimum memory and resource utilization.</source>
          <target state="translated">Em edições de cliente do Windows, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> método é otimizado para a utilização de recursos e de memória mínima.</target>       </trans-unit>
        <trans-unit id="3096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Use of the <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType&gt;</ph> flag in the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType&gt;</ph> property on the <ph id="ph3">`e`</ph> parameter can deliver significant performance benefits.</source>
          <target state="translated">Usar o <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType&gt;</ph> sinalizador no <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType&gt;</ph> propriedade no <ph id="ph3">`e`</ph> parâmetro pode fornecer benefícios significativos de desempenho.</target>       </trans-unit>
        <trans-unit id="3097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the thread initiating the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method call is being used for heavy computations, it is possible, though unlikely, that APCs could be prevented from launching.</source>
          <target state="translated">Se o thread iniciar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> chamada de método está sendo usada para cálculos pesados, é possível, embora seja improvável, que APCs podem ser impedidos de iniciar.</target>       </trans-unit>
        <trans-unit id="3098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Note that there is a difference between kernel and user-mode APCs.</source>
          <target state="translated">Observe que há uma diferença entre APCs kernel e o modo de usuário.</target>       </trans-unit>
        <trans-unit id="3099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Kernel APCs launch when a thread is in a wait state.</source>
          <target state="translated">Inicie o kernel APCs quando um thread está em um estado de espera.</target>       </trans-unit>
        <trans-unit id="3100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>User-mode APCs launch when a thread is in an alertable wait state</source>
          <target state="translated">Modo de usuário APCs iniciem quando um thread está em um estado de espera podem gerar alertas</target>       </trans-unit>
        <trans-unit id="3101" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The file specified in the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /&gt;</ph> property was not found.</source>
          <target state="translated">O arquivo especificado na propriedade <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /&gt;</ph> não foi encontrado.</target>       </trans-unit>
        <trans-unit id="3102" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated">Uma operação de soquete já estava em andamento com o objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> especificado no parâmetro <ph id="ph2">&lt;paramref name="e" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3103" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">É necessário o Windows XP ou posterior para esse método.</target>       </trans-unit>
        <trans-unit id="3104" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception also occurs if the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is not connected to a remote host.</source>
          <target state="translated">Essa exceção também ocorre se o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> não estiver conectado a um host remoto.</target>       </trans-unit>
        <trans-unit id="3105" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="3106" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A connectionless <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is being used and the file being sent exceeds the maximum packet size of the underlying transport.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> sem conexão está sendo usado e o arquivo sendo enviado excede o tamanho máximo do pacote de transporte subjacente.</target>       </trans-unit>
        <trans-unit id="3107" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>Gets or sets a value that specifies the amount of time after which a synchronous <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.Send" /&gt;</ph> call will time out.</source>
          <target state="translated">Obtém ou define um valor que especifica o tempo após o qual uma chamada <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.Send" /&gt;</ph> síncrona atingirá o tempo limite.</target>       </trans-unit>
        <trans-unit id="3108" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>The time-out value, in milliseconds.</source>
          <target state="translated">O valor de tempo limite, em milissegundos.</target>       </trans-unit>
        <trans-unit id="3109" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>If you set the property with a value between 1 and 499, the value will be changed to 500.</source>
          <target state="translated">Se você definir a propriedade com um valor entre 1 e 499, o valor será alterado para 500.</target>       </trans-unit>
        <trans-unit id="3110" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>The default value is 0, which indicates an infinite time-out period.</source>
          <target state="translated">O valor padrão é 0, que indica um período de tempo limite infinito.</target>       </trans-unit>
        <trans-unit id="3111" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>Specifying -1 also indicates an infinite time-out period.</source>
          <target state="translated">Especificar -1 também indica um período de tempo limite infinito.</target>       </trans-unit>
        <trans-unit id="3112" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>This option applies to synchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> calls only.</source>
          <target state="translated">Essa opção se aplica a síncrona <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> chama somente.</target>       </trans-unit>
        <trans-unit id="3113" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>If the time-out period is exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se o período de tempo limite for excedido, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> método lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3114" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A&gt;</ph> property.</source>
          <target state="translated">O exemplo de código a seguir demonstra o uso do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="3115" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="3116" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="3117" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>The value specified for a set operation is less than -1.</source>
          <target state="translated">O valor especificado para uma operação de definição é menor que -1.</target>       </trans-unit>
        <trans-unit id="3118" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sends data to a specific endpoint.</source>
          <target state="translated">Envia dados para um ponto de extremidade específico.</target>       </trans-unit>
        <trans-unit id="3119" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que contém os dados a serem enviados.</target>       </trans-unit>
        <trans-unit id="3120" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that represents the destination for the data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> que representa o destino dos dados.</target>       </trans-unit>
        <trans-unit id="3121" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>Sends data to the specified endpoint.</source>
          <target state="translated">Envia dados ao ponto de extremidade especificado.</target>       </trans-unit>
        <trans-unit id="3122" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>The number of bytes sent.</source>
          <target state="translated">O número de bytes enviados.</target>       </trans-unit>
        <trans-unit id="3123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>In this overload, the buffer offset defaults to 0, the number of bytes to send defaults to the size of the <ph id="ph1">`buffer`</ph> parameter, and the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to 0.</source>
          <target state="translated">Essa sobrecarga, o buffer de deslocamento padrão é 0, o número de bytes a enviar os padrões para o tamanho do <ph id="ph1">`buffer`</ph> parâmetro e o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> valor padrão é 0.</target>       </trans-unit>
        <trans-unit id="3124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, você não precisa estabelecer um host remoto padrão com o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método antes de chamar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.</source>
          <target state="translated">Você só precisa fazer isso se você pretende chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id="ph3">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.</source>
          <target state="translated">Se você chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método antes de chamar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, o <ph id="ph3">`remoteEP`</ph> parâmetro substituirá o host remoto padrão especificado para que enviar apenas a operação.</target>       </trans-unit>
        <trans-unit id="3127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, because the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">Também não é necessário chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> método, porque o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local mais adequado.</target>       </trans-unit>
        <trans-unit id="3128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you need to identify the assigned local network address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method successfully completes.</source>
          <target state="translated">Se for necessário identificar o número de porta e endereço de rede local atribuído, você pode usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> propriedade após o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> concluído com êxito.</target>       </trans-unit>
        <trans-unit id="3129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>Although intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> also works with connection-oriented protocols.</source>
          <target state="translated">Embora destinado protocolos sem conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> também funciona com protocolos orientados a conexão.</target>       </trans-unit>
        <trans-unit id="3130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming connection request using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, você deve primeiro estabelecer uma conexão de host remoto chamando o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método ou aceitar uma solicitação conexão entrada usando o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you do not establish or accept a remote host connection, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você estabelecer ou aceitar uma conexão de host remoto, não <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Você também pode estabelecer um host remoto padrão para um protocolo sem-conexão antes de chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>In either of these cases, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only send data to the connected or default remote host.</source>
          <target state="translated">Em ambos os casos, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> ignorará o <ph id="ph2">`remoteEP`</ph> parâmetro e apenas enviar dados para o conectado ou host remoto padrão.</target>       </trans-unit>
        <trans-unit id="3134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>Blocking sockets will block until the all of the bytes in the buffer are sent.</source>
          <target state="translated">Bloquear soquetes será bloqueado até que todos os bytes no buffer são enviadas.</target>       </trans-unit>
        <trans-unit id="3135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>Since a nonblocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> completes immediately, it might not send all of the bytes in the <ph id="ph2">`buffer`</ph>.</source>
          <target state="translated">Como um sem bloqueio <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> é concluída imediatamente, ele pode enviar todos os bytes não o <ph id="ph2">`buffer`</ph>.</target>       </trans-unit>
        <trans-unit id="3136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the <ph id="ph1">`buffer`</ph>.</source>
          <target state="translated">É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envie todos os bytes de <ph id="ph1">`buffer`</ph>.</target>       </trans-unit>
        <trans-unit id="3137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</target>       </trans-unit>
        <trans-unit id="3138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada.</target>       </trans-unit>
        <trans-unit id="3139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Uma execução bem-sucedida do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</target>       </trans-unit>
        <trans-unit id="3140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you are using a connectionless protocol in blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão no modo de bloqueio, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> será bloqueada até que o datagrama seja enviado.</target>       </trans-unit>
        <trans-unit id="3141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se você deseja enviar dados para um endereço de difusão, você deve primeiro chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> opção de método e defina o soquete para <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Você também deve ser-se de que o número de bytes enviados não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</target>       </trans-unit>
        <trans-unit id="3143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se isso acontecer, o datagrama não será enviado e <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="3145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="3146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="3147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>The following code example sends a connectionless datagram to the specified remote host.</source>
          <target state="translated">O exemplo de código a seguir envia um datagrama sem conexão com o host remoto especificado.</target>       </trans-unit>
        <trans-unit id="3149" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3150" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="3151" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3152" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="3153" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="3154" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que contém os dados a serem enviados.</target>       </trans-unit>
        <trans-unit id="3155" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Uma combinação bit a bit dos valores <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3156" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that represents the destination location for the data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> que representa o local de destino dos dados.</target>       </trans-unit>
        <trans-unit id="3157" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Sends data to a specific endpoint using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Envia dados para um ponto de extremidade específico usando o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="3158" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The number of bytes sent.</source>
          <target state="translated">O número de bytes enviados.</target>       </trans-unit>
        <trans-unit id="3159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>In this overload, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the <ph id="ph1">`buffer`</ph>.</source>
          <target state="translated">Essa sobrecarga, o buffer de deslocamento padrão é 0 e o número de bytes a enviar os padrões para o tamanho do <ph id="ph1">`buffer`</ph>.</target>       </trans-unit>
        <trans-unit id="3160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Se você especificar o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> sinalizador como o <ph id="ph2">`socketflags`</ph> parâmetro, os dados que você está enviando não serão roteadas.</target>       </trans-unit>
        <trans-unit id="3161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, você não precisa estabelecer um host remoto padrão com o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método antes de chamar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.</source>
          <target state="translated">Você só precisa fazer isso se você pretende chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id="ph3">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.</source>
          <target state="translated">Se você chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método antes de chamar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, o <ph id="ph3">`remoteEP`</ph> parâmetro substituirá o host remoto padrão especificado para que enviar apenas a operação.</target>       </trans-unit>
        <trans-unit id="3164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, because the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">Também não é necessário chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> método, porque o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local mais adequado.</target>       </trans-unit>
        <trans-unit id="3165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you need to identify the assigned local network address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method successfully completes.</source>
          <target state="translated">Se for necessário identificar o número de porta e endereço de rede local atribuído, você pode usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> propriedade após o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> concluído com êxito.</target>       </trans-unit>
        <trans-unit id="3166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Although intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> also works with connection-oriented protocols.</source>
          <target state="translated">Embora destinado protocolos sem conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> também funciona com protocolos orientados a conexão.</target>       </trans-unit>
        <trans-unit id="3167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming connection request using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, você deve primeiro estabelecer uma conexão de host remoto chamando o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método ou aceitar uma solicitação conexão entrada usando o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you do not establish or accept a remote host connection, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você estabelecer ou aceitar uma conexão de host remoto, não <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Você também pode estabelecer um host remoto padrão para um protocolo sem-conexão antes de chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>In either of these cases, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only send data to the connected or default remote host.</source>
          <target state="translated">Em ambos os casos, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> ignorará o <ph id="ph2">`remoteEP`</ph> parâmetro e apenas enviar dados para o conectado ou host remoto padrão.</target>       </trans-unit>
        <trans-unit id="3171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Blocking sockets will block until the requested all of the bytes in the <ph id="ph1">`buffer`</ph> are sent.</source>
          <target state="translated">Bloquear soquetes será bloqueado até que o solicitado todos os bytes de <ph id="ph1">`buffer`</ph> são enviadas.</target>       </trans-unit>
        <trans-unit id="3172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Since a nonblocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> completes immediately, it might not send all of the bytes in the <ph id="ph2">`buffer`</ph>.</source>
          <target state="translated">Como um sem bloqueio <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> é concluída imediatamente, ele pode enviar todos os bytes não o <ph id="ph2">`buffer`</ph>.</target>       </trans-unit>
        <trans-unit id="3173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the <ph id="ph1">`buffer`</ph>.</source>
          <target state="translated">É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envie todos os bytes de <ph id="ph1">`buffer`</ph>.</target>       </trans-unit>
        <trans-unit id="3174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</target>       </trans-unit>
        <trans-unit id="3175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</source>
          <target state="translated">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados out-indo é coletada.</target>       </trans-unit>
        <trans-unit id="3176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Uma execução bem-sucedida do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</target>       </trans-unit>
        <trans-unit id="3177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connectionless protocol in blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão no modo de bloqueio, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> será bloqueada até que o datagrama seja enviado.</target>       </trans-unit>
        <trans-unit id="3178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se você deseja enviar dados para um endereço de difusão, você deve primeiro chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> opção de método e defina o soquete para <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Você também deve ser-se de que o número de bytes enviados não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</target>       </trans-unit>
        <trans-unit id="3180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se isso acontecer, o datagrama não será enviado e <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="3182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="3183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="3184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The following code example sends a connectionless datagram to the specified remote host.</source>
          <target state="translated">O exemplo de código a seguir envia um datagrama sem conexão com o host remoto especificado.</target>       </trans-unit>
        <trans-unit id="3186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> are passed to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> são passados para o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3187" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3188" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="3189" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3190" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="3191" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="3192" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que contém os dados a serem enviados.</target>       </trans-unit>
        <trans-unit id="3193" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The number of bytes to send.</source>
          <target state="translated">O número de bytes a serem enviados.</target>       </trans-unit>
        <trans-unit id="3194" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Uma combinação bit a bit dos valores <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3195" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that represents the destination location for the data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> que representa o local de destino dos dados.</target>       </trans-unit>
        <trans-unit id="3196" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Sends the specified number of bytes of data to the specified endpoint using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Envia o número especificado de bytes de dados para um ponto de extremidade especificado usando o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="3197" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The number of bytes sent.</source>
          <target state="translated">O número de bytes enviados.</target>       </trans-unit>
        <trans-unit id="3198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>In this overload, the buffer offset defaults to 0.</source>
          <target state="translated">Essa sobrecarga, o buffer de deslocamento padrão é 0.</target>       </trans-unit>
        <trans-unit id="3199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Se você especificar o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> sinalizador como o <ph id="ph2">`socketflags`</ph> parâmetro, os dados que você está enviando não serão roteadas.</target>       </trans-unit>
        <trans-unit id="3200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, você não precisa estabelecer um host remoto padrão com o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método antes de chamar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.</source>
          <target state="translated">Você só precisa fazer isso se você pretende chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id="ph3">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.</source>
          <target state="translated">Se você chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método antes de chamar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, o <ph id="ph3">`remoteEP`</ph> parâmetro substituirá o host remoto padrão especificado para que enviar apenas a operação.</target>       </trans-unit>
        <trans-unit id="3203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, because the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">Também não é necessário chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> método, porque o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local mais adequado.</target>       </trans-unit>
        <trans-unit id="3204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you need to identify the assigned local network address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method successfully completes.</source>
          <target state="translated">Se for necessário identificar o número de porta e endereço de rede local atribuído, você pode usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> propriedade após o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> concluído com êxito.</target>       </trans-unit>
        <trans-unit id="3205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Although intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> also works with connection-oriented protocols.</source>
          <target state="translated">Embora destinado protocolos sem conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> também funciona com protocolos orientados a conexão.</target>       </trans-unit>
        <trans-unit id="3206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming connection request using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, você deve primeiro estabelecer uma conexão de host remoto chamando o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método ou aceitar uma solicitação conexão entrada usando o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you do not establish or accept a remote host connection, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você estabelecer ou aceitar uma conexão de host remoto, não <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Você também pode estabelecer um host remoto padrão para um protocolo sem-conexão antes de chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>In either of these cases, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only send data to the connected or default remote host.</source>
          <target state="translated">Em ambos os casos, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> ignorará o <ph id="ph2">`remoteEP`</ph> parâmetro e apenas enviar dados para o conectado ou host remoto padrão.</target>       </trans-unit>
        <trans-unit id="3210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Blocking sockets will block until the requested number of bytes are sent.</source>
          <target state="translated">Bloquear soquetes será bloqueado até que o número solicitado de bytes é enviado.</target>       </trans-unit>
        <trans-unit id="3211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Since a nonblocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> completes immediately, it might not send all of the bytes requested in a single operation.</source>
          <target state="translated">Como um sem bloqueio <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> é concluída imediatamente, pode não enviar todos os bytes solicitados em uma única operação.</target>       </trans-unit>
        <trans-unit id="3212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
          <target state="translated">É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envia o número solicitado de bytes.</target>       </trans-unit>
        <trans-unit id="3213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</target>       </trans-unit>
        <trans-unit id="3214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</source>
          <target state="translated">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados out-indo é coletada.</target>       </trans-unit>
        <trans-unit id="3215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Uma execução bem-sucedida do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</target>       </trans-unit>
        <trans-unit id="3216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connectionless protocol in blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão no modo de bloqueio, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> será bloqueada até que o datagrama seja enviado.</target>       </trans-unit>
        <trans-unit id="3217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se você deseja enviar dados para um endereço de difusão, você deve primeiro chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> opção de método e defina o soquete para <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Você também deve ser-se de que o número de bytes enviados não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</target>       </trans-unit>
        <trans-unit id="3219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se isso acontecer, o datagrama não será enviado e <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="3221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="3222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="3223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The following code example sends a connectionless datagram to the specified remote host.</source>
          <target state="translated">O exemplo de código a seguir envia um datagrama sem conexão com o host remoto especificado.</target>       </trans-unit>
        <trans-unit id="3225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The size and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> are passed to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">O tamanho e <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> são passados para o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3226" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3227" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="3228" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3229" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The specified <ph id="ph1">&lt;paramref name="size" /&gt;</ph> exceeds the size of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;paramref name="size" /&gt;</ph> especificado excede o tamanho de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3230" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="3231" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="3232" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que contém os dados a serem enviados.</target>       </trans-unit>
        <trans-unit id="3233" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The position in the data buffer at which to begin sending data.</source>
          <target state="translated">A posição no buffer de dados na qual o envio de dados deve começar.</target>       </trans-unit>
        <trans-unit id="3234" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The number of bytes to send.</source>
          <target state="translated">O número de bytes a serem enviados.</target>       </trans-unit>
        <trans-unit id="3235" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Uma combinação bit a bit dos valores <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3236" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that represents the destination location for the data.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> que representa o local de destino dos dados.</target>       </trans-unit>
        <trans-unit id="3237" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Sends the specified number of bytes of data to the specified endpoint, starting at the specified location in the buffer, and using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Envia o número especificado de bytes de dados para o ponto de extremidade especificado, começando no local especificado no buffer e usando o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="3238" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The number of bytes sent.</source>
          <target state="translated">O número de bytes enviados.</target>       </trans-unit>
        <trans-unit id="3239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>In this overload, if you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Essa sobrecarga, se você especificar o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> sinalizador como o <ph id="ph2">`socketflags`</ph> parâmetro, os dados que você está enviando não serão roteadas.</target>       </trans-unit>
        <trans-unit id="3240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, você não precisa estabelecer um host remoto padrão com o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método antes de chamar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.</source>
          <target state="translated">Você só precisa fazer isso se você pretende chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id="ph3">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.</source>
          <target state="translated">Se você chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método antes de chamar <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, o <ph id="ph3">`remoteEP`</ph> parâmetro substituirá o host remoto padrão especificado para que enviar apenas a operação.</target>       </trans-unit>
        <trans-unit id="3243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, because the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">Também não é necessário chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> método, porque o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local mais adequado.</target>       </trans-unit>
        <trans-unit id="3244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you need to identify the assigned local network address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method successfully completes.</source>
          <target state="translated">Se for necessário identificar o número de porta e endereço de rede local atribuído, você pode usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> propriedade após o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> concluído com êxito.</target>       </trans-unit>
        <trans-unit id="3245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Although intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> also works with connection-oriented protocols.</source>
          <target state="translated">Embora destinado protocolos sem conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> também funciona com protocolos orientados a conexão.</target>       </trans-unit>
        <trans-unit id="3246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming connection request using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, você deve primeiro estabelecer uma conexão de host remoto chamando o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> método ou aceitar uma solicitação conexão entrada usando o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you do not establish or accept a remote host connection, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se você estabelecer ou aceitar uma conexão de host remoto, não <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Você também pode estabelecer um host remoto padrão para um protocolo sem-conexão antes de chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>In either of these cases, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only send data to the connected or default remote host.</source>
          <target state="translated">Em ambos os casos, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> ignorará o <ph id="ph2">`remoteEP`</ph> parâmetro e apenas enviar dados para o conectado ou host remoto padrão.</target>       </trans-unit>
        <trans-unit id="3250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Blocking sockets will block until the requested number of bytes are sent.</source>
          <target state="translated">Bloquear soquetes será bloqueado até que o número solicitado de bytes é enviado.</target>       </trans-unit>
        <trans-unit id="3251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Since a non-blocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> completes immediately, it might not send all of the bytes requested in a single operation.</source>
          <target state="translated">Desde sem bloqueio <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> é concluída imediatamente, pode não enviar todos os bytes solicitados em uma única operação.</target>       </trans-unit>
        <trans-unit id="3252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>It is your applications responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
          <target state="translated">É sua responsabilidade de aplicativos para controlar o número de bytes enviados e repita a operação até que o aplicativo envia o número solicitado de bytes.</target>       </trans-unit>
        <trans-unit id="3253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</target>       </trans-unit>
        <trans-unit id="3254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</source>
          <target state="translated">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados out-indo é coletada.</target>       </trans-unit>
        <trans-unit id="3255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Uma execução bem-sucedida do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</target>       </trans-unit>
        <trans-unit id="3256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connectionless protocol in blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão no modo de bloqueio, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> será bloqueada até que o datagrama seja enviado.</target>       </trans-unit>
        <trans-unit id="3257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se você deseja enviar dados para um endereço de difusão, você deve primeiro chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> opção de método e defina o soquete para <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Você também deve ser-se de que o tamanho não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</target>       </trans-unit>
        <trans-unit id="3259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se isso acontecer, o datagrama não será enviado e <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="3261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="3262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="3263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The following code example sends a connectionless datagram to the specified remote host.</source>
          <target state="translated">O exemplo de código a seguir envia um datagrama sem conexão com o host remoto especificado.</target>       </trans-unit>
        <trans-unit id="3265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The offset, size, and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> are passed to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">O deslocamento, tamanho, e <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> são passados para o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3266" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3267" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="3268" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3269" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="3270" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="3271" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> é maior que o comprimento do <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3272" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="3273" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="3274" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="3275" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> é maior que o comprimento da subtração de <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> e do valor do parâmetro <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3276" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> não é uma combinação válida de valores.</target>       </trans-unit>
        <trans-unit id="3277" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="3278" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Ocorre um erro de sistema operacional ao acessar o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3279" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="3280" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">Um chamador na pilha de chamadas não tem as permissões necessárias.</target>       </trans-unit>
        <trans-unit id="3281" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> a ser usado nessa operação de soquete assíncrono.</target>       </trans-unit>
        <trans-unit id="3282" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Sends data asynchronously to a specific remote host.</source>
          <target state="translated">Envia dados de maneira assíncrona para um host remoto específico.</target>       </trans-unit>
        <trans-unit id="3283" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">Retorna <ph id="ph1">&lt;see langword="true" /&gt;</ph> se a operação de E/S está pendente.</target>       </trans-unit>
        <trans-unit id="3284" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">O evento <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> no parâmetro <ph id="ph2">&lt;paramref name="e" /&gt;</ph> será acionado após a conclusão da operação.</target>       </trans-unit>
        <trans-unit id="3285" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">Retorna <ph id="ph1">&lt;see langword="false" /&gt;</ph> se a operação de E/S foi concluída de forma síncrona.</target>       </trans-unit>
        <trans-unit id="3286" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">Nesse caso, o evento <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> no parâmetro <ph id="ph2">&lt;paramref name="e" /&gt;</ph> não será gerado e o objeto <ph id="ph3">&lt;paramref name="e" /&gt;</ph> passado como um parâmetro poderá ser examinado imediatamente depois que a chamada do método for retornada para recuperar o resultado da operação.</target>       </trans-unit>
        <trans-unit id="3287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method starts an asynchronous send operation to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property of the <ph id="ph3">`e`</ph> parameter.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> método inicia uma operação de envio assíncrono para o host remoto especificado no <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> propriedade o <ph id="ph3">`e`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="3288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">Chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> método lhe oferece a capacidade de enviar dados dentro de um thread de execução separado.</target>       </trans-unit>
        <trans-unit id="3289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Although this method is intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> works with both connectionless and connection-oriented protocols.</source>
          <target state="translated">Embora esse método destina-se a protocolos sem conexão, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> funciona com protocolos sem conexão e orientada a conexão.</target>       </trans-unit>
        <trans-unit id="3290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>To be notified of completion, you must create a callback method that implements the EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs&gt; delegate and attach the callback to the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">Para ser notificado de conclusão, você deve criar um método de retorno de chamada que implementa EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs &gt; delegar e anexe o retorno de chamada para o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="3291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required to successfully call this method:</source>
          <target state="translated">As seguintes propriedades e eventos no <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> objeto são necessárias para chamar com êxito este método:</target>       </trans-unit>
        <trans-unit id="3292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">O chamador pode definir o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> propriedade para qualquer objeto de estado do usuário desejado antes de chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> método, para que as informações serão recuperáveis no método de retorno de chamada.</target>       </trans-unit>
        <trans-unit id="3293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">Se o retorno de chamada precisa de mais informações do que um único objeto, uma pequena classe pode ser criada para manter as outras informações de estado necessárias como membros.</target>       </trans-unit>
        <trans-unit id="3294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connection-oriented protocol, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, você deve primeiro chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, ou <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Otherwise <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Caso contrário, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>When using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method will ignore the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property and send data to the <ph id="ph3">&lt;xref:System.Net.EndPoint?displayProperty=nameWithType&gt;</ph> established in the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph9">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method.</source>
          <target state="translated">Ao usar um protocolo orientado a conexão, o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> método irá ignorar o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> propriedade e enviar dados para o <ph id="ph3">&lt;xref:System.Net.EndPoint?displayProperty=nameWithType&gt;</ph> estabelecido no <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, ou <ph id="ph9">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, você não precisa estabelecer um host remoto padrão com o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> método antes de chamar <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> methods.</source>
          <target state="translated">Você só precisa fazer isso se você pretende chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="3299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>, the <ph id="ph5">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property will override the specified default remote host for that send operation only.</source>
          <target state="translated">Se você chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> método antes de chamar <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>, o <ph id="ph5">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> propriedade substituirá o host remoto padrão especificado para que enviar apenas a operação.</target>       </trans-unit>
        <trans-unit id="3300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">Também não é necessário chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, the underlying service provider will assign the most appropriate local network IP address and port number.</source>
          <target state="translated">Nesse caso, o provedor de serviço subjacente atribuirá o mais apropriado local de rede IP endereço e número da porta.</target>       </trans-unit>
        <trans-unit id="3302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Use a port number of zero if you want the underlying service provider to select a free port.</source>
          <target state="translated">Use um número de porta de zero se quiser que o provedor de serviço subjacente para selecionar uma porta livre.</target>       </trans-unit>
        <trans-unit id="3303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you need to identify the assigned local network IP address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event is signaled and the associated delegates are called.</source>
          <target state="translated">Se for necessário identificar o número de porta e endereço IP atribuído de rede local, você pode usar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> propriedade após o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> evento é sinalizado e delegados associados são chamados.</target>       </trans-unit>
        <trans-unit id="3304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option for <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph> to true.</source>
          <target state="translated">Se você deseja enviar dados para um endereço de difusão, você deve primeiro chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> opção de método e defina o soquete para <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph> como true.</target>       </trans-unit>
        <trans-unit id="3305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Você também deve ser-se de que o tamanho do buffer de não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</target>       </trans-unit>
        <trans-unit id="3306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se isso acontecer, o datagrama não será enviado e <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you specify the DontRoute flag in the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType&gt;</ph> property, the data you are sending will not be routed.</source>
          <target state="translated">Se você especificar o sinalizador de DontRoute a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType&gt;</ph> propriedade, os dados que você está enviando não serão roteadas.</target>       </trans-unit>
        <trans-unit id="3308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying transport.</source>
          <target state="translated">Para soquetes orientado a mensagens, deve-se ter cuidado para não exceder o tamanho máximo da mensagem de transporte subjacente.</target>       </trans-unit>
        <trans-unit id="3309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the size of the buffer exceeds the maximum packet size of the underlying service provider, the datagram is not sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Se o tamanho do buffer excede o tamanho máximo do pacote do provedor de serviço subjacente, o datagrama não é enviado e <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> lançará um <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The successful completion of a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method does not indicate that the data was successfully delivered.</source>
          <target state="translated">A conclusão bem-sucedida de uma <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> método não indica que os dados foi entregue com êxito.</target>       </trans-unit>
        <trans-unit id="3311" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> cannot be null.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> não pode ser nulo.</target>       </trans-unit>
        <trans-unit id="3312" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated">Uma operação de soquete já estava em andamento com o objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> especificado no parâmetro <ph id="ph2">&lt;paramref name="e" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3313" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">É necessário o Windows XP ou posterior para esse método.</target>       </trans-unit>
        <trans-unit id="3314" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="3315" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The protocol specified is connection-oriented, but the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is not yet connected.</source>
          <target state="translated">O protocolo especificado é orientado para a conexão, mas o <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> ainda não está conectado.</target>       </trans-unit>
        <trans-unit id="3316" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>The IP protection level to set on this socket.</source>
          <target state="translated">O nível de proteção IP a ser definido nesse soquete.</target>       </trans-unit>
        <trans-unit id="3317" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>Set the IP protection level on a socket.</source>
          <target state="translated">Defina o nível de proteção IP em um soquete.</target>       </trans-unit>
        <trans-unit id="3318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A&gt;</ph> method enables restricting an a IPv6 or IP socket to listen on a specified scope, such as addresses with the same link local or site local prefix.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A&gt;</ph> método permite restringir um um soquete IP ou IPv6 para escutar em um escopo especificado, como endereços com o mesmo locais do link ou prefixo local do site.</target>       </trans-unit>
        <trans-unit id="3319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>This socket option enables applications to place access restrictions on IPv6 or IP sockets.</source>
          <target state="translated">Essa opção de soquete permite que os aplicativos colocar as restrições de acesso em soquetes IP ou IPv6.</target>       </trans-unit>
        <trans-unit id="3320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>Such restrictions enable an application running on a private LAN to simply and robustly harden itself against external attacks.</source>
          <target state="translated">Essas restrições permitem que um aplicativo em execução em uma LAN privada proteja-se de modo simples e robusto contra ataques externos.</target>       </trans-unit>
        <trans-unit id="3321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>This socket option can also be used to remove access restrictions if the <ph id="ph1">`level`</ph> parameter is set to <ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.Unrestricted&gt;</ph>.</source>
          <target state="translated">Essa opção de soquete também pode ser usada para remover as restrições de acesso se o <ph id="ph1">`level`</ph> parâmetro está definido como <ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.Unrestricted&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>This socket option widens or narrows the scope of a listening socket, enabling unrestricted access from public and private users when appropriate, or restricting access only to the same site, as required.</source>
          <target state="translated">Essa opção de soquete amplia ou reduz o escopo de um soquete de escuta, permitindo acesso irrestrito de usuários públicos e privados, quando apropriado, ou restringindo o acesso somente ao mesmo site, conforme necessário.</target>       </trans-unit>
        <trans-unit id="3323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>This socket option has defined protection levels specified in the <ph id="ph1">&lt;xref:System.Net.Sockets.IPProtectionLevel&gt;</ph> enumeration.</source>
          <target state="translated">Essa opção de soquete definiu os níveis de proteção especificados na enumeração <ph id="ph1">&lt;xref:System.Net.Sockets.IPProtectionLevel&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A&gt;</ph> method is used to enable or disable Network Address Traversal (NAT) for a <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A&gt;</ph> método é usado para habilitar ou desabilitar a passagem de endereços de rede (NAT) para um <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instância.</target>       </trans-unit>
        <trans-unit id="3325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>NAT traversal may be provided using Teredo, 6to4, or an ISATAP tunnel.</source>
          <target state="translated">Percurso de NAT pode ser fornecido usando um túnel ISATAP, 6to4 ou Teredo.</target>       </trans-unit>
        <trans-unit id="3326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>When the <ph id="ph1">`level`</ph> parameter is set to <ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.IPProtectionLevel.Restricted&gt;</ph>, this explicitly disables NAT traversal for a <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance.</source>
          <target state="translated">Quando o <ph id="ph1">`level`</ph> parâmetro está definido como <ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Net.Sockets.IPProtectionLevel.Restricted&gt;</ph>, isso desabilita o percurso de NAT para explicitamente um <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instância.</target>       </trans-unit>
        <trans-unit id="3327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>When the <ph id="ph1">`level`</ph> parameter is set to <ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted&gt;</ph>, this may allow NAT traversal for a <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> depending on firewall rules in place on the system.</source>
          <target state="translated">Quando o <ph id="ph1">`level`</ph> parâmetro está definido como <ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted&gt;</ph>, isso pode permitir percurso de NAT para um <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> dependendo de regras de firewall em vigor no sistema.</target>       </trans-unit>
        <trans-unit id="3328" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>The <ph id="ph1">&lt;paramref name="level" /&gt;</ph> parameter cannot be <ph id="ph2">&lt;see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" /&gt;</ph>.</source>
          <target state="translated">O parâmetro <ph id="ph1">&lt;paramref name="level" /&gt;</ph> não pode ser <ph id="ph2">&lt;see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3329" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>The IP protection level cannot be set to unspecified.</source>
          <target state="translated">O nível de proteção IP não pode ser definido como não especificado.</target>       </trans-unit>
        <trans-unit id="3330" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.AddressFamily" /&gt;</ph> of the socket must be either <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.AddressFamily" /&gt;</ph> do soquete deve ser <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> ou <ph id="ph3">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3331" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sets a <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option.</source>
          <target state="translated">Define uma opção <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3332" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          <target state="translated">Um dos valores de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3333" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          <target state="translated">Um dos valores de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3334" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>The value of the option, represented as a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph>.</source>
          <target state="translated">O valor da opção, representado como um <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3335" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>Sets the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option to the specified <ph id="ph2">&lt;see cref="T:System.Boolean" /&gt;</ph> value.</source>
          <target state="translated">Define a opção <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> especificada para o valor especificado de <ph id="ph2">&lt;see cref="T:System.Boolean" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> opções determinam o comportamento do atual <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>Set <ph id="ph1">`optionValue`</ph> to <ph id="ph2">`true`</ph> to enable the option, or to <ph id="ph3">`false`</ph> to disable the option.</source>
          <target state="translated">Definir <ph id="ph1">`optionValue`</ph> para <ph id="ph2">`true`</ph> para habilitar a opção, ou <ph id="ph3">`false`</ph> para desabilitar a opção.</target>       </trans-unit>
        <trans-unit id="3338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options are grouped by level of protocol support.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> opções são agrupadas por nível de suporte de protocolo.</target>       </trans-unit>
        <trans-unit id="3339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>Listed below are the various <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options that can be set using this overload.</source>
          <target state="translated">Abaixo estão as várias <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> opções que podem ser definidas usando essa sobrecarga.</target>       </trans-unit>
        <trans-unit id="3340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>These options are grouped by the appropriate <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph> value.</source>
          <target state="translated">Essas opções são agrupadas por apropriada <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph> valor.</target>       </trans-unit>
        <trans-unit id="3341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>If you intend to set any of these options, be sure to use the appropriate <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph> value for the <ph id="ph2">`optionLevel`</ph> parameter.</source>
          <target state="translated">Se você pretende definir qualquer uma dessas opções, certifique-se de usar apropriada <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph> valor para o <ph id="ph2">`optionLevel`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="3342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>The option you choose to set must be specified in the <ph id="ph1">`optionName`</ph> parameter.</source>
          <target state="translated">A opção que você optar por definir deve ser especificada no <ph id="ph1">`optionName`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="3343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>If you want to get the current value of any of the options listed, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">Se você deseja obter o valor atual de qualquer uma das opções listadas, use o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType&gt;</ph> opções que podem ser definidas usando essa sobrecarga.</target>       </trans-unit>
        <trans-unit id="3345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType&gt;</ph> opções que podem ser definidas usando essa sobrecarga.</target>       </trans-unit>
        <trans-unit id="3346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType&gt;</ph> opções que podem ser definidas usando essa sobrecarga.</target>       </trans-unit>
        <trans-unit id="3347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType&gt;</ph> opções que podem ser definidas usando essa sobrecarga.</target>       </trans-unit>
        <trans-unit id="3348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>For more information on these options, refer to the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName&gt;</ph> enumeration.</source>
          <target state="translated">Para obter mais informações sobre essas opções, consulte o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName&gt;</ph> enumeração.</target>       </trans-unit>
        <trans-unit id="3349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exceção, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="3350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="3351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>The following code example opens a socket and enables the <ph id="ph1">`DontLinger`</ph> and the <ph id="ph2">`OutOfBandInline`</ph> socket options.</source>
          <target state="translated">O exemplo de código a seguir abre um soquete e permite que o <ph id="ph1">`DontLinger`</ph> e <ph id="ph2">`OutOfBandInline`</ph> opções de soquete.</target>       </trans-unit>
        <trans-unit id="3352" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="3353" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="3354" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          <target state="translated">Um dos valores de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3355" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          <target state="translated">Um dos valores de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3356" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that represents the value of the option.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> que representa o valor da opção.</target>       </trans-unit>
        <trans-unit id="3357" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>Sets the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option to the specified value, represented as a byte array.</source>
          <target state="translated">Define a opção <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> especificada para o valor especificado, representado como uma matriz de bytes.</target>       </trans-unit>
        <trans-unit id="3358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> opções determinam o comportamento do atual <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>Use this overload to set those <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options that require a byte array as an option value.</source>
          <target state="translated">Use essa sobrecarga de configurá-los <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> opções que exigem uma matriz de bytes como um valor de opção.</target>       </trans-unit>
        <trans-unit id="3360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="3361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="3362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="3363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>The following code example sets the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> time-out values.</source>
          <target state="translated">O seguinte exemplo de código define o <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> e <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> valores de tempo limite.</target>       </trans-unit>
        <trans-unit id="3365" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="3366" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="3367" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          <target state="translated">Um dos valores de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3368" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          <target state="translated">Um dos valores de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3369" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>A value of the option.</source>
          <target state="translated">Um valor da opção.</target>       </trans-unit>
        <trans-unit id="3370" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>Sets the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option to the specified integer value.</source>
          <target state="translated">Define a opção <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> especificada para o valor inteiro especificado.</target>       </trans-unit>
        <trans-unit id="3371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> opções determinam o comportamento do atual <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>For an option with a <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> data type, specify a nonzero value to enable the option, and a zero value to disable the option.</source>
          <target state="translated">Para uma opção com um <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> de tipo de dados, especifique um valor diferente de zero para habilitar a opção e um valor igual a zero para desabilitar a opção.</target>       </trans-unit>
        <trans-unit id="3373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>For an option with an integer data type, specify the appropriate value.</source>
          <target state="translated">Para uma opção com um tipo de dados inteiro, especifique o valor apropriado.</target>       </trans-unit>
        <trans-unit id="3374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options are grouped by level of protocol support.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> opções são agrupadas por nível de suporte de protocolo.</target>       </trans-unit>
        <trans-unit id="3375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>Listed below are the various <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options that can be set using this overload.</source>
          <target state="translated">Abaixo estão as várias <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> opções que podem ser definidas usando essa sobrecarga.</target>       </trans-unit>
        <trans-unit id="3376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>These options are grouped by the appropriate <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph>.</source>
          <target state="translated">Essas opções são agrupadas por apropriada <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>If you intend to set any of these options, be sure to use the appropriate <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph> for the <ph id="ph2">`optionLevel`</ph> parameter.</source>
          <target state="translated">Se você pretende definir qualquer uma dessas opções, certifique-se de usar apropriada <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph> para o <ph id="ph2">`optionLevel`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="3378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The option you choose to set must be specified in the <ph id="ph1">`optionName`</ph> parameter.</source>
          <target state="translated">A opção que você optar por definir deve ser especificada no <ph id="ph1">`optionName`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="3379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>If you want to get the current value of any of the options listed, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">Se você deseja obter o valor atual de qualquer uma das opções listadas, use o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType&gt;</ph> opções que podem ser definidas usando essa sobrecarga.</target>       </trans-unit>
        <trans-unit id="3381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType&gt;</ph> opções que podem ser definidas usando essa sobrecarga.</target>       </trans-unit>
        <trans-unit id="3382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType&gt;</ph> opções que podem ser definidas usando essa sobrecarga.</target>       </trans-unit>
        <trans-unit id="3383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType&gt;</ph> opções que podem ser definidas usando essa sobrecarga.</target>       </trans-unit>
        <trans-unit id="3384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType&gt;</ph> opções que podem ser definidas usando essa sobrecarga.</target>       </trans-unit>
        <trans-unit id="3385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>For more information about these options, refer to the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName&gt;</ph> enumeration.</source>
          <target state="translated">Para obter mais informações sobre essas opções, consulte o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName&gt;</ph> enumeração.</target>       </trans-unit>
        <trans-unit id="3386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="3387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="3388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="3389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The following code example sets the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> time-out values.</source>
          <target state="translated">O seguinte exemplo de código define o <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> e <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> valores de tempo limite.</target>       </trans-unit>
        <trans-unit id="3391" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="3392" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="3393" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          <target state="translated">Um dos valores de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3394" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          <target state="translated">Um dos valores de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3395" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.LingerOption" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Net.Sockets.MulticastOption" /&gt;</ph> that contains the value of the option.</source>
          <target state="translated">Uma <ph id="ph1">&lt;see cref="T:System.Net.Sockets.LingerOption" /&gt;</ph> ou <ph id="ph2">&lt;see cref="T:System.Net.Sockets.MulticastOption" /&gt;</ph> que contém o valor da opção.</target>       </trans-unit>
        <trans-unit id="3396" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>Sets the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option to the specified value, represented as an object.</source>
          <target state="translated">Define a opção <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> especificada com o valor especificado, representado como um objeto.</target>       </trans-unit>
        <trans-unit id="3397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> opções determinam o comportamento do atual <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>Use this overload to set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph><ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options.</source>
          <target state="translated">Use essa sobrecarga para definir o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph>, e <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph> <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> opções.</target>       </trans-unit>
        <trans-unit id="3399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>For the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph> option, use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> for the <ph id="ph3">`optionLevel`</ph> parameter.</source>
          <target state="translated">Para o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph> opção, use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> para o <ph id="ph3">`optionLevel`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="3400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>For <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph>, use <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph>.</source>
          <target state="translated">Para <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph> e <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph>, use <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>If you want to get the current value of any of the options listed above, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">Se você deseja obter o valor atual de qualquer uma das opções listadas acima, use o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="3402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="3403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="3404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>The following code example sets the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> time out values.</source>
          <target state="translated">O seguinte exemplo de código define o <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> e <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> valores de tempo limite.</target>       </trans-unit>
        <trans-unit id="3405" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source><ph id="ph1">&lt;paramref name="optionValue" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="optionValue" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3406" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="3407" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="3408" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketShutdown" /&gt;</ph> values that specifies the operation that will no longer be allowed.</source>
          <target state="translated">Um dos valores <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketShutdown" /&gt;</ph> que especifica a operação que não será mais permitida.</target>       </trans-unit>
        <trans-unit id="3409" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Disables sends and receives on a <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Desabilita envios e recebimentos em um <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>When using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, always call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method before closing the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Ao usar uma conexão orientada <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, sempre chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> método antes de fechar o <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>This ensures that all data is sent and received on the connected socket before it is closed.</source>
          <target state="translated">Isso garante que todos os dados são enviadas e recebidas no soquete conectado antes de ser fechado.</target>       </trans-unit>
        <trans-unit id="3412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method to free all managed and unmanaged resources associated with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Chamar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> método para liberar todos os recursos gerenciados e associados a <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Do not attempt to reuse the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> after closing.</source>
          <target state="translated">Não tente reutilizar o <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> após fechar.</target>       </trans-unit>
        <trans-unit id="3414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>The following table shows the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketShutdown&gt;</ph> enumeration values that are valid for the <ph id="ph2">`how`</ph> parameter.</source>
          <target state="translated">A tabela a seguir mostra o <ph id="ph1">&lt;xref:System.Net.Sockets.SocketShutdown&gt;</ph> valores de enumeração válidos para o <ph id="ph2">`how`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="3415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Value</source>
          <target state="translated">Valor</target>       </trans-unit>
        <trans-unit id="3416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="3417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Send</source>
          <target state="translated">Enviar</target>       </trans-unit>
        <trans-unit id="3418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Disable sending on this <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Desabilitar envio neste <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Receive</source>
          <target state="translated">Receber</target>       </trans-unit>
        <trans-unit id="3420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Disable receiving on this <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Desabilitar o recebimento neste <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Both</source>
          <target state="translated">Ambos</target>       </trans-unit>
        <trans-unit id="3422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Disable both sending and receiving on this <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Desabilitar enviando e recebendo neste <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Setting <ph id="ph1">`how`</ph> to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Send&gt;</ph> specifies that subsequent calls to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> are not allowed.</source>
          <target state="translated">Configuração <ph id="ph1">`how`</ph> para <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Send&gt;</ph> Especifica que subsequentes chamadas para <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> não são permitidas.</target>       </trans-unit>
        <trans-unit id="3424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, specifying <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Send&gt;</ph> will have no effect.</source>
          <target state="translated">Se você estiver usando um sem-conexão <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, especificando <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Send&gt;</ph> não terá efeito.</target>       </trans-unit>
        <trans-unit id="3425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Setting <ph id="ph1">`how`</ph> to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Receive&gt;</ph> specifies that subsequent calls to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> are not allowed.</source>
          <target state="translated">Configuração <ph id="ph1">`how`</ph> para <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Receive&gt;</ph> Especifica que subsequentes chamadas para <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> não são permitidas.</target>       </trans-unit>
        <trans-unit id="3426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>This has no effect on lower protocol layers.</source>
          <target state="translated">Isso não tem nenhum efeito em camadas inferiores de protocolo.</target>       </trans-unit>
        <trans-unit id="3427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>If you are using a connection-oriented protocol, the connection is terminated if either of the following conditions exist after a call to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> :</source>
          <target state="translated">Se você estiver usando um protocolo orientado a conexão, a conexão será encerrada, se uma das seguintes condições for verdadeira após uma chamada para <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> :</target>       </trans-unit>
        <trans-unit id="3428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Data is in the incoming network buffer waiting to be received.</source>
          <target state="translated">Dados estão no buffer de rede de entrada aguardando para ser recebida.</target>       </trans-unit>
        <trans-unit id="3429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>More data has arrived.</source>
          <target state="translated">Mais dados são recebidos.</target>       </trans-unit>
        <trans-unit id="3430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>If you are using a connectionless protocol, datagrams are accepted and queued.</source>
          <target state="translated">Se você estiver usando um protocolo sem-conexão, datagramas são aceitos e em fila.</target>       </trans-unit>
        <trans-unit id="3431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>However, if no buffer space is available for additional incoming datagrams, they will be discarded and no error will be returned to the sender.</source>
          <target state="translated">No entanto, se nenhum espaço de buffer está disponível para os datagramas de entrada adicionais, eles serão descartados e nenhum erro será retornado para o remetente.</target>       </trans-unit>
        <trans-unit id="3432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Using <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> on a connectionless <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is not recommended.</source>
          <target state="translated">Usando <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> em sem uma conexão <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> não é recomendado.</target>       </trans-unit>
        <trans-unit id="3433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Setting <ph id="ph1">`how`</ph> to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Both&gt;</ph> disables both sends and receives as described above.</source>
          <target state="translated">Configuração <ph id="ph1">`how`</ph> para <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Both&gt;</ph> desabilita os dois envia e recebe conforme descrito acima.</target>       </trans-unit>
        <trans-unit id="3434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> when calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, use the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> ao chamar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> método, use o <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="3435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="3436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="3437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>rastreamento de rede no .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>The following code example uses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> to disable the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">O seguinte exemplo de código usa <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> para desabilitar o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3439" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="3440" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="3441" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SocketType">
          <source>Gets the type of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Obtém o tipo do <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3442" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SocketType">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph> values.</source>
          <target state="translated">Um dos valores de <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3443" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SocketType">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SocketType%2A&gt;</ph> is read-only and is set when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is created.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SocketType%2A&gt;</ph> é somente leitura e é definido quando o <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> é criado.</target>       </trans-unit>
        <trans-unit id="3444" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SocketType">
          <source>The following code example displays the <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> to the console.</source>
          <target state="translated">O código a seguir exemplo exibe o <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType&gt;</ph>, e <ph id="ph3">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> para o console.</target>       </trans-unit>
        <trans-unit id="3445" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SupportsIPv4">
          <source>Gets a value indicating whether IPv4 support is available and enabled on the current host.</source>
          <target state="translated">Obtém um valor que indica se o suporte para IPv4 está disponível e habilitado no host atual.</target>       </trans-unit>
        <trans-unit id="3446" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SupportsIPv4">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current host supports the IPv4 protocol; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se o host atual oferece suporte o protocolo IPv4. Caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3447" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SupportsIPv4">
          <source>The operating system may support both IPv4 and IPv6 protocols.</source>
          <target state="translated">O sistema operacional pode oferecer suporte a protocolos IPv4 e IPv6.</target>       </trans-unit>
        <trans-unit id="3448" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SupportsIPv6">
          <source>Gets a value that indicates whether the Framework supports IPv6 for certain obsolete <ph id="ph1">&lt;see cref="T:System.Net.Dns" /&gt;</ph> members.</source>
          <target state="translated">Obtém um valor que indica se o Framework dá suporte a IPv6 para determinados membros <ph id="ph1">&lt;see cref="T:System.Net.Dns" /&gt;</ph> obsoletos.</target>       </trans-unit>
        <trans-unit id="3449" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SupportsIPv6">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the Framework supports IPv6 for certain obsolete <ph id="ph2">&lt;see cref="T:System.Net.Dns" /&gt;</ph> methods; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se o Framework oferece suporte a IPv6 para determinados obsoleto <ph id="ph2">&lt;see cref="T:System.Net.Dns" /&gt;</ph> métodos; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3450" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SupportsIPv6">
          <source>The operating system may support both IPv4 and IPv6 protocols.</source>
          <target state="translated">O sistema operacional pode oferecer suporte a protocolos IPv4 e IPv6.</target>       </trans-unit>
        <trans-unit id="3451" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>Gets or sets a value that specifies the Time To Live (TTL) value of Internet Protocol (IP) packets sent by the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Obtém ou define um valor que especifica o valor TTL (vida útil) de pacotes IP (Protocolo de Internet) enviados pelo <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3452" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>The TTL value.</source>
          <target state="translated">O valor TTL.</target>       </trans-unit>
        <trans-unit id="3453" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>The TTL value indicates the maximum number of routers the packet can traverse before the router discards the packet and an Internet Control Message Protocol (ICMP) "TTL exceeded" error message is returned to the sender.</source>
          <target state="translated">O valor de TTL indica o número máximo de roteadores que o pacote pode percorrer antes do roteador descarta o pacote e uma mensagem de protocolo ICMP (Internet Control) "TTL excedido" mensagem de erro é retornada para o remetente.</target>       </trans-unit>
        <trans-unit id="3454" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>The TTL value may be set to a value from 0 to 255.</source>
          <target state="translated">O valor de TTL pode ser definido como um valor de 0 a 255.</target>       </trans-unit>
        <trans-unit id="3455" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>When this property is not set, the default TTL value for a socket is 32.</source>
          <target state="translated">Quando essa propriedade não é definida, o valor TTL padrão para um soquete é 32.</target>       </trans-unit>
        <trans-unit id="3456" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>Setting this property on a Transmission Control Protocol (TCP) socket is ignored by the TCP/IP stack if a successful connection has been established using the socket.</source>
          <target state="translated">A definição dessa propriedade em um soquete do protocolo de controle de transmissão (TCP) é ignorada pela pilha de TCP/IP, se foi estabelecida uma conexão bem-sucedida com o soquete.</target>       </trans-unit>
        <trans-unit id="3457" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Se você receber um <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use o <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> propriedade para obter o código de erro específico.</target>       </trans-unit>
        <trans-unit id="3458" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</target>       </trans-unit>
        <trans-unit id="3459" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Ttl%2A&gt;</ph> property.</source>
          <target state="translated">O exemplo de código a seguir demonstra o uso do <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Ttl%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="3460" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>The TTL value can't be set to a negative number.</source>
          <target state="translated">O valor TTL não pode ser definido como um número negativo.</target>       </trans-unit>
        <trans-unit id="3461" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>This property can be set only for sockets in the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> families.</source>
          <target state="translated">Essa propriedade pode ser definida apenas para soquetes nas famílias <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> ou <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3462" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Ocorreu um erro ao tentar acessar o soquete.</target>       </trans-unit>
        <trans-unit id="3463" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>This error is also returned when an attempt was made to set TTL to a value higher than 255.</source>
          <target state="translated">Esse erro também é retornado quando tiver sido feita uma tentativa para definir o TTL como um valor maior que 255.</target>       </trans-unit>
        <trans-unit id="3464" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> foi fechado.</target>       </trans-unit>
        <trans-unit id="3465" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO">
          <source>Specifies whether the socket should only use Overlapped I/O mode.</source>
          <target state="translated">Especifica se o soquete deve usar apenas o modo de E/S Sobreposta.</target>       </trans-unit>
        <trans-unit id="3466" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> uses only overlapped I/O; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> usa apenas E/S sobreposta; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3467" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3468" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO">
          <source>Set this property to <ph id="ph1">`true`</ph> for a <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> you intend to call <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.DuplicateAndClose%2A&gt;</ph>.</source>
          <target state="translated">Defina essa propriedade como <ph id="ph1">`true`</ph> para um <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> você pretende chamar <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.DuplicateAndClose%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3469" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO">
          <source>Otherwise, the Framework may assign a completion port to the socket, which would prohibit the use of <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DuplicateAndClose%2A&gt;</ph>.</source>
          <target state="translated">Caso contrário, a estrutura pode atribuir uma porta de conclusão no soquete, o que impeça o uso de <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DuplicateAndClose%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3470" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO">
          <source>The socket has been bound to a completion port.</source>
          <target state="translated">O soquete foi associado a uma porta de conclusão.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>