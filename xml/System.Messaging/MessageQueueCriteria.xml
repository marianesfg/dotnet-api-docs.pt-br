<Type Name="MessageQueueCriteria" FullName="System.Messaging.MessageQueueCriteria">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8671370755dbebeed83b86ed7fd88a50c49e101f" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36476885" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MessageQueueCriteria" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueueCriteria extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueueCriteria" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageQueueCriteria" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageQueueCriteria" />
  <TypeSignature Language="F#" Value="type MessageQueueCriteria = class" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Filters message queues when performing a query using the <see cref="T:System.Messaging.MessageQueue" /> class's <see cref="M:System.Messaging.MessageQueue.GetPublicQueues" /> method.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.MessageQueue> classe fornece vários métodos que permitem filtrar sua pesquisa para filas públicas na rede. Métodos específicos para a filtragem por fila rótulo, categoria ou servidor local são o <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%2A>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%2A>, e <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%2A>.  
  
 O <xref:System.Messaging.MessageQueueCriteria> classe, quando usado com o <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> método, permite que você refine seu filtro. Você pode especificar critérios de pesquisa não especificamente endereçados por meio de uma da `GetPublicQueuesBy`* métodos, ou por vários critérios. Você pode passar um <xref:System.Messaging.MessageQueueCriteria> de instância para o <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> método para pesquisar, por exemplo, por vezes de criação ou modificação de fila, a fila reside no computador, o rótulo da fila ou categoria ou qualquer combinação dessas propriedades.  
  
 Ao filtrar por várias propriedades, os critérios são compostos, aplicando o `AND` operador para o conjunto de propriedades. Portanto, quando você especifica um valor para o <xref:System.Messaging.MessageQueueCriteria.CreatedAfter%2A> propriedade junto com o <xref:System.Messaging.MessageQueueCriteria.MachineName%2A> propriedade, você está solicitando todas as filas que foram criados após um tempo especificado e que residem em um computador específico.  
  
 Quando você definir qualquer propriedade, o método que define a propriedade também define um sinalizador para indicar que devem ser incluído no filtro que você está criando. Você não pode remover propriedades individuais de filtro de pesquisa. Em vez disso, você remover todas as propriedades do filtro chamando <xref:System.Messaging.MessageQueueCriteria.ClearAll%2A>e, em seguida, defina as propriedades que você deseja compilar no filtro de pesquisa. <xref:System.Messaging.MessageQueueCriteria.ClearAll%2A> Redefine todas as propriedades em um estado padrão "não configurado".  
  
 Você deve definir uma propriedade antes de tentar ler. Caso contrário, uma exceção será lançada.  
  
   
  
## Examples  
 O exemplo a seguir itera por meio de filas de mensagens e exibe o caminho de cada fila que foi criada no último dia e que existe no computador "MyComputer".  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CPP/mqgetmessagequeueenumerator_criteria.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CS/mqgetmessagequeueenumerator_criteria.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/VB/mqgetmessagequeueenumerator_criteria.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
    <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
    <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
    <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueueCriteria ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueueCriteria.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueueCriteria();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Messaging.MessageQueueCriteria" /> class.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public Guid Category { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Category" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueueCriteria.Category" />
      <MemberSignature Language="VB.NET" Value="Public Property Category As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Category { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.Category : Guid with get, set" Usage="System.Messaging.MessageQueueCriteria.Category" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the category by which to filter queues in the network.</summary>
        <value>Categoria das filas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A categoria de fila permite que um aplicativo categorizem suas filas. Por exemplo, você pode colocar todas as filas de cobrança em uma categoria e todas as filas de pedido em outro. O <xref:System.Messaging.MessageQueue.Category%2A> propriedade é definido pelo aplicativo e não tem nenhum significado intrínseco para enfileiramento de mensagens.  
  
 Se você estiver filtrando somente por categoria ao pesquisar as filas na rede, você pode usar o método <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%2A>, que é projetado especificamente para essa finalidade. Se você estiver procurando por vários critérios que incluem a categoria, defina <xref:System.Messaging.MessageQueueCriteria.Category%2A> propriedade e passar o parâmetro em <xref:System.Messaging.MessageQueue.GetPublicQueues%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The application did not set the <see cref="P:System.Messaging.MessageQueueCriteria.Category" /> property before reading it.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
      </Docs>
    </Member>
    <Member MemberName="ClearAll">
      <MemberSignature Language="C#" Value="public void ClearAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearAll() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueueCriteria.ClearAll" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearAll ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearAll();" />
      <MemberSignature Language="F#" Value="member this.ClearAll : unit -&gt; unit" Usage="messageQueueCriteria.ClearAll " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clears all properties from being built into a filter and puts all property values into a "not set" state.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você chama <xref:System.Messaging.MessageQueueCriteria.ClearAll%2A>, o método define sinalizadores relacionados a cada o <xref:System.Messaging.MessageQueueCriteria> propriedades, que indicam que não há propriedades devem ser incluídas quando o aplicativo cria o filtro de pesquisa. <xref:System.Messaging.MessageQueueCriteria.ClearAll%2A> Redefine todas as propriedades que têm valores em um estado padrão "não configurado". As propriedades que você alterar posteriormente são combinadas usando lógica `AND` operador para definir um novo filtro para o <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> método. Quando você altera a propriedade, o método que define a propriedade também define um sinalizador para indicar que devem ser incluído no filtro que você está criando.  
  
 Você não pode remover propriedades individuais de filtro de pesquisa. Em vez disso, você remover todas as propriedades do filtro chamando <xref:System.Messaging.MessageQueueCriteria.ClearAll%2A>e, em seguida, defina as propriedades que você deseja compilar no filtro de pesquisa.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreatedAfter">
      <MemberSignature Language="C#" Value="public DateTime CreatedAfter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreatedAfter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueueCriteria.CreatedAfter" />
      <MemberSignature Language="VB.NET" Value="Public Property CreatedAfter As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime CreatedAfter { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.CreatedAfter : DateTime with get, set" Usage="System.Messaging.MessageQueueCriteria.CreatedAfter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the lower boundary of the queue creation date and time by which to filter queues on the network.</summary>
        <value>Um <see cref="T:System.DateTime" /> que especifica o limite inferior para a data e hora de uma fila.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.MessageQueueCriteria> propriedades são combinadas usando uma lógica `AND`, para definir ambos <xref:System.Messaging.MessageQueueCriteria.CreatedAfter%2A> e <xref:System.Messaging.MessageQueueCriteria.CreatedBefore%2A> dos limites de um intervalo de tempo para a criação das filas. Se você definir apenas <xref:System.Messaging.MessageQueueCriteria.CreatedAfter%2A>, não há nenhum limite superior na data.  
  
 Se você tentar definir <xref:System.Messaging.MessageQueueCriteria.CreatedAfter%2A> para posterior <xref:System.DateTime> valor que <xref:System.Messaging.MessageQueueCriteria.CreatedBefore%2A>, <xref:System.Messaging.MessageQueueCriteria.CreatedBefore%2A> é redefinido para o mesmo valor (novo) como <xref:System.Messaging.MessageQueueCriteria.CreatedAfter%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The application did not set the <see cref="P:System.Messaging.MessageQueueCriteria.CreatedAfter" /> property before reading it.</exception>
        <altmember cref="P:System.Messaging.MessageQueueCriteria.CreatedBefore" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="P:System.Messaging.MessageQueue.CreateTime" />
      </Docs>
    </Member>
    <Member MemberName="CreatedBefore">
      <MemberSignature Language="C#" Value="public DateTime CreatedBefore { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreatedBefore" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueueCriteria.CreatedBefore" />
      <MemberSignature Language="VB.NET" Value="Public Property CreatedBefore As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime CreatedBefore { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.CreatedBefore : DateTime with get, set" Usage="System.Messaging.MessageQueueCriteria.CreatedBefore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the upper boundary of the queue creation date and time by which to filter queues on the network.</summary>
        <value>Um <see cref="T:System.DateTime" /> que especifica o limite superior para a data e hora de uma fila.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.MessageQueueCriteria> propriedades são combinadas usando uma lógica `AND`, para definir ambos <xref:System.Messaging.MessageQueueCriteria.CreatedAfter%2A> e <xref:System.Messaging.MessageQueueCriteria.CreatedBefore%2A> dos limites de um intervalo de tempo para a criação das filas. Se você definir apenas <xref:System.Messaging.MessageQueueCriteria.CreatedBefore%2A>, não há nenhum limite inferior na data.  
  
 Se você tentar definir <xref:System.Messaging.MessageQueueCriteria.CreatedBefore%2A> para um anterior <xref:System.DateTime> valor que <xref:System.Messaging.MessageQueueCriteria.CreatedAfter%2A>, <xref:System.Messaging.MessageQueueCriteria.CreatedAfter%2A> é redefinido para o mesmo valor (novo) como <xref:System.Messaging.MessageQueueCriteria.CreatedBefore%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The application did not set the <see cref="P:System.Messaging.MessageQueueCriteria.CreatedBefore" /> property before reading it.</exception>
        <altmember cref="P:System.Messaging.MessageQueueCriteria.CreatedAfter" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="P:System.Messaging.MessageQueue.CreateTime" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueueCriteria.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.MessageQueueCriteria.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the label by which to filter queues in the network.</summary>
        <value>Rótulo das filas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rótulo de uma fila de mensagens é uma descrição definida pelo aplicativo da fila. Ele não tem nenhum significado intrínseco para enfileiramento de mensagens.  
  
 Se você estiver filtrando somente por rótulo ao pesquisar as filas na rede, você pode usar o método <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%2A>, que é projetado especificamente para essa finalidade. Se você estiver procurando por vários critérios que incluem o rótulo, defina <xref:System.Messaging.MessageQueueCriteria.Label%2A> propriedade e passar o parâmetro em <xref:System.Messaging.MessageQueue.GetPublicQueues%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The application did not set the <see cref="P:System.Messaging.MessageQueueCriteria.Label" /> property before reading it.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueueCriteria.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Messaging.MessageQueueCriteria.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the computer name by which to filter queues in the network.</summary>
        <value>O nome do computador em que as filas residem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma fila de mensagens <xref:System.Messaging.MessageQueue.MachineName%2A> reflita o nome do servidor no qual reside a fila, sem precedentes barras invertidas (\\\\).  
  
 Se você estiver filtrando apenas pelo nome do computador ao pesquisar as filas na rede, você pode usar o método <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%2A>, que é projetado especificamente para essa finalidade. Se você estiver procurando por vários critérios que incluem o nome do computador, defina <xref:System.Messaging.MessageQueueCriteria.MachineName%2A> propriedade e passar o parâmetro em <xref:System.Messaging.MessageQueue.GetPublicQueues%2A>.  
  
 Você também pode pesquisar as filas particulares na rede, especificando um nome de computador no <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The application did not set the <see cref="P:System.Messaging.MessageQueueCriteria.MachineName" /> property before reading it.  -or-  The computer name syntax is invalid.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="ModifiedAfter">
      <MemberSignature Language="C#" Value="public DateTime ModifiedAfter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ModifiedAfter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueueCriteria.ModifiedAfter" />
      <MemberSignature Language="VB.NET" Value="Public Property ModifiedAfter As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ModifiedAfter { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.ModifiedAfter : DateTime with get, set" Usage="System.Messaging.MessageQueueCriteria.ModifiedAfter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the lower boundary of the queue modification date and time by which to filter queues on the network.</summary>
        <value>Um <see cref="T:System.DateTime" /> que especifica o limite inferior para a última data de modificação e hora de uma fila.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sinalizador de modificação de uma fila é definido quando você alterar as propriedades de uma fila, mas não quando uma mensagem é lida ou gravada na fila.  
  
 O <xref:System.Messaging.MessageQueueCriteria> propriedades são combinadas usando uma lógica `AND`, para definir ambos <xref:System.Messaging.MessageQueueCriteria.ModifiedAfter%2A> e <xref:System.Messaging.MessageQueueCriteria.ModifiedBefore%2A> dos limites de um intervalo de tempo da última modificação das filas. Se você definir apenas <xref:System.Messaging.MessageQueueCriteria.ModifiedAfter%2A>, não há nenhum limite superior na data.  
  
 Se você tentar definir <xref:System.Messaging.MessageQueueCriteria.ModifiedAfter%2A> para posterior <xref:System.DateTime> valor que <xref:System.Messaging.MessageQueueCriteria.ModifiedBefore%2A>, <xref:System.Messaging.MessageQueueCriteria.ModifiedBefore%2A> é redefinido para o mesmo valor (novo) como <xref:System.Messaging.MessageQueueCriteria.ModifiedAfter%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The application did not set the <see cref="P:System.Messaging.MessageQueueCriteria.ModifiedAfter" /> property before reading it.</exception>
        <altmember cref="P:System.Messaging.MessageQueueCriteria.ModifiedBefore" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="P:System.Messaging.MessageQueue.LastModifyTime" />
      </Docs>
    </Member>
    <Member MemberName="ModifiedBefore">
      <MemberSignature Language="C#" Value="public DateTime ModifiedBefore { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ModifiedBefore" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueueCriteria.ModifiedBefore" />
      <MemberSignature Language="VB.NET" Value="Public Property ModifiedBefore As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ModifiedBefore { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.ModifiedBefore : DateTime with get, set" Usage="System.Messaging.MessageQueueCriteria.ModifiedBefore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the upper boundary of the queue modification date and time by which to filter queues on the network.</summary>
        <value>Um <see cref="T:System.DateTime" /> que especifica o limite superior para a última data de modificação e hora de uma fila.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sinalizador de modificação de uma fila é definido quando você alterar as propriedades de uma fila, mas não quando uma mensagem é lida ou gravada na fila.  
  
 O <xref:System.Messaging.MessageQueueCriteria> propriedades são combinadas usando uma lógica `AND`, para definir ambos <xref:System.Messaging.MessageQueueCriteria.ModifiedBefore%2A> e <xref:System.Messaging.MessageQueueCriteria.ModifiedAfter%2A> dos limites de um intervalo de tempo da última modificação das filas. Se você definir apenas <xref:System.Messaging.MessageQueueCriteria.ModifiedBefore%2A>, não há nenhum limite inferior na data.  
  
 Se você tentar definir <xref:System.Messaging.MessageQueueCriteria.ModifiedBefore%2A> para um anterior <xref:System.DateTime> valor que <xref:System.Messaging.MessageQueueCriteria.ModifiedAfter%2A>, <xref:System.Messaging.MessageQueueCriteria.ModifiedAfter%2A> é redefinido para o mesmo valor (novo) como <xref:System.Messaging.MessageQueueCriteria.ModifiedBefore%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The application did not set the <see cref="P:System.Messaging.MessageQueueCriteria.ModifiedBefore" /> property before reading it.</exception>
        <altmember cref="P:System.Messaging.MessageQueueCriteria.ModifiedAfter" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="P:System.Messaging.MessageQueue.LastModifyTime" />
      </Docs>
    </Member>
  </Members>
</Type>