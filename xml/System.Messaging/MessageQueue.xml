<Type Name="MessageQueue" FullName="System.Messaging.MessageQueue">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8a3b48da9992b9aeff6762ac46f7ab9eadbaffe5" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36555528" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MessageQueue : System.ComponentModel.Component, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueue" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageQueue&#xA;Inherits Component&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageQueue : System::ComponentModel::Component, System::Collections::IEnumerable" />
  <TypeSignature Language="F#" Value="type MessageQueue = class&#xA;    inherit Component&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("ReceiveCompleted")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides access to a queue on a Message Queuing server.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tecnologia de enfileiramento de mensagens permite que os aplicativos executados em momentos diferentes para se comunicar por redes heterogêneas e sistemas podem estar temporariamente offline. Aplicativos enviam, receber, ou inspecionar (ler sem remover) mensagens das filas. O Message Queuing é um componente opcional do [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] e Windows NT e deve ser instalado separadamente.  
  
 O <xref:System.Messaging.MessageQueue> classe é um wrapper em torno de enfileiramento de mensagens. Há várias versões do enfileiramento de mensagens e usando o <xref:System.Messaging.MessageQueue> classe pode resultar em comportamento um pouco diferente, dependendo do sistema operacional você está usando. Para obter informações sobre os recursos específicos de cada versão do enfileiramento de mensagens, consulte o tópico "O que há de novo no serviço de enfileiramento" no SDK da plataforma no MSDN.  
  
 O <xref:System.Messaging.MessageQueue> classe fornece uma referência a uma fila do serviço de enfileiramento de mensagens. Você pode especificar um caminho no <xref:System.Messaging.MessageQueue.%23ctor%2A> construtor para se conectar a um recurso existente, ou você pode criar uma nova fila no servidor. Antes de chamar <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, ou <xref:System.Messaging.MessageQueue.Receive%2A>, você deve associar a nova instância do <xref:System.Messaging.MessageQueue> classe com uma fila existente. Nesse ponto, você pode manipular as propriedades de fila como <xref:System.Messaging.MessageQueue.Category%2A> e <xref:System.Messaging.MessageQueue.Label%2A>.  
  
 <xref:System.Messaging.MessageQueue> dá suporte a dois tipos de recuperação de mensagens: síncronas e assíncronas. Métodos síncronos, <xref:System.Messaging.MessageQueue.Peek%2A> e <xref:System.Messaging.MessageQueue.Receive%2A>, fazer com que o thread de processo de um intervalo de tempo especificado para uma nova mensagem chegar na fila de espera. Os métodos assíncronos, <xref:System.Messaging.MessageQueue.BeginPeek%2A> e <xref:System.Messaging.MessageQueue.BeginReceive%2A>, permitir que as tarefas do aplicativo principal continuar em um thread separado, até que uma mensagem chega na fila. Esses métodos funcionam com objetos de retorno de chamada e do estado para transmitir informações entre threads.  
  
 Quando você cria uma nova instância do <xref:System.Messaging.MessageQueue> classe, você não está criando uma nova fila do serviço de enfileiramento de mensagens. Em vez disso, você pode usar o <xref:System.Messaging.MessageQueue.Create%28System.String%29>, <xref:System.Messaging.MessageQueue.Delete%28System.String%29>, e <xref:System.Messaging.MessageQueue.Purge%2A> métodos para gerenciar as filas no servidor.  
  
 Ao contrário de <xref:System.Messaging.MessageQueue.Purge%2A>, <xref:System.Messaging.MessageQueue.Create%28System.String%29> e <xref:System.Messaging.MessageQueue.Delete%28System.String%29> são `static` membros, portanto você pode chamá-las sem criar uma nova instância do <xref:System.Messaging.MessageQueue> classe.  
  
 Você pode definir o <xref:System.Messaging.MessageQueue> do objeto <xref:System.Messaging.MessageQueue.Path%2A> propriedade com um dos três nomes: o nome amigável, o <xref:System.Messaging.MessageQueue.FormatName%2A>, ou o <xref:System.Messaging.MessageQueue.Label%2A>. O nome amigável, que é definido como a fila <xref:System.Messaging.MessageQueue.MachineName%2A> e <xref:System.Messaging.MessageQueue.QueueName%2A> propriedades, é <xref:System.Messaging.MessageQueue.MachineName%2A> \\ <xref:System.Messaging.MessageQueue.QueueName%2A> para uma fila pública, e <xref:System.Messaging.MessageQueue.MachineName%2A> \\ `Private$` \\ <xref:System.Messaging.MessageQueue.QueueName%2A> para uma fila particular. O <xref:System.Messaging.MessageQueue.FormatName%2A> propriedade permite o acesso offline para filas de mensagens. Por fim, você pode usar a fila <xref:System.Messaging.MessageQueue.Label%2A> propriedade para definir a fila <xref:System.Messaging.MessageQueue.Path%2A>.  
  
 Para obter uma lista de valores de propriedade inicial para uma instância do <xref:System.Messaging.MessageQueue>, consulte o <xref:System.Messaging.MessageQueue.%23ctor%2A> construtor.  
  
   
  
## Examples  
 O exemplo de código a seguir cria novos <xref:System.Messaging.MessageQueue> objetos usando vários tipos de sintaxe de nome de caminho. Em cada caso, ele envia uma mensagem para a fila cujo caminho é definido no construtor.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 O exemplo de código a seguir envia uma mensagem para uma fila e recebe uma mensagem de uma fila, usando uma classe específica de aplicativo chamada `Order`.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Somente o <see cref="M:System.Messaging.MessageQueue.GetAllMessages" /> método é thread-safe.</threadsafe>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="T:System.Messaging.MessageQueueException" />
    <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
    <altmember cref="P:System.Messaging.MessageQueue.Path" />
    <altmember cref="P:System.Messaging.MessageQueue.Label" />
    <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
    <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
    <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Messaging.MessageQueue" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Messaging.MessageQueue" /> class. After the default constructor initializes the new instance, you must set the instance's <see cref="P:System.Messaging.MessageQueue.Path" /> property before you can use the instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para criar uma nova instância do <xref:System.Messaging.MessageQueue> classe imediatamente não estiver associado a uma fila no servidor de enfileiramento de mensagens. Antes de usar essa instância, você deve ser conectar a uma fila existente do serviço de enfileiramento de mensagens, definindo o <xref:System.Messaging.MessageQueue.Path%2A> propriedade. Como alternativa, você pode definir o <xref:System.Messaging.MessageQueue> referência para o <xref:System.Messaging.MessageQueue.Create%28System.String%29> valor de retorno do método, criando uma nova fila do serviço de enfileiramento de mensagens.  
  
 O <xref:System.Messaging.MessageQueue.%23ctor%2A> construtor cria uma nova instância do <xref:System.Messaging.MessageQueue> classe; ele não cria uma nova fila do serviço de enfileiramento de mensagens.  
  
 A tabela a seguir mostra os valores de propriedade inicial para uma instância do <xref:System.Messaging.MessageQueue>.  
  
|Propriedade|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Os valores definidos pelo construtor padrão da <xref:System.Messaging.DefaultPropertiesToSend> classe.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Os valores definidos pelo construtor padrão da <xref:System.Messaging.MessagePropertyFilter> classe. Todos os valores de filtro estão definidos como `true`.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
  
   
  
## Examples  
 O exemplo de código a seguir cria um novo <xref:System.Messaging.MessageQueue>.  
  
 [!code-csharp[MessageQueue#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The location of the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Messaging.MessageQueue" /> class that references the Message Queuing queue at the specified path.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga quando você deseja associar o novo <xref:System.Messaging.MessageQueue> instância para uma determinada fila Enfileiramento de mensagens, para o qual você sabe o caminho, nome de formato ou rótulo. Se você deseja conceder acesso exclusivo para o primeiro aplicativo que faz referência a fila, você deve definir o <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> propriedade `true` ou use o construtor que passa um parâmetro de restrição de acesso de leitura.  
  
 O <xref:System.Messaging.MessageQueue.%23ctor%2A> construtor cria uma nova instância do <xref:System.Messaging.MessageQueue> classe; ele não cria uma nova fila do serviço de enfileiramento de mensagens. Para criar uma nova fila no enfileiramento de mensagens, use <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 A sintaxe do `path` parâmetro depende do tipo de fila-referências, conforme mostrado na tabela a seguir.  
  
|Tipo de fila|Sintaxe|  
|----------------|------------|  
|Fila pública|`MachineName`\\`QueueName`|  
|Fila particular|`MachineName`\\`Private$`\\`QueueName`|  
|Fila de diário|`MachineName`\\`QueueName`\\`Journal$`|  
|Fila de diário do computador|`MachineName`\\`Journal$`|  
|Fila de mensagens mortas da máquina|`MachineName`\\`Deadletter$`|  
|Fila de mensagens mortas transacional do computador|`MachineName`\\`XactDeadletter$`|  
  
 Como alternativa, você pode usar o <xref:System.Messaging.MessageQueue.FormatName%2A> ou <xref:System.Messaging.MessageQueue.Label%2A> para descrever o caminho da fila, conforme mostrado na tabela a seguir.  
  
|Referência|Sintaxe|Exemplo|  
|---------------|------------|-------------|  
|Nome do formato|`FormatName:` [ *nome do formato* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Rotular|`Label:` [ *label* ]|`Label:` TheLabel|  
  
 Para trabalhar offline, você deve usar a sintaxe de nome de formato, não a sintaxe do nome do caminho para o construtor. Caso contrário, uma exceção é lançada porque o controlador de domínio primário não está disponível para resolver o caminho para o nome de formato.  
  
 A tabela a seguir mostra os valores de propriedade inicial para uma instância do <xref:System.Messaging.MessageQueue>. Esses valores se baseiam nas propriedades da fila do serviço de enfileiramento de mensagens com o caminho especificado pelo `path` parâmetro.  
  
|Propriedade|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Os valores definidos pelo construtor padrão da <xref:System.Messaging.DefaultPropertiesToSend> classe.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, se a configuração de nível de privacidade do enfileiramento de mensagens da fila é "Body"; Caso contrário, `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|O valor da propriedade de nome de computador do enfileiramento de mensagens da fila.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Os valores definidos pelo construtor padrão da <xref:System.Messaging.MessagePropertyFilter> classe.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, se não for definido pelo construtor.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, se não for definido pelo construtor.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, se a configuração de diário do objeto enfileiramento de mensagens está habilitada; Caso contrário, `false`.|  
  
   
  
## Examples  
 O exemplo de código a seguir cria novos <xref:System.Messaging.MessageQueue> objetos usando vários tipos de sintaxe de nome de caminho. Em cada caso, ele envia uma mensagem para a fila cujo caminho é definido no construtor.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Messaging.MessageQueue.Path" /> property is not valid, possibly because it has not been set.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">The location of the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />, which can be "." for the local computer.</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> to grant exclusive read access to the first application that accesses the queue; otherwise, <see langword="false" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Messaging.MessageQueue" /> class that references the Message Queuing queue at the specified path and with the specified read-access restriction.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga quando você deseja associar o novo <xref:System.Messaging.MessageQueue> para uma determinada fila Enfileiramento de mensagens, para o qual você sabe o caminho, nome de formato ou rótulo. Se você deseja conceder acesso exclusivo para o primeiro aplicativo que faz referência a fila, defina o `sharedModeDenyReceive` parâmetro `true`. Caso contrário, defina `sharedModeDenyReceive` para `false` ou use o construtor que tem apenas um `path` parâmetro.  
  
 Configuração `sharedModeDenyReceive` para `true` afeta todos os objetos que acessam o enfileiramento de mensagens, incluindo outros aplicativos. Os efeitos do parâmetro não estão restritos a esse aplicativo.  
  
 O <xref:System.Messaging.MessageQueue.%23ctor%2A> construtor cria uma nova instância do <xref:System.Messaging.MessageQueue> classe; ele não cria uma nova fila do serviço de enfileiramento de mensagens. Para criar uma nova fila no enfileiramento de mensagens, use <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 A sintaxe do `path` parâmetro depende do tipo de fila.  
  
|Tipo de fila|Sintaxe|  
|----------------|------------|  
|Fila pública|`MachineName`\\`QueueName`|  
|Fila particular|`MachineName`\\`Private$`\\`QueueName`|  
|Fila de diário|`MachineName`\\`QueueName`\\`Journal$`|  
|Fila de diário do computador|`MachineName`\\`Journal$`|  
|Fila de mensagens mortas da máquina|`MachineName`\\`Deadletter$`|  
|Fila de mensagens mortas transacional do computador|`MachineName`\\`XactDeadletter$`|  
  
 Como alternativa, você pode usar o nome de formato ou rótulo de uma fila do serviço de enfileiramento de mensagens para descrever o caminho da fila.  
  
|Referência|Sintaxe|Exemplo|  
|---------------|------------|-------------|  
|Nome do formato|`FormatName:` [ *nome do formato* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Rotular|`Label:` [ *label* ]|`Label:` TheLabel|  
  
 Para trabalhar offline, você deve usar a sintaxe de nome de formato, em vez da sintaxe de nome amigável. Caso contrário, uma exceção é lançada porque o controlador de domínio primário (no qual o Active Directory reside) não está disponível para resolver o caminho para o nome de formato.  
  
 Se um <xref:System.Messaging.MessageQueue> abre uma fila com o `sharedModeDenyReceive` parâmetro definido como `true`, qualquer <xref:System.Messaging.MessageQueue> que gera de tenta ler da fila subsequentemente uma <xref:System.Messaging.MessageQueueException> devido a uma violação de compartilhamento. Um <xref:System.Messaging.MessageQueueException> também é gerada se um <xref:System.Messaging.MessageQueue> tenta acessar a fila em modo exclusivo, enquanto outras <xref:System.Messaging.MessageQueue> já tem acesso de não-exclusivo para a fila.  
  
 A tabela a seguir mostra os valores de propriedade inicial para uma instância do <xref:System.Messaging.MessageQueue>. Esses valores se baseiam nas propriedades da fila de enfileiramento de mensagens, com o caminho especificado pelo `path` parâmetro.  
  
|Propriedade|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`.|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0.|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>.|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Os valores definidos pelo construtor padrão da <xref:System.Messaging.DefaultPropertiesToSend> classe.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, se a configuração de nível de privacidade do enfileiramento de mensagens da fila é "Body"; Caso contrário, `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>.|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>.|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|O valor da propriedade de nome de computador do enfileiramento de mensagens da fila.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Os valores definidos pelo construtor padrão da <xref:System.Messaging.MessagePropertyFilter> classe.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, se não for definido pelo construtor.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, se não for definido pelo construtor.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|O valor de `sharedModeDenyReceive` parâmetro.|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, se a configuração de diário do objeto enfileiramento de mensagens está habilitada; Caso contrário, `false`.|  
  
   
  
## Examples  
 O exemplo de código a seguir cria um novo <xref:System.Messaging.MessageQueue> com acesso exclusivo, define seu caminho e envia uma mensagem à fila.  
  
 [!code-cpp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CPP/mqctor_denysharedreceive.cpp#1)]
 [!code-csharp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CS/mqctor_denysharedreceive.cs#1)]
 [!code-vb[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/VB/mqctor_denysharedreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Messaging.MessageQueue.Path" /> property is not valid, possibly because it has not been set.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">The location of the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />, which can be "." for the local computer.</param>
        <param name="accessMode">One of the <see cref="T:System.Messaging.QueueAccessMode" /> values.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Messaging.MessageQueue" /> class.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">The location of the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />, which can be "." for the local computer.</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> to grant exclusive read access to the first application that accesses the queue; otherwise, <see langword="false" />.</param>
        <param name="enableCache">
          <see langword="true" /> to create and use a connection cache; otherwise, <see langword="false" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Messaging.MessageQueue" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir cria um novo <xref:System.Messaging.MessageQueue> com acesso de leitura exclusivo e conexão em cache habilitada.  
  
 [!code-cpp[MessageQueue4#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue4/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue4#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue4/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">The location of the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />, which can be "." for the local computer.</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> to grant exclusive read access to the first application that accesses the queue; otherwise, <see langword="false" />.</param>
        <param name="enableCache">
          <see langword="true" /> to create and use a connection cache; otherwise, <see langword="false" />.</param>
        <param name="accessMode">One of the <see cref="T:System.Messaging.QueueAccessMode" /> values.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Messaging.MessageQueue" /> class.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessMode">
      <MemberSignature Language="C#" Value="public System.Messaging.QueueAccessMode AccessMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.QueueAccessMode AccessMode" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.AccessMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessMode As QueueAccessMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::QueueAccessMode AccessMode { System::Messaging::QueueAccessMode get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessMode : System.Messaging.QueueAccessMode" Usage="System.Messaging.MessageQueue.AccessMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.QueueAccessMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates the access mode for the queue.</summary>
        <value>Um dos valores de <see cref="T:System.Messaging.QueueAccessMode" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O modo de acesso padrão para uma fila é `QueueAccessMode.SendAndReceive`, a menos que você especifique o contrário ao chamar o construtor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public bool Authenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Authenticate" />
      <MemberSignature Language="VB.NET" Value="Public Property Authenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Authenticate : bool with get, set" Usage="System.Messaging.MessageQueue.Authenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Authenticate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the queue accepts only authenticated messages.</summary>
        <value>
          <see langword="true" /> se a fila aceita apenas mensagens autenticadas; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Autenticação de mensagem fornece uma maneira para garantir a integridade da mensagem e verificar que enviou a mensagem. Para solicitar a autenticação, o aplicativo de envio define o nível de autenticação da mensagem.  
  
 Quando você define <xref:System.Messaging.MessageQueue.Authenticate%2A> para `true`, você está restringindo acesso à fila no servidor, não apenas a esta <xref:System.Messaging.MessageQueue> instância. Todos os clientes que trabalham com a mesma fila do serviço de enfileiramento de mensagens serão afetados.  
  
 Uma fila que aceita apenas mensagens autenticadas rejeitará uma mensagem não autenticada. Para solicitar a notificação de rejeição de mensagem, um aplicativo de envio pode definir o <xref:System.Messaging.Message.AcknowledgeType%2A> propriedade da mensagem. Como não existe nenhuma outra indicação de rejeição de mensagem, o aplicativo de envio pode perder a mensagem, a menos que você solicita que ele seja enviada para a fila de mensagens mortas.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.Authenticate%2A> propriedade.  
  
 [!code-csharp[MessageQueue#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public short BasePriority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public Property BasePriority As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short BasePriority { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int16 with get, set" Usage="System.Messaging.MessageQueue.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_BasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the base priority Message Queuing uses to route a public queue's messages over the network.</summary>
        <value>A prioridade base única para todas as mensagens enviadas à fila (pública). O padrão é zero (0).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prioridade básica de uma fila de mensagens Especifica como uma mensagem voltados à fila é tratada como trafegam através da rede. Você pode definir o <xref:System.Messaging.MessageQueue.BasePriority%2A> propriedade confere uma prioridade maior ou menor para todas as mensagens enviadas para a fila especificada daqueles enviados para outras filas. A definição dessa propriedade modifica o enfileiramento de mensagens. Portanto, qualquer outro <xref:System.Messaging.MessageQueue> instâncias são afetadas pela alteração.  
  
 Uma fila de mensagens <xref:System.Messaging.MessageQueue.BasePriority%2A> não está relacionado ao <xref:System.Messaging.Message.Priority%2A> propriedade de uma mensagem, que especifica a ordem na qual uma mensagem de entrada é colocada na fila.  
  
 <xref:System.Messaging.MessageQueue.BasePriority%2A> aplica-se somente para as filas públicas cujo caminho especificado usando o nome de formato. A prioridade base de uma fila particular é sempre zero (0).  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.BasePriority%2A> propriedade.  
  
 [!code-csharp[MessageQueue#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The base priority was set to an invalid value.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginPeek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <summary>Initiates an asynchronous peek operation by telling Message Queuing to begin peeking a message and notify the event handler when finished.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek();" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : unit -&gt; IAsyncResult" Usage="messageQueue.BeginPeek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initiates an asynchronous peek operation that has no time-out. The operation is not complete until a message becomes available in the queue.</summary>
        <returns>The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O processamento assíncrono, você usa <xref:System.Messaging.MessageQueue.BeginPeek%2A> para gerar o <xref:System.Messaging.MessageQueue.PeekCompleted> quando uma mensagem se torna disponível na fila de eventos.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> também é gerado se já existir uma mensagem na fila.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginPeek%2A>, criar um manipulador de eventos que processa os resultados da operação assíncrona e associá-lo com o delegado do evento. <xref:System.Messaging.MessageQueue.BeginPeek%2A> inicia uma operação assíncrona peek; o <xref:System.Messaging.MessageQueue> é notificado por meio do aumento do <xref:System.Messaging.MessageQueue.PeekCompleted> evento, quando uma mensagem chega na fila. O <xref:System.Messaging.MessageQueue> pode acessar a mensagem chamando <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> ou recuperando o resultado usando o <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 O <xref:System.Messaging.MessageQueue.BeginPeek%2A> método retorna imediatamente, mas não é possível concluir a operação assíncrona até que o manipulador de eventos é chamado.  
  
 Porque <xref:System.Messaging.MessageQueue.BeginPeek%2A> é assíncrona, você pode chamá-lo para inspecionar a fila sem bloquear o thread atual de execução. Para inspecionar sincronamente a fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método.  
  
 Quando uma operação assíncrona for concluída, você pode chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente no manipulador de eventos para manter receber notificações.  
  
 O <xref:System.IAsyncResult> que <xref:System.Messaging.MessageQueue.BeginPeek%2A> retorna identifica a operação assíncrona que o método foi iniciado. Você pode usar isso <xref:System.IAsyncResult> durante o tempo de vida da operação, embora você geralmente não usá-lo até <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> é chamado. No entanto, se você iniciar várias operações assíncronas, você pode colocar seus <xref:System.IAsyncResult> valores em uma matriz e especificar se deseja esperar que todas as operações ou qualquer operação seja concluída. Nesse caso, você usa o <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriedade o <xref:System.IAsyncResult> para identificar a operação concluída.  
  
 Se <xref:System.Messaging.MessageQueue.CanRead%2A> é `false`, o evento de conclusão é gerado, mas será lançada uma exceção ao chamar <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir cria um manipulador de eventos chamado `MyPeekCompleted`, anexa-o para o <xref:System.Messaging.MessageQueue.PeekCompleted> representante do manipulador de eventos e chamadas <xref:System.Messaging.MessageQueue.BeginPeek%2A> para iniciar uma operação assíncrona inspecionar na fila que está localizada no caminho ". \myQueue". Quando um <xref:System.Messaging.MessageQueue.PeekCompleted> é gerado, o exemplo exibe a mensagem e grava seu corpo para a tela. O exemplo, em seguida, chama <xref:System.Messaging.MessageQueue.BeginPeek%2A> novamente para iniciar uma nova operação assíncrona de pico.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginPeek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</param>
        <summary>Initiates an asynchronous peek operation that has a specified time-out. The operation is not complete until either a message becomes available in the queue or the time-out occurs.</summary>
        <returns>The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O processamento assíncrono, você usa <xref:System.Messaging.MessageQueue.BeginPeek%2A> para gerar o <xref:System.Messaging.MessageQueue.PeekCompleted> eventos quando uma mensagem se torna disponível na fila ou quando o intervalo de tempo especificado tiver expirado.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> também é gerado se já existir uma mensagem na fila.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginPeek%2A>, criar um manipulador de eventos que processa os resultados da operação assíncrona e associá-lo com o delegado do evento. <xref:System.Messaging.MessageQueue.BeginPeek%2A> inicia uma operação assíncrona peek; o <xref:System.Messaging.MessageQueue> é notificado por meio do aumento do <xref:System.Messaging.MessageQueue.PeekCompleted> evento, quando uma mensagem chega na fila. O <xref:System.Messaging.MessageQueue> pode acessar a mensagem chamando <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> ou recuperando o resultado usando o <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 O <xref:System.Messaging.MessageQueue.BeginPeek%2A> método retorna imediatamente, mas não é possível concluir a operação assíncrona até que o manipulador de eventos é chamado.  
  
 Porque <xref:System.Messaging.MessageQueue.BeginPeek%2A> é assíncrona, você pode chamá-lo para inspecionar a fila sem bloquear o thread atual de execução. Para inspecionar sincronamente a fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método.  
  
 Quando uma operação assíncrona for concluída, você pode chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente no manipulador de eventos para manter receber notificações.  
  
 O <xref:System.IAsyncResult> que <xref:System.Messaging.MessageQueue.BeginPeek%2A> retorna identifica a operação assíncrona que o método foi iniciado. Você pode usar isso <xref:System.IAsyncResult> durante o tempo de vida da operação, embora você geralmente não usá-lo até <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> é chamado. No entanto, se você iniciar várias operações assíncronas, você pode colocar seus <xref:System.IAsyncResult> valores em uma matriz e especificar se deseja esperar que todas as operações ou qualquer operação seja concluída. Nesse caso, você usa o <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriedade o <xref:System.IAsyncResult> para identificar a operação concluída.  
  
 Essa sobrecarga Especifica um tempo limite. Se o intervalo especificado pelo `timeout` parâmetro expira, esse componente gera o <xref:System.Messaging.MessageQueue.PeekCompleted> evento. Como não existe nenhuma mensagem, uma chamada subsequente para <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> lançará uma exceção.  
  
 Se <xref:System.Messaging.MessageQueue.CanRead%2A> é `false`, o evento de conclusão é gerado, mas será lançada uma exceção ao chamar <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma operação assíncrona de pico, usando o caminho da fila ". \myQueue". Ele cria um manipulador de eventos, `MyPeekCompleted`e anexa-o para o <xref:System.Messaging.MessageQueue.PeekCompleted> representante do manipulador de eventos. <xref:System.Messaging.MessageQueue.BeginPeek%2A> é chamado com um tempo limite de um minuto para iniciar a operação assíncrona de pico. Quando um <xref:System.Messaging.MessageQueue.PeekCompleted> é gerado ou o tempo limite expirar, a mensagem é recuperada, se houver, e seu corpo é gravado para a tela. Em seguida, <xref:System.Messaging.MessageQueue.BeginPeek%2A> é chamado novamente para iniciar uma nova operação de pico assíncrona com o tempo limite da mesma.  
  
 [!code-cpp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CPP/mqbeginpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CS/mqbeginpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/VB/mqbeginpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</param>
        <param name="stateObject">A state object, specified by the application, that contains information associated with the asynchronous operation.</param>
        <summary>Initiates an asynchronous peek operation that has a specified time-out and a specified state object, which provides associated information throughout the operation's lifetime. The operation is not complete until either a message becomes available in the queue or the time-out occurs.</summary>
        <returns>The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O processamento assíncrono, você usa <xref:System.Messaging.MessageQueue.BeginPeek%2A> para gerar o <xref:System.Messaging.MessageQueue.PeekCompleted> eventos quando uma mensagem se torna disponível na fila ou quando o intervalo de tempo especificado tiver expirado.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> também é gerado se já existir uma mensagem na fila.  
  
 Use essa sobrecarga para associar informações com a operação que será preservada ao longo do tempo de vida da operação. O manipulador de eventos pode acessar essas informações examinando o <xref:System.IAsyncResult.AsyncState%2A> propriedade o <xref:System.IAsyncResult> que está associado com a operação.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginPeek%2A>, criar um manipulador de eventos que processa os resultados da operação assíncrona e associá-lo com o delegado do evento. <xref:System.Messaging.MessageQueue.BeginPeek%2A> inicia uma operação assíncrona peek; o <xref:System.Messaging.MessageQueue> é notificado por meio do aumento do <xref:System.Messaging.MessageQueue.PeekCompleted> evento, quando uma mensagem chega na fila. O <xref:System.Messaging.MessageQueue> pode acessar a mensagem chamando <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> ou recuperando o resultado usando o <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 O <xref:System.Messaging.MessageQueue.BeginPeek%2A> método retorna imediatamente, mas não é possível concluir a operação assíncrona até que o manipulador de eventos é chamado.  
  
 Porque <xref:System.Messaging.MessageQueue.BeginPeek%2A> é assíncrona, você pode chamá-lo para inspecionar a fila sem bloquear o thread atual de execução. Para inspecionar sincronamente a fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método.  
  
 Quando uma operação assíncrona for concluída, você pode chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente no manipulador de eventos para manter receber notificações.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Retorna um <xref:System.IAsyncResult> que identifica a operação assíncrona que o método foi iniciado. Você pode usar isso <xref:System.IAsyncResult> durante o tempo de vida da operação, embora você geralmente não usá-lo até <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> é chamado. No entanto, se você iniciar várias operações assíncronas, você pode colocar seus <xref:System.IAsyncResult> valores em uma matriz e especificar se deseja esperar que todas as operações ou qualquer operação seja concluída. Nesse caso, você usa o <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriedade o <xref:System.IAsyncResult> para identificar a operação concluída.  
  
 Essa sobrecarga Especifica um tempo limite e um objeto de estado. Se o intervalo especificado pelo `timeout` parâmetro expira, esse componente gera o <xref:System.Messaging.MessageQueue.PeekCompleted> evento. Como não existe nenhuma mensagem, uma chamada subsequente para <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> lançará uma exceção.  
  
 O objeto de estado associa informações de estado com a operação. Por exemplo, se você chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> várias vezes para iniciar várias operações, você pode identificar cada operação por meio de um objeto de estado separado que você definir. Para ilustrar esse cenário, consulte a seção de exemplo.  
  
 Você também pode usar o objeto de estado para transmitir informações entre os threads de processo. Se um thread é iniciado, mas o retorno de chamada está em um thread diferente em um cenário assíncrono, o objeto de estado é empacotado e passado novamente juntamente com informações do evento.  
  
 Se <xref:System.Messaging.MessageQueue.CanRead%2A> é `false`, o evento de conclusão é gerado, mas será lançada uma exceção ao chamar <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma operação assíncrona de pico, usando o caminho da fila ". \myQueue". Ele cria um manipulador de eventos, `MyPeekCompleted`e anexa-o para o <xref:System.Messaging.MessageQueue.PeekCompleted> representante do manipulador de eventos. <xref:System.Messaging.MessageQueue.BeginPeek%2A> é chamado, com um tempo limite de um minuto. Cada chamada para <xref:System.Messaging.MessageQueue.BeginPeek%2A> tem um inteiro exclusivo associado que identifica a operação específica. Quando um <xref:System.Messaging.MessageQueue.PeekCompleted> é gerado ou o tempo limite expirou, a mensagem, se houver, foi recuperada e seu corpo e o identificador de inteiro de operação específico são gravados na tela. Em seguida, <xref:System.Messaging.MessageQueue.BeginPeek%2A> é chamado novamente para iniciar uma nova operação de pico assíncrona com o mesmo limite e o número inteiro associado da operação acabou de concluir.  
  
 [!code-cpp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CPP/mqbeginpeek_timeoutstateobject.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CS/mqbeginpeek_timeoutstateobject.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/VB/mqbeginpeek_timeoutstateobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</param>
        <param name="stateObject">A state object, specified by the application, that contains information associated with the asynchronous operation.</param>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> that will receive the notification of the asynchronous operation completion.</param>
        <summary>Initiates an asynchronous peek operation that has a specified time-out and a specified state object, which provides associated information throughout the operation's lifetime. This overload receives notification, through a callback, of the identity of the event handler for the operation. The operation is not complete until either a message becomes available in the queue or the time-out occurs.</summary>
        <returns>The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você usa essa sobrecarga, o retorno de chamada especificado no parâmetro de retorno de chamada é invocado diretamente quando uma mensagem se torna disponível na fila ou quando o intervalo de tempo especificado tiver expirado; o <xref:System.Messaging.MessageQueue.PeekCompleted> não é gerado. As outras sobrecargas de <xref:System.Messaging.MessageQueue.BeginPeek%2A> contam com este componente para gerar o <xref:System.Messaging.MessageQueue.PeekCompleted> evento.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> também é gerado se já existir uma mensagem na fila.  
  
 O <xref:System.Messaging.MessageQueue.BeginPeek%2A> método retorna imediatamente, mas não é possível concluir a operação assíncrona até que o manipulador de eventos é chamado.  
  
 Porque <xref:System.Messaging.MessageQueue.BeginPeek%2A> é assíncrona, você pode chamá-lo para inspecionar a fila sem bloquear o thread atual de execução. Para inspecionar sincronamente a fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método.  
  
 Quando uma operação assíncrona for concluída, você pode chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente no manipulador de eventos para manter receber notificações.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Retorna um <xref:System.IAsyncResult> que identifica a operação assíncrona que o método foi iniciado. Você pode usar isso <xref:System.IAsyncResult> durante o tempo de vida da operação, embora você geralmente não usá-lo até <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> é chamado. No entanto, se você iniciar várias operações assíncronas, você pode colocar seus <xref:System.IAsyncResult> valores em uma matriz e especificar se deseja esperar que todas as operações ou qualquer operação seja concluída. Nesse caso, você usa o <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriedade o <xref:System.IAsyncResult> para identificar a operação concluída.  
  
 O objeto de estado associa informações de estado com a operação. Por exemplo, se você chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> várias vezes para iniciar várias operações, você pode identificar cada operação por meio de um objeto de estado separado que você definir.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma operação assíncrona de pico. O envia de exemplo de código uma mensagem para uma fila de mensagens local, em seguida, chama <xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, passando: um valor de tempo limite de dez segundos; um inteiro exclusivo que identifica a mensagem específica; e uma nova instância da <xref:System.AsyncCallback> que identifica o manipulador de eventos, `MyPeekCompleted`. Quando um <xref:System.Messaging.MessageQueue.PeekCompleted> é gerado, o manipulador de eventos exibe a mensagem e grava o corpo da mensagem e o identificador inteiro da mensagem para a tela.  
  
 [!code-cpp[MessageQueueBeginPeek#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginPeek/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginPeek#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginPeek/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, cursor, action, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> that maintains a specific position in the message queue.</param>
        <param name="action">One of the <see cref="T:System.Messaging.PeekAction" /> values. Indicates whether to peek at the current message in the queue, or the next message.</param>
        <param name="state">A state object, specified by the application, that contains information associated with the asynchronous operation.</param>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> that receives the notification of the asynchronous operation completion.</param>
        <summary>Initiates an asynchronous peek operation that has a specified time-out and that uses a specified cursor, a specified peek action, and a specified state object. The state object provides associated information throughout the lifetime of the operation. This overload receives notification, through a callback, of the identity of the event handler for the operation. The operation is not complete until either a message becomes available in the queue or the time-out occurs.</summary>
        <returns>The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você usa essa sobrecarga, o retorno de chamada especificado no parâmetro de retorno de chamada é invocado diretamente quando uma mensagem se torna disponível na fila ou quando o intervalo de tempo especificado tiver expirado. O <xref:System.Messaging.MessageQueue.PeekCompleted> não é gerado. As outras sobrecargas de <xref:System.Messaging.MessageQueue.BeginPeek%2A> contam com este componente para gerar o <xref:System.Messaging.MessageQueue.PeekCompleted> evento.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> também é gerado se já existir uma mensagem na fila.  
  
 O <xref:System.Messaging.MessageQueue.BeginPeek%2A> método retorna imediatamente, mas não é possível concluir a operação assíncrona até que o manipulador de eventos é chamado.  
  
 Porque <xref:System.Messaging.MessageQueue.BeginPeek%2A> é assíncrona, você pode chamá-lo para inspecionar a fila sem bloquear o thread atual de execução. Para inspecionar sincronamente a fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método.  
  
 Quando uma operação assíncrona for concluída, você pode chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente no manipulador de eventos para manter receber notificações.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Retorna um <xref:System.IAsyncResult> que identifica a operação assíncrona iniciada pelo método. Você pode usar isso <xref:System.IAsyncResult> durante o tempo de vida da operação, embora você geralmente não usá-lo até <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> é chamado. No entanto, se você iniciar várias operações assíncronas, você pode colocar seus <xref:System.IAsyncResult> valores em uma matriz e especificar se deseja esperar que todas as operações ou qualquer operação seja concluída. Nesse caso, use o <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriedade o <xref:System.IAsyncResult> para identificar a operação concluída.  
  
 O objeto de estado associa informações de estado com a operação. Por exemplo, se você chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> várias vezes para iniciar várias operações, você pode identificar cada operação por meio de um objeto de estado separado que você definir.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">A value other than <see langword="PeekAction.Current" /> or <see langword="PeekAction.Next" /> was specified for the <paramref name="action" /> parameter.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="cursor" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <summary>Initiates an asynchronous receive operation by telling Message Queuing to begin receiving a message and notify the event handler when finished.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive();" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : unit -&gt; IAsyncResult" Usage="messageQueue.BeginReceive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initiates an asynchronous receive operation that has no time-out. The operation is not complete until a message becomes available in the queue.</summary>
        <returns>The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O processamento assíncrono, você usa <xref:System.Messaging.MessageQueue.BeginReceive%2A> para gerar o <xref:System.Messaging.MessageQueue.ReceiveCompleted> quando uma mensagem foi removida da fila de eventos.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> também é gerado se já existir uma mensagem na fila.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginReceive%2A>, crie um manipulador de eventos que processa os resultados da operação assíncrona e associá-lo com o delegado do evento. <xref:System.Messaging.MessageQueue.BeginReceive%2A> inicia uma assíncrona recebe operação. o <xref:System.Messaging.MessageQueue> é notificado por meio do aumento do <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento, quando uma mensagem chega na fila. O <xref:System.Messaging.MessageQueue> pode acessar a mensagem chamando <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 O <xref:System.Messaging.MessageQueue.BeginReceive%2A> método retorna imediatamente, mas não é possível concluir a operação assíncrona até que o manipulador de eventos é chamado.  
  
 Porque <xref:System.Messaging.MessageQueue.BeginReceive%2A> é assíncrona, você pode chamá-lo para receber uma mensagem da fila sem bloquear o thread atual de execução. Para modo síncrono receber uma mensagem, use o <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Quando uma operação assíncrona for concluída, você pode chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente no manipulador de eventos para manter receber notificações.  
  
 O <xref:System.IAsyncResult> que <xref:System.Messaging.MessageQueue.BeginReceive%2A> retorna identifica a operação assíncrona que o método foi iniciado. Você pode usar isso <xref:System.IAsyncResult> durante o tempo de vida da operação, embora você geralmente não usá-lo até <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> é chamado. No entanto, se você iniciar várias operações assíncronas, você pode colocar seus <xref:System.IAsyncResult> valores em uma matriz e especificar se deseja esperar que todas as operações ou qualquer operação seja concluída. Nesse caso, você usa o <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriedade o <xref:System.IAsyncResult> para identificar a operação concluída.  
  
 Se <xref:System.Messaging.MessageQueue.CanRead%2A> é `false`, o evento de conclusão é gerado, mas será lançada uma exceção ao chamar <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Não use a chamada assíncrona <xref:System.Messaging.MessageQueue.BeginReceive%2A> com transações. Se você quiser executar uma operação assíncrona transacional, chame <xref:System.Messaging.MessageQueue.BeginPeek%2A>e colocar a transação e (síncrono) <xref:System.Messaging.MessageQueue.Receive%2A> método no manipulador de eventos que você criar para a operação de pico. O manipulador de eventos pode conter funcionalidade, como mostra o código c# a seguir.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir encadeia solicitações assíncronas. Ele assume que há uma fila no computador local chamado "myQueue". O `Main` função inicia a operação assíncrona que é manipulada pelo `MyReceiveCompleted` rotina. `MyReceiveCompleted` processa a mensagem atual e inicia um novo assíncrona operação de recebimento.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 O exemplo de código a seguir enfileira solicitações assíncronas. A chamada para <xref:System.Messaging.MessageQueue.BeginReceive%2A> usa o <xref:System.IAsyncResult.AsyncWaitHandle%2A> em seu valor de retorno. O `Main` rotina aguarda até que todas as operações assíncronas sejam concluídas antes de sair.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_wh.cpp#2)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_wh.cs#2)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_wh.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginReceive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</param>
        <summary>Initiates an asynchronous receive operation that has a specified time-out. The operation is not complete until either a message becomes available in the queue or the time-out occurs.</summary>
        <returns>The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O processamento assíncrono, você usa <xref:System.Messaging.MessageQueue.BeginReceive%2A> para gerar o <xref:System.Messaging.MessageQueue.ReceiveCompleted> eventos quando uma mensagem se torna disponível na fila ou quando o intervalo de tempo especificado tiver expirado.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> também é gerado se já existir uma mensagem na fila.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginReceive%2A>, crie um manipulador de eventos que processa os resultados da operação assíncrona e associá-lo com o delegado do evento. <xref:System.Messaging.MessageQueue.BeginReceive%2A> inicia uma assíncrona recebe operação. o <xref:System.Messaging.MessageQueue> é notificado por meio do aumento do <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento, quando uma mensagem chega na fila. O <xref:System.Messaging.MessageQueue> pode acessar a mensagem chamando <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> ou recuperar o resultado usando o <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 O <xref:System.Messaging.MessageQueue.BeginReceive%2A> método retorna imediatamente, mas não é possível concluir a operação assíncrona até que o manipulador de eventos é chamado.  
  
 Porque <xref:System.Messaging.MessageQueue.BeginReceive%2A> é assíncrona, você pode chamá-lo para receber uma mensagem da fila sem bloquear o thread atual de execução. Para modo síncrono receber uma mensagem, use o <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Quando uma operação assíncrona for concluída, você pode chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente no manipulador de eventos para manter receber notificações.  
  
 Se <xref:System.Messaging.MessageQueue.CanRead%2A> é `false`, o evento de conclusão é gerado, mas será lançada uma exceção ao chamar <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 O <xref:System.IAsyncResult> que <xref:System.Messaging.MessageQueue.BeginReceive%2A> retorna identifica a operação assíncrona que o método foi iniciado. Você pode usar isso <xref:System.IAsyncResult> durante o tempo de vida da operação, embora você geralmente não usá-lo até <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> é chamado. No entanto, se você iniciar várias operações assíncronas, você pode colocar seus <xref:System.IAsyncResult> valores em uma matriz e especificar se deseja esperar que todas as operações ou qualquer operação seja concluída. Nesse caso, você usa o <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriedade o <xref:System.IAsyncResult> para identificar a operação concluída.  
  
 Essa sobrecarga Especifica um tempo limite. Se o intervalo especificado pelo `timeout` parâmetro expira, esse componente gera o <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento. Como não existe nenhuma mensagem, uma chamada subsequente para <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> lançará uma exceção.  
  
 Não use a chamada assíncrona <xref:System.Messaging.MessageQueue.BeginReceive%2A> com transações. Se você quiser executar uma operação assíncrona transacional, chame <xref:System.Messaging.MessageQueue.BeginPeek%2A>e colocar a transação e (síncrono) <xref:System.Messaging.MessageQueue.Receive%2A> método no manipulador de eventos que você criar para a operação de pico. O manipulador de eventos pode conter funcionalidade, como mostra o código c# a seguir.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma assíncrona operação de recebimento. O exemplo de código cria um manipulador de eventos, `MyReceiveCompleted`e anexa-o para o <xref:System.Messaging.MessageQueue.ReceiveCompleted> representante do manipulador de eventos. O envia de exemplo de código uma mensagem para uma fila de mensagens local, em seguida, chama <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29>, passando um valor de tempo limite de dez segundos. Quando um <xref:System.Messaging.MessageQueue.ReceiveCompleted> é gerado, o manipulador de eventos recebe a mensagem e grava o corpo da mensagem para a tela.  
  
 [!code-cpp[MessageQueueBeginReceive1#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive1/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive1#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive1/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly because it represents a negative number.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</param>
        <param name="stateObject">A state object, specified by the application, that contains information associated with the asynchronous operation.</param>
        <summary>Initiates an asynchronous receive operation that has a specified time-out and a specified state object, which provides associated information throughout the operation's lifetime. The operation is not complete until either a message becomes available in the queue or the time-out occurs.</summary>
        <returns>The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O processamento assíncrono, você usa <xref:System.Messaging.MessageQueue.BeginReceive%2A> para gerar o <xref:System.Messaging.MessageQueue.ReceiveCompleted> eventos quando uma mensagem se torna disponível na fila ou quando o intervalo de tempo especificado tiver expirado.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> também é gerado se já existir uma mensagem na fila.  
  
 Use essa sobrecarga para associar informações com a operação que será preservada ao longo do tempo de vida da operação. O manipulador de eventos pode detectar essa informação examinando o <xref:System.IAsyncResult.AsyncState%2A> propriedade o <xref:System.IAsyncResult> que está associado com a operação.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginReceive%2A>, crie um manipulador de eventos que processa os resultados da operação assíncrona e associá-lo com o delegado do evento. <xref:System.Messaging.MessageQueue.BeginReceive%2A> inicia uma assíncrona recebe operação. o <xref:System.Messaging.MessageQueue> é notificado por meio do aumento do <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento, quando uma mensagem chega na fila. O <xref:System.Messaging.MessageQueue> pode acessar a mensagem chamando <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> ou recuperar o resultado usando o <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 O <xref:System.Messaging.MessageQueue.BeginReceive%2A> método retorna imediatamente, mas não é possível concluir a operação assíncrona até que o manipulador de eventos é chamado.  
  
 Porque <xref:System.Messaging.MessageQueue.BeginReceive%2A> é assíncrona, você pode chamá-lo para receber uma mensagem da fila sem bloquear o thread atual de execução. Para modo síncrono receber uma mensagem, use o <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Quando uma operação assíncrona for concluída, você pode chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente no manipulador de eventos para manter receber notificações.  
  
 O <xref:System.IAsyncResult> que <xref:System.Messaging.MessageQueue.BeginReceive%2A> retorna identifica a operação assíncrona que o método foi iniciado. Você pode usar isso <xref:System.IAsyncResult> durante o tempo de vida da operação, embora você geralmente não usá-lo até <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> é chamado. No entanto, se você iniciar várias operações assíncronas, você pode colocar seus <xref:System.IAsyncResult> valores em uma matriz e especificar se deseja esperar que todas as operações ou qualquer operação seja concluída. Nesse caso, você usa o <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriedade o <xref:System.IAsyncResult> para identificar a operação concluída.  
  
 Essa sobrecarga Especifica um tempo limite e um objeto de estado. Se o intervalo especificado pelo `timeout` parâmetro expira, esse componente gera o <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento. Como não existe nenhuma mensagem, uma chamada subsequente para <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> lançará uma exceção.  
  
 O objeto de estado associa informações de estado com a operação. Por exemplo, se você chamar <xref:System.Messaging.MessageQueue.BeginReceive%2A> várias vezes para iniciar várias operações, você pode identificar cada operação por meio de um objeto de estado separado que você definir.  
  
 Você também pode usar o objeto de estado para transmitir informações entre os threads de processo. Se um thread é iniciado, mas o retorno de chamada está em um thread diferente em um cenário assíncrono, o objeto de estado é empacotado e passado novamente juntamente com informações do evento.  
  
 Não use a chamada assíncrona <xref:System.Messaging.MessageQueue.BeginReceive%2A> com transações. Se você quiser executar uma operação assíncrona transacional, chame <xref:System.Messaging.MessageQueue.BeginPeek%2A>e colocar a transação e (síncrono) <xref:System.Messaging.MessageQueue.Receive%2A> método no manipulador de eventos que você criar para a operação de pico. O manipulador de eventos pode conter funcionalidade, como mostra o código c# a seguir.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma assíncrona operação de recebimento. O exemplo de código cria um manipulador de eventos, `MyReceiveCompleted`e anexa-o para o <xref:System.Messaging.MessageQueue.ReceiveCompleted> representante do manipulador de eventos. O envia de exemplo de código uma mensagem para uma fila de mensagens local, em seguida, chama <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29>, passando um valor de tempo limite de dez segundos e um inteiro exclusivo que identifica essa mensagem específica. Quando um <xref:System.Messaging.MessageQueue.ReceiveCompleted> é gerado, o manipulador de eventos recebe a mensagem e grava o corpo da mensagem e o identificador inteiro da mensagem para a tela.  
  
 [!code-cpp[MessageQueueBeginReceive2#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive2/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive2#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive2/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</param>
        <param name="stateObject">A state object, specified by the application, that contains information associated with the asynchronous operation.</param>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> that will receive the notification of the asynchronous operation completion.</param>
        <summary>Initiates an asynchronous receive operation that has a specified time-out and a specified state object, which provides associated information throughout the operation's lifetime. This overload receives notification, through a callback, of the identity of the event handler for the operation. The operation is not complete until either a message becomes available in the queue or the time-out occurs.</summary>
        <returns>The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você usa essa sobrecarga, o retorno de chamada especificado no parâmetro de retorno de chamada é invocado diretamente quando uma mensagem se torna disponível na fila ou quando o intervalo de tempo especificado tiver expirado; o <xref:System.Messaging.MessageQueue.ReceiveCompleted> não é gerado. As outras sobrecargas de <xref:System.Messaging.MessageQueue.BeginReceive%2A> contam com este componente para gerar o <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> também é gerado se já existir uma mensagem na fila.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginReceive%2A>, crie um manipulador de eventos que processa os resultados da operação assíncrona e associá-lo com o delegado do evento. <xref:System.Messaging.MessageQueue.BeginReceive%2A> inicia uma assíncrona recebe operação. o <xref:System.Messaging.MessageQueue> é notificado por meio do aumento do <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento, quando uma mensagem chega na fila. O <xref:System.Messaging.MessageQueue> pode acessar a mensagem chamando <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> ou recuperar o resultado usando o <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 O <xref:System.Messaging.MessageQueue.BeginReceive%2A> método retorna imediatamente, mas não é possível concluir a operação assíncrona até que o manipulador de eventos é chamado.  
  
 Porque <xref:System.Messaging.MessageQueue.BeginReceive%2A> é assíncrona, você pode chamá-lo para receber uma mensagem da fila sem bloquear o thread atual de execução. Para modo síncrono receber uma mensagem, use o <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Quando uma operação assíncrona for concluída, você pode chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente no manipulador de eventos para manter receber notificações.  
  
 O <xref:System.IAsyncResult> que <xref:System.Messaging.MessageQueue.BeginReceive%2A> retorna identifica a operação assíncrona que o método foi iniciado. Você pode usar isso <xref:System.IAsyncResult> durante o tempo de vida da operação, embora você geralmente não usá-lo até <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> é chamado. No entanto, se você iniciar várias operações assíncronas, você pode colocar seus <xref:System.IAsyncResult> valores em uma matriz e especificar se deseja esperar que todas as operações ou qualquer operação seja concluída. Nesse caso, você usa o <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriedade o <xref:System.IAsyncResult> para identificar a operação concluída.  
  
 O objeto de estado associa informações de estado com a operação. Por exemplo, se você chamar <xref:System.Messaging.MessageQueue.BeginReceive%2A> várias vezes para iniciar várias operações, você pode identificar cada operação por meio de um objeto de estado separado que você definir.  
  
 Você também pode usar o objeto de estado para transmitir informações entre os threads de processo. Se um thread é iniciado, mas o retorno de chamada está em um thread diferente em um cenário assíncrono, o objeto de estado é empacotado e passado novamente juntamente com informações do evento.  
  
 Não use a chamada assíncrona <xref:System.Messaging.MessageQueue.BeginReceive%2A> com transações. Se você quiser executar uma operação assíncrona transacional, chame <xref:System.Messaging.MessageQueue.BeginPeek%2A>e colocar a transação e (síncrono) <xref:System.Messaging.MessageQueue.Receive%2A> método no manipulador de eventos que você criar para a operação de pico. O manipulador de eventos pode conter funcionalidade, como mostra o código c# a seguir.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma assíncrona operação de recebimento. O envia de exemplo de código uma mensagem para uma fila de mensagens local, em seguida, chama <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, passando: um valor de tempo limite de dez segundos; um inteiro exclusivo que identifica a mensagem específica; e uma nova instância da <xref:System.AsyncCallback> que identifica o manipulador de eventos, `MyReceiveCompleted`. Quando um <xref:System.Messaging.MessageQueue.ReceiveCompleted> é gerado, o manipulador de eventos recebe a mensagem e grava o corpo da mensagem e o identificador inteiro da mensagem para a tela.  
  
 [!code-cpp[MessageQueueBeginReceive3#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive3/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive3#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive3/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, System.Messaging.Cursor cursor, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * System.Messaging.Cursor * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, cursor, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the interval of time to wait for a message to become available.</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> that maintains a specific position in the message queue.</param>
        <param name="state">A state object, specified by the application, that contains information associated with the asynchronous operation.</param>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> that receives the notification of the asynchronous operation completion.</param>
        <summary>Initiates an asynchronous receive operation that has a specified time-out and uses a specified cursor and a specified state object. The state object provides associated information throughout the lifetime of the operation. This overload receives notification, through a callback, of the identity of the event handler for the operation. The operation is not complete until either a message becomes available in the queue or the time-out occurs.</summary>
        <returns>The <see cref="T:System.IAsyncResult" /> that identifies the posted asynchronous request.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você usa essa sobrecarga, o retorno de chamada especificado no parâmetro de retorno de chamada é invocado diretamente quando uma mensagem se torna disponível na fila ou quando o intervalo de tempo especificado tiver expirado; o <xref:System.Messaging.MessageQueue.ReceiveCompleted> não é gerado. As outras sobrecargas de <xref:System.Messaging.MessageQueue.BeginReceive%2A> contam com este componente para gerar o <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> também é gerado se já existir uma mensagem na fila.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginReceive%2A>, crie um manipulador de eventos que processa os resultados da operação assíncrona e associá-lo com o delegado do evento. <xref:System.Messaging.MessageQueue.BeginReceive%2A> inicia uma assíncrona recebe operação. o <xref:System.Messaging.MessageQueue> é notificado por meio do aumento do <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento, quando uma mensagem chega na fila. O <xref:System.Messaging.MessageQueue> pode acessar a mensagem chamando <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> ou recuperar o resultado usando o <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 O <xref:System.Messaging.MessageQueue.BeginReceive%2A> método retorna imediatamente, mas não é possível concluir a operação assíncrona até que o manipulador de eventos é chamado.  
  
 Porque <xref:System.Messaging.MessageQueue.BeginReceive%2A> é assíncrona, você pode chamá-lo para receber uma mensagem da fila sem bloquear o thread atual de execução. Para modo síncrono receber uma mensagem, use o <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Quando uma operação assíncrona for concluída, você pode chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente no manipulador de eventos para manter receber notificações.  
  
 O <xref:System.IAsyncResult> que <xref:System.Messaging.MessageQueue.BeginReceive%2A> retorna identifica a operação assíncrona que o método foi iniciado. Você pode usar isso <xref:System.IAsyncResult> durante o tempo de vida da operação, embora você geralmente não usá-lo até <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> é chamado. No entanto, se você iniciar várias operações assíncronas, você pode colocar seus <xref:System.IAsyncResult> valores em uma matriz e especificar se deseja esperar que todas as operações ou qualquer operação seja concluída. Nesse caso, use o <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriedade o <xref:System.IAsyncResult> para identificar a operação concluída.  
  
 O objeto de estado associa informações de estado com a operação. Por exemplo, se você chamar <xref:System.Messaging.MessageQueue.BeginReceive%2A> várias vezes para iniciar várias operações, você pode identificar cada operação por meio de um objeto de estado separado que você definir.  
  
 Você também pode usar o objeto de estado para transmitir informações entre os threads de processo. Se um thread é iniciado, mas o retorno de chamada está em um thread diferente em um cenário assíncrono, o objeto de estado é empacotado e passado novamente juntamente com informações do evento.  
  
 Não use a chamada assíncrona <xref:System.Messaging.MessageQueue.BeginReceive%2A> com transações. Se você quiser executar uma operação assíncrona transacional, chame <xref:System.Messaging.MessageQueue.BeginPeek%2A>e colocar a transação e (síncrono) <xref:System.Messaging.MessageQueue.Receive%2A> método no manipulador de eventos que você criar para a operação de pico. O manipulador de eventos pode conter funcionalidade, como mostra o código c# a seguir.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="cursor" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Messaging.MessageQueue.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanRead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the <see cref="T:System.Messaging.MessageQueue" /> can be read.</summary>
        <value>
          <see langword="true" /> Se o <see cref="T:System.Messaging.MessageQueue" /> existe e o aplicativo pode lê-lo; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanRead%2A> Indica se o aplicativo é capaz de inspecionar ou receber mensagens da fila. Se <xref:System.Messaging.MessageQueue.CanRead%2A> é `true`, o <xref:System.Messaging.MessageQueue> pode receber ou inspecionar mensagens da fila. Caso contrário, ele não pode.  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A> é `false` se uma fila já está aberta com acesso de leitura exclusivo (ou se ele está aberto com acesso não-exclusivo e isso <xref:System.Messaging.MessageQueue> solicita acesso exclusivo), ou se o aplicativo não tem direitos suficientes para acessá-lo. Se seu aplicativo tentar ler de uma fila quando <xref:System.Messaging.MessageQueue.CanRead%2A> é `false`, o acesso foi negado.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.CanRead%2A> propriedade.  
  
 [!code-csharp[MessageQueue#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Messaging.MessageQueue.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanWrite")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the <see cref="T:System.Messaging.MessageQueue" /> can be written to.</summary>
        <value>
          <see langword="true" /> Se o <see cref="T:System.Messaging.MessageQueue" /> existe e o aplicativo pode gravar nela; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> Indica se o aplicativo é capaz de enviar mensagens à fila. Se <xref:System.Messaging.MessageQueue.CanWrite%2A> é `true`, o <xref:System.Messaging.MessageQueue> pode enviar mensagens à fila. Caso contrário, ele não pode.  
  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> é `false` se uma fila já está aberta com acesso de gravação exclusivo (ou se ele está aberto com acesso não-exclusivo e isso <xref:System.Messaging.MessageQueue> solicita acesso exclusivo), ou se o aplicativo não tem direitos suficientes para acessá-lo. Se seu aplicativo tentar gravar em uma fila quando <xref:System.Messaging.MessageQueue.CanWrite%2A> é `false`, o acesso foi negado.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.CanWrite%2A> propriedade.  
  
 [!code-csharp[MessageQueue#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public Guid Category { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Category" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Category" />
      <MemberSignature Language="VB.NET" Value="Public Property Category As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Category { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.Category : Guid with get, set" Usage="System.Messaging.MessageQueue.Category" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Category")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the queue category.</summary>
        <value>Um <see cref="T:System.Guid" /> que representa a categoria de fila (enfileiramento tipo identificador), que permite que os aplicativos categorizem suas filas. O padrão é <see langword="Guid.empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A categoria de fila permite que um aplicativo categorizem suas filas. Por exemplo, você pode colocar todas as filas de cobrança em uma categoria e todas as filas de pedido em outro.  
  
 O <xref:System.Messaging.MessageQueue.Category%2A> propriedade fornece acesso para a propriedade de ID do tipo de serviço de enfileiramento de mensagem (que é leitura/gravação), acessíveis por meio de **propriedades da fila de** caixa de diálogo no Console de gerenciamento do computador. Você pode definir uma nova categoria. Embora você possa usar <xref:System.Guid.NewGuid%2A> para criar um valor de categoria é exclusivo em todas as <xref:System.Guid> valores, essa ação é desnecessária. O valor da categoria deve ser distinto somente de outras categorias, não de todos os outros <xref:System.Guid> valores. Por exemplo, você pode atribuir {00000000-0000-0000-0000-000000000001} como o <xref:System.Messaging.MessageQueue.Category%2A> para um conjunto de filas e {00000000-0000-0000-0000-000000000002} como o <xref:System.Messaging.MessageQueue.Category%2A> para outro conjunto.  
  
 Não é necessário definir o <xref:System.Messaging.MessageQueue.Category%2A>. O valor pode ser `null`.  
  
 A definição dessa propriedade modifica o enfileiramento de mensagens. Portanto, qualquer outro <xref:System.Messaging.MessageQueue> instâncias são afetadas pela alteração.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.Category%2A> propriedade.  
  
 [!code-csharp[MessageQueue#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The queue category was set to an invalid value.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Id" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ClearConnectionCache">
      <MemberSignature Language="C#" Value="public static void ClearConnectionCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearConnectionCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearConnectionCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearConnectionCache();" />
      <MemberSignature Language="F#" Value="static member ClearConnectionCache : unit -&gt; unit" Usage="System.Messaging.MessageQueue.ClearConnectionCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clears the connection cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você chama <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, os nomes de formato armazenados no cache são removidos e identificadores abertos e armazenados em cache são fechados.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir chama <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>.  
  
 [!code-csharp[MessageQueue#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageQueue.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Frees all resources allocated by the <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Close%2A> libera todos os recursos associados com um <xref:System.Messaging.MessageQueue>, incluindo recursos compartilhados se apropriado. O sistema novamente adquire estes recursos automaticamente se eles ainda estão disponíveis, por exemplo quando você chamar o <xref:System.Messaging.MessageQueue.Send%28System.Object%29> método, como o código c# a seguir.  
  
```csharp  
myMessageQueue.Send("Text 1.");  
myMessageQueue.Close();  
myMessageQueue.Send("Text 2."); //Resources are re-acquired.  
```  
  
 Quando você chama <xref:System.Messaging.MessageQueue.Close%2A>, todos os <xref:System.Messaging.MessageQueue> propriedades que acessem diretamente a fila do serviço de enfileiramento de mensagens estão limpo. O <xref:System.Messaging.MessageQueue.Path%2A>, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, <xref:System.Messaging.MessageQueue.Formatter%2A>, e <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> todas permanecem como estavam.  
  
 <xref:System.Messaging.MessageQueue.Close%2A> nem sempre Libere a leitura e gravação identificadores em uma fila, porque eles podem ser compartilhados. Você pode executar qualquer uma das etapas a seguir para garantir que <xref:System.Messaging.MessageQueue.Close%2A> libera os identificadores de leitura e gravação a uma fila:  
  
-   Criar o <xref:System.Messaging.MessageQueue> com acesso exclusivo. Para fazer isso, chame o <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29> ou <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> construtor e defina o `sharedModeDenyReceive` parâmetro `true`.  
  
-   Criar o <xref:System.Messaging.MessageQueue> com conexão caching desabilitado. Para fazer isso, chame o <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> construtor e defina o `enableConnectionCache` parâmetro `false`.  
  
-   Desabilite o cache de conexão. Para fazer isso, defina o <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> propriedade `false`.  
  
 Você deve chamar <xref:System.Messaging.MessageQueue.Close%2A> para uma fila antes de excluir a fila no servidor de enfileiramento de mensagens. Caso contrário, as mensagens enviadas para a fila podem gerar exceções ou aparecem na fila de mensagens mortas.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir fecha uma fila do serviço de enfileiramento de mensagens.  
  
 [!code-cpp[MessageQueue.Close#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Close/CPP/mqclose.cpp#1)]
 [!code-csharp[MessageQueue.Close#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Close/CS/mqclose.cs#1)]
 [!code-vb[MessageQueue.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Close/VB/mqclose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a new queue at the specified path on a Message Queuing server.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The path of the queue to create.</param>
        <summary>Creates a non-transactional Message Queuing queue at the specified path.</summary>
        <returns>A <see cref="T:System.Messaging.MessageQueue" /> that represents the new queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para criar uma fila de enfileiramento de mensagens não transacionais.  
  
 Para criar uma nova instância do <xref:System.Messaging.MessageQueue> classe em seu aplicativo e associá-lo a uma fila existente, use o <xref:System.Messaging.MessageQueue.%23ctor%2A> construtor. Para criar uma nova fila no enfileiramento de mensagens, chame <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 A sintaxe para a `path` parâmetro depende do tipo de fila-referências, conforme mostrado na tabela a seguir.  
  
|Tipo de fila|Sintaxe|  
|----------------|------------|  
|Fila pública|`MachineName`\\`QueueName`|  
|Fila particular|`MachineName`\\`Private$`\\`QueueName`|  
  
 Use "." para o computador local. Para obter a sintaxe mais, consulte o <xref:System.Messaging.MessageQueue.Path%2A> propriedade.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir cria filas públicas e privadas. Envia uma mensagem para filas selecionadas.  
  
 [!code-cpp[MessageQueue.Create_path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_path/CPP/mqcreate.cpp#1)]
 [!code-csharp[MessageQueue.Create_path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_path/CS/mqcreate.cs#1)]
 [!code-vb[MessageQueue.Create_path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_path/VB/mqcreate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="path" /> parameter is <see langword="null" /> or is an empty string ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A queue already exists at the specified path.  -or-  An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path, bool transactional);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path, bool transactional) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, transactional As Boolean) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path, bool transactional);" />
      <MemberSignature Language="F#" Value="static member Create : string * bool -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create (path, transactional)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactional" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">The path of the queue to create.</param>
        <param name="transactional">
          <see langword="true" /> to create a transactional queue; <see langword="false" /> to create a non-transactional queue.</param>
        <summary>Creates a transactional or non-transactional Message Queuing queue at the specified path.</summary>
        <returns>A <see cref="T:System.Messaging.MessageQueue" /> that represents the new queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar essa sobrecarga para criar uma fila transacional no enfileiramento de mensagens. Você pode criar uma fila não transacional, definindo o `transactional` parâmetro `false` ou chamando a outra sobrecarga do <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Para criar uma nova instância do <xref:System.Messaging.MessageQueue> classe em seu aplicativo e associá-lo a uma fila existente, use o <xref:System.Messaging.MessageQueue.%23ctor%2A> construtor. Para criar uma nova fila no enfileiramento de mensagens, chame <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 A sintaxe para a `path` parâmetro depende do tipo de fila-referências, conforme mostrado na tabela a seguir.  
  
|Tipo de fila|Sintaxe|  
|----------------|------------|  
|Fila pública|`MachineName`\\`QueueName`|  
|Fila particular|`MachineName`\\`Private$`\\`QueueName`|  
  
 Use "." para o computador local. Para obter a sintaxe mais, consulte o <xref:System.Messaging.MessageQueue.Path%2A> propriedade.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir cria filas transacionais públicas e privadas. Envia uma mensagem para filas selecionadas.  
  
 [!code-cpp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CPP/mqcreate_transactional.cpp#1)]
 [!code-csharp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CS/mqcreate_transactional.cs#1)]
 [!code-vb[MessageQueue.Create_PathTransactional#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/VB/mqcreate_transactional.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="path" /> parameter is <see langword="null" /> or is an empty string ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A queue already exists at the specified path.  -or-  An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="CreateCursor">
      <MemberSignature Language="C#" Value="public System.Messaging.Cursor CreateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Cursor CreateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.CreateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCursor () As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Cursor ^ CreateCursor();" />
      <MemberSignature Language="F#" Value="member this.CreateCursor : unit -&gt; System.Messaging.Cursor" Usage="messageQueue.CreateCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Cursor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a new <see cref="T:System.Messaging.Cursor" /> for the current message queue.</summary>
        <returns>A new <see cref="T:System.Messaging.Cursor" /> for the current message queue. This cursor is used to maintain a specific location in the queue when reading the queue's messages.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Messaging.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CreateTime">
      <MemberSignature Language="C#" Value="public DateTime CreateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreateTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CreateTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreateTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime CreateTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateTime : DateTime" Usage="System.Messaging.MessageQueue.CreateTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CreateTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the time and date that the queue was created in Message Queuing.</summary>
        <value>Um <see cref="T:System.DateTime" /> que representa a data e hora em que a fila foi criada.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CreateTime%2A> refere-se à fila no servidor de enfileiramento de mensagens, não o <xref:System.Messaging.MessageQueue> instância.  
  
 Se a fila existe, esta propriedade representa a hora em que a fila foi criada, ajustados à hora local do servidor no qual a fila existe.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.CreateTime%2A> propriedade.  
  
 [!code-csharp[MessageQueue#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.LastModifyTime" />
      </Docs>
    </Member>
    <Member MemberName="DefaultPropertiesToSend">
      <MemberSignature Language="C#" Value="public System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultPropertiesToSend As DefaultPropertiesToSend" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::DefaultPropertiesToSend ^ DefaultPropertiesToSend { System::Messaging::DefaultPropertiesToSend ^ get(); void set(System::Messaging::DefaultPropertiesToSend ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultPropertiesToSend : System.Messaging.DefaultPropertiesToSend with get, set" Usage="System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.DefaultPropertiesToSend</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the message property values to be used by default when the application sends messages to the queue.</summary>
        <value>Um <see cref="T:System.Messaging.DefaultPropertiesToSend" /> que contém os valores da propriedade da mensagem Enfileiramento de Mensagens usados quando o aplicativo envia objetos diferentes de instâncias <see cref="T:System.Messaging.Message" /> para a fila.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você envia qualquer objeto que não é do tipo <xref:System.Messaging.Message> na fila, o <xref:System.Messaging.MessageQueue> insere o objeto em uma mensagem do serviço de enfileiramento de mensagens. Nesse momento, o <xref:System.Messaging.MessageQueue> aplica-se a mensagem os valores de propriedade que você especificar o <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriedade. Por outro lado, se você enviar um <xref:System.Messaging.Message> para a fila, essas propriedades já foram especificadas para a instância em si, portanto <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> é ignorado para o <xref:System.Messaging.Message>.  
  
 Embora você defina as propriedades por meio de <xref:System.Messaging.MessageQueue> objeto, o <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> se refere às propriedades das mensagens que são enviadas à fila, e não a própria fila.  
  
 Os valores padrão para as propriedades são mostrados na tabela a seguir.  
  
|Propriedade|Valor padrão|  
|--------------|-------------------|  
|<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>|Zero (0)|  
|<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>|Uma matriz de bytes de comprimento zero|  
|<xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Label%2A>|cadeia de caracteres vazia ("")|  
|<xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>|`false`|  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir usa a prioridade de uma mensagem para determinar as propriedades padrão para enviar a mensagem.  
  
 [!code-cpp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CPP/mqdefaultpropertiestosend.cpp#1)]
 [!code-csharp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CS/mqdefaultpropertiestosend.cs#1)]
 [!code-vb[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/VB/mqdefaultpropertiestosend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The default properties could not be set for the queue, possibly because one of the properties is not valid.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="T:System.Messaging.EncryptionAlgorithm" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Messaging.MessageQueue.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The location of the queue to be deleted.</param>
        <summary>Deletes a queue on a Message Queuing server.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A sintaxe para a `path` parâmetro depende do tipo de fila.  
  
|Tipo de fila|Sintaxe|  
|----------------|------------|  
|Fila pública|`MachineName`\\`QueueName`|  
|Fila particular|`MachineName`\\`Private$`\\`QueueName`|  
  
 Para obter a sintaxe mais, consulte o <xref:System.Messaging.MessageQueue.Path%2A> propriedade.  
  
 Como alternativa, você pode usar o <xref:System.Messaging.MessageQueue.FormatName%2A> ou <xref:System.Messaging.MessageQueue.Label%2A> para descrever o caminho da fila.  
  
|Referência|Sintaxe|  
|---------------|------------|  
|Nome do formato|FormatName: [ *nome do formato* ]|  
|Rotular|Label:[ *label* ]|  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir exclui uma fila do enfileiramento de mensagens, se ele existir.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="path" /> parameter is <see langword="null" /> or is an empty string ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The syntax for the <paramref name="path" /> parameter is not valid.  -or-  An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="DenySharedReceive">
      <MemberSignature Language="C#" Value="public bool DenySharedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DenySharedReceive" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberSignature Language="VB.NET" Value="Public Property DenySharedReceive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DenySharedReceive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DenySharedReceive : bool with get, set" Usage="System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_DenySharedReceive")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether this <see cref="T:System.Messaging.MessageQueue" /> has exclusive access to receive messages from the Message Queuing queue.</summary>
        <value>
          <see langword="true" /> Se este <see cref="T:System.Messaging.MessageQueue" /> tem direitos exclusivos para receber mensagens da fila; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> Especifica o modo compartilhado da fila referenciada por este <xref:System.Messaging.MessageQueue>. Definir <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> para `true` para indicar que somente este <xref:System.Messaging.MessageQueue> devem ter acesso ao inspecionar ou receber mensagens da fila com especificado <xref:System.Messaging.MessageQueue.Path%2A>. Se houver outro <xref:System.Messaging.MessageQueue> ou outro aplicativo está associado com o mesmo recurso de fila, essa instância ou aplicativo não será capaz de inspecionar ou receber mensagens, mas ainda pode enviá-los.  
  
 Se <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> é `false`, a fila está disponível para vários aplicativos para enviar, inspecionar ou receber mensagens.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> propriedade.  
  
 [!code-csharp[MessageQueue#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="messageQueue.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>Disposes of the resources (other than memory) used by the <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> quando tiver terminado de usar o <xref:System.Messaging.MessageQueue>. O <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> método deixa o <xref:System.Messaging.MessageQueue> em um estado inutilizável. Depois de chamar <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>, você deve liberar todas as referências para o <xref:System.Messaging.MessageQueue> para a memória estava ocupando pode ser recuperada pela coleta de lixo.  
  
 Você deve chamar <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> antes de liberar sua última referência para o <xref:System.Messaging.MessageQueue>. Caso contrário, os recursos de <xref:System.Messaging.MessageQueue> está usando não será liberada até que as chamadas de coleta de lixo a <xref:System.Messaging.MessageQueue> destruidor do objeto.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <Member MemberName="EnableConnectionCache">
      <MemberSignature Language="C#" Value="public static bool EnableConnectionCache { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableConnectionCache" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableConnectionCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableConnectionCache { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableConnectionCache : bool with get, set" Usage="System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether a cache of connections will be maintained by the application.</summary>
        <value>
          <see langword="true" /> para criar e usar um cache de conexão; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um cache de conexão é uma lista de referências a estruturas que contêm a leitura ou gravação identificadores para filas. Quando <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> é `true`, o <xref:System.Messaging.MessageQueue> usa identificadores do cache de cada vez que você chamar <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, ou <xref:System.Messaging.MessageQueue.Receive%2A>, em vez de identificadores abertos de novo. Isso pode melhorar o desempenho. Usar um cache de conexão também protege o <xref:System.Messaging.MessageQueue> de alterações na topologia da rede.  
  
 Se você criar uma nova conexão a uma fila quando o cache de conexão está cheio, o <xref:System.Messaging.MessageQueue> substitui a estrutura menos acessada recentemente com a nova conexão. Você pode limpar o cache inteiramente chamando <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, por exemplo, se os nomes de formato de filas que você está trabalhando com foram alterados para que o anterior de leitura e gravação identificadores não são mais válidos.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> propriedade.  
  
 [!code-csharp[MessageQueue#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionRequired">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionRequired EncryptionRequired { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionRequired EncryptionRequired" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionRequired As EncryptionRequired" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionRequired EncryptionRequired { System::Messaging::EncryptionRequired get(); void set(System::Messaging::EncryptionRequired value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionRequired : System.Messaging.EncryptionRequired with get, set" Usage="System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_EncryptionRequired")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionRequired</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the queue accepts only non-private (non-encrypted) messages.</summary>
        <value>Um dos valores de <see cref="T:System.Messaging.EncryptionRequired" />. O padrão é <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você especificar que a criptografia é necessária para as mensagens enviadas para uma fila, somente os corpos de mensagens são criptografados. Os outros membros (por exemplo, o <xref:System.Messaging.Message.Label%2A> e <xref:System.Messaging.Message.SenderId%2A> propriedades) não pode ser criptografada.  
  
 A definição dessa propriedade modifica o enfileiramento de mensagens. Portanto, qualquer outro <xref:System.Messaging.MessageQueue> instâncias são afetadas pela alteração.  
  
 Criptografar uma mensagem faz com que a mensagem privada. Você pode especificar o requisito de criptografia da fila seja `None`, `Body`, ou `Optional` definindo o <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> propriedade adequadamente. O <xref:System.Messaging.Message.UseEncryption%2A> configuração da mensagem deve corresponder ao requisito de criptografia da fila. Se a mensagem não está criptografada, mas a fila especifica `Body`, ou se a mensagem for criptografada, mas a fila especifica `None`, a mensagem será rejeitada pela fila. Se o aplicativo de envio solicita uma mensagem de confirmação negativa nesse caso, o enfileiramento de mensagens indica rejeição da mensagem para o aplicativo de envio. Se o <xref:System.Messaging.Message.UseDeadLetterQueue%2A> é de propriedade `true`, uma mensagem de falha de criptografia é enviada para a fila de mensagens mortas. Caso contrário, a mensagem será perdida.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> propriedade.  
  
 [!code-csharp[MessageQueue#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="T:System.Messaging.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="EndPeek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndPeek (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndPeek(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndPeek (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndPeek(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndPeek : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndPeek asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">The <see cref="T:System.IAsyncResult" /> that identifies the asynchronous peek operation to finish and from which to retrieve an end result.</param>
        <summary>Completes the specified asynchronous peek operation.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> associated with the completed asynchronous operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando o <xref:System.Messaging.MessageQueue.PeekCompleted> é gerado, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> conclui a operação foi iniciada pelo <xref:System.Messaging.MessageQueue.BeginPeek%2A> chamar. Para fazer isso, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> exibe a mensagem.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> pode especificar um tempo limite, o que faz com que o <xref:System.Messaging.MessageQueue.PeekCompleted> evento a ser gerado se o tempo limite ocorre antes que será exibida uma mensagem na fila. Quando um tempo limite ocorre sem uma mensagem que chega na fila, uma chamada subsequente para <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> lança uma exceção.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> é usado para ler a mensagem que causou o <xref:System.Messaging.MessageQueue.PeekCompleted> evento ser gerado.  
  
 Se você quiser continuar a assincronamente inspecionar mensagens, você pode chamar novamente <xref:System.Messaging.MessageQueue.BeginPeek%2A> depois de chamar <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir cria um manipulador de eventos chamado `MyPeekCompleted`, anexa-o para o <xref:System.Messaging.MessageQueue.PeekCompleted> representante do manipulador de eventos e chamadas <xref:System.Messaging.MessageQueue.BeginPeek%2A> para iniciar uma operação assíncrona inspecionar na fila que está localizada no caminho ". \myQueue". Quando um <xref:System.Messaging.MessageQueue.PeekCompleted> é gerado, o exemplo exibe a mensagem e grava seu corpo para a tela. O exemplo, em seguida, chama <xref:System.Messaging.MessageQueue.BeginPeek%2A> novamente para iniciar uma nova operação assíncrona de pico.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="asyncResult" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The syntax of the <paramref name="asyncResult" /> parameter is not valid.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndReceive (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndReceive(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndReceive(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndReceive asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">The <see cref="T:System.IAsyncResult" /> that identifies the asynchronous receive operation to finish and from which to retrieve an end result.</param>
        <summary>Completes the specified asynchronous receive operation.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> associated with the completed asynchronous operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando o <xref:System.Messaging.MessageQueue.ReceiveCompleted> é gerado, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> conclui a operação foi iniciada pelo <xref:System.Messaging.MessageQueue.BeginReceive%2A> chamar. Para fazer isso, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> recebe a mensagem.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> pode especificar um tempo limite, o que faz com que o <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento a ser gerado se o tempo limite ocorre antes que será exibida uma mensagem na fila. Quando um tempo limite ocorre sem uma mensagem que chega na fila, uma chamada subsequente para <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> lança uma exceção.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> é usado para ler (remover da fila) a mensagem que causou o <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento ser gerado.  
  
 Se você quiser continuar a mensagens de forma assíncrona, você pode chamar novamente <xref:System.Messaging.MessageQueue.BeginReceive%2A> depois de chamar <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir encadeia solicitações assíncronas. Ele assume que há uma fila no computador local chamado "myQueue". O `Main` função inicia a operação assíncrona que é manipulada pelo `MyReceiveCompleted` rotina. `MyReceiveCompleted` processa a mensagem atual e inicia um novo assíncrona operação de recebimento.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="asyncResult" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The syntax of the <paramref name="asyncResult" /> parameter is not valid.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Messaging.MessageQueue.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The location of the queue to find.</param>
        <summary>Determines whether a Message Queuing queue exists at the specified path.</summary>
        <returns>
          <see langword="true" /> if a queue with the specified path exists; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.MessageQueue.Exists%28System.String%29> método determina se existe uma fila do serviço de enfileiramento de mensagens em um caminho especificado. Nenhum método existe para determinar se existe uma fila com um nome de formato especificado. Para obter mais informações sobre a sintaxe de nome de formato e outras formas de sintaxe de caminho, consulte o <xref:System.Messaging.MessageQueue.Path%2A> propriedade.)  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> é uma operação cara. Usá-lo somente quando é necessário no aplicativo.  
  
> [!NOTE]
>  O <xref:System.Messaging.MessageQueue.Exists%28System.String%29> método não oferece suporte a <xref:System.Messaging.MessageQueue.FormatName%2A> prefixo.  
  
 A sintaxe para a `path` parâmetro depende do tipo de fila, conforme mostrado na tabela a seguir.  
  
|Tipo de fila|Sintaxe|  
|----------------|------------|  
|Fila pública|`MachineName`\\`QueueName`|  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> não pode ser chamado para verificar a existência de uma fila particular remota.  
  
 Para obter a sintaxe mais, consulte o <xref:System.Messaging.MessageQueue.Path%2A> propriedade.  
  
 Como alternativa, você pode usar o <xref:System.Messaging.MessageQueue.Label%2A> para descrever o caminho da fila.  
  
|Referência|Sintaxe|  
|---------------|------------|  
|Rotular|Rótulo: [ `label` ]|  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Não|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir verifica se uma fila do serviço de enfileiramento de mensagens existe e, em seguida, exclui-lo.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="path" /> syntax is not valid.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.  -or-  The <see cref="M:System.Messaging.MessageQueue.Exists(System.String)" /> method is being called on a remote private queue</exception>
        <exception cref="T:System.InvalidOperationException">The application used format name syntax when verifying queue existence.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="FormatName">
      <MemberSignature Language="C#" Value="public string FormatName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FormatName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.FormatName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FormatName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FormatName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FormatName : string" Usage="System.Messaging.MessageQueue.FormatName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_FormatName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the unique queue name that Message Queuing generated at the time of the queue's creation.</summary>
        <value>O nome da fila, que é exclusivo na rede.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.MessageQueue.FormatName%2A> propriedade contém o nome do formato da fila. O Message Queuing usa o nome de formato para identificar qual fila para abrir e como acessá-la. Ao contrário da maioria das características da fila, o nome de formato não é uma propriedade de fila do enfileiramento de aplicativos, portanto você não pode acessá-lo por meio da ferramenta de gerenciamento do serviço de enfileiramento de mensagens. O nome de formato é simplesmente um nome exclusivo para a fila, que o enfileiramento de mensagens gera quando ele cria a fila ou que o aplicativo gera mais tarde.  
  
 Se você especificar um caminho usando a sintaxe de nome de caminho (como `myComputer\myQueue`) em vez de usar a sintaxe de nome de formato ao ler ou gravar na fila, o controlador de domínio primário (que usa o Active Directory) converte o <xref:System.Messaging.MessageQueue.Path%2A> para o associado<xref:System.Messaging.MessageQueue.FormatName%2A> antes de acessar a fila. Se seu aplicativo estiver trabalhando offline, você deve usar a sintaxe de nome de formato; Caso contrário, o controlador de domínio primário não estará disponível para executar a conversão de caminho.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.FormatName%2A> propriedade.  
  
 [!code-csharp[MessageQueue#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">The <see cref="P:System.Messaging.MessageQueue.Path" /> is not set.  -or-  An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="T:System.Messaging.MessageQueue" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.MessageQueue.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Formatter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the formatter used to serialize an object into or deserialize an object from the body of a message read from or written to the queue.</summary>
        <value>O <see cref="T:System.Messaging.IMessageFormatter" /> que produz um fluxo a ser gravado ou lido do corpo da mensagem. O padrão é <see cref="T:System.Messaging.XmlMessageFormatter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.MessageQueue.Formatter%2A> propriedade contém uma instância de um objeto formatador, que transforma mensagens quando o aplicativo lê ou grava na fila.  
  
 Quando o aplicativo envia a mensagem para a fila, o formatador serializa o objeto em um fluxo e o insere no corpo da mensagem. Ao ler de uma fila, o formatador desserializa os dados da mensagem para o <xref:System.Messaging.Message.Body%2A> propriedade de um <xref:System.Messaging.Message>.  
  
 O <xref:System.Messaging.XmlMessageFormatter> é flexível, portanto, não é necessário ter o mesmo objeto de tipo no remetente e destinatário, ao usar esse formato. O <xref:System.Messaging.ActiveXMessageFormatter> e <xref:System.Messaging.BinaryMessageFormatter> serializar os dados em representação binária. O <xref:System.Messaging.ActiveXMessageFormatter> é usado ao enviar ou receber componentes COM.  
  
 <xref:System.Messaging.BinaryMessageFormatter> e <xref:System.Messaging.ActiveXMessageFormatter> fornecer a taxa de transferência mais rápida que o <xref:System.Messaging.XmlMessageFormatter>. O <xref:System.Messaging.ActiveXMessageFormatter> permite a interoperabilidade com aplicativos de enfileiramento de mensagens do Visual Basic 6.0.  
  
 Quando o aplicativo envia mensagens na fila, o <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> só se aplica a essas mensagens que usam as propriedades de mensagem padrão, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>. Se você enviar um <xref:System.Messaging.Message> para a fila, enfileiramento de mensagens usa o formatador definido no <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propriedade para serializar o corpo em vez disso.  
  
 O <xref:System.Messaging.MessageQueue> classe sempre usará um <xref:System.Messaging.Message> para receber ou espiar uma mensagem da fila. A mensagem é desserializada usando o <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propriedade.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra a formatação de um corpo de mensagem usando <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 O exemplo de código a seguir demonstra a formatação de um corpo de mensagem usando <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="GetAllMessages">
      <MemberSignature Language="C#" Value="public System.Messaging.Message[] GetAllMessages ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message[] GetAllMessages() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetAllMessages" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMessages () As Message()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Messaging::Message ^&gt; ^ GetAllMessages();" />
      <MemberSignature Language="F#" Value="member this.GetAllMessages : unit -&gt; System.Messaging.Message[]" Usage="messageQueue.GetAllMessages " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns all the messages that are in the queue.</summary>
        <returns>An array of type <see cref="T:System.Messaging.Message" /> that represents all the messages in the queue, in the same order as they appear in the Message Queuing queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> Retorna um instantâneo estático do mensagens na fila, os links não dinâmicos para essas mensagens. Portanto, você não pode usar a matriz para modificar as mensagens na fila. Se você quiser interação dinâmica, em tempo real com a fila (como a capacidade de excluir mensagens), chame o <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> método, que retorna uma lista dinâmica de mensagens na fila.  
  
 Porque <xref:System.Messaging.MessageQueue.GetAllMessages%2A> retorna uma cópia das mensagens na fila no momento em que o método foi chamado, a matriz não reflete as novas mensagens que chegam na fila ou mensagens que são removidas da fila.  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> recupera apenas as propriedades não filtradas pelo <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> propriedade.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.GetAllMessages%2A>.  
  
 [!code-cpp[MessageQueue2#21](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#21)]
 [!code-csharp[MessageQueue2#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="messageQueue.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Enumerates the messages in a queue. <see cref="M:System.Messaging.MessageQueue.GetEnumerator" /> is deprecated. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /> should be used instead.</summary>
        <returns>A <see cref="T:System.Collections.IEnumerator" /> that provides a dynamic connection to the messages in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.GetEnumerator%2A>.  
  
 [!code-cpp[MessageQueue2#22](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#22)]
 [!code-csharp[MessageQueue2#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMachineId">
      <MemberSignature Language="C#" Value="public static Guid GetMachineId (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetMachineId(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMachineId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineId (machineName As String) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetMachineId(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetMachineId : string -&gt; Guid" Usage="System.Messaging.MessageQueue.GetMachineId machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">The name of the computer that contains the queue, without the two preceding backslashes (\\\\).</param>
        <summary>Gets the identifier of the computer on which the queue referenced by this <see cref="T:System.Messaging.MessageQueue" /> is located.</summary>
        <returns>A <see cref="T:System.Guid" /> that represents a unique identifier for the computer on which the queue is located.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar o identificador do computador para dois propósitos, entre outros: para ler o diário do computador e configurar certificados de segurança. No entanto, você não pode chamar <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> para um computador remoto quando você estiver trabalhando offline, porque o aplicativo deve ter acesso ao serviço de diretório no controlador de domínio.  
  
 O identificador do computador (ou o identificador de máquina) é um <xref:System.Guid> que o enfileiramento de mensagens cria quando um computador é adicionado à empresa. O Message Queuing combina o identificador do computador com o `Machine` e `Journal` palavras-chave para criar o nome do formato do diário do computador, que tem a sintaxe `Machine=<computeridentifier>;Journal`. O diário do computador, que também é conhecido como a fila de diário, é uma fila do sistema que armazena cópias das gerados pelo aplicativo de mensagens quando o <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> é de propriedade `true`.  
  
 Essa sintaxe para o diário é válido somente ao construir o nome do formato da fila. A sintaxe de nome de caminho é `MachineName` \\ `Journal$`.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Não|  
|Computador local e o nome de formato direto|Não|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir chama <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29>.  
  
 [!code-csharp[MessageQueue#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">The computer identifier could not be retrieved, possibly because the directory service is not available; for example, if you are working offline.  -or-  An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates an enumerator object for all the messages in the queue. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" /> is deprecated. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /> should be used instead.</summary>
        <returns>The <see cref="T:System.Messaging.MessageEnumerator" /> holding the messages that are contained in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> cria uma lista dinâmica de todas as mensagens em uma fila. Você pode remover da fila a mensagem na posição atual do enumerador chamando <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> para o <xref:System.Messaging.MessageEnumerator> que <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> retorna.  
  
 Como o cursor é associado com a lista dinâmica de mensagens na fila, a enumeração reflete qualquer modificação que você fizer as mensagens na fila, se a mensagem está além da posição atual do cursor. Por exemplo, o enumerador pode acessar automaticamente uma mensagem de prioridade mais baixa colocado além da posição atual do cursor, mas não uma mensagem de prioridade mais alta inseridos antes de posição. No entanto, você pode redefinir a enumeração, assim, movendo o cursor volta para o início da lista, chamando <xref:System.Messaging.MessageEnumerator.Reset%2A> para o <xref:System.Messaging.MessageEnumerator>.  
  
 A ordem das mensagens na enumeração reflete a ordem na fila, para que mensagens de prioridade mais alta serão exibido antes que os de prioridade mais baixa.  
  
 Se você quiser um instantâneo estático das mensagens em fila em vez de uma conexão dinâmica a eles, chame <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. Esse método retorna uma matriz de <xref:System.Messaging.Message> objetos que representam as mensagens no momento em que o método foi chamado.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém uma lista dinâmica de mensagens em uma fila e contagens de todas as mensagens com o <xref:System.Messaging.Message.Priority%2A> propriedade definida como <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator2">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator2() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator2 () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator2();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator2 : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator2 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates an enumerator object for all the messages in the queue.</summary>
        <returns>The <see cref="T:System.Messaging.MessageEnumerator" /> holding the messages that are contained in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> cria uma lista dinâmica de todas as mensagens em uma fila. Você pode remover da fila a mensagem na posição atual do enumerador chamando <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> para o <xref:System.Messaging.MessageEnumerator> que <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> retorna.  
  
 Como o cursor é associado com a lista dinâmica de mensagens na fila, a enumeração reflete qualquer modificação que você fizer as mensagens na fila, se a mensagem está além da posição atual do cursor. Por exemplo, o enumerador pode acessar automaticamente uma mensagem de prioridade mais baixa colocado além da posição atual do cursor, mas não uma mensagem de prioridade mais alta inseridos antes de posição. No entanto, você pode redefinir a enumeração, assim, movendo o cursor volta para o início da lista, chamando <xref:System.Messaging.MessageEnumerator.Reset%2A> para o <xref:System.Messaging.MessageEnumerator>.  
  
 A ordem das mensagens na enumeração reflete a ordem na fila, para que mensagens de prioridade mais alta serão exibido antes que os de prioridade mais baixa.  
  
 Se você quiser um instantâneo estático das mensagens em fila em vez de uma conexão dinâmica a eles, chame <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. Esse método retorna uma matriz de <xref:System.Messaging.Message> objetos que representam as mensagens no momento em que o método foi chamado.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMessageQueueEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates an enumerator object for a dynamic listing of the public queues on the network.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator () As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator();" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : unit -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Provides forward-only cursor semantics to enumerate through all public queues on the network.</summary>
        <returns>A <see cref="T:System.Messaging.MessageQueueEnumerator" /> that provides a dynamic listing of all the public message queues on the network.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga do <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> retorna uma enumeração de todas as filas públicas que estão em uma rede.  
  
 Porque o cursor está associado uma lista dinâmica, a enumeração reflete as modificações feitas a uma lista de fila para filas excluído ou adicionado além da posição atual do cursor. Adições ou exclusões de filas localizadas antes da posição atual do cursor não são refletidas. Por exemplo, o enumerador automaticamente pode acessar uma fila acrescentado além da posição do cursor, mas não uma inseridos antes de posição. No entanto, você pode redefinir a enumeração, assim, movendo o cursor volta para o início da lista, chamando <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> para o <xref:System.Messaging.MessageQueueEnumerator>.  
  
 Não há nenhuma ordem definida de filas em uma rede. Um enumerador não ordene-as, por exemplo, computador, rótulo, status público ou privado ou quaisquer outros critérios acessíveis.  
  
 Se você quiser um instantâneo estático de filas da rede em vez de uma conexão dinâmica a eles, chame <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> ou <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Cada um desses dois métodos retorna uma matriz de <xref:System.Messaging.MessageQueue> objetos que representam as filas no momento em que o método foi chamado.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Não|  
|Computador local e o nome de formato direto|Não|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir itera todas as filas de mensagens na rede e examina o caminho para cada fila. Finalmente, ele exibe o número de filas públicas na rede.  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator (criteria As MessageQueueCriteria) As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">A <see cref="T:System.Messaging.MessageQueueCriteria" /> that contains the criteria used to filter the available message queues.</param>
        <summary>Provides forward-only cursor semantics to enumerate through all public queues on the network that meet the specified criteria.</summary>
        <returns>A <see cref="T:System.Messaging.MessageQueueEnumerator" /> that provides a dynamic listing of the public message queues on the network that satisfy the restrictions specified by the <paramref name="criteria" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga do <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> retorna uma lista de todas as filas públicas na rede que atendem a critérios definidos nos critérios de aplicativo. Você pode especificar os critérios para incluir, por exemplo, fila hora de criação ou modificação, nome do computador, rótulo, categoria ou qualquer combinação desses elementos.  
  
 Porque o cursor está associado uma lista dinâmica, a enumeração reflete as modificações feitas para uma fila que ocorre além da posição atual do cursor. Alterações em filas localizadas antes da posição atual do cursor não são refletidas. Por exemplo, o enumerador automaticamente pode acessar uma fila acrescentado além da posição do cursor, mas não uma inseridos antes de posição. No entanto, você pode redefinir a enumeração, assim, movendo o cursor volta para o início da lista, chamando <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> para o <xref:System.Messaging.MessageQueueEnumerator>.  
  
 Não há nenhuma ordem definida de filas em uma rede. Um enumerador não ordene-as, por exemplo, computador, rótulo, status público ou privado ou quaisquer outros critérios acessíveis.  
  
 Se você quiser um instantâneo estático de filas da rede em vez de uma conexão dinâmica a eles, especifique os critérios para <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> ou chame <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Cada um desses dois métodos retorna uma matriz de <xref:System.Messaging.MessageQueue> objetos que representam as filas no momento em que o método foi chamado. Chamando <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, ou <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> fornece os mesmos resultados que chamar <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> com os critérios de filtragem de <xref:System.Messaging.MessageQueue.Category%2A>, <xref:System.Messaging.MessageQueue.Label%2A>, e <xref:System.Messaging.MessageQueue.MachineName%2A>, respectivamente.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Não|  
|Computador local e o nome de formato direto|Não|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir itera por meio de filas de mensagens e exibe o caminho de cada fila que foi criada no último dia e que existe no computador "MyComputer".  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CPP/mqgetmessagequeueenumerator_criteria.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CS/mqgetmessagequeueenumerator_criteria.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/VB/mqgetmessagequeueenumerator_criteria.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetPrivateQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPrivateQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPrivateQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPrivateQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPrivateQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPrivateQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPrivateQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">The computer from which to retrieve the private queues.</param>
        <summary>Retrieves all the private queues on the specified computer.</summary>
        <returns>An array of <see cref="T:System.Messaging.MessageQueue" /> objects that reference the retrieved private queues.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> recupera um instantâneo estático de filas em um computador especificado.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir recupera a lista de filas.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="machineName" /> parameter is <see langword="null" /> or an empty string ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPublicQueues">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retrieves all the public queues on the network.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues () As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues();" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : unit -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retrieves all the public queues on the network.</summary>
        <returns>An array of <see cref="T:System.Messaging.MessageQueue" /> objects that reference the retrieved public queues.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga se você quiser uma lista completa de todas as filas públicas na rede. Se você deseja restringir a lista por certos critérios, como <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, ou a hora da última modificação use outra sobrecarga desse método. (Como alternativa, você pode usar <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, ou <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>.)  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> recupera um instantâneo estático das filas. Para interagir com uma lista dinâmica de filas, use <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Não|  
|Computador local e o nome de formato direto|Não|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir recupera a lista de filas.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues (criteria As MessageQueueCriteria) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">A <see cref="T:System.Messaging.MessageQueueCriteria" /> that contains the criteria used to filter the queues.</param>
        <summary>Retrieves all the public queues on the network that meet the specified criteria.</summary>
        <returns>An array of <see cref="T:System.Messaging.MessageQueue" /> objects that reference the retrieved public queues.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você deseja filtrar todas as filas públicas na rede pelo rótulo, categoria ou nome do computador, o <xref:System.Messaging.MessageQueue> classe contém métodos específicos que fornecem essa funcionalidade (<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, e <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, respectivamente). Use essa sobrecarga para obter uma lista de todas as filas públicas na rede que atendam a mais de um desses critérios (por exemplo, se você deseja especificar um rótulo e uma categoria). Você também pode filtrar por critérios de mensagem diferente de <xref:System.Messaging.MessageQueue.Label%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, e <xref:System.Messaging.MessageQueue.MachineName%2A>. Por exemplo, você deve usar essa sobrecarga para filtrar por hora da última modificação da fila. Basta criar uma nova instância do <xref:System.Messaging.MessageQueueCriteria> classe, defina as propriedades adequadas na instância e passe a instância como o `criteria` parâmetro.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> recupera um instantâneo estático das filas. Para interagir com uma lista dinâmica de filas, use <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Não|  
|Computador local e o nome de formato direto|Não|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir recupera a lista de filas.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="T:System.Messaging.MessageQueueCriteria" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByCategory">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByCategory (Guid category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByCategory(valuetype System.Guid category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByCategory (category As Guid) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByCategory(Guid category);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByCategory : Guid -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByCategory category" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="category">A <see cref="T:System.Guid" /> that groups the set of queues to be retrieved.</param>
        <summary>Retrieves all the public queues on the network that belong to the specified category.</summary>
        <returns>An array of <see cref="T:System.Messaging.MessageQueue" /> objects that reference the retrieved public queues.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para filtrar as filas públicas por categoria. O <xref:System.Messaging.MessageQueue.Category%2A> propriedade fornece acesso para o Message Queuing tipo propriedade ID (que é leitura/gravação) de uma determinada fila. Embora você possa usar <xref:System.Guid.NewGuid%2A> para criar um valor de categoria é exclusivo em todas as <xref:System.Guid> valores, não é necessário. O valor da categoria deve ser distinto somente de outras categorias, não de todos os outros <xref:System.Guid> valores. Por exemplo, você pode atribuir {00000000-0000-0000-0000-000000000001} como o <xref:System.Messaging.MessageQueue.Category%2A> para um conjunto de filas e {00000000-0000-0000-0000-000000000002} como o <xref:System.Messaging.MessageQueue.Category%2A> para outro conjunto.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> recupera um instantâneo estático das filas. Para interagir com uma lista dinâmica de filas, use <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Você pode especificar a categoria como parte do <xref:System.Messaging.MessageQueueCriteria> passar para o método.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Não|  
|Computador local e o nome de formato direto|Não|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir recupera a lista de filas.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByLabel">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByLabel (string label);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByLabel(string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByLabel (label As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByLabel(System::String ^ label);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByLabel : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByLabel label" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="label">A label that groups the set of queues to be retrieved.</param>
        <summary>Retrieves all the public queues on the network that carry the specified label.</summary>
        <returns>An array of <see cref="T:System.Messaging.MessageQueue" /> objects that reference the retrieved public queues.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para filtrar as filas públicas por rótulo.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> recupera um instantâneo estático das filas. Para interagir com uma lista dinâmica de filas, use <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Você pode especificar o rótulo como parte do <xref:System.Messaging.MessageQueueCriteria> passar para o método.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Não|  
|Computador local e o nome de formato direto|Não|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir recupera a lista de filas.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="label" /> parameter is <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">The name of the computer that contains the set of public queues to be retrieved.</param>
        <summary>Retrieves all the public queues that reside on the specified computer.</summary>
        <returns>An array of <see cref="T:System.Messaging.MessageQueue" /> objects that reference the public queues on the computer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para filtrar as filas públicas por computador.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> recupera um instantâneo estático das filas. Para interagir com uma lista dinâmica de filas, use <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Você pode especificar o nome do computador como parte do <xref:System.Messaging.MessageQueueCriteria> passar para o método.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Não|  
|Computador local e o nome de formato direto|Não|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir recupera a lista de filas.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="machineName" /> parameter has incorrect syntax.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityContext">
      <MemberSignature Language="C#" Value="public static System.Messaging.SecurityContext GetSecurityContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.SecurityContext GetSecurityContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetSecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSecurityContext () As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::SecurityContext ^ GetSecurityContext();" />
      <MemberSignature Language="F#" Value="static member GetSecurityContext : unit -&gt; System.Messaging.SecurityContext" Usage="System.Messaging.MessageQueue.GetSecurityContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retrieves the security context that MSMQ associates with the current user (thread identity) at the time of this call.</summary>
        <returns>A <see cref="T:System.Messaging.SecurityContext" /> object that contains the security context.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Messaging.Message.SecurityContext" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Id { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : Guid" Usage="System.Messaging.MessageQueue.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_GuidId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the unique Message Queuing identifier of the queue.</summary>
        <value>Um <see cref="P:System.Messaging.MessageQueue.Id" /> que representa o identificador da mensagem gerado pelo aplicativo do serviço de enfileiramento de mensagens.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Conjuntos de enfileiramento de mensagens a <xref:System.Messaging.MessageQueue.Id%2A> propriedade quando ele cria a fila. Essa propriedade só está disponível para filas públicas.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.Id%2A> propriedade.  
  
 [!code-csharp[MessageQueue#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteQueueSize">
      <MemberSignature Language="C#" Value="public static readonly long InfiniteQueueSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 InfiniteQueueSize" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteQueueSize As Long " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly long InfiniteQueueSize;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteQueueSize : int64" Usage="System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies that no size restriction exists for a queue.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse membro é frequentemente usado ao definir <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> ou <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Messaging.MessageQueue.InfiniteQueueSize> membro.  
  
 [!code-csharp[MessageQueue#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies that no time-out exists for methods that peek or receive messages.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue> dá suporte a dois tipos de recuperação de mensagens: síncronas e assíncronas. Métodos síncronos, <xref:System.Messaging.MessageQueue.Peek%2A> e <xref:System.Messaging.MessageQueue.Receive%2A>, fazer com que o thread de processo de um intervalo de tempo especificado para uma nova mensagem chegar na fila de espera. Se o intervalo de tempo especificado for <xref:System.Messaging.MessageQueue.InfiniteTimeout>, o thread de processo permanecerá bloqueado até que uma nova mensagem está disponível. Por outro lado, <xref:System.Messaging.MessageQueue.BeginPeek%2A> e <xref:System.Messaging.MessageQueue.BeginReceive%2A> (os métodos assíncronos), permitir que as tarefas de aplicativo principal continuar em um thread separado, até que uma mensagem chega na fila.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Messaging.MessageQueue.InfiniteTimeout> membro.  
  
 [!code-csharp[MessageQueue#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.MessageQueue.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Label")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the queue description.</summary>
        <value>O rótulo para a fila de mensagens. O padrão é uma cadeia de caracteres vazia ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O comprimento máximo de um rótulo de fila de mensagens é 124 caracteres.  
  
 O <xref:System.Messaging.MessageQueue.Label%2A> propriedade precisa ser exclusivo em todas as filas. No entanto, se várias filas compartilham o mesmo <xref:System.Messaging.MessageQueue.Label%2A>, você não pode usar o <xref:System.Messaging.MessageQueue.Send%28System.Object%29> método para difundir uma mensagem a todos eles. Se você usar a sintaxe do rótulo para o <xref:System.Messaging.MessageQueue.Path%2A> propriedade ao enviar a mensagem, uma exceção será lançada se o <xref:System.Messaging.MessageQueue.Label%2A> não é exclusivo.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.Label%2A> propriedade.  
  
 [!code-csharp[MessageQueue#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The label was set to an invalid value.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="LastModifyTime">
      <MemberSignature Language="C#" Value="public DateTime LastModifyTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastModifyTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.LastModifyTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastModifyTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime LastModifyTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.LastModifyTime : DateTime" Usage="System.Messaging.MessageQueue.LastModifyTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_LastModifyTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the last time the properties of a queue were modified.</summary>
        <value>Um <see cref="T:System.DateTime" /> que indica quando as propriedades de fila foram modificadas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A hora da última modificação inclui quando a fila foi criada e qualquer <xref:System.Messaging.MessageQueue> propriedade que modifica o enfileiramento de mensagens, como <xref:System.Messaging.MessageQueue.BasePriority%2A>. O valor de <xref:System.Messaging.MessageQueue.LastModifyTime%2A> propriedade representa a hora do sistema do computador local.  
  
 Você deve chamar <xref:System.Messaging.MessageQueue.Refresh%2A> antes de obter o <xref:System.Messaging.MessageQueue.LastModifyTime%2A> propriedade; caso contrário, a hora da modificação associado a esta <xref:System.Messaging.MessageQueue> podem não ser atuais.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.LastModifyTime%2A> propriedade.  
  
 [!code-csharp[MessageQueue#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CreateTime" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Messaging.MessageQueue.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the computer where the Message Queuing queue is located.</summary>
        <value>O nome do computador no qual a fila está localizada. O padrão do serviço de enfileiramento de mensagens é “.”, o computador local.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.MessageQueue.MachineName%2A> é um componente integrante da sintaxe do nome amigável da fila de <xref:System.Messaging.MessageQueue.Path%2A>. A tabela a seguir mostra a sintaxe que você deve usar para uma fila de um tipo especificado quando você deseja identificar o caminho da fila usando seu nome amigável.  
  
|Tipo de fila|Sintaxe|  
|----------------|------------|  
|Fila pública|`MachineName`\\`QueueName`|  
|Fila particular|`MachineName`\\`Private$`\\`QueueName`|  
|Fila de diário|`MachineName`\\`QueueName`\\`Journal$`|  
|Fila de diário do computador|`MachineName`\\`Journal$`|  
|Fila de mensagens mortas da máquina|`MachineName`\\`Deadletter$`|  
|Fila de mensagens mortas transacional do computador|`MachineName`\\`XactDeadletter$`|  
  
 Use "." para o computador local ao especificar o <xref:System.Messaging.MessageQueue.MachineName%2A>. Somente o nome do computador é reconhecido para esta propriedade, por exemplo, `Server0`. O <xref:System.Messaging.MessageQueue.MachineName%2A> propriedade não dá suporte para o formato do endereço IP.  
  
 Se você definir o <xref:System.Messaging.MessageQueue.Path%2A> em termos do <xref:System.Messaging.MessageQueue.MachineName%2A>, o aplicativo gera uma exceção ao trabalhar offline porque o controlador de domínio é necessário para a conversão de caminho. Portanto, você deve usar o <xref:System.Messaging.MessageQueue.FormatName%2A> para o <xref:System.Messaging.MessageQueue.Path%2A> sintaxe ao trabalhar offline.  
  
 O <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, e <xref:System.Messaging.MessageQueue.QueueName%2A> propriedades relacionadas. Alterando o <xref:System.Messaging.MessageQueue.MachineName%2A> propriedade faz com que o <xref:System.Messaging.MessageQueue.Path%2A> propriedade a ser alterada. É criado a partir do novo <xref:System.Messaging.MessageQueue.MachineName%2A> e <xref:System.Messaging.MessageQueue.QueueName%2A>. Alterando o <xref:System.Messaging.MessageQueue.Path%2A> (por exemplo, para usar a sintaxe de nome de formato) redefine o <xref:System.Messaging.MessageQueue.MachineName%2A> e <xref:System.Messaging.MessageQueue.QueueName%2A> propriedades para referir-se a nova fila. Se o <xref:System.Messaging.MessageQueue.QueueName%2A> propriedade estiver vazia, o <xref:System.Messaging.MessageQueue.Path%2A> está definido para a fila de diário do computador que você especificar.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.MachineName%2A> propriedade.  
  
 [!code-csharp[MessageQueue#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The name of the computer is not valid, possibly because the syntax is incorrect.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="MaximumJournalSize">
      <MemberSignature Language="C#" Value="public long MaximumJournalSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumJournalSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumJournalSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumJournalSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumJournalSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumJournalSize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum size of the journal queue.</summary>
        <value>O tamanho máximo, em quilobytes, da fila de diário. O padrão do Enfileiramento de Mensagens especifica que não há limite.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> fornece acesso para o limite de armazenamento do diário de enfileiramento de mensagens. Ele é relevante somente quando <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> é `true`. A definição dessa propriedade modifica o enfileiramento de mensagens. Portanto, qualquer outro <xref:System.Messaging.MessageQueue> instâncias são afetadas pela alteração  
  
 Se você armazenar mensagens em uma fila de mensagens mortas ou diário, você deve limpar periodicamente a fila para remover as mensagens que não são mais necessários. Contagem de mensagens em uma fila para a cota de mensagens para o computador em que a fila reside. (O administrador define a cota do computador).  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> propriedade.  
  
 [!code-csharp[MessageQueue#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The maximum journal queue size was set to an invalid value.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumQueueSize">
      <MemberSignature Language="C#" Value="public long MaximumQueueSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumQueueSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumQueueSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumQueueSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumQueueSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumQueueSize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum size of the queue.</summary>
        <value>O tamanho máximo, em quilobytes, da fila. O padrão do Enfileiramento de Mensagens especifica que não há limite.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> fornece acesso ao limite de armazenamento de mensagem enfileiramento de mensagens, que é separado da cota de mensagens do computador que o administrador define. Para obter mais informações sobre a cota de mensagens, consulte <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>.  
  
 A definição dessa propriedade modifica o enfileiramento de mensagens. Portanto, qualquer outro <xref:System.Messaging.MessageQueue> instâncias são afetadas pela alteração  
  
 Se for feita uma tentativa de exceder o tamanho máximo da fila ou a cota de mensagens do computador, as mensagens podem ser perdidas. Quando a cota da fila for atingida, o enfileiramento de mensagens notifica a fila de administração do aplicativo de envio para indicar que a fila está cheia, retornando uma mensagem de confirmação negativa. O Message Queuing continuará a enviar confirmações negativas, até que o tamanho total das mensagens na fila fique abaixo do limite.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> propriedade.  
  
 [!code-csharp[MessageQueue#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The maximum queue size contains a negative value.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MessageReadPropertyFilter">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePropertyFilter MessageReadPropertyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessagePropertyFilter MessageReadPropertyFilter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageReadPropertyFilter As MessagePropertyFilter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePropertyFilter ^ MessageReadPropertyFilter { System::Messaging::MessagePropertyFilter ^ get(); void set(System::Messaging::MessagePropertyFilter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MessageReadPropertyFilter : System.Messaging.MessagePropertyFilter with get, set" Usage="System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePropertyFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the property filter for receiving or peeking messages.</summary>
        <value>O <see cref="T:System.Messaging.MessagePropertyFilter" /> usado pela fila para filtrar o conjunto de propriedades que ela recebe ou espia para cada mensagem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse filtro é um conjunto de valores booleanos, restringindo as propriedades de mensagem que o <xref:System.Messaging.MessageQueue> recebe ou exibe. Quando o <xref:System.Messaging.MessageQueue> recebe ou exibe uma mensagem da fila do servidor, ele recupera apenas as propriedades para o qual o <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> valor é `true`.  
  
 A seguir mostra os valores de propriedade inicial para o <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> propriedade. Essas configurações são idênticas à chamada <xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A> em um <xref:System.Messaging.MessagePropertyFilter>.  
  
|Propriedade|Valor padrão|  
|--------------|-------------------|  
|<xref:System.Messaging.MessagePropertyFilter.Acknowledgment%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AcknowledgeType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AdministrationQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AppSpecific%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ArrivedTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AttachSenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Authenticated%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderName%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Body%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.ConnectorType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.CorrelationId%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultBodySize%2A>|1024 bytes|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultExtensionSize%2A>|255 bytes|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultLabelSize%2A>|255 bytes|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationSymmetricKey%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DigitalSignature%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.EncryptionAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Extension%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.HashAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Id%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.IsFirstInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.IsLastInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Label%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.MessageType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Priority%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Recoverable%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ResponseQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderCertificate%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderVersion%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SentTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SourceMachine%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToBeReceived%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToReachQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionStatusQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseTracing%2A>|`false`|  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> para restringir as propriedades da mensagem recebidas.  
  
 [!code-cpp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CPP/mqmessagereadpropertyfilter.cpp#1)]
 [!code-csharp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CS/mqmessagereadpropertyfilter.cs#1)]
 [!code-vb[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/VB/mqmessagereadpropertyfilter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The filter is <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="MulticastAddress">
      <MemberSignature Language="C#" Value="public string MulticastAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MulticastAddress" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MulticastAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MulticastAddress { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastAddress : string with get, set" Usage="System.Messaging.MessageQueue.MulticastAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MulticastAddress")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Introduced in MSMQ 3.0. Gets or sets the multicast address associated with the queue.</summary>
        <value>Um <see cref="T:System.String" /> que contém um endereço multicast válido (no formato mostrado abaixo) ou <see langword="null" />, que indica que a fila não está associada a um endereço multicast.  
  
```  
&lt;endereço&gt;:&lt;porta&gt;  
```</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.MessageQueue.MulticastAddress%2A> propriedade é usada para associar a um endereço de multicast que pode ser usado ao enviar mensagens de uma fila não transacional. Você não pode associar uma fila transacional com um endereço de multicast. Quando o aplicativo de envio envia mensagens para um endereço de difusão seletiva, enfileiramento de mensagens envia uma cópia da mensagem para cada fila associada a esse endereço.  
  
 Multicast IP endereços devem estar no intervalo de classe D de 224.0.0.0 a 239.255.255.255, que corresponde à configuração os quatro primeiros bits de ordem superior como iguais a 1110. No entanto, somente determinados intervalos de endereços nesse intervalo são não reservado e disponível para enviar mensagens de multicast. Para obter a lista mais recente de endereços multicast reservados, consulte o [endereços Multicast do número autoridade IANA (Internet Assigned) da Internet](http://go.microsoft.com/fwlink/?linkid=3859) página da Web. Não há nenhuma restrição sobre o número da porta.  
  
 Se vários computadores de origem estão enviando mensagens de multicast e desejar que uma fila específica para receber mensagens de um único computador de origem, cada computador de origem deve enviar mensagens para uma combinação diferente de número de porta e endereço IP.  
  
 Para desassociar uma fila de um endereço de multicast, defina o <xref:System.Messaging.MessageQueue.MulticastAddress%2A> propriedade como uma cadeia de caracteres de comprimento zero. Não defina-a como `null`, pois isso resultará em um <xref:System.ArgumentNullException>.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 is not installed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.Messaging.MessageQueue.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Path")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the queue's path. Setting the <see cref="P:System.Messaging.MessageQueue.Path" /> causes the <see cref="T:System.Messaging.MessageQueue" /> to point to a new queue.</summary>
        <value>A fila que é referenciada pelo <see cref="T:System.Messaging.MessageQueue" />. O padrão depende do construtor <see cref="M:System.Messaging.MessageQueue.#ctor" /> usado, ele é <see langword="null" /> ou especificado pelo parâmetro <paramref name="path" /> do construtor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A sintaxe para a <xref:System.Messaging.MessageQueue.Path%2A> propriedade depende do tipo de fila-pontos a, conforme mostrado na tabela a seguir.  
  
|Tipo de fila|Sintaxe|  
|----------------|------------|  
|Fila pública|`MachineName`\\`QueueName`|  
|Fila particular|`MachineName`\\`Private$`\\`QueueName`|  
|Fila de diário|`MachineName`\\`QueueName`\\`Journal$`|  
|Fila de diário do computador|`MachineName`\\`Journal$`|  
|Fila de mensagens mortas da máquina|`MachineName`\\`Deadletter$`|  
|Fila de mensagens mortas transacional do computador|`MachineName`\\`XactDeadletter$`|  
  
 Use "." para representar o computador local.  
  
 O <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, e <xref:System.Messaging.MessageQueue.QueueName%2A> propriedades relacionadas. Alterando o <xref:System.Messaging.MessageQueue.MachineName%2A> propriedade faz com que o <xref:System.Messaging.MessageQueue.Path%2A> propriedade a ser alterada. É criado a partir do novo <xref:System.Messaging.MessageQueue.MachineName%2A> e <xref:System.Messaging.MessageQueue.QueueName%2A>. Alterando o <xref:System.Messaging.MessageQueue.Path%2A> (por exemplo, para usar a sintaxe de nome de formato) redefine o <xref:System.Messaging.MessageQueue.MachineName%2A> e <xref:System.Messaging.MessageQueue.QueueName%2A> propriedades para referir-se a nova fila.  
  
 Como alternativa, você pode usar o <xref:System.Messaging.MessageQueue.FormatName%2A> ou <xref:System.Messaging.MessageQueue.Label%2A> para descrever o caminho da fila, conforme mostrado na tabela a seguir.  
  
|Referência|Sintaxe|Exemplo|  
|---------------|------------|-------------|  
|Nome do formato|`FormatName:` [ *nome do formato* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112|  
|Rotular|`Label:` [ *label* ]|`Label:` TheLabel|  
  
 Se você usar a sintaxe do rótulo para o <xref:System.Messaging.MessageQueue.Path%2A> propriedade ao enviar a mensagem, uma exceção será lançada se o <xref:System.Messaging.MessageQueue.Label%2A> não é exclusivo.  
  
 Para trabalhar offline, você deve usar a sintaxe de nome de formato, em vez da sintaxe de nome amigável da primeira tabela. Caso contrário, uma exceção é lançada porque o controlador de domínio primário (no qual o Active Directory reside) não está disponível para resolver o caminho para o nome de formato.  
  
 Definir um novo caminho fecha a fila de mensagens e libera todos os identificadores.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
> [!NOTE]
>  No modo de grupo de trabalho, você pode usar somente as filas particulares. Especifique o caminho usando a sintaxe de fila particular `MachineName` \\ `Private$` \\ `QueueName`.  
  
   
  
## Examples  
 O exemplo de código a seguir cria novos <xref:System.Messaging.MessageQueue> objetos usando vários tipos de sintaxe de nome de caminho. Em cada caso, ele envia uma mensagem para a fila cujo caminho é definido no construtor.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The path is not valid, possibly because the syntax is not valid.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Peek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <summary>Returns a copy of the first message in the queue without removing the message from the queue.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek();" />
      <MemberSignature Language="F#" Value="member this.Peek : unit -&gt; System.Messaging.Message" Usage="messageQueue.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns without removing (peeks) the first message in the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />. The <see cref="M:System.Messaging.MessageQueue.Peek" /> method is synchronous, so it blocks the current thread until a message becomes available.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> that represents the first message in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga espiar uma fila ou aguarde até que existe uma mensagem na fila.  
  
 O <xref:System.Messaging.MessageQueue.Peek%2A> método lê, mas não remove a primeira mensagem da fila. Portanto, repetidas chamadas para <xref:System.Messaging.MessageQueue.Peek%2A> retornar a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método, por outro lado, lê e remove a primeira mensagem da fila. Repetidas chamadas para <xref:System.Messaging.MessageQueue.Receive%2A>, portanto, retornar mensagens diferentes.  
  
 O Message Queuing ordena as mensagens na fila de acordo com a hora de chegada e prioridade. Uma mensagem mais recente é colocada antes mais antiga somente se ele for de uma prioridade mais alta.  
  
 Use <xref:System.Messaging.MessageQueue.Peek%2A> quando é aceitável para o thread atual a ser bloqueado enquanto aguarda uma mensagem para chegar na fila. Como essa sobrecarga não especifica um tempo limite, o aplicativo pode aguardar indefinidamente. Se você precisar continuar sem aguardar o processamento de aplicativo, use o assíncrona <xref:System.Messaging.MessageQueue.BeginPeek%2A> método. Como alternativa, você pode especificar um tempo limite para uma mensagem para chegar na fila usando a sobrecarga do <xref:System.Messaging.MessageQueue.Peek%2A> que especifica um tempo limite.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 Os exemplos a seguir usam o <xref:System.Messaging.MessageQueue.Peek%2A> método em uma fila.  
  
 No primeiro exemplo, o aplicativo aguarda uma mensagem se torna disponível na fila. Observe que o primeiro exemplo não acessa a mensagem que chega; ele simplesmente pausa até que uma mensagem chega de processamento. Se uma mensagem já existe na fila, ela retornará imediatamente.  
  
 No segundo exemplo, uma mensagem que contém um aplicativo definido `Order` classe é enviada para a fila e, em seguida, inspecionada da fila.  
  
 [!code-cpp[MessageQueue.Peek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CPP/mqpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Peek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CS/mqpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.Peek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_noparms/VB/mqpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Peek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the maximum time to wait for the queue to contain a message.</param>
        <summary>Returns without removing (peeks) the first message in the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />. The <see cref="M:System.Messaging.MessageQueue.Peek" /> method is synchronous, so it blocks the current thread until a message becomes available or the specified time-out occurs.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> that represents the first message in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga espiar uma fila ou aguardar um período especificado de tempo até que existe uma mensagem na fila. O método retorna imediatamente se já existe uma mensagem na fila.  
  
 O <xref:System.Messaging.MessageQueue.Peek%2A> método lê, mas não remove a primeira mensagem da fila. Portanto, repetidas chamadas para <xref:System.Messaging.MessageQueue.Peek%2A> retornar a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método, por outro lado, lê e remove a primeira mensagem da fila. Repetidas chamadas para <xref:System.Messaging.MessageQueue.Receive%2A>, portanto, retornar mensagens diferentes.  
  
 O Message Queuing ordena as mensagens na fila de acordo com a hora de chegada e prioridade. Uma mensagem mais recente é colocada antes mais antiga somente se ele for de uma prioridade mais alta.  
  
 Use <xref:System.Messaging.MessageQueue.Peek%2A> quando é aceitável para o thread atual a ser bloqueado enquanto aguarda uma mensagem para chegar na fila. O thread será bloqueado até que o período especificado de tempo ou indefinidamente se você indicou <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Se você precisar continuar sem aguardar o processamento de aplicativo, use o assíncrona <xref:System.Messaging.MessageQueue.BeginPeek%2A> método.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Messaging.MessageQueue.Peek%2A> método com um tempo limite de zero para verificar se a fila está vazia.  
  
 [!code-cpp[MessageQueue.Peek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CPP/mqpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Peek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CS/mqpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.Peek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_timeout/VB/mqpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction -&gt; System.Messaging.Message" Usage="messageQueue.Peek (timeout, cursor, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the maximum time to wait for the queue to contain a message.</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> that maintains a specific position in the message queue.</param>
        <param name="action">One of the <see cref="T:System.Messaging.PeekAction" /> values. Indicates whether to peek at the current message in the queue, or the next message.</param>
        <summary>Returns without removing (peeks) the current or next message in the queue, using the specified cursor. The <see cref="M:System.Messaging.MessageQueue.Peek" /> method is synchronous, so it blocks the current thread until a message becomes available or the specified time-out occurs.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that represents a message in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga espiar uma fila ou aguardar um período especificado de tempo até que existe uma mensagem na fila. O método retorna imediatamente se já existe uma mensagem na fila.  
  
 O <xref:System.Messaging.MessageQueue.Peek%2A> método lê, mas não remove uma mensagem da fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método, por outro lado, lê e remove uma mensagem da fila.  
  
 Use <xref:System.Messaging.MessageQueue.Peek%2A> quando é aceitável para o thread atual a ser bloqueado enquanto aguarda uma mensagem para chegar na fila. O thread está bloqueado até o período especificado de tempo ou indefinidamente se você indicou <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Se você precisar continuar sem aguardar o processamento de aplicativo, use o assíncrona <xref:System.Messaging.MessageQueue.BeginPeek%2A> método.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">A value other than <see langword="PeekAction.Current" /> or <see langword="PeekAction.Next" /> was specified for the <paramref name="action" /> parameter.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="cursor" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid. Possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.PeekAction" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Peeks a message that matches a given correlation identifier.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to peek.</param>
        <summary>Peeks the message that matches the given correlation identifier and immediately raises an exception if no message with the specified correlation identifier currently exists in the queue.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método examina a fila referenciada pelo <xref:System.Messaging.MessageQueue> para uma mensagem cujo <xref:System.Messaging.Message.CorrelationId%2A> corresponde especificado `correlationId` parâmetro. Se nenhuma mensagem for encontrada que corresponda a `correlationID` parâmetro, uma exceção será lançada.  
  
 O <xref:System.Messaging.Message.CorrelationId%2A> propriedade é usada para ligar uma mensagem enviada para a fila de mensagens de resposta, relatório ou confirmação associadas.  
  
 Dois outros métodos permitem que você inspecionar mensagens em uma fila. O <xref:System.Messaging.MessageQueue.Peek%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método é usado para recuperar uma mensagem especificando seu identificador exclusivo.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir envia e recebe uma mensagem que contém um pedido de e para uma fila. Ele solicita uma confirmação positiva especificamente quando a mensagem original atinge ou é recuperada da fila.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="correlationId" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The message with the specified <paramref name="correlationId" /> could not be found.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to peek.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</param>
        <summary>Peeks the message that matches the given correlation identifier and waits until either a message with the specified correlation identifier is available in the queue, or the time-out expires.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método examina a fila referenciada pelo <xref:System.Messaging.MessageQueue> para uma mensagem cujo <xref:System.Messaging.Message.CorrelationId%2A> corresponde especificado `correlationId` parâmetro. Se nenhuma mensagem for encontrada que corresponda a `correlationID` parâmetro e nenhuma nova mensagem chega na fila de dentro do período especificado o `timeout` parâmetro, uma exceção será lançada.  
  
 O `timeout` parâmetro não especifica o total de tempo para esse método de execução. Em vez disso, ele especifica o tempo de espera por uma nova mensagem chegar na fila. Cada vez que uma nova mensagem chega, este método examina o <xref:System.Messaging.Message.CorrelationId%2A> da nova mensagem para ver se ele corresponde a `correlationId` parâmetro. Caso contrário, esse método inicia o período de tempo limite em e aguarda até que outra nova mensagem chegue. Portanto, se continuarem novas mensagens chegarem dentro do período de tempo limite, é possível para esse método continuar a executar indefinidamente, até que o período de tempo limite expira sem novas mensagens que chegam, ou até que uma mensagem chega cujo <xref:System.Messaging.Message.CorrelationId%2A> corresponde a `correlationId` parâmetro.  
  
 O <xref:System.Messaging.Message.CorrelationId%2A> propriedade é usada para ligar uma mensagem enviada para a fila de mensagens de resposta, relatório ou confirmação associadas.  
  
 Dois outros métodos permitem que você inspecionar mensagens em uma fila. O <xref:System.Messaging.MessageQueue.Peek%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método é usado para recuperar uma mensagem especificando seu identificador exclusivo.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#5](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#5)]
 [!code-csharp[MessageQueue2#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="correlationId" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">The message with the specified <paramref name="correlationId" /> does not exist in the queue and did not arrive before the time-out expired.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A message did not arrive before the time-out expired.  -or-  An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a copy of the message that has the specified message identifier without removing the message from the queue.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">The <see cref="P:System.Messaging.Message.Id" /> of the message to peek.</param>
        <summary>Peeks the message whose message identifier matches the <paramref name="id" /> parameter.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> ler sem remover da fila, uma mensagem que tem um identificador de mensagem conhecidos. O identificador de uma mensagem é exclusivo em toda a empresa de enfileiramento de mensagens, para que haja no máximo uma mensagem na fila que corresponde a determinado `id` parâmetro. Essa sobrecarga lança uma exceção se a fila não contém a mensagem no momento.  
  
 Dois métodos adicionais permitem a você inspecionar mensagens em uma fila: <xref:System.Messaging.MessageQueue.Peek%2A> e <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. O <xref:System.Messaging.MessageQueue.Peek%2A> método retorna a primeira mensagem na fila; <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> retorna uma confirmação, o relatório ou a mensagem de resposta geradas pelo aplicativo que foi criada como resultado de uma mensagem enviada para a fila.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#6](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#6)]
 [!code-csharp[MessageQueue2#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="id" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">No message with the specified <paramref name="id" /> exists.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">The <see cref="P:System.Messaging.Message.Id" /> of the message to peek.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</param>
        <summary>Peeks the message whose message identifier matches the <paramref name="id" /> parameter. Waits until the message appears in the queue or a time-out occurs.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> ler sem remover da fila, uma mensagem que tem um identificador de mensagem conhecidos. O identificador de uma mensagem é exclusivo em toda a empresa de enfileiramento de mensagens, para que haja no máximo uma mensagem na fila que corresponde a determinado `id` parâmetro. Essa sobrecarga lança uma exceção se a fila não contém a mensagem no momento e uma nova mensagem chegou antes do tempo limite ocorre.  
  
 O `timeout` parâmetro não especifica o total de tempo para esse método de execução. Em vez disso, ele especifica o tempo de espera por uma nova mensagem chegar na fila. Cada vez que uma nova mensagem chega, este método examina o <xref:System.Messaging.Message.Id%2A> da nova mensagem para ver se ele corresponde a `id` parâmetro. Caso contrário, esse método inicia o período de tempo limite em e aguarda até que outra nova mensagem chegue. Portanto, se continuarem novas mensagens chegarem dentro do período de tempo limite, é possível para esse método continuar a executar indefinidamente, até que o período de tempo limite expira sem novas mensagens que chegam, ou até que uma mensagem chega cujo <xref:System.Messaging.Message.Id%2A> corresponde a `id` parâmetro.  
  
 Dois métodos adicionais permitem a você inspecionar mensagens em uma fila: <xref:System.Messaging.MessageQueue.Peek%2A> e <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. O <xref:System.Messaging.MessageQueue.Peek%2A> método retorna a primeira mensagem na fila; <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> retorna uma confirmação, o relatório ou a mensagem de resposta geradas pelo aplicativo que foi criada como resultado de uma mensagem enviada para a fila.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#7](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#7)]
 [!code-csharp[MessageQueue2#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="id" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">The message with the specified <paramref name="id" /> does not exist in the queue and did not arrive before the period specified by the <paramref name="timeout" /> parameter expired.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Introduced in MSMQ 3.0. Peeks at a specific message from the queue. The message can be specified by a lookup identifier or by its position at the front or end of the queue.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">The <see cref="P:System.Messaging.Message.LookupId" /> of the message to peek at.</param>
        <summary>Introduced in MSMQ 3.0. Peeks at the message that matches the given lookup identifier from a non-transactional queue.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.LookupId" /> property matches the <paramref name="lookupId" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador de pesquisa conhecidos sem removê-la da fila. Este método lança uma exceção imediatamente a mensagem não está na fila.  
  
 O <xref:System.Messaging.Message.LookupId%2A> propriedade de uma mensagem é exclusiva para a fila onde reside a mensagem, para que haja no máximo uma mensagem na fila que corresponde a determinado `lookupId` parâmetro.  
  
 Para ler uma mensagem com um identificador de pesquisa especificado e remova-a da fila, use o <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> método.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 is not installed.</exception>
        <exception cref="T:System.InvalidOperationException">The message with the specified <paramref name="lookupId" /> could not be found.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (System.Messaging.MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (action As MessageLookupAction, lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(System::Messaging::MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : System.Messaging.MessageLookupAction * int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId (action, lookupId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="action">One of the <see cref="T:System.Messaging.MessageLookupAction" /> values, specifying how the message is read in the queue. Specify one of the following:  <see langword="MessageLookupAction.Current" />: Peeks at the message specified by <c>lookupId</c>.  
  
 <see langword="MessageLookupAction.Next" />: Peeks at the message following the message specified by <c>lookupId</c>.  
  
 <see langword="MessageLookupAction.Previous" />: Peeks at the message preceding the message specified by <c>lookupId</c>.  
  
 <see langword="MessageLookupAction.First" />: Peeks at the first message in the queue. The <c>lookupId</c> parameter must be set to 0.  
  
 <see langword="MessageLookupAction.Last" />: Peeks at the last message in the queue. The <c>lookupId</c> parameter must be set to 0.</param>
        <param name="lookupId">The <see cref="P:System.Messaging.Message.LookupId" /> of the message to peek at, or 0. 0 is used when accessing the first or last message in the queue.</param>
        <summary>Introduced in MSMQ 3.0. Peeks at a specific message from the queue. The message can be specified by a lookup identifier or by its position at the front or end of the queue.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> specified by the <paramref name="action" /> and <paramref name="lookupId" /> parameters passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador de pesquisa conhecidos sem removê-la da fila. Este método lança uma exceção imediatamente a mensagem não está na fila.  
  
 O <xref:System.Messaging.Message.LookupId%2A> propriedade de uma mensagem é exclusiva para a fila onde reside a mensagem, para que haja no máximo uma mensagem na fila que corresponde a determinado `lookupId` parâmetro.  
  
 Para ler uma mensagem com um identificador especificado e removê-la da fila, use o <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> método.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 is not installed.</exception>
        <exception cref="T:System.InvalidOperationException">The message with the specified <paramref name="lookupId" /> could not be found.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The <paramref name="action" /> parameter is not one of the <see cref="T:System.Messaging.MessageLookupAction" /> members.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.PeekCompletedEventHandler PeekCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.PeekCompletedEventHandler PeekCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.PeekCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PeekCompleted As PeekCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::PeekCompletedEventHandler ^ PeekCompleted;" />
      <MemberSignature Language="F#" Value="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " Usage="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_PeekCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.PeekCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a message is read without being removed from the queue. This is a result of the asynchronous operation, <see cref="M:System.Messaging.MessageQueue.BeginPeek" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> é usada no processamento assíncrono para gerar o <xref:System.Messaging.MessageQueue.PeekCompleted> quando uma mensagem fica disponível na fila de eventos.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> é usado para concluir a operação iniciada por uma chamada para <xref:System.Messaging.MessageQueue.BeginPeek%2A> e inspecionar mensagem quando o <xref:System.Messaging.MessageQueue.PeekCompleted> é gerado.  
  
 Quando você cria um <xref:System.Messaging.PeekCompletedEventHandler> delegado, você identificar o método que manipulará o evento. Para associar o evento com o manipulador de eventos, adicione uma instância do representante ao evento. O manipulador de eventos é chamado sempre que o evento ocorre, a menos que você remova o representante. Para obter mais informações sobre delegados de manipulador de eventos, consulte [tratamento e gerando eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 O exemplo de código a seguir cria um manipulador de eventos chamado `MyPeekCompleted`, anexa-o para o <xref:System.Messaging.MessageQueue.PeekCompleted> representante do manipulador de eventos e chamadas <xref:System.Messaging.MessageQueue.BeginPeek%2A> para iniciar uma operação assíncrona inspecionar na fila que está localizada no caminho ". \myQueue". Quando um <xref:System.Messaging.MessageQueue.PeekCompleted> é gerado, o exemplo exibe a mensagem e grava seu corpo para a tela. O exemplo, em seguida, chama <xref:System.Messaging.MessageQueue.BeginPeek%2A> novamente para iniciar uma nova operação assíncrona de pico  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="public void Purge ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Purge() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Purge" />
      <MemberSignature Language="VB.NET" Value="Public Sub Purge ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Purge();" />
      <MemberSignature Language="F#" Value="member this.Purge : unit -&gt; unit" Usage="messageQueue.Purge " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Deletes all the messages contained in the queue.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Limpar a fila faz com que o enfileiramento de mensagens definir o sinalizador de modificação de fila, que afeta o <xref:System.Messaging.MessageQueue.LastModifyTime%2A> propriedade. As mensagens são limpos da fila são perdidas; eles não são enviados para a fila de mensagens mortas ou a fila de diário.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.Purge%2A>.  
  
 [!code-cpp[MessageQueue2#29](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#29)]
 [!code-csharp[MessageQueue2#29](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="M:System.Messaging.MessageQueue.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="QueueName">
      <MemberSignature Language="C#" Value="public string QueueName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QueueName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.QueueName" />
      <MemberSignature Language="VB.NET" Value="Public Property QueueName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ QueueName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.QueueName : string with get, set" Usage="System.Messaging.MessageQueue.QueueName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_QueueName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the friendly name that identifies the queue.</summary>
        <value>O nome que identifica a fila referenciada por essa <see cref="T:System.Messaging.MessageQueue" />. O valor não pode ser <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode combinar o <xref:System.Messaging.MessageQueue.QueueName%2A> com o <xref:System.Messaging.MessageQueue.MachineName%2A> para criar um amigável <xref:System.Messaging.MessageQueue.Path%2A> nome para a fila. A sintaxe para a variação do nome amigável do <xref:System.Messaging.MessageQueue.Path%2A> propriedade depende do tipo de fila, conforme mostrado na tabela a seguir.  
  
|Tipo de fila|Sintaxe|  
|----------------|------------|  
|Fila pública|`MachineName`\\`QueueName`|  
|Fila particular|`MachineName`\\`Private$`\\`QueueName`|  
|Fila de diário|`MachineName`\\`QueueName`\\`Journal$`|  
  
 Use "." para representar o computador local.  
  
 Alterando o <xref:System.Messaging.MessageQueue.QueueName%2A> propriedade afeta o <xref:System.Messaging.MessageQueue.Path%2A> propriedade. Se você definir o <xref:System.Messaging.MessageQueue.QueueName%2A> sem definir o <xref:System.Messaging.MessageQueue.MachineName%2A> propriedade, o <xref:System.Messaging.MessageQueue.Path%2A> propriedade torna-se.\\ `QueueName`. Caso contrário, o <xref:System.Messaging.MessageQueue.Path%2A> se torna `MachineName` \\ `QueueName`.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.QueueName%2A> propriedade.  
  
 [!code-csharp[MessageQueue#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The queue name is <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="ReadHandle">
      <MemberSignature Language="C#" Value="public IntPtr ReadHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ReadHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.ReadHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ReadHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadHandle : nativeint" Usage="System.Messaging.MessageQueue.ReadHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReadHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the native handle used to read messages from the message queue.</summary>
        <value>Um identificador para o objeto de fila nativo que você usa para exibir e receber mensagens da fila.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.MessageQueue.ReadHandle%2A> fornece um identificador nativo do Windows para o objeto de fila de mensagem que é usado para inspecionar e receber mensagens da fila. Se você alterar o caminho da fila, o identificador é fechado e reaberto com um novo valor.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <summary>Receives the first message in the queue, removing it from the queue.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive();" />
      <MemberSignature Language="F#" Value="member this.Receive : unit -&gt; System.Messaging.Message" Usage="messageQueue.Receive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Receives the first message available in the queue referenced by the <see cref="T:System.Messaging.MessageQueue" />. This call is synchronous, and blocks the current thread of execution until a message is available.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para receber uma mensagem de uma fila ou aguarde até que haja mensagens na fila.  
  
 O <xref:System.Messaging.MessageQueue.Receive%2A> método permite a leitura síncrona de uma mensagem, removendo-la da fila. As chamadas subsequentes para <xref:System.Messaging.MessageQueue.Receive%2A> retornará as mensagens que execute na fila ou novo, as mensagens de alta prioridade.  
  
 Para ler a primeira mensagem em uma fila sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método. O <xref:System.Messaging.MessageQueue.Peek%2A> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila.  
  
 Use uma chamada para <xref:System.Messaging.MessageQueue.Receive%2A> quando é aceitável para o thread atual a ser bloqueado enquanto aguarda uma mensagem para chegar na fila. Como essa sobrecarga do <xref:System.Messaging.MessageQueue.Receive%2A> método Especifica um tempo limite infinito, o aplicativo pode aguardar indefinidamente. Se o processamento do aplicativo deve continuar sem esperar que a mensagem, considere usar o método assíncrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir recebe uma mensagem de uma fila e envia informações sobre essa mensagem para a tela.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</param>
        <summary>Receives the first message available in the transactional queue referenced by the <see cref="T:System.Messaging.MessageQueue" />. This call is synchronous, and blocks the current thread of execution until a message is available.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para receber uma mensagem de uma fila transacional usando o contexto de transação interna definido pelo `transaction` parâmetro ou aguarde até que haja mensagens na fila.  
  
 O <xref:System.Messaging.MessageQueue.Receive%2A> método permite a leitura síncrona de uma mensagem, removendo-la da fila. As chamadas subsequentes para <xref:System.Messaging.MessageQueue.Receive%2A> retornará as mensagens que execute na fila.  
  
 Como esse método é chamado em uma fila transacional, a mensagem recebida será retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 Para ler a primeira mensagem em uma fila sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método. O <xref:System.Messaging.MessageQueue.Peek%2A> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.Peek%2A>. Porque <xref:System.Messaging.MessageQueue.Peek%2A> não remove quaisquer mensagens na fila, não haveria nada para reverter por uma chamada para <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Use uma chamada para <xref:System.Messaging.MessageQueue.Receive%2A> quando é aceitável para o thread atual a ser bloqueado enquanto aguarda uma mensagem para chegar na fila. Como essa sobrecarga do <xref:System.Messaging.MessageQueue.Receive%2A> método Especifica um tempo limite infinito, o aplicativo pode aguardar indefinidamente. Se o processamento do aplicativo deve continuar sem esperar que a mensagem, considere usar o método assíncrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir se conecta a uma fila transacional no computador local e envia uma mensagem à fila. Em seguida, ele recebe a mensagem que contém um pedido. Se ele encontrar uma fila não transacional, ela irá gerar e exceção e reverter a transação.  
  
 [!code-cpp[MessageQueue.Receive_transaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CPP/mqreceive_transaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_transaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CS/mqreceive_transaction.cs#1)]
 [!code-vb[MessageQueue.Receive_transaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_transaction/VB/mqreceive_transaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.  -or-  The queue is non-transactional.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</param>
        <summary>Receives the first message available in the queue referenced by the <see cref="T:System.Messaging.MessageQueue" />. This call is synchronous, and blocks the current thread of execution until a message is available.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para receber uma mensagem de uma fila usando um contexto de transação definido pelo `transactionType` parâmetro ou aguarde até que haja mensagens na fila.  
  
 Especifique `Automatic` para o `transactionType` parâmetro se já houver um contexto de transação externa é anexado ao thread que você deseja usar para receber a mensagem. Especificar `Single` se você deseja receber a mensagem como uma única transação interna. Você pode especificar `None` se você quiser receber uma mensagem de uma fila transacional fora de um contexto de transação.  
  
 O <xref:System.Messaging.MessageQueue.Receive%2A> método permite a leitura síncrona de uma mensagem, removendo-la da fila. As chamadas subsequentes para <xref:System.Messaging.MessageQueue.Receive%2A> retornará as mensagens que execute na fila.  
  
 Se esse método é chamado para receber uma mensagem de uma fila transacional, a mensagem é recebida será retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 Para ler a primeira mensagem em uma fila sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método. O <xref:System.Messaging.MessageQueue.Peek%2A> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.Peek%2A>. Porque <xref:System.Messaging.MessageQueue.Peek%2A> não remove quaisquer mensagens na fila, não haveria nada para reverter por uma chamada para <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Use uma chamada para <xref:System.Messaging.MessageQueue.Receive%2A> quando é aceitável para o thread atual a ser bloqueado enquanto aguarda uma mensagem para chegar na fila. Como essa sobrecarga do <xref:System.Messaging.MessageQueue.Receive%2A> método Especifica um tempo limite infinito, o aplicativo pode aguardar indefinidamente. Se o processamento do aplicativo deve continuar sem esperar que a mensagem, considere usar o método assíncrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#9](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#9)]
 [!code-csharp[MessageQueue2#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Receive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</param>
        <summary>Receives the first message available in the queue referenced by the <see cref="T:System.Messaging.MessageQueue" /> and waits until either a message is available in the queue, or the time-out expires.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para receber uma mensagem e retorná-la em um período de tempo especificado se não houver mensagens na fila.  
  
 O <xref:System.Messaging.MessageQueue.Receive%2A> método permite a leitura síncrona de uma mensagem, a remoção da fila. As chamadas subsequentes para <xref:System.Messaging.MessageQueue.Receive%2A> retornará as mensagens que execute na fila ou novo, as mensagens de alta prioridade.  
  
 Para ler a primeira mensagem em uma fila sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método. O <xref:System.Messaging.MessageQueue.Peek%2A> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila.  
  
 Use uma chamada para <xref:System.Messaging.MessageQueue.Receive%2A> quando é aceitável para o thread atual a ser bloqueado enquanto aguarda uma mensagem para chegar na fila. O thread será bloqueado para o período de tempo ou indefinidamente se você especificou o valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para o `timeout` parâmetro. Se o processamento do aplicativo deve continuar sem esperar por uma mensagem, considere usar o método assíncrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir recebe uma mensagem de uma fila e envia informações sobre essa mensagem para a tela. O exemplo pausa a execução por até cinco segundos, enquanto aguarda uma mensagem para chegar na fila.  
  
 [!code-cpp[MessageQueue.Receive_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CPP/mqreceive_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Receive_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CS/mqreceive_timeout.cs#1)]
 [!code-vb[MessageQueue.Receive_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_timeout/VB/mqreceive_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A message did not arrive in the queue before the time-out expired.  -or-  An error occurred when accessing a Message Queuing method</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> that maintains a specific position in the message queue.</param>
        <summary>Receives the current message in the queue, using a specified cursor. If no message is available, this method waits until either a message is available, or the time-out expires.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A message did not arrive in the queue before the time-out expired.  -or-  An error occurred when accessing a Message Queuing method  Use this overload to receive a message and return in a specified period of time if there are no messages in the queue.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</param>
        <param name="transaction">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</param>
        <summary>Receives the first message available in the transactional queue referenced by the <see cref="T:System.Messaging.MessageQueue" /> and waits until either a message is available in the queue, or the time-out expires.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para receber uma mensagem de uma fila transacional usando o contexto de transação interna definido pelo `transaction` parâmetro e retornar em um período especificado de tempo se não existem mensagens na fila.  
  
 O <xref:System.Messaging.MessageQueue.Receive%2A> método permite a leitura síncrona de uma mensagem, removendo-la da fila. As chamadas subsequentes para <xref:System.Messaging.MessageQueue.Receive%2A> retornará as mensagens que execute na fila.  
  
 Como esse método é chamado em uma fila transacional, a mensagem recebida será retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 Para ler a primeira mensagem em uma fila sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método. O <xref:System.Messaging.MessageQueue.Peek%2A> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.Peek%2A>. Porque <xref:System.Messaging.MessageQueue.Peek%2A> não remove quaisquer mensagens na fila, não haveria nada para reverter por uma chamada para <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Use uma chamada para <xref:System.Messaging.MessageQueue.Receive%2A> quando é aceitável para o thread atual a ser bloqueado enquanto aguarda uma mensagem para chegar na fila. O thread será bloqueado para o período de tempo ou indefinidamente se você especificou o valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para o `timeout` parâmetro. Se o processamento do aplicativo deve continuar sem esperar por uma mensagem, considere usar o método assíncrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso deste método.  
  
 [!code-cpp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CPP/mqreceive_timeouttransaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CS/mqreceive_timeouttransaction.cs#1)]
 [!code-vb[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/VB/mqreceive_timeouttransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A message did not arrive in the queue before the time-out expired.  -or-  The queue is non-transactional.  -or-  An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</param>
        <param name="transactionType">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</param>
        <summary>Receives the first message available in the queue referenced by the <see cref="T:System.Messaging.MessageQueue" />. This call is synchronous, and waits until either a message is available in the queue, or the time-out expires.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para receber uma mensagem de uma fila usando um contexto de transação definido pelo `transactionType` parâmetro e retornar em um período especificado de tempo se não existem mensagens na fila.  
  
 Especifique `Automatic` para o `transactionType` parâmetro se já houver um contexto de transação externa é anexado ao thread que você deseja usar para receber a mensagem. Especificar `Single` se você deseja receber a mensagem como uma única transação interna. Você pode especificar `None` se você quiser receber uma mensagem de uma fila transacional fora de um contexto de transação.  
  
 O <xref:System.Messaging.MessageQueue.Receive%2A> método permite a leitura síncrona de uma mensagem, removendo-la da fila. As chamadas subsequentes para <xref:System.Messaging.MessageQueue.Receive%2A> retornará as mensagens que execute na fila.  
  
 Se esse método é chamado para receber uma mensagem de uma fila transacional, a mensagem é recebida será retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 Para ler a primeira mensagem em uma fila sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método. O <xref:System.Messaging.MessageQueue.Peek%2A> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.Peek%2A>. Porque <xref:System.Messaging.MessageQueue.Peek%2A> não remove quaisquer mensagens na fila, não haveria nada para reverter por uma chamada para <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Use uma chamada para <xref:System.Messaging.MessageQueue.Receive%2A> quando é aceitável para o thread atual a ser bloqueado enquanto aguarda uma mensagem para chegar na fila. O thread será bloqueado para o período de tempo ou indefinidamente se você especificou o valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para o `timeout` parâmetro. Se o processamento do aplicativo deve continuar sem esperar por uma mensagem, considere usar o método assíncrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso deste método.  
  
 [!code-cpp[MessageQueue2#8](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#8)]
 [!code-csharp[MessageQueue2#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A message did not arrive in the queue before the time-out expired.  -or-  An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> that maintains a specific position in the message queue.</param>
        <param name="transaction">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</param>
        <summary>Receives the current message in the queue, using a specified cursor. If no message is available, this method waits until either a message is available, or the time-out expires.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references a message in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para receber uma mensagem de uma fila transacional usando o contexto de transação interna definido pelo `transaction` parâmetro e retornar em um período especificado de tempo se não existem mensagens na fila.  
  
 O <xref:System.Messaging.MessageQueue.Receive%2A> método permite a leitura síncrona de uma mensagem, removendo-la da fila. As chamadas subsequentes para <xref:System.Messaging.MessageQueue.Receive%2A> retornar as mensagens que execute na fila.  
  
 Como esse método é chamado em uma fila transacional, a mensagem recebida é retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 Para ler uma mensagem em uma fila sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.Peek%2A>. Porque <xref:System.Messaging.MessageQueue.Peek%2A> não remove quaisquer mensagens na fila, não há nada para reverter por uma chamada para <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Use uma chamada para <xref:System.Messaging.MessageQueue.Receive%2A> quando é aceitável para o thread atual a ser bloqueado enquanto aguarda uma mensagem para chegar na fila. O thread está bloqueado para o período de tempo ou indefinidamente se você especificou o valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para o `timeout` parâmetro. Se o processamento do aplicativo deve continuar sem esperar por uma mensagem, considere usar o método assíncrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="cursor" /> parameter is <see langword="null" />.  -or-  The <paramref name="transaction" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid. Possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A message did not arrive in the queue before the time-out expired.  -or-  The queue is non-transactional.  -or-  An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> that maintains a specific position in the message queue.</param>
        <param name="transactionType">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values that describes the type of transaction context to associate with the message.</param>
        <summary>Receives the current message in the queue, using a specified cursor. If no message is available, this method waits until either a message is available, or the time-out expires.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> that references a message in the queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para receber uma mensagem de uma fila usando um contexto de transação definido pelo `transactionType` parâmetro e retornar em um período especificado de tempo se não existem mensagens na fila.  
  
 Especifique `Automatic` para o `transactionType` parâmetro se já houver um contexto de transação externa é anexado ao thread que você deseja usar para receber a mensagem. Especificar `Single` se você deseja receber a mensagem como uma única transação interna. Você pode especificar `None` se você quiser receber uma mensagem de uma fila transacional fora de um contexto de transação.  
  
 O <xref:System.Messaging.MessageQueue.Receive%2A> método permite a leitura síncrona de uma mensagem, removendo-la da fila. As chamadas subsequentes para <xref:System.Messaging.MessageQueue.Receive%2A> retornar as mensagens que execute na fila.  
  
 Se esse método é chamado para receber uma mensagem de uma fila transacional, a mensagem recebida é retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 Para ler uma mensagem em uma fila sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.Peek%2A>. Porque <xref:System.Messaging.MessageQueue.Peek%2A> não remove quaisquer mensagens na fila, não há nada para reverter por uma chamada para <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Use uma chamada para <xref:System.Messaging.MessageQueue.Receive%2A> quando é aceitável para o thread atual a ser bloqueado enquanto aguarda uma mensagem para chegar na fila. O thread está bloqueado para o período de tempo ou indefinidamente se você especificou o valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para o `timeout` parâmetro. Se o processamento do aplicativo deve continuar sem esperar por uma mensagem, considere usar o método assíncrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="cursor" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid. Possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A message did not arrive in the queue before the time-out expired.  -or-  An error occurred when accessing a Message Queuing method.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Receives a message that matches a given correlation identifier.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to receive.</param>
        <summary>Receives the message that matches the given correlation identifier (from a non-transactional queue) and immediately raises an exception if no message with the specified correlation identifier currently exists in the queue.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método examina a fila não transacional referenciada pelo <xref:System.Messaging.MessageQueue> para uma mensagem cujo <xref:System.Messaging.Message.CorrelationId%2A> corresponde especificado `correlationId` parâmetro. Se nenhuma mensagem for encontrada que corresponda a `correlationID` parâmetro, uma exceção será lançada. Caso contrário, a mensagem é removida da fila e retornada ao aplicativo.  
  
 O <xref:System.Messaging.Message.CorrelationId%2A> propriedade é usada para ligar uma mensagem enviada para a fila de mensagens de resposta, relatório ou confirmação associadas.  
  
 Dois outros métodos permitem que você receber mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> método recupera uma mensagem especificando seu identificador exclusivo.  
  
 Para ler uma mensagem com um identificador de correlação especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir envia e recebe uma mensagem que contém um pedido de e para uma fila. Ele solicita uma confirmação positiva especificamente quando a mensagem original atinge ou é recuperada da fila.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="correlationId" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The message with the specified <paramref name="correlationId" /> could not be found.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to receive.</param>
        <param name="transaction">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</param>
        <summary>Receives the message that matches the given correlation identifier (from a transactional queue) and immediately raises an exception if no message with the specified correlation identifier currently exists in the queue.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método examina a fila transacional referenciada pelo <xref:System.Messaging.MessageQueue> para uma mensagem cujo <xref:System.Messaging.Message.CorrelationId%2A> corresponde especificado `correlationId` parâmetro. Se nenhuma mensagem for encontrada que corresponda a `correlationID` parâmetro, uma exceção será lançada. Caso contrário, a mensagem é removida da fila e retornada para o aplicativo usando o contexto de transação interna definido pelo `transaction` parâmetro.  
  
 Como esse método é chamado em uma fila transacional, a mensagem recebida será retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 O <xref:System.Messaging.Message.CorrelationId%2A> propriedade é usada para ligar uma mensagem enviada para a fila de mensagens de resposta, relatório ou confirmação associadas.  
  
 Dois outros métodos permitem que você receber mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> método é usado para recuperar uma mensagem especificando seu identificador exclusivo.  
  
 Para ler uma mensagem com um identificador de correlação especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Porque <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> não remove quaisquer mensagens na fila, não haveria nada para ser revertida se a transação foi anulada.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#14](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#14)]
 [!code-csharp[MessageQueue2#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="correlationId" /> parameter is <see langword="null" />.  -or-  The <paramref name="transaction" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The message with the specified <paramref name="correlationId" /> could not be found.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The queue is non-transactional.  -or-  An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to receive.</param>
        <param name="transactionType">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</param>
        <summary>Receives the message that matches the given correlation identifier and immediately raises an exception if no message with the specified correlation identifier currently exists in the queue.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método examina a fila referenciada pelo <xref:System.Messaging.MessageQueue> para uma mensagem cujo <xref:System.Messaging.Message.CorrelationId%2A> corresponde especificado `correlationId` parâmetro. Se nenhuma mensagem for encontrada que corresponda a `correlationID` parâmetro, uma exceção será lançada. Caso contrário, a mensagem é removida da fila e retornada para o aplicativo usando um contexto de transação definido pelo `transactionType` parâmetro.  
  
 Especifique `Automatic` para o `transactionType` parâmetro se já houver um contexto de transação externa é anexado ao thread que você deseja usar para receber a mensagem. Especificar `Single` se você deseja receber a mensagem como uma única transação interna. Você pode especificar `None` se você quiser receber uma mensagem de uma fila transacional fora de um contexto de transação.  
  
 Se esse método é chamado para receber uma mensagem de uma fila transacional, a mensagem é recebida será retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 O <xref:System.Messaging.Message.CorrelationId%2A> propriedade é usada para ligar uma mensagem enviada para a fila de mensagens de resposta, relatório ou confirmação associadas.  
  
 Dois outros métodos permitem que você receber mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> método é usado para recuperar uma mensagem especificando seu identificador exclusivo.  
  
 Para ler uma mensagem com um identificador de correlação especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Porque <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> não remove quaisquer mensagens na fila, não haveria nada para ser revertida se a transação foi anulada.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#11](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#11)]
 [!code-csharp[MessageQueue2#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="correlationId" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The message with the specified <paramref name="correlationId" /> could not be found.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to receive.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</param>
        <summary>Receives the message that matches the given correlation identifier (from a non-transactional queue) and waits until either a message with the specified correlation identifier is available in the queue, or the time-out expires.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método examina a fila não transacional referenciada pelo <xref:System.Messaging.MessageQueue> para uma mensagem cujo <xref:System.Messaging.Message.CorrelationId%2A> corresponde especificado `correlationId` parâmetro. Este método retorna imediatamente se a mensagem com o identificador de correlação especificado o `correlationId` parâmetro está na fila. Caso contrário, o método aguarda por determinado período de tempo para uma nova mensagem chegue. Se uma nova mensagem não chegar antes do tempo limite expirar, uma exceção será lançada.  
  
 O `timeout` parâmetro não especifica o total de tempo para esse método de execução. Em vez disso, ele especifica o tempo de espera por uma nova mensagem chegar na fila. Cada vez que uma nova mensagem chega, este método examina o <xref:System.Messaging.Message.CorrelationId%2A> da nova mensagem para ver se ele corresponde a `correlationId` parâmetro. Caso contrário, esse método inicia o período de tempo limite em e aguarda até que outra nova mensagem chegue. Portanto, se continuarem novas mensagens chegarem dentro do período de tempo limite, é possível para esse método continuar a executar indefinidamente, até que o período de tempo limite expira sem novas mensagens que chegam, ou até que uma mensagem chega cujo <xref:System.Messaging.Message.CorrelationId%2A> corresponde a `correlationId` parâmetro.  
  
 O <xref:System.Messaging.Message.CorrelationId%2A> propriedade é usada para ligar uma mensagem enviada para a fila de mensagens de resposta, relatório ou confirmação associadas.  
  
 Dois outros métodos permitem que você receber mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> método é usado para recuperar uma mensagem especificando seu identificador exclusivo.  
  
 Para ler uma mensagem com um identificador de correlação especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#10](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#10)]
 [!code-csharp[MessageQueue2#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="correlationId" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The message with the specified <paramref name="correlationId" /> does not exist in the queue and did not arrive before the time-out expired.  -or-  An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to receive.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</param>
        <param name="transaction">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</param>
        <summary>Receives the message that matches the given correlation identifier (from a transactional queue) and waits until either a message with the specified correlation identifier is available in the queue, or the time-out expires.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método examina a fila transacional referenciada pelo <xref:System.Messaging.MessageQueue> para uma mensagem cujo <xref:System.Messaging.Message.CorrelationId%2A> corresponde especificado `correlationId` parâmetro. Esse método retorna imediatamente quando a mensagem com o identificador de correlação especificado pelo `correlationId` parâmetro está na fila, usando o contexto de transação interna definido pelo `transaction` parâmetro. Caso contrário, o método aguarda por determinado período de tempo para uma nova mensagem chegue. Se uma nova mensagem não chegar antes do tempo limite expirar, uma exceção será lançada.  
  
 O `timeout` parâmetro não especifica o total de tempo para esse método de execução. Em vez disso, ele especifica o tempo de espera por uma nova mensagem chegar na fila. Cada vez que uma nova mensagem chega, este método examina o <xref:System.Messaging.Message.CorrelationId%2A> da nova mensagem para ver se ele corresponde a `correlationId` parâmetro. Caso contrário, esse método inicia o período de tempo limite em e aguarda até que outra nova mensagem chegue. Portanto, se continuarem novas mensagens chegarem dentro do período de tempo limite, é possível para esse método continuar a executar indefinidamente, até que o período de tempo limite expira sem novas mensagens que chegam, ou até que uma mensagem chega cujo <xref:System.Messaging.Message.CorrelationId%2A> corresponde a `correlationId` parâmetro.  
  
 Como esse método é chamado em uma fila transacional, a mensagem recebida será retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 O <xref:System.Messaging.Message.CorrelationId%2A> propriedade é usada para ligar uma mensagem enviada para a fila de mensagens de resposta, relatório ou confirmação associadas.  
  
 Dois outros métodos permitem que você receber mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> método é usado para recuperar uma mensagem especificando seu identificador exclusivo.  
  
 Para ler uma mensagem com um identificador de correlação especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Porque <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> não remove quaisquer mensagens na fila, não haveria nada para ser revertida se a transação foi anulada.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#13](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#13)]
 [!code-csharp[MessageQueue2#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="correlationId" /> parameter is <see langword="null" />.  -or-  The <paramref name="transaction" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The message with the specified <paramref name="correlationId" /> does not exist in the queue and did not arrive before the time-out expired.  -or-  The queue is non-transactional.  -or-  An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">The <see cref="P:System.Messaging.Message.CorrelationId" /> of the message to receive.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</param>
        <param name="transactionType">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</param>
        <summary>Receives the message that matches the given correlation identifier and waits until either a message with the specified correlation identifier is available in the queue, or the time-out expires.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.CorrelationId" /> matches the <paramref name="correlationId" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método examina a fila referenciada pelo <xref:System.Messaging.MessageQueue> para uma mensagem cujo <xref:System.Messaging.Message.CorrelationId%2A> corresponde especificado `correlationId` parâmetro. Este método retorna imediatamente se a mensagem com o identificador de correlação especificado o `correlationId` parâmetro está na fila, usando um contexto de transação definido pelo `transactionType` parâmetro. Caso contrário, o método aguarda por determinado período de tempo para uma nova mensagem chegue. Se uma nova mensagem não chegar antes do tempo limite expirar, uma exceção será lançada.  
  
 O `timeout` parâmetro não especifica o total de tempo para esse método de execução. Em vez disso, ele especifica o tempo de espera por uma nova mensagem chegar na fila. Cada vez que uma nova mensagem chega, este método examina o <xref:System.Messaging.Message.CorrelationId%2A> da nova mensagem para ver se ele corresponde a `correlationId` parâmetro. Caso contrário, esse método inicia o período de tempo limite em e aguarda até que outra nova mensagem chegue. Portanto, se continuarem novas mensagens chegarem dentro do período de tempo limite, é possível para esse método continuar a executar indefinidamente, até que o período de tempo limite expira sem novas mensagens que chegam, ou até que uma mensagem chega cujo <xref:System.Messaging.Message.CorrelationId%2A> corresponde a `correlationId` parâmetro. Especifique `Automatic` para o `transactionType` parâmetro se já houver um contexto de transação externa é anexado ao thread que você deseja usar para receber a mensagem. Especificar `Single` se você deseja receber a mensagem como uma única transação interna. Você pode especificar `None` se você quiser receber uma mensagem de uma fila transacional fora de um contexto de transação.  
  
 Se esse método é chamado para receber uma mensagem de uma fila transacional, a mensagem é recebida será retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 O <xref:System.Messaging.Message.CorrelationId%2A> propriedade é usada para ligar uma mensagem enviada para a fila de mensagens de resposta, relatório ou confirmação associadas.  
  
 Dois outros métodos permitem que você receber mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> método é usado para recuperar uma mensagem especificando seu identificador exclusivo.  
  
 Para ler uma mensagem com um identificador de correlação especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Porque <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> não remove quaisquer mensagens na fila, não haveria nada para ser revertida se a transação foi anulada.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#12](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#12)]
 [!code-csharp[MessageQueue2#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="correlationId" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The message with the specified <paramref name="correlationId" /> could not be found.</exception>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The message with the specified <paramref name="correlationId" /> does not exist in the queue and did not arrive before the time-out expired.  -or-  An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Receives the message that matches the given identifier, removing it from the queue.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">The <see cref="P:System.Messaging.Message.Id" /> of the message to receive.</param>
        <summary>Receives the message that matches the given identifier from a non-transactional queue and immediately raises an exception if no message with the specified identifier currently exists in the queue.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador conhecido e removê-la da fila. Este método lança uma exceção imediatamente a mensagem não está na fila.  
  
 O <xref:System.Messaging.Message.Id%2A> propriedade de uma mensagem é exclusiva em toda a empresa de enfileiramento de mensagens, para que haja no máximo uma mensagem na fila que corresponde a determinado `id` parâmetro.  
  
 Dois outros métodos permitem que você receber mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> método é usado para recuperar uma confirmação, o relatório ou a mensagem de resposta geradas pelo aplicativo que foi criada como resultado de uma mensagem enviada para a fila.  
  
 Para ler uma mensagem com um identificador especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#16](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#16)]
 [!code-csharp[MessageQueue2#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="id" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The message with the specified <paramref name="id" /> could not be found.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">The <see cref="P:System.Messaging.Message.Id" /> of the message to receive.</param>
        <param name="transaction">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</param>
        <summary>Receives the message that matches the given identifier (from a transactional queue) and immediately raises an exception if no message with the specified identifier currently exists in the queue.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador conhecido e removê-la da fila, usando o contexto de transação interna definido pelo `transaction` parâmetro. Este método lança uma exceção imediatamente a mensagem não está na fila  
  
 O <xref:System.Messaging.Message.Id%2A> propriedade de uma mensagem é exclusiva em toda a empresa de enfileiramento de mensagens, para que haja no máximo uma mensagem na fila que corresponde a determinado `id` parâmetro.  
  
 Como esse método é chamado em uma fila transacional, a mensagem recebida será retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 Dois outros métodos permitem que você receber mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> método é usado para recuperar uma confirmação, o relatório ou a mensagem de resposta geradas pelo aplicativo que foi criada como resultado de uma mensagem enviada para a fila.  
  
 Para ler uma mensagem com um identificador especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Porque <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> não remove quaisquer mensagens na fila, não haveria nada para ser revertida se a transação foi anulada.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#17](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#17)]
 [!code-csharp[MessageQueue2#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="id" /> parameter is <see langword="null" />.  -or-  The <paramref name="transaction" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The message with the specified <paramref name="id" /> could not be found.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The queue is non-transactional.  -or-  An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">The <see cref="P:System.Messaging.Message.Id" /> of the message to receive.</param>
        <param name="transactionType">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</param>
        <summary>Receives the message that matches the given identifier and immediately raises an exception if no message with the specified identifier currently exists in the queue.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador conhecido e removê-la da fila. Este método lança uma exceção imediatamente a mensagem não está na fila. Caso contrário, a mensagem é removida da fila e retornada para o aplicativo usando um contexto de transação definido pelo `transactionType` parâmetro.  
  
 Especifique `Automatic` para o `transactionType` parâmetro se já houver um contexto de transação externa é anexado ao thread que você deseja usar para receber a mensagem. Especificar `Single` se você deseja receber a mensagem como uma única transação interna. Você pode especificar `None` se você quiser receber uma mensagem de uma fila transacional fora de um contexto de transação.  
  
 O <xref:System.Messaging.Message.Id%2A> propriedade de uma mensagem é exclusiva em toda a empresa de enfileiramento de mensagens, para que haja no máximo uma mensagem na fila que corresponde a determinado `id` parâmetro. Se a mensagem com o identificador especificado está em uma fila diferente daquele que está associado a esta <xref:System.Messaging.MessageQueue> instância, a mensagem não será localizada.  
  
 Se esse método é chamado para receber uma mensagem de uma fila transacional, a mensagem é recebida será retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 Dois outros métodos permitem que você receber mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> método é usado para recuperar uma confirmação, o relatório ou a mensagem de resposta geradas pelo aplicativo que foi criada como resultado de uma mensagem enviada para a fila.  
  
 Para ler uma mensagem com um identificador especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Porque <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> não remove quaisquer mensagens na fila, não haveria nada para ser revertida se a transação foi anulada.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#15](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#15)]
 [!code-csharp[MessageQueue2#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="id" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The message with the specified <paramref name="id" /> could not be found.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">The <see cref="P:System.Messaging.Message.Id" /> of the message to receive.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</param>
        <summary>Receives the message that matches the given identifier (from a non-transactional queue) and waits until either a message with the specified identifier is available in the queue or the time-out expires.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador conhecido e removê-la da fila. Esse método retorna imediatamente se a mensagem com o identificador especificado o `id` parâmetro está na fila. Caso contrário, o método aguarda por determinado período de tempo para uma nova mensagem chegue. Se uma nova mensagem não chegar antes do tempo limite expirar, uma exceção será lançada.  
  
 O `timeout` parâmetro não especifica o total de tempo para esse método de execução. Em vez disso, ele especifica o tempo de espera por uma nova mensagem chegar na fila. Cada vez que uma nova mensagem chega, este método examina o <xref:System.Messaging.Message.Id%2A> da nova mensagem para ver se ele corresponde a `id` parâmetro. Caso contrário, esse método inicia o período de tempo limite em e aguarda até que outra nova mensagem chegue. Portanto, se continuarem novas mensagens chegarem dentro do período de tempo limite, é possível para esse método continuar a executar indefinidamente, até que o período de tempo limite expira sem novas mensagens que chegam, ou até que uma mensagem chega cujo <xref:System.Messaging.Message.Id%2A> corresponde a `id` parâmetro.  
  
 O <xref:System.Messaging.Message.Id%2A> propriedade de uma mensagem é exclusiva em toda a empresa de enfileiramento de mensagens, para que haja no máximo uma mensagem na fila que corresponde a determinado `id` parâmetro.  
  
 Use essa sobrecarga de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> quando ele é aceitável para o thread atual a ser bloqueada como continuam novas mensagens chegam na fila de dentro do período de tempo limite especificado pelo `timeout` parâmetro. O thread será bloqueado pelo menos o período de tempo ou indefinidamente se você especificou o valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para o `timeout` parâmetro, ou se novas mensagens chegam na fila de dentro do período de tempo limite especificado pelo `timeout` parâmetro.  
  
 Dois outros métodos permitem que você receber mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> método é usado para recuperar uma confirmação, o relatório ou a mensagem de resposta geradas pelo aplicativo que foi criada como resultado de uma mensagem enviada para a fila.  
  
 Para ler uma mensagem com um identificador especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#20](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#20)]
 [!code-csharp[MessageQueue2#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="id" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A message with the specified <paramref name="id" /> did not arrive in the queue before the time-out expired.  -or-  An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">The <see cref="P:System.Messaging.Message.Id" /> of the message to receive.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</param>
        <param name="transaction">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</param>
        <summary>Receives the message that matches the given identifier (from a transactional queue) and waits until either a message with the specified identifier is available in the queue or the time-out expires.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador conhecido e removê-la da fila, usando o contexto de transação interna definido pelo `transaction` parâmetro. Esse método retorna imediatamente se a mensagem com o identificador especificado o `id` parâmetro está na fila. Caso contrário, o método aguarda por determinado período de tempo para uma nova mensagem chegue. Se uma nova mensagem não chegar antes do tempo limite expirar, uma exceção será lançada.  
  
 O `timeout` parâmetro não especifica o total de tempo para esse método de execução. Em vez disso, ele especifica o tempo de espera por uma nova mensagem chegar na fila. Cada vez que uma nova mensagem chega, este método examina o <xref:System.Messaging.Message.Id%2A> da nova mensagem para ver se ele corresponde a `id` parâmetro. Caso contrário, esse método inicia o período de tempo limite em e aguarda até que outra nova mensagem chegue. Portanto, se continuarem novas mensagens chegarem dentro do período de tempo limite, é possível para esse método continuar a executar indefinidamente, até que o período de tempo limite expira sem novas mensagens que chegam, ou até que uma mensagem chega cujo <xref:System.Messaging.Message.Id%2A> corresponde a `id` parâmetro.  
  
 O <xref:System.Messaging.Message.Id%2A> propriedade de uma mensagem é exclusiva em toda a empresa de enfileiramento de mensagens, para que haja no máximo uma mensagem na fila que corresponde a determinado `id` parâmetro.  
  
 Use essa sobrecarga de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> quando ele é aceitável para o thread atual a ser bloqueada como continuam novas mensagens chegam na fila de dentro do período de tempo limite especificado pelo `timeout` parâmetro. O thread será bloqueado pelo menos o período de tempo ou indefinidamente se você especificou o valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para o `timeout` parâmetro, ou se novas mensagens chegam na fila de dentro do período de tempo limite especificado pelo `timeout` parâmetro.  
  
 Como esse método é chamado em uma fila transacional, a mensagem recebida será retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 Dois outros métodos permitem que você receber mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> método é usado para recuperar uma confirmação, o relatório ou a mensagem de resposta geradas pelo aplicativo que foi criada como resultado de uma mensagem enviada para a fila.  
  
 Para ler uma mensagem com um identificador especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Porque <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> não remove quaisquer mensagens na fila, não haveria nada para ser revertida se a transação foi anulada.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#18](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#18)]
 [!code-csharp[MessageQueue2#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="id" /> parameter is <see langword="null" />.  -or-  The <paramref name="transaction" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A message with the specified <paramref name="id" /> did not arrive in the queue before the time-out expired.  -or-  The queue is non-transactional.  -or-  An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">The <see cref="P:System.Messaging.Message.Id" /> of the message to receive.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that indicates the time to wait until a new message is available for inspection.</param>
        <param name="transactionType">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</param>
        <summary>Receives the message that matches the given identifier and waits until either a message with the specified identifier is available in the queue or the time-out expires.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Id" /> property matches the <paramref name="id" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador conhecido e removê-la da fila. Esse método retorna imediatamente se a mensagem com o identificador especificado o `id` parâmetro está na fila, usando um contexto de transação definido pelo `transactionType` parâmetro. Caso contrário, o método aguarda por determinado período de tempo para uma nova mensagem chegue. Se uma nova mensagem não chegar antes do tempo limite expirar, uma exceção será lançada.  
  
 O `timeout` parâmetro não especifica o total de tempo para esse método de execução. Em vez disso, ele especifica o tempo de espera por uma nova mensagem chegar na fila. Cada vez que uma nova mensagem chega, este método examina o <xref:System.Messaging.Message.Id%2A> da nova mensagem para ver se ele corresponde a `id` parâmetro. Caso contrário, esse método inicia o período de tempo limite em e aguarda até que outra nova mensagem chegue. Portanto, se continuarem novas mensagens chegarem dentro do período de tempo limite, é possível para esse método continuar a executar indefinidamente, até que o período de tempo limite expira sem novas mensagens que chegam, ou até que uma mensagem chega cujo <xref:System.Messaging.Message.Id%2A> corresponde a `id` parâmetro.  
  
 Especifique `Automatic` para o `transactionType` parâmetro se já houver um contexto de transação externa é anexado ao thread que você deseja usar para receber a mensagem. Especificar `Single` se você deseja receber a mensagem como uma única transação interna. Você pode especificar `None` se você quiser receber uma mensagem de uma fila transacional fora de um contexto de transação.  
  
 O <xref:System.Messaging.Message.Id%2A> propriedade de uma mensagem é exclusiva em toda a empresa de enfileiramento de mensagens, para que haja no máximo uma mensagem na fila que corresponde a determinado `id` parâmetro. Se a mensagem com o identificador especificado está em uma fila diferente daquele que está associado a esta <xref:System.Messaging.MessageQueue> instância, a mensagem não será localizada.  
  
 Use essa sobrecarga de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> quando ele é aceitável para o thread atual a ser bloqueada como continuam novas mensagens chegam na fila de dentro do período de tempo limite especificado pelo `timeout` parâmetro. O thread será bloqueado pelo menos o período de tempo ou indefinidamente se você especificou o valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para o `timeout` parâmetro, ou se novas mensagens chegam na fila de dentro do período de tempo limite especificado pelo `timeout` parâmetro.  
  
 Se esse método é chamado para receber uma mensagem de uma fila transacional, a mensagem é recebida será retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 Dois outros métodos permitem que você receber mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> método é usado para recuperar uma confirmação, o relatório ou a mensagem de resposta geradas pelo aplicativo que foi criada como resultado de uma mensagem enviada para a fila.  
  
 Para ler uma mensagem com um identificador especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Porque <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> não remove quaisquer mensagens na fila, não haveria nada para ser revertida se a transação foi anulada.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#19](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#19)]
 [!code-csharp[MessageQueue2#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="id" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The value specified for the <paramref name="timeout" /> parameter is not valid, possibly <paramref name="timeout" /> is less than <see cref="F:System.TimeSpan.Zero" /> or greater than <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A message with the specified <paramref name="id" /> did not arrive in the queue before the time-out expired.  -or-  An error occurred when accessing a Message Queuing method.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Introduced in MSMQ 3.0. Receives a specific message from the queue. The message can be specified by a lookup identifier or by its position at the front or end of the queue.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">The <see cref="P:System.Messaging.Message.LookupId" /> of the message to receive.</param>
        <summary>Introduced in MSMQ 3.0. Receives the message that matches the given lookup identifier from a non-transactional queue.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.LookupId" /> property matches the <paramref name="lookupId" /> parameter passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador de pesquisa conhecidos e removê-la da fila. Este método lança uma exceção imediatamente a mensagem não está na fila.  
  
 O <xref:System.Messaging.Message.LookupId%2A> propriedade de uma mensagem é exclusiva para a fila onde reside a mensagem, para que haja no máximo uma mensagem na fila que corresponde a determinado `lookupId` parâmetro.  
  
 Para ler uma mensagem com um identificador de pesquisa especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> método.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 is not installed.</exception>
        <exception cref="T:System.InvalidOperationException">The message with the specified <paramref name="lookupId" /> could not be found.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="action">One of the <see cref="T:System.Messaging.MessageLookupAction" /> values, specifying how the message is read in the queue. Specify one of the following:  <see langword="MessageLookupAction.Current" />: Receives the message specified by <c>lookupId</c> and removes it from the queue.  
  
 <see langword="MessageLookupAction.Next" />: Receives the message following the message specified by <c>lookupId</c> and removes it from the queue.  
  
 <see langword="MessageLookupAction.Previous" />: Receives the message preceding the message specified by <c>lookupId</c> and removes it from the queue.  
  
 <see langword="MessageLookupAction.First" />: Receives the first message in the queue and removes it from the queue. The <c>lookupId</c> parameter must be set to 0.  
  
 <see langword="MessageLookupAction.Last" />: Receives the last message in the queue and removes it from the queue. The <c>lookupId</c> parameter must be set to 0.</param>
        <param name="lookupId">The <see cref="P:System.Messaging.Message.LookupId" /> of the message to receive, or 0. 0 is used when accessing the first or last message in the queue.</param>
        <param name="transaction">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</param>
        <summary>Introduced in MSMQ 3.0. Receives a specific message from a transactional queue. The message can be specified by a lookup identifier or by its position at the front or end of the queue.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> specified by the <paramref name="lookupId" /> and <paramref name="action" /> parameters passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador de pesquisa conhecidos e removê-la da fila, usando um contexto de transação definido pelo `transaction` parâmetro. Este método lança uma exceção imediatamente a mensagem não está na fila.  
  
 O <xref:System.Messaging.Message.LookupId%2A> propriedade de uma mensagem é exclusiva para a fila onde reside a mensagem, para que haja no máximo uma mensagem na fila que corresponde a determinado `lookupId` parâmetro.  
  
 Como esse método é chamado em uma fila transacional, a mensagem recebida será retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 Para ler uma mensagem com um identificador especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> método. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Porque <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> não remove quaisquer mensagens da fila, não haveria nada para ser revertida se a transação foi anulada.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 is not installed.</exception>
        <exception cref="T:System.InvalidOperationException">The message with the specified <paramref name="lookupId" /> could not be found.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.  -or-  The queue is non-transactional.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The <paramref name="action" /> parameter is not one of the <see cref="T:System.Messaging.MessageLookupAction" /> members.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="action">One of the <see cref="T:System.Messaging.MessageLookupAction" /> values, specifying how the message is read in the queue. Specify one of the following:  <see langword="MessageLookupAction.Current" />: Receives the message specified by <c>lookupId</c> and removes it from the queue.  
  
 <see langword="MessageLookupAction.Next" />: Receives the message following the message specified by <c>lookupId</c> and removes it from the queue.  
  
 <see langword="MessageLookupAction.Previous" />: Receives the message preceding the message specified by <c>lookupId</c> and removes it from the queue.  
  
 <see langword="MessageLookupAction.First" />: Receives the first message in the queue and removes it from the queue. The <c>lookupId</c> parameter must be set to 0.  
  
 <see langword="MessageLookupAction.Last" />: Receives the last message in the queue and removes it from the queue. The <c>lookupId</c> parameter must be set to 0.</param>
        <param name="lookupId">The <see cref="P:System.Messaging.Message.LookupId" /> of the message to receive, or 0. 0 is used when accessing the first or last message in the queue.</param>
        <param name="transactionType">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</param>
        <summary>Introduced in MSMQ 3.0. Receives a specific message from the queue, using the specified transaction context. The message can be specified by a lookup identifier or by its position at the front or end of the queue.</summary>
        <returns>The <see cref="T:System.Messaging.Message" /> specified by the <paramref name="action" /> and <paramref name="lookupId" /> parameters passed in.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador de pesquisa conhecidos e removê-la da fila, usando um contexto de transação definido pelo `transactionType` parâmetro. Este método lança uma exceção imediatamente a mensagem não está na fila.  
  
 O <xref:System.Messaging.Message.LookupId%2A> propriedade de uma mensagem é exclusiva para a fila onde reside a mensagem, para que haja no máximo uma mensagem na fila que corresponde a determinado `lookupId` parâmetro.  
  
 Para ler uma mensagem com um identificador especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> método. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Porque <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> não remove quaisquer mensagens da fila, não haveria nada para ser revertida se a transação foi anulada.  
  
 Especifique `Automatic` para o `transactionType` parâmetro se já houver um contexto de transação externa é anexado ao thread que você deseja usar para receber a mensagem. Especificar `Single` se você deseja receber a mensagem como uma única transação interna. Você pode especificar `None` se você quiser receber uma mensagem de uma fila transacional fora de um contexto de transação.  
  
 Se esse método é chamado para receber uma mensagem de uma fila transacional, a mensagem é recebida será retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 is not installed.</exception>
        <exception cref="T:System.InvalidOperationException">The message with the specified <paramref name="lookupId" /> could not be found.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The <paramref name="action" /> parameter is not one of the <see cref="T:System.Messaging.MessageLookupAction" /> members.  -or-  The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReceiveCompleted As ReceiveCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::ReceiveCompletedEventHandler ^ ReceiveCompleted;" />
      <MemberSignature Language="F#" Value="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " Usage="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReceiveCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.ReceiveCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a message has been removed from the queue. This event is raised by the asynchronous operation, <see cref="M:System.Messaging.MessageQueue.BeginReceive" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> é usada no processamento assíncrono para gerar o <xref:System.Messaging.MessageQueue.ReceiveCompleted> quando uma mensagem fica disponível na fila de eventos.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> é usado para concluir a operação iniciada por uma chamada para <xref:System.Messaging.MessageQueue.BeginReceive%2A> e inspecionar mensagem quando o <xref:System.Messaging.MessageQueue.ReceiveCompleted> é gerado.  
  
 Quando você cria um <xref:System.Messaging.ReceiveCompletedEventHandler> delegado, você identificar o método que manipulará o evento. Para associar o evento com o manipulador de eventos, adicione uma instância do representante ao evento. O manipulador de eventos é chamado sempre que o evento ocorre, a menos que você remova o representante. Para obter mais informações sobre delegados de manipulador de eventos, consulte [tratamento e gerando eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 O exemplo de código a seguir cria um manipulador de eventos chamado `MyReceiveCompleted`, anexa-o para o <xref:System.Messaging.MessageQueue.ReceiveCompleted> representante do manipulador de eventos e chamadas <xref:System.Messaging.MessageQueue.BeginReceive%2A> para iniciar uma recepção assíncrona a operação na fila que está localizada no caminho ". \myQueue". Quando um <xref:System.Messaging.MessageQueue.ReceiveCompleted> é gerado, o exemplo recebe a mensagem e grava seu corpo para a tela. O exemplo, em seguida, chama <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente para iniciar um novo assíncrona operação de recebimento.  
  
 [!code-cpp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CPP/mqreceivecompletedeventhandler.cpp#1)]
 [!code-csharp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CS/mqreceivecompletedeventhandler.cs#1)]
 [!code-vb[MessageQueue.ReceiveCompleted#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/VB/mqreceivecompletedeventhandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="messageQueue.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Refreshes the properties presented by the <see cref="T:System.Messaging.MessageQueue" /> to reflect the current state of the resource.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Refresh%2A> sincroniza as propriedades de um <xref:System.Messaging.MessageQueue> com seus recursos de servidor de enfileiramento de mensagens associado. Se qualquer propriedade, como <xref:System.Messaging.MessageQueue.Label%2A> ou <xref:System.Messaging.MessageQueue.Category%2A>, foi alterado no servidor desde a hora de <xref:System.Messaging.MessageQueue> foi criado, <xref:System.Messaging.MessageQueue.Refresh%2A> atualizações a <xref:System.Messaging.MessageQueue> com as novas informações.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.Refresh%2A>.  
  
 [!code-cpp[MessageQueue2#28](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#28)]
 [!code-csharp[MessageQueue2#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ResetPermissions">
      <MemberSignature Language="C#" Value="public void ResetPermissions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetPermissions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ResetPermissions" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetPermissions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetPermissions();" />
      <MemberSignature Language="F#" Value="member this.ResetPermissions : unit -&gt; unit" Usage="messageQueue.ResetPermissions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resets the permission list to the operating system's default values. Removes any queue permissions you have appended to the default list.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você chama <xref:System.Messaging.MessageQueue.ResetPermissions%2A>, retornar a lista de permissão para seus valores padrão. Em geral, isso concede todas as permissões do criador da fila e concede ao grupo todos os seguintes direitos:  
  
-   Obtenha as propriedades da fila.  
  
-   Obter as permissões da fila.  
  
-   Grave na fila.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ResetPermissions%2A>.  
  
 [!code-cpp[MessageQueue2#27](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#27)]
 [!code-csharp[MessageQueue2#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sends an object to a queue.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Send : obj -&gt; unit" Usage="messageQueue.Send obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">The object to send to the queue.</param>
        <summary>Sends an object to non-transactional queue referenced by this <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para enviar uma mensagem que contém o `obj` parâmetro para a fila referenciada pelo <xref:System.Messaging.MessageQueue>. O objeto que você envia para a fila pode ser um <xref:System.Messaging.Message> ou qualquer objeto gerenciado. Se você enviar qualquer objeto diferente de um <xref:System.Messaging.Message>, o objeto é serializado e inserido no corpo da mensagem.  
  
 Se você usar essa sobrecarga para enviar uma mensagem para uma fila transacional, a mensagem será enviada para a fila de mensagens mortas. Se você quiser que a mensagem seja parte de uma transação que contém outras mensagens, use uma sobrecarga que utiliza um <xref:System.Messaging.MessageQueueTransaction> ou <xref:System.Messaging.MessageQueueTransactionType> como um parâmetro.  
  
 Se você não definir a <xref:System.Messaging.MessageQueue.Formatter%2A> propriedade antes de chamar <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, o formatador padrão é o <xref:System.Messaging.XmlMessageFormatter>.  
  
 O <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriedade se aplica a qualquer objeto diferente de um <xref:System.Messaging.Message>. Se você especificar, por exemplo, um rótulo ou uma prioridade usando o <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membro, esses valores se aplicam a qualquer mensagem que contém um objeto que não é do tipo <xref:System.Messaging.Message> quando o seu aplicativo a envia para a fila. Ao enviar um <xref:System.Messaging.Message>, os valores de propriedade definidos para o <xref:System.Messaging.Message> têm precedência sobre <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> e a mensagem <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propriedade tem precedência sobre a fila <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propriedade.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir se conecta a uma fila de mensagens e envia uma mensagem à fila.  
  
 [!code-cpp[MessageQueue.Send_obj#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_obj/CPP/mqsend_generic.cpp#1)]
 [!code-csharp[MessageQueue.Send_obj#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_obj/CS/mqsend_generic.cs#1)]
 [!code-vb[MessageQueue.Send_obj#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_obj/VB/mqsend_generic.vb#1)]  
  
 O exemplo de código a seguir envia um aplicativo definido `Order` classe para uma fila e, em seguida, recebe uma mensagem de fila.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">The <see cref="P:System.Messaging.MessageQueue.Path" /> property has not been set.  -or-  An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">The object to send to the queue.</param>
        <param name="transaction">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</param>
        <summary>Sends an object to the transactional queue referenced by this <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para enviar uma mensagem que contém o `obj` parâmetro para a fila transacional referenciada pelo <xref:System.Messaging.MessageQueue>, usando um contexto de transação interna definido pelo `transaction` parâmetro. O objeto que você envia para a fila pode ser um <xref:System.Messaging.Message> ou qualquer objeto gerenciado. Se você enviar qualquer objeto diferente de um <xref:System.Messaging.Message>, o objeto é serializado e inserido no corpo da mensagem.  
  
 Se você usar essa sobrecarga para enviar uma mensagem para uma fila não transacional, a mensagem pode ser enviada para a fila de mensagens mortas sem lançar uma exceção.  
  
 Se você não definir a <xref:System.Messaging.MessageQueue.Formatter%2A> propriedade antes de chamar <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, o formatador padrão é o <xref:System.Messaging.XmlMessageFormatter>.  
  
 O <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriedade se aplica a qualquer objeto diferente de um <xref:System.Messaging.Message>. Se você especificar, por exemplo, um rótulo ou uma prioridade usando o <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membro, esses valores se aplicam a qualquer mensagem que contém um objeto que não é do tipo <xref:System.Messaging.Message> quando o seu aplicativo a envia para a fila. Ao enviar um <xref:System.Messaging.Message>, os valores de propriedade definidos para o <xref:System.Messaging.Message> têm precedência sobre <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> e a mensagem <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propriedade tem precedência sobre a fila <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propriedade.  
  
 <xref:System.Messaging.MessageQueueTransaction> é de thread apartment com suporte, portanto, se o estado de apartment é `STA`, você não pode usar a transação em vários threads. Visual Basic define o estado do thread principal para `STA`, portanto, você deve aplicar o <xref:System.MTAThreadAttribute> no `Main` sub-rotina. Caso contrário, o envio de uma mensagem transacional usando outro thread gerará uma exceção <xref:System.Messaging.MessageQueueException>. Aplicar o <xref:System.MTAThreadAttribute> usando o seguinte fragmento.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir envia uma cadeia de caracteres para uma fila transacional e, em seguida, recebe uma mensagem de fila.  
  
 [!code-cpp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CPP/mqsend_objtransaction.cpp#1)]
 [!code-csharp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CS/mqsend_objtransaction.cs#1)]
 [!code-vb[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/VB/mqsend_objtransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="transaction" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The <see cref="P:System.Messaging.MessageQueue.Path" /> property has not been set.  -or-  The Message Queuing application indicated an incorrect transaction use.  -or-  An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">The object to send to the queue.</param>
        <param name="transactionType">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</param>
        <summary>Sends an object to the queue referenced by this <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para enviar uma mensagem que contém o `obj` parâmetro para a fila referenciada pelo <xref:System.Messaging.MessageQueue>, usando um contexto de transação definido pelo `transactionType` parâmetro. Especifique `Automatic` para o `transactionType` parâmetro se já houver um contexto de transação externa é anexado ao thread que você deseja usar para enviar a mensagem. Especificar `Single` se você deseja enviar a mensagem como uma única transação interna. Você pode especificar `None` se você quiser enviar uma mensagem transacional para um thread não-transacional.  
  
 O objeto que você envia para a fila pode ser um <xref:System.Messaging.Message> ou qualquer objeto gerenciado. Se você enviar qualquer objeto diferente de um <xref:System.Messaging.Message>, o objeto é serializado e inserido no corpo da mensagem.  
  
 Se você não definir a <xref:System.Messaging.MessageQueue.Formatter%2A> propriedade antes de chamar <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, o formatador padrão é o <xref:System.Messaging.XmlMessageFormatter>.  
  
 O <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriedade se aplica a qualquer objeto diferente de um <xref:System.Messaging.Message>. Se você especificar, por exemplo, um rótulo ou uma prioridade usando o <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membro, esses valores se aplicam a qualquer mensagem que contém um objeto que não é do tipo <xref:System.Messaging.Message> quando o seu aplicativo a envia para a fila. Ao enviar um <xref:System.Messaging.Message>, os valores de propriedade definidos para o <xref:System.Messaging.Message> têm precedência sobre <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> e a mensagem <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propriedade tem precedência sobre a fila <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propriedade.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#2)]
 [!code-csharp[MessageQueue2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The <see cref="P:System.Messaging.MessageQueue.Path" /> property has not been set.  -or-  An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string -&gt; unit" Usage="messageQueue.Send (obj, label)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">The object to send to the queue.</param>
        <param name="label">The label of the message.</param>
        <summary>Sends an object to the non-transactional queue referenced by this <see cref="T:System.Messaging.MessageQueue" /> and specifies a label for the message.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para enviar uma mensagem que contém o `obj` parâmetro para a fila referenciada pelo <xref:System.Messaging.MessageQueue>. Com essa sobrecarga, você pode especificar o rótulo de cadeia de caracteres que identifica a mensagem. O objeto que você envia para a fila pode ser uma <xref:System.Messaging.Message>, uma estrutura, um objeto de dados ou qualquer objeto gerenciado. Se você enviar qualquer objeto diferente de um <xref:System.Messaging.Message>, o objeto é serializado e inserido no corpo da mensagem.  
  
 O rótulo da mensagem é diferente do rótulo da fila de mensagem, mas ambos são dependentes do aplicativo e não têm herdar significado para enfileiramento de mensagens.  
  
 Se você usar essa sobrecarga para enviar uma mensagem para uma fila transacional, a mensagem será enviada para a fila de mensagens mortas. Se você quiser que a mensagem seja parte de uma transação que contém outras mensagens, use uma sobrecarga que utiliza um <xref:System.Messaging.MessageQueueTransaction> ou <xref:System.Messaging.MessageQueueTransactionType> como um parâmetro.  
  
 O <xref:System.Messaging.MessageQueue.Path%2A> propriedade para este <xref:System.Messaging.MessageQueue> instância deve ser especificada antes de enviar a mensagem. Se você não definir a <xref:System.Messaging.MessageQueue.Formatter%2A> propriedade antes de chamar <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, o formatador padrão é o <xref:System.Messaging.XmlMessageFormatter>.  
  
 O <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriedade se aplica a qualquer objeto diferente de um <xref:System.Messaging.Message>. Se você especificar, por exemplo, um rótulo ou uma prioridade usando o <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membro, esses valores se aplicam a qualquer mensagem que contém um objeto que não é do tipo <xref:System.Messaging.Message> quando o seu aplicativo a envia para a fila. Ao enviar um <xref:System.Messaging.Message>, os valores de propriedade definidos para o <xref:System.Messaging.Message> têm precedência sobre <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> e a mensagem <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propriedade tem precedência sobre a fila <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propriedade.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29>.  
  
 [!code-cpp[MessageQueue2#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue2#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="label" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The <see cref="P:System.Messaging.MessageQueue.Path" /> property has not been set.  -or-  An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, label, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">The object to send to the queue.</param>
        <param name="label">The label of the message.</param>
        <param name="transaction">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object.</param>
        <summary>Sends an object to the transactional queue referenced by this <see cref="T:System.Messaging.MessageQueue" /> and specifies a label for the message.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para enviar uma mensagem que contém o `obj` parâmetro para a fila transacional referenciada pelo <xref:System.Messaging.MessageQueue>, usando um contexto de transação interna definido pelo `transaction` parâmetro. Com essa sobrecarga, você pode especificar o rótulo de cadeia de caracteres que identifica a mensagem. O objeto que você envia para a fila pode ser uma <xref:System.Messaging.Message>, uma estrutura, um objeto de dados ou qualquer objeto gerenciado. Se você enviar qualquer objeto diferente de um <xref:System.Messaging.Message>, o objeto é serializado e inserido no corpo da mensagem.  
  
 O rótulo da mensagem é diferente do rótulo da fila de mensagem, mas ambos são dependentes do aplicativo e não têm herdar significado para enfileiramento de mensagens.  
  
 Se você usar essa sobrecarga para enviar uma mensagem para uma fila não transacional, a mensagem pode ser enviada para a fila de mensagens mortas sem lançar uma exceção.  
  
 Se você não definir a <xref:System.Messaging.MessageQueue.Formatter%2A> propriedade antes de chamar <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, o formatador padrão é o <xref:System.Messaging.XmlMessageFormatter>.  
  
 O <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriedade se aplica a qualquer objeto diferente de um <xref:System.Messaging.Message>. Se você especificar, por exemplo, um rótulo ou uma prioridade usando o <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membro, esses valores se aplicam a qualquer mensagem que contém um objeto que não é do tipo <xref:System.Messaging.Message> quando o seu aplicativo a envia para a fila. Ao enviar um <xref:System.Messaging.Message>, os valores de propriedade definidos para o <xref:System.Messaging.Message> têm precedência sobre <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> e a mensagem <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propriedade tem precedência sobre a fila <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propriedade  
  
 <xref:System.Messaging.MessageQueueTransaction> é de thread apartment com suporte, portanto, se o estado de apartment é `STA`, você não pode usar a transação em vários threads. Visual Basic define o estado do thread principal para `STA`, portanto, você deve aplicar o <xref:System.MTAThreadAttribute> no `Main` sub-rotina. Caso contrário, o envio de uma mensagem transacional usando outro thread gerará uma exceção <xref:System.Messaging.MessageQueueException>. Aplicar o <xref:System.MTAThreadAttribute> usando o seguinte fragmento.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#4](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#4)]
 [!code-csharp[MessageQueue2#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="label" /> parameter is <see langword="null" />.  -or-  The <paramref name="transaction" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The <see cref="P:System.Messaging.MessageQueue.Path" /> property has not been set.  -or-  The Message Queuing application indicated an incorrect transaction usage.  -or-  An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, label, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">The object to send to the queue.</param>
        <param name="label">The label of the message.</param>
        <param name="transactionType">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</param>
        <summary>Sends an object to the queue referenced by this <see cref="T:System.Messaging.MessageQueue" /> and specifies a label for the message.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para enviar uma mensagem que contém o `obj` parâmetro para a fila referenciada pelo <xref:System.Messaging.MessageQueue>, usando um contexto de transação definido pelo `transactionType` parâmetro. Especifique `Automatic` para o `transactionType` parâmetro se já houver um contexto de transação externa é anexado ao thread que você deseja usar para enviar a mensagem. Especificar `Single` se você deseja enviar a mensagem como uma única transação interna. Você pode especificar `None` se você quiser enviar uma mensagem transacional para um thread não-transacional.  
  
 O objeto que você envia para a fila pode ser um <xref:System.Messaging.Message> ou qualquer objeto gerenciado. Se você enviar qualquer objeto diferente de um <xref:System.Messaging.Message>, o objeto é serializado e inserido no corpo da mensagem. Com essa sobrecarga, você pode especificar o rótulo de cadeia de caracteres que identifica a mensagem.  
  
 O rótulo da mensagem é diferente do rótulo da fila de mensagem, mas ambos são dependentes do aplicativo e não têm herdar significado para enfileiramento de mensagens.  
  
 Se você não definir a <xref:System.Messaging.MessageQueue.Formatter%2A> propriedade antes de chamar <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, o formatador padrão é o <xref:System.Messaging.XmlMessageFormatter>.  
  
 O <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriedade se aplica a qualquer objeto diferente de um <xref:System.Messaging.Message>. Se você especificar, por exemplo, um rótulo ou uma prioridade usando o <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membro, esses valores se aplicam a qualquer mensagem que contém um objeto que não é do tipo <xref:System.Messaging.Message> quando o seu aplicativo a envia para a fila. Ao enviar um <xref:System.Messaging.Message>, os valores de propriedade definidos para o <xref:System.Messaging.Message> têm precedência sobre <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>e a mensagem <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propriedade tem precedência sobre a fila <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propriedade.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#3](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#3)]
 [!code-csharp[MessageQueue2#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="label" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueTransaction">The Message Queuing application indicated an incorrect transaction usage.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">The <see cref="P:System.Messaging.MessageQueue.Path" /> property has not been set.  -or-  An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetPermissions">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adds permissions to the current set. This controls who has access rights to queue properties and messages in the queue.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.AccessControlList dacl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.AccessControlList dacl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (dacl As AccessControlList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::AccessControlList ^ dacl);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.AccessControlList -&gt; unit" Usage="messageQueue.SetPermissions dacl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dacl" Type="System.Messaging.AccessControlList" />
      </Parameters>
      <Docs>
        <param name="dacl">A <see cref="T:System.Messaging.AccessControlList" /> that contains one or more access control entries that specify the trustees and the permissions to grant.</param>
        <summary>Assigns access rights to the queue based on the contents of an access control list.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para conceder, negar ou revogar direitos por meio de uma coleção de entradas de controle de acesso para especificar informações de objeto de confiança e permissões. Isso é usado, por exemplo, para conceder permissões a vários usuários ao mesmo tempo.  
  
 O objeto de confiança especificado quando você cria o `ace` parâmetro pode ser um usuário individual, um grupo de usuários ou um computador. Se o objeto de confiança é um indivíduo, use o formato `DOMAIN` \\ `user`. Você pode especificar "." para o objeto de confiança indicar o computador local.  
  
 As permissões atribuídas a <xref:System.Messaging.MessageQueue.SetPermissions%2A> adicionar direitos à lista existente. Por padrão, o criador de uma fila pública ou privada tem controle total e o grupo de domínio todos têm permissão para obter as propriedades de fila, obter permissões e gravar na fila. Quando você chama <xref:System.Messaging.MessageQueue.SetPermissions%2A>, as informações de permissões de usuário e são anexadas à parte inferior da lista existente.  
  
 O sistema examina cada <xref:System.Messaging.AccessControlEntry> na sequência até que ocorra um dos seguintes eventos:  
  
-   Um acesso negado <xref:System.Messaging.AccessControlEntry> nega explicitamente qualquer um dos direitos de acesso solicitado a um dos objetos de confiança mencionados no token de acesso do thread.  
  
-   Um ou mais acesso permitidos <xref:System.Messaging.AccessControlEntry> itens para objetos de confiança explicitamente listados no token de acesso do thread concedem os direitos de acesso solicitado.  
  
-   Todos os <xref:System.Messaging.AccessControlEntry> itens foram verificados e há ainda pelo menos um solicitada direito de acesso que não foi explicitamente permitido, nesse caso, o acesso é negado implicitamente.  
  
 Quando você cria o `dacl` parâmetro, adicione <xref:System.Messaging.AccessControlEntry> instâncias do seu <xref:System.Messaging.AccessControlList> coleção. Quando você construir cada entrada de controle de acesso, você pode especificar os direitos de acesso genérico ou padrão. Os direitos para uma fila podem ser qualquer combinação das seguintes opções:  
  
-   Excluir  
  
-   Segurança de leitura  
  
-   Segurança de gravação  
  
-   Sincronizar  
  
-   Modificar proprietário  
  
-   Ler  
  
-   Write  
  
-   Executar  
  
-   Necessária  
  
-   Todos  
  
-   Nenhum  
  
 Esses direitos são um conjunto de sinalizadores de bit que você pode combinar usando o operador OR de bit a bit.  
  
-   Controle total  
  
-   Excluir mensagem  
  
-   Receber mensagem  
  
-   Inspecionar mensagem  
  
-   Receber mensagens do diário  
  
-   Obter propriedades de fila  
  
-   Definir propriedades de fila  
  
-   Obter permissões  
  
-   Conjunto de permissões  
  
-   Assumir a propriedade de fila  
  
-   Gravar a mensagem  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29>.      
  
 [!code-cpp[MessageQueue2#26](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#26)]
 [!code-csharp[MessageQueue2#26](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.AccessControlList" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.MessageQueueAccessControlEntry ace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.MessageQueueAccessControlEntry ace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (ace As MessageQueueAccessControlEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::MessageQueueAccessControlEntry ^ ace);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.MessageQueueAccessControlEntry -&gt; unit" Usage="messageQueue.SetPermissions ace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ace" Type="System.Messaging.MessageQueueAccessControlEntry" />
      </Parameters>
      <Docs>
        <param name="ace">A <see cref="T:System.Messaging.MessageQueueAccessControlEntry" /> that specifies a user, an access type, and a permission type.</param>
        <summary>Assigns access rights to the queue based on the contents of an access control entry.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para conceder, negar ou revogar direitos por meio de uma entrada de controle de acesso para especificar o objeto de confiança e informações de direitos.  
  
 O objeto de confiança especificado quando você cria o `ace` parâmetro pode ser um usuário individual, um grupo de usuários ou um computador. Se o objeto de confiança é um indivíduo, use o formato `DOMAIN` \\ `user`. Você pode especificar "." para o objeto de confiança indicar o computador local.  
  
 As permissões atribuídas a <xref:System.Messaging.MessageQueue.SetPermissions%2A> adicionar direitos à lista existente. Por padrão, o criador de uma fila pública ou privada tem controle total e o grupo de domínio todos têm permissão para obter as propriedades de fila, obter permissões e gravar na fila. Quando você chama <xref:System.Messaging.MessageQueue.SetPermissions%2A>, as informações de permissões de usuário e são anexadas à parte inferior da lista existente.  
  
 O sistema examina cada <xref:System.Messaging.AccessControlEntry> na sequência até que ocorra um dos seguintes eventos:  
  
-   Um acesso negado <xref:System.Messaging.AccessControlEntry> nega explicitamente qualquer um dos direitos de acesso solicitado a um dos objetos de confiança mencionados no token de acesso do thread.  
  
-   Um ou mais acesso permitidos <xref:System.Messaging.AccessControlEntry> itens para objetos de confiança explicitamente listados no token de acesso do thread concedem os direitos de acesso solicitado.  
  
-   Todos os <xref:System.Messaging.AccessControlEntry> itens foram verificados e há ainda pelo menos um solicitada direito de acesso que não foi explicitamente permitido, nesse caso, o acesso é negado implicitamente.  
  
 Os direitos para uma fila, que você especificar na `rights` parâmetro quando você construir o <xref:System.Messaging.MessageQueueAccessControlEntry>, pode ser qualquer combinação das seguintes opções:  
  
-   Controle total  
  
-   Excluir mensagem  
  
-   Receber mensagem  
  
-   Inspecionar mensagem  
  
-   Receber mensagens do diário  
  
-   Obter propriedades de fila  
  
-   Definir propriedades de fila  
  
-   Obter permissões  
  
-   Conjunto de permissões  
  
-   Assumir a propriedade de fila  
  
-   Gravar a mensagem  
  
 O `rights` parâmetro que você especificar no construtor para o `ace` parâmetro é um sinalizador do <xref:System.Messaging.MessageQueueAccessRights> enumeração. Representa um conjunto de sinalizadores de bit que você pode combinar usando o operador bit a bit ou quando você cria o `rights` parâmetro.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29>.  
  
 [!code-cpp[MessageQueue2#24](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#24)]
 [!code-csharp[MessageQueue2#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.MessageQueueAccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights -&gt; unit" Usage="messageQueue.SetPermissions (user, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
      </Parameters>
      <Docs>
        <param name="user">The individual, group, or computer that gets additional rights to the queue.</param>
        <param name="rights">A <see cref="T:System.Messaging.MessageQueueAccessRights" /> that indicates the set of rights to the queue that Message Queuing assigns to the <c>user</c> passed in.</param>
        <summary>Gives a computer, group, or user the specified access rights.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para conceder direitos especificados para um usuário individual. O usuário pode ser qualquer objeto de confiança válido, o que inclui usuários individuais, grupos de usuários ou um computador. Se o usuário for um indivíduo, use o formato `DOMAIN` \\ `user` para o `user` parâmetro. Você pode especificar "." para o `user` parâmetro para indicar o computador local.  
  
 As permissões atribuídas a <xref:System.Messaging.MessageQueue.SetPermissions%2A> adicionar direitos à lista existente. Por padrão, o criador de uma fila pública ou privada tem controle total e o grupo de domínio todos têm permissão para obter as propriedades de fila, obter permissões e gravar na fila. Quando você chama <xref:System.Messaging.MessageQueue.SetPermissions%2A>, as informações de permissões de usuário e são anexadas à parte inferior da lista existente.  
  
 O sistema examina cada <xref:System.Messaging.AccessControlEntry> na sequência até que ocorra um dos seguintes eventos:  
  
-   Um acesso negado <xref:System.Messaging.AccessControlEntry> nega explicitamente qualquer um dos direitos de acesso solicitado a um dos objetos de confiança mencionados no token de acesso do thread.  
  
-   Um ou mais acesso permitidos <xref:System.Messaging.AccessControlEntry> itens para objetos de confiança explicitamente listados no token de acesso do thread concedem os direitos de acesso solicitado.  
  
-   Todos os <xref:System.Messaging.AccessControlEntry> itens foram verificados e há ainda pelo menos um solicitada direito de acesso que não foi explicitamente permitido, nesse caso, o acesso é negado implicitamente.  
  
 Os direitos para uma fila, especificado no `rights` parâmetro pode ser qualquer combinação das seguintes opções:  
  
-   Controle total  
  
-   Excluir mensagem  
  
-   Receber mensagem  
  
-   Inspecionar mensagem  
  
-   Receber mensagens do diário  
  
-   Obter propriedades de fila  
  
-   Definir propriedades de fila  
  
-   Obter permissões  
  
-   Conjunto de permissões  
  
-   Assumir a propriedade de fila  
  
-   Gravar a mensagem  
  
 O <xref:System.Messaging.MessageQueueAccessRights> enumeração representa um conjunto de sinalizadores de bit que você pode combinar usando o operador bit a bit ou para criar o `rights` parâmetro.  
  
 Com essa sobrecarga, você só pode conceder permissões; Você não pode revogar ou negar. Você deve usar uma sobrecarga diferente para conceder explicitamente qualquer <xref:System.Messaging.AccessControlEntryType> que `Allow`.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29>.  
  
 [!code-cpp[MessageQueue2#23](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#23)]
 [!code-csharp[MessageQueue2#23](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="user" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights, System.Messaging.AccessControlEntryType entryType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights, valuetype System.Messaging.AccessControlEntryType entryType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights, entryType As AccessControlEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights, System::Messaging::AccessControlEntryType entryType);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights * System.Messaging.AccessControlEntryType -&gt; unit" Usage="messageQueue.SetPermissions (user, rights, entryType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
        <Parameter Name="entryType" Type="System.Messaging.AccessControlEntryType" />
      </Parameters>
      <Docs>
        <param name="user">The individual, group, or computer that gets additional rights to the queue.</param>
        <param name="rights">A <see cref="T:System.Messaging.MessageQueueAccessRights" /> that indicates the set of rights to the queue that Message Queuing assigns to the <c>user</c> passed in.</param>
        <param name="entryType">A <see cref="T:System.Messaging.AccessControlEntryType" /> that specifies whether to grant, deny, or revoke the permissions specified by the <c>rights</c> parameter.</param>
        <summary>Gives a computer, group, or user the specified access rights, with the specified access control type (allow, deny, revoke, or set).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para conceder, negar ou revogar direitos especificados para um usuário individual. O usuário pode ser qualquer objeto de confiança válido, o que inclui usuários individuais, grupos de usuários ou um computador. Se o usuário for um indivíduo, use o formato `DOMAIN` \\ `user` para o `user` parâmetro. Você pode especificar "." para o `user` parâmetro para indicar o computador local.  
  
 As permissões atribuídas a <xref:System.Messaging.MessageQueue.SetPermissions%2A> adicionar direitos à lista existente. Por padrão, o criador de uma fila pública ou privada tem controle total e o grupo de domínio todos têm permissão para obter as propriedades de fila, obter permissões e gravar na fila. Quando você chama <xref:System.Messaging.MessageQueue.SetPermissions%2A>, as informações de permissões de usuário e são anexadas à parte inferior da lista existente.  
  
 O sistema examina cada <xref:System.Messaging.AccessControlEntry> na sequência até que ocorra um dos seguintes eventos:  
  
-   Um acesso negado <xref:System.Messaging.AccessControlEntry> nega explicitamente qualquer um dos direitos de acesso solicitado a um dos objetos de confiança mencionados no token de acesso do thread.  
  
-   Um ou mais acesso permitidos <xref:System.Messaging.AccessControlEntry> itens para objetos de confiança explicitamente listados no token de acesso do thread concedem os direitos de acesso solicitado.  
  
-   Todos os <xref:System.Messaging.AccessControlEntry> itens foram verificados e há ainda pelo menos um solicitada direito de acesso que não foi explicitamente permitido, nesse caso, o acesso é negado implicitamente.  
  
 Os direitos para uma fila, especificado no `rights` parâmetro pode ser qualquer combinação das seguintes opções:  
  
-   Controle total  
  
-   Excluir mensagem  
  
-   Receber mensagem  
  
-   Inspecionar mensagem  
  
-   Receber mensagens do diário  
  
-   Obter propriedades de fila  
  
-   Definir propriedades de fila  
  
-   Obter permissões  
  
-   Conjunto de permissões  
  
-   Assumir a propriedade de fila  
  
-   Gravar a mensagem  
  
 O <xref:System.Messaging.MessageQueueAccessRights> enumeração representa um conjunto de sinalizadores de bit que você pode combinar usando o operador bit a bit ou para criar o `rights` parâmetro.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29>.  
  
 [!code-cpp[MessageQueue2#25](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#25)]
 [!code-csharp[MessageQueue2#25](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.AccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_SynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the object that marshals the event-handler call resulting from a <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> or <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> event.</summary>
        <value>Um <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, que representa o objeto que controla a chamada do manipulador de eventos resultantes de um <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> ou <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> eventos. O padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Messaging.MessageQueue.ReceiveCompleted> ou <xref:System.Messaging.MessageQueue.PeekCompleted> evento resulta de uma <xref:System.Messaging.MessageQueue.BeginReceive%2A> ou <xref:System.Messaging.MessageQueue.BeginPeek%2A> solicitar, respectivamente, para um segmento específico. Normalmente, o <xref:System.Messaging.MessageQueue.SynchronizingObject%2A> é definido quando o componente relacionado é colocado dentro de um controle ou formulário, porque esses componentes estão associados a um segmento específico.  
  
 Normalmente, o objeto de sincronização realiza marshaling de uma chamada de método em um único thread.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Transactional">
      <MemberSignature Language="C#" Value="public bool Transactional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Transactional" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Transactional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transactional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Transactional { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Transactional : bool" Usage="System.Messaging.MessageQueue.Transactional" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Transactional")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the queue accepts only transactions.</summary>
        <value>
          <see langword="true" /> se a fila aceita apenas mensagens enviadas como parte de uma transação; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mensagens transacionais refere-se a união de várias mensagens relacionadas em uma única transação. Envio de mensagens como parte de uma transação assegura que as mensagens são entregues em ordem, entregue apenas uma vez e recuperados com êxito da sua fila de destino.  
  
 Se uma fila for transacional, ele aceita apenas mensagens que são enviadas como parte de uma transação. No entanto, uma mensagem não transacional pode ser enviada ou recebida de uma fila de transação local sem explicitamente usando transacional <xref:System.Messaging.MessageQueueTransaction.Begin%2A>, <xref:System.Messaging.MessageQueueTransaction.Commit%2A>, e <xref:System.Messaging.MessageQueueTransaction.Abort%2A> sintaxe. Se uma mensagem não transacional é enviada para uma fila transacional, esse componente cria uma transação de mensagem única para ele, exceto no caso de referência a uma fila em um computador remoto usando um nome de formato direto. Nessa situação, se você não especificar um contexto de transação ao enviar uma mensagem, ela não é criada para você e a mensagem será enviada para a fila de mensagens mortas.  
  
 Se você enviar uma mensagem não transacional para uma fila transacional, você não poderá reverter a mensagem em caso de uma exceção.  
  
 <xref:System.Messaging.MessageQueueTransaction> é de thread apartment com suporte, portanto, se o estado de apartment é `STA`, você não pode usar a transação em vários threads. Visual Basic define o estado do thread principal para `STA`, portanto, você deve aplicar o <xref:System.MTAThreadAttribute> no `Main` sub-rotina. Caso contrário, o envio de uma mensagem transacional usando outro thread gerará uma exceção <xref:System.Messaging.MessageQueueException>. Aplicar o <xref:System.MTAThreadAttribute> usando o seguinte fragmento.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.Transactional%2A> propriedade.  
  
 [!code-csharp[MessageQueue#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Begin" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Commit" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Abort" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether received messages are copied to the journal queue.</summary>
        <value>
          <see langword="true" /> Se as mensagens recebidas da fila são copiadas para a sua fila de diário; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando o aplicativo do serviço de enfileiramento de mensagens cria uma nova fila de aplicativo, ele cria automaticamente uma fila de diário associado no mesmo local. A fila de diário é usada para rastrear as mensagens removidas da fila. A definição dessa propriedade modifica o enfileiramento de mensagens. Portanto, qualquer outro <xref:System.Messaging.MessageQueue> instâncias são afetadas pela alteração.  
  
 A fila de diário não controla mensagens removidas da fila porque o timer de seu tempo de recebimento expirou, nem acompanha mensagens limpas da fila usando um serviço de diretório enfileiramento de mensagens (armazenamento de informações ou do Active Directory).  
  
 Aplicativos não podem enviar mensagens para filas de diário; eles são limitados a acesso somente leitura dessas filas. Além disso, enfileiramento de mensagens nunca remove as mensagens das filas de diário. O aplicativo usando a fila deve limpar essas mensagens recebê-los ou limpar a fila.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> propriedade.  
  
 [!code-csharp[MessageQueue#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing method.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="WriteHandle">
      <MemberSignature Language="C#" Value="public IntPtr WriteHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int WriteHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.WriteHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriteHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr WriteHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteHandle : nativeint" Usage="System.Messaging.MessageQueue.WriteHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the native handle used to send messages to the message queue.</summary>
        <value>Um identificador para o objeto de fila nativo que você usa para enviar mensagens à fila.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.MessageQueue.WriteHandle%2A> fornece um identificador nativo do Windows para o objeto de fila de mensagem que é usado para enviar mensagens à fila. Se você alterar o caminho da fila, o identificador é fechado e reaberto com um novo valor.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">The message queue is not available for writing.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
  </Members>
</Type>