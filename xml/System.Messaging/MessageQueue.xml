<Type Name="MessageQueue" FullName="System.Messaging.MessageQueue">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c3cea7cb79bd35bfc3544b467a76a8ca2a8133cd" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48649467" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MessageQueue : System.ComponentModel.Component, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueue" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageQueue&#xA;Inherits Component&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageQueue : System::ComponentModel::Component, System::Collections::IEnumerable" />
  <TypeSignature Language="F#" Value="type MessageQueue = class&#xA;    inherit Component&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("ReceiveCompleted")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.MessageQueueInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Messaging.MessagingDescription("MessageQueueDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornece acesso a uma fila de um servidor do Enfileiramento de Mensagens.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tecnologia de enfileiramento de mensagens permite que os aplicativos executados em momentos diferentes para se comunicar por redes heterogêneas e sistemas que podem estar temporariamente offline. Aplicativos enviam, receba ou inspecione (ler sem remover) mensagens de filas. O enfileiramento é um componente opcional do [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] e Windows NT e deve ser instalado separadamente.  
  
 O <xref:System.Messaging.MessageQueue> classe é um wrapper em torno de enfileiramento de mensagens. Há várias versões do enfileiramento de mensagens e usando o <xref:System.Messaging.MessageQueue> classe pode resultar em comportamento um pouco diferente, dependendo do sistema operacional você está usando. Para obter informações sobre os recursos específicos de cada versão do serviço de enfileiramento, consulte o tópico "O que há de novo no serviço de enfileiramento" no SDK da plataforma no MSDN.  
  
 O <xref:System.Messaging.MessageQueue> classe fornece uma referência a uma fila de enfileiramento de mensagens. Você pode especificar um caminho no <xref:System.Messaging.MessageQueue.%23ctor%2A> construtor para se conectar a um recurso existente, ou você pode criar uma nova fila no servidor. Antes de chamar <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, ou <xref:System.Messaging.MessageQueue.Receive%2A>, você deve associar a nova instância da <xref:System.Messaging.MessageQueue> classe com uma fila existente. Nesse ponto, você pode manipular as propriedades de fila, como <xref:System.Messaging.MessageQueue.Category%2A> e <xref:System.Messaging.MessageQueue.Label%2A>.  
  
 <xref:System.Messaging.MessageQueue> dá suporte a dois tipos de recuperação da mensagem: síncrono e assíncrono. Os métodos síncronos, <xref:System.Messaging.MessageQueue.Peek%2A> e <xref:System.Messaging.MessageQueue.Receive%2A>, fazer com que o thread de processo aguardar um intervalo de tempo especificado por uma nova mensagem chegar na fila. Os métodos assíncronos, <xref:System.Messaging.MessageQueue.BeginPeek%2A> e <xref:System.Messaging.MessageQueue.BeginReceive%2A>, permitir que as tarefas do aplicativo principal continuar em um thread separado, até que uma mensagem chega na fila. Esses métodos funcionam por meio de objetos de retorno de chamada e objetos de estado para comunicar informações entre threads.  
  
 Quando você cria uma nova instância do <xref:System.Messaging.MessageQueue> classe, você não estiver criando uma nova fila do serviço de enfileiramento de mensagens. Em vez disso, você pode usar o <xref:System.Messaging.MessageQueue.Create%28System.String%29>, <xref:System.Messaging.MessageQueue.Delete%28System.String%29>, e <xref:System.Messaging.MessageQueue.Purge%2A> métodos para gerenciar as filas no servidor.  
  
 Diferentemente <xref:System.Messaging.MessageQueue.Purge%2A>, <xref:System.Messaging.MessageQueue.Create%28System.String%29> e <xref:System.Messaging.MessageQueue.Delete%28System.String%29> são `static` membros, portanto, você pode chamá-las sem criar uma nova instância do <xref:System.Messaging.MessageQueue> classe.  
  
 Você pode definir as <xref:System.Messaging.MessageQueue> do objeto <xref:System.Messaging.MessageQueue.Path%2A> propriedade com um dos três nomes: o nome amigável, o <xref:System.Messaging.MessageQueue.FormatName%2A>, ou o <xref:System.Messaging.MessageQueue.Label%2A>. O nome amigável, que é definido pela fila de <xref:System.Messaging.MessageQueue.MachineName%2A> e <xref:System.Messaging.MessageQueue.QueueName%2A> propriedades, é <xref:System.Messaging.MessageQueue.MachineName%2A> \\ <xref:System.Messaging.MessageQueue.QueueName%2A> para uma fila pública, e <xref:System.Messaging.MessageQueue.MachineName%2A> \\ `Private$` \\ <xref:System.Messaging.MessageQueue.QueueName%2A> para uma fila particular. O <xref:System.Messaging.MessageQueue.FormatName%2A> propriedade permite o acesso offline a filas de mensagens. Por fim, você pode usar a fila <xref:System.Messaging.MessageQueue.Label%2A> propriedade para definir a fila <xref:System.Messaging.MessageQueue.Path%2A>.  
  
 Para obter uma lista de valores de propriedade inicial para uma instância do <xref:System.Messaging.MessageQueue>, consulte o <xref:System.Messaging.MessageQueue.%23ctor%2A> construtor.  
  
   
  
## Examples  
 O exemplo de código a seguir cria novos <xref:System.Messaging.MessageQueue> objetos usando vários tipos de sintaxe de nome de caminho. Em cada caso, ele envia uma mensagem para a fila cujo caminho é definido no construtor.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 O exemplo de código a seguir envia uma mensagem para uma fila e recebe uma mensagem de uma fila usando uma classe específica do aplicativo de chamada `Order`.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Somente o <see cref="M:System.Messaging.MessageQueue.GetAllMessages" /> método é thread-safe.</threadsafe>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="T:System.Messaging.MessageQueueException" />
    <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
    <altmember cref="P:System.Messaging.MessageQueue.Path" />
    <altmember cref="P:System.Messaging.MessageQueue.Label" />
    <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
    <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
    <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Messaging.MessageQueue" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Messaging.MessageQueue" />. Depois que o construtor padrão inicializa a nova instância, você deve definir a propriedade <see cref="P:System.Messaging.MessageQueue.Path" /> da instância antes de usar a instância.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para criar uma nova instância do <xref:System.Messaging.MessageQueue> classe que não está vinculado a uma fila no servidor de enfileiramento de mensagens imediatamente. Antes de usar essa instância, você deve conectá-lo a uma fila existente do serviço de enfileiramento de mensagens, definindo o <xref:System.Messaging.MessageQueue.Path%2A> propriedade. Como alternativa, você pode definir as <xref:System.Messaging.MessageQueue> de referência para o <xref:System.Messaging.MessageQueue.Create%28System.String%29> o valor retornado do método, criando uma nova fila do serviço de enfileiramento de mensagens.  
  
 O <xref:System.Messaging.MessageQueue.%23ctor%2A> construtor cria uma nova instância do <xref:System.Messaging.MessageQueue> classe; ele não cria uma nova fila do serviço de enfileiramento de mensagens.  
  
 A tabela a seguir mostra os valores de propriedade inicial para uma instância do <xref:System.Messaging.MessageQueue>.  
  
|Propriedade|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Os valores definidos pelo construtor padrão da <xref:System.Messaging.DefaultPropertiesToSend> classe.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Os valores definidos pelo construtor padrão da <xref:System.Messaging.MessagePropertyFilter> classe. Todos os valores de filtro são definidos como `true`.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
  
   
  
## Examples  
 O exemplo de código a seguir cria um novo <xref:System.Messaging.MessageQueue>.  
  
 [!code-csharp[MessageQueue#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O local da fila referenciada por este <see cref="T:System.Messaging.MessageQueue" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Messaging.MessageQueue" /> que referencia a fila de Enfileiramento de Mensagens no caminho especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga quando você deseja associar o novo <xref:System.Messaging.MessageQueue> instância para uma determinada fila Enfileiramento de mensagens, para o qual você sabe o caminho, nome de formato ou rótulo. Se você deseja conceder acesso exclusivo para o primeiro aplicativo que referencia a fila, você deve definir a <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> propriedade para `true` ou usar o construtor que passa um parâmetro de restrição de acesso de leitura.  
  
 O <xref:System.Messaging.MessageQueue.%23ctor%2A> construtor cria uma nova instância do <xref:System.Messaging.MessageQueue> classe; ele não cria uma nova fila do serviço de enfileiramento de mensagens. Para criar uma nova fila no enfileiramento de mensagens, use <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 A sintaxe do `path` parâmetro depende do tipo de fila-referências, conforme mostrado na tabela a seguir.  
  
|Tipo de fila|Sintaxe|  
|----------------|------------|  
|Fila pública|`MachineName`\\`QueueName`|  
|Fila particular|`MachineName`\\`Private$`\\`QueueName`|  
|Fila de diário|`MachineName`\\`QueueName`\\`Journal$`|  
|Fila de diário da máquina|`MachineName`\\`Journal$`|  
|Fila de inatividade do computador|`MachineName`\\`Deadletter$`|  
|Fila de inatividade transacional do computador|`MachineName`\\`XactDeadletter$`|  
  
 Como alternativa, você pode usar o <xref:System.Messaging.MessageQueue.FormatName%2A> ou <xref:System.Messaging.MessageQueue.Label%2A> para descrever o caminho da fila, conforme mostrado na tabela a seguir.  
  
|Referência|Sintaxe|Exemplo|  
|---------------|------------|-------------|  
|Nome do formato|`FormatName:` [ *nome do formato* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Rotular|`Label:` [ *label* ]|`Label:` TheLabel|  
  
 Para trabalhar offline, você deve usar a sintaxe de nome de formato, não a sintaxe de nome de caminho para o construtor. Caso contrário, uma exceção é gerada porque o controlador de domínio primário não está disponível para resolver o caminho para o nome do formato.  
  
 A tabela a seguir mostra os valores de propriedade inicial para uma instância do <xref:System.Messaging.MessageQueue>. Esses valores são com base nas propriedades da fila de enfileiramento de mensagens com o caminho especificado pelo `path` parâmetro.  
  
|Propriedade|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Os valores definidos pelo construtor padrão da <xref:System.Messaging.DefaultPropertiesToSend> classe.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, se a configuração de nível de privacidade do enfileiramento de mensagens da fila é o "Corpo"; Caso contrário, `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|O valor da propriedade de nome de computador do enfileiramento de mensagens da fila.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Os valores definidos pelo construtor padrão da <xref:System.Messaging.MessagePropertyFilter> classe.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, se não for definido pelo construtor.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, se não for definido pelo construtor.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, se a configuração de diário do objeto enfileiramento de mensagens estiver habilitada; Caso contrário, `false`.|  
  
   
  
## Examples  
 O exemplo de código a seguir cria novos <xref:System.Messaging.MessageQueue> objetos usando vários tipos de sintaxe de nome de caminho. Em cada caso, ele envia uma mensagem para a fila cujo caminho é definido no construtor.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A propriedade <see cref="P:System.Messaging.MessageQueue.Path" /> não é válida, possivelmente porque não foi definida.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">O local da fila referenciada por este <see cref="T:System.Messaging.MessageQueue" />, que pode ser “.” no computador local.</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> para conceder acesso de leitura exclusivo ao primeiro aplicativo que acessar a fila; caso contrário, <see langword="false" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Messaging.MessageQueue" /> que referencia a fila do serviço de enfileiramento de mensagens no caminho especificado e com a restrição de acesso de leitura especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga quando você deseja associar o novo <xref:System.Messaging.MessageQueue> para uma determinada fila Enfileiramento de mensagens, para o qual você sabe o caminho, nome de formato ou rótulo. Se você deseja conceder acesso exclusivo para o primeiro aplicativo que faz referência a fila, defina as `sharedModeDenyReceive` parâmetro para `true`. Caso contrário, defina `sharedModeDenyReceive` à `false` ou usar o construtor que tem apenas um `path` parâmetro.  
  
 Definindo `sharedModeDenyReceive` para `true` afeta todos os objetos que acessam a fila de enfileiramento de mensagens, incluindo outros aplicativos. Os efeitos do parâmetro não estão restritos a esse aplicativo.  
  
 O <xref:System.Messaging.MessageQueue.%23ctor%2A> construtor cria uma nova instância do <xref:System.Messaging.MessageQueue> classe; ele não cria uma nova fila do serviço de enfileiramento de mensagens. Para criar uma nova fila no enfileiramento de mensagens, use <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 A sintaxe do `path` parâmetro depende do tipo de fila.  
  
|Tipo de fila|Sintaxe|  
|----------------|------------|  
|Fila pública|`MachineName`\\`QueueName`|  
|Fila particular|`MachineName`\\`Private$`\\`QueueName`|  
|Fila de diário|`MachineName`\\`QueueName`\\`Journal$`|  
|Fila de diário da máquina|`MachineName`\\`Journal$`|  
|Fila de inatividade do computador|`MachineName`\\`Deadletter$`|  
|Fila de inatividade transacional do computador|`MachineName`\\`XactDeadletter$`|  
  
 Como alternativa, você pode usar o nome de formato ou o rótulo de uma fila de enfileiramento de mensagens para descrever o caminho da fila.  
  
|Referência|Sintaxe|Exemplo|  
|---------------|------------|-------------|  
|Nome do formato|`FormatName:` [ *nome do formato* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Rotular|`Label:` [ *label* ]|`Label:` TheLabel|  
  
 Para trabalhar offline, você deve usar a sintaxe de nome de formato, em vez da sintaxe de nome amigável. Caso contrário, uma exceção é gerada porque o controlador de domínio primário (no qual o Active Directory reside) não está disponível para resolver o caminho para o nome do formato.  
  
 Se um <xref:System.Messaging.MessageQueue> abrir uma fila com o `sharedModeDenyReceive` parâmetro definido como `true`, qualquer <xref:System.Messaging.MessageQueue> que gera de tentar ler da fila subsequentemente um <xref:System.Messaging.MessageQueueException> devido a uma violação de compartilhamento. Um <xref:System.Messaging.MessageQueueException> também será gerada se um <xref:System.Messaging.MessageQueue> tenta acessar a fila no modo exclusivo quando outra <xref:System.Messaging.MessageQueue> já tem o acesso não exclusivo para a fila.  
  
 A tabela a seguir mostra os valores de propriedade inicial para uma instância do <xref:System.Messaging.MessageQueue>. Esses valores são baseados nas propriedades da fila de enfileiramento de mensagens, com o caminho especificado pelo `path` parâmetro.  
  
|Propriedade|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`.|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0.|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>.|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Os valores definidos pelo construtor padrão da <xref:System.Messaging.DefaultPropertiesToSend> classe.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, se a configuração de nível de privacidade do enfileiramento de mensagens da fila é o "Corpo"; Caso contrário, `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>.|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>.|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|O valor da propriedade de nome de computador do enfileiramento de mensagens da fila.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Os valores definidos pelo construtor padrão da <xref:System.Messaging.MessagePropertyFilter> classe.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, se não for definido pelo construtor.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, se não for definido pelo construtor.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|O valor da `sharedModeDenyReceive` parâmetro.|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, se a configuração de diário do objeto enfileiramento de mensagens estiver habilitada; Caso contrário, `false`.|  
  
   
  
## Examples  
 O exemplo de código a seguir cria um novo <xref:System.Messaging.MessageQueue> com acesso exclusivo, define seu caminho e envia uma mensagem à fila.  
  
 [!code-cpp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CPP/mqctor_denysharedreceive.cpp#1)]
 [!code-csharp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CS/mqctor_denysharedreceive.cs#1)]
 [!code-vb[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/VB/mqctor_denysharedreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A propriedade <see cref="P:System.Messaging.MessageQueue.Path" /> não é válida, possivelmente porque não foi definida.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">O local da fila referenciada por este <see cref="T:System.Messaging.MessageQueue" />, que pode ser “.” no computador local.</param>
        <param name="accessMode">Um dos valores de <see cref="T:System.Messaging.QueueAccessMode" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">O local da fila referenciada por este <see cref="T:System.Messaging.MessageQueue" />, que pode ser “.” no computador local.</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> para conceder acesso de leitura exclusivo ao primeiro aplicativo que acessar a fila; caso contrário, <see langword="false" />.</param>
        <param name="enableCache">
          <see langword="true" /> para criar e usar um cache de conexão; caso contrário, <see langword="false" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir cria um novo <xref:System.Messaging.MessageQueue> com acesso de leitura exclusivo e com a conexão em cache habilitada.  
  
 [!code-cpp[MessageQueue4#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue4/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue4#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue4/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">O local da fila referenciada por este <see cref="T:System.Messaging.MessageQueue" />, que pode ser “.” no computador local.</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> para conceder acesso de leitura exclusivo ao primeiro aplicativo que acessar a fila; caso contrário, <see langword="false" />.</param>
        <param name="enableCache">
          <see langword="true" /> para criar e usar um cache de conexão; caso contrário, <see langword="false" />.</param>
        <param name="accessMode">Um dos valores de <see cref="T:System.Messaging.QueueAccessMode" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessMode">
      <MemberSignature Language="C#" Value="public System.Messaging.QueueAccessMode AccessMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.QueueAccessMode AccessMode" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.AccessMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessMode As QueueAccessMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::QueueAccessMode AccessMode { System::Messaging::QueueAccessMode get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessMode : System.Messaging.QueueAccessMode" Usage="System.Messaging.MessageQueue.AccessMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.QueueAccessMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica o modo de acesso da fila.</summary>
        <value>Um dos valores de <see cref="T:System.Messaging.QueueAccessMode" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O modo de acesso padrão para uma fila é `QueueAccessMode.SendAndReceive`, a menos que você especifique de outra forma ao chamar o construtor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public bool Authenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Authenticate" />
      <MemberSignature Language="VB.NET" Value="Public Property Authenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Authenticate : bool with get, set" Usage="System.Messaging.MessageQueue.Authenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Authenticate")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se a fila aceita apenas mensagens autenticadas.</summary>
        <value>
          <see langword="true" /> se a fila aceita apenas mensagens autenticadas; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Autenticação de mensagem fornece uma maneira de garantir a integridade de mensagens e para verificar quem enviou a mensagem. Para solicitar autenticação, o aplicativo de envio define o nível de autenticação da mensagem.  
  
 Quando você define <xref:System.Messaging.MessageQueue.Authenticate%2A> à `true`, você está restringindo acesso à fila no servidor, não apenas a este <xref:System.Messaging.MessageQueue> instância. Todos os clientes que trabalham com a mesma fila do serviço de enfileiramento de mensagens serão afetados.  
  
 Uma fila que aceita apenas mensagens autenticadas rejeitará uma mensagem não autenticada. Para solicitar notificação de rejeição de mensagem, um aplicativo de envio pode definir o <xref:System.Messaging.Message.AcknowledgeType%2A> propriedade da mensagem. Como não existe nenhuma outra indicação de rejeição da mensagem, o aplicativo de envio pode perder a mensagem, a menos que você solicita que ela seja enviada para a fila de inatividade.  
  
 A tabela a seguir mostra se essa propriedade está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.Authenticate%2A> propriedade.  
  
 [!code-csharp[MessageQueue#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public short BasePriority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public Property BasePriority As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short BasePriority { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int16 with get, set" Usage="System.Messaging.MessageQueue.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_BasePriority")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a prioridade base que o Enfileiramento de Mensagens usa para rotear mensagens de uma fila pública pela rede.</summary>
        <value>A prioridade base única para todas as mensagens enviadas à fila (pública). O padrão é zero (0).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prioridade básica de uma fila de mensagens Especifica como uma mensagem voltados para que a fila é tratada enquanto trafegam por meio da rede. Você pode definir o <xref:System.Messaging.MessageQueue.BasePriority%2A> propriedade concede uma prioridade maior ou menor para todas as mensagens enviadas para a fila especificada do que aquelas enviadas a outras filas. A definição dessa propriedade modifica a fila de enfileiramento de mensagens. Portanto, qualquer outro <xref:System.Messaging.MessageQueue> instâncias são afetadas pela alteração.  
  
 Uma fila de mensagens <xref:System.Messaging.MessageQueue.BasePriority%2A> não está relacionado ao <xref:System.Messaging.Message.Priority%2A> propriedade de uma mensagem, que especifica a ordem na qual uma mensagem de entrada é colocada na fila.  
  
 <xref:System.Messaging.MessageQueue.BasePriority%2A> aplica-se somente para as filas públicas cujos caminhos são especificados usando o nome de formato. A prioridade básica de uma fila particular é sempre zero (0).  
  
 A tabela a seguir mostra se essa propriedade está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.BasePriority%2A> propriedade.  
  
 [!code-csharp[MessageQueue#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A prioridade base foi definida como um valor inválido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginPeek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <summary>Inicia uma operação de espiada assíncrona informando o Enfileiramento de Mensagens para começar a espiar uma mensagem e notificar o manipulador de eventos quando terminar.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek();" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : unit -&gt; IAsyncResult" Usage="messageQueue.BeginPeek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia uma operação de espiada assíncrona que não tem um tempo limite. A operação não é concluída até que uma mensagem se torna disponível na fila.</summary>
        <returns>O <see cref="T:System.IAsyncResult" /> que identifica a solicitação assíncrona postada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O processamento assíncrono, você usa <xref:System.Messaging.MessageQueue.BeginPeek%2A> para gerar o <xref:System.Messaging.MessageQueue.PeekCompleted> evento quando uma mensagem fique disponível na fila.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> também será gerado se já existir uma mensagem na fila.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginPeek%2A>, crie um manipulador de eventos que processa os resultados da operação assíncrona e associá-lo com seu representante de evento. <xref:System.Messaging.MessageQueue.BeginPeek%2A> inicia uma operação de espiada assíncrona; o <xref:System.Messaging.MessageQueue> recebe uma notificação por meio do aumento dos o <xref:System.Messaging.MessageQueue.PeekCompleted> evento, quando uma mensagem chega na fila. O <xref:System.Messaging.MessageQueue> , em seguida, pode acessar a mensagem chamando <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> ou recuperando os resultados usando o <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 O <xref:System.Messaging.MessageQueue.BeginPeek%2A> método retorna imediatamente, mas não é possível concluir a operação assíncrona até que o manipulador de eventos é chamado.  
  
 Porque <xref:System.Messaging.MessageQueue.BeginPeek%2A> é assíncrona, você pode chamá-lo para inspecionar a fila sem bloquear o thread de execução atual. Para inspecionar sincronamente a fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método.  
  
 Quando uma operação assíncrona for concluída, você pode chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente no manipulador de eventos para manter recebimento de notificações.  
  
 O <xref:System.IAsyncResult> que <xref:System.Messaging.MessageQueue.BeginPeek%2A> retorna identifica a operação assíncrona que o método foi iniciado. Você pode usá-lo <xref:System.IAsyncResult> durante o tempo de vida da operação, embora você geralmente não usá-lo até <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> é chamado. No entanto, se você iniciar várias operações assíncronas, você pode colocar suas <xref:System.IAsyncResult> valores em uma matriz e especifique se deseja aguardar a conclusão de qualquer operação ou de todas as operações. Nesse caso, você usa o <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriedade do <xref:System.IAsyncResult> para identificar a operação concluída.  
  
 Se <xref:System.Messaging.MessageQueue.CanRead%2A> está `false`, o evento de conclusão é gerado, mas uma exceção será gerada ao chamar <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir cria um manipulador de eventos chamado `MyPeekCompleted`, anexa-o para o <xref:System.Messaging.MessageQueue.PeekCompleted> delegado manipulador de eventos e chamadas <xref:System.Messaging.MessageQueue.BeginPeek%2A> para iniciar uma operação de espiada assíncrona na fila que está localizada no caminho ". \myQueue". Quando um <xref:System.Messaging.MessageQueue.PeekCompleted> evento é gerado, o exemplo espia a mensagem e grava seu corpo para a tela. O exemplo, em seguida, chama <xref:System.Messaging.MessageQueue.BeginPeek%2A> novamente para iniciar uma nova operação de espiada assíncrona.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginPeek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o intervalo de tempo para aguardar uma mensagem se tornar disponível.</param>
        <summary>Inicia uma operação de espiada assíncrona que tem um tempo limite especificado. A operação não é concluída até que uma mensagem se torna disponível na fila ou que ocorra o tempo limite.</summary>
        <returns>O <see cref="T:System.IAsyncResult" /> que identifica a solicitação assíncrona postada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O processamento assíncrono, você usa <xref:System.Messaging.MessageQueue.BeginPeek%2A> para gerar o <xref:System.Messaging.MessageQueue.PeekCompleted> evento quando uma mensagem fique disponível na fila ou o intervalo de tempo especificado tiver expirado.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> também será gerado se já existir uma mensagem na fila.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginPeek%2A>, crie um manipulador de eventos que processa os resultados da operação assíncrona e associá-lo com seu representante de evento. <xref:System.Messaging.MessageQueue.BeginPeek%2A> inicia uma operação de espiada assíncrona; o <xref:System.Messaging.MessageQueue> recebe uma notificação por meio do aumento dos o <xref:System.Messaging.MessageQueue.PeekCompleted> evento, quando uma mensagem chega na fila. O <xref:System.Messaging.MessageQueue> , em seguida, pode acessar a mensagem chamando <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> ou recuperando os resultados usando o <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 O <xref:System.Messaging.MessageQueue.BeginPeek%2A> método retorna imediatamente, mas não é possível concluir a operação assíncrona até que o manipulador de eventos é chamado.  
  
 Porque <xref:System.Messaging.MessageQueue.BeginPeek%2A> é assíncrona, você pode chamá-lo para inspecionar a fila sem bloquear o thread de execução atual. Para inspecionar sincronamente a fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método.  
  
 Quando uma operação assíncrona for concluída, você pode chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente no manipulador de eventos para manter recebimento de notificações.  
  
 O <xref:System.IAsyncResult> que <xref:System.Messaging.MessageQueue.BeginPeek%2A> retorna identifica a operação assíncrona que o método foi iniciado. Você pode usá-lo <xref:System.IAsyncResult> durante o tempo de vida da operação, embora você geralmente não usá-lo até <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> é chamado. No entanto, se você iniciar várias operações assíncronas, você pode colocar suas <xref:System.IAsyncResult> valores em uma matriz e especifique se deseja aguardar a conclusão de qualquer operação ou de todas as operações. Nesse caso, você usa o <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriedade do <xref:System.IAsyncResult> para identificar a operação concluída.  
  
 Essa sobrecarga Especifica um tempo limite. Se o intervalo especificado pela `timeout` parâmetro expira, esse componente aciona o <xref:System.Messaging.MessageQueue.PeekCompleted> eventos. Como não existe nenhuma mensagem, uma chamada subsequente para <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> lançará uma exceção.  
  
 Se <xref:System.Messaging.MessageQueue.CanRead%2A> está `false`, o evento de conclusão é gerado, mas uma exceção será gerada ao chamar <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma operação de espiada assíncrona, usando o caminho da fila ". \myQueue". Ele cria um manipulador de eventos `MyPeekCompleted`e anexa-o para o <xref:System.Messaging.MessageQueue.PeekCompleted> delegado manipulador de eventos. <xref:System.Messaging.MessageQueue.BeginPeek%2A> é chamado com um tempo limite de um minuto, para iniciar a operação de espiada assíncrona. Quando um <xref:System.Messaging.MessageQueue.PeekCompleted> é gerado ou o tempo limite expirar, a mensagem é recuperada, se houver, e seu corpo é gravado na tela. Em seguida, <xref:System.Messaging.MessageQueue.BeginPeek%2A> é chamado novamente para iniciar uma nova operação de espiada assíncrona com o tempo limite da mesma.  
  
 [!code-cpp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CPP/mqbeginpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CS/mqbeginpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/VB/mqbeginpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o intervalo de tempo para aguardar uma mensagem se tornar disponível.</param>
        <param name="stateObject">Um objeto de estado, especificado pelo aplicativo, que contém informações associadas à operação assíncrona.</param>
        <summary>Inicia uma operação assíncrona de espiada que tem um tempo limite especificado e um objeto de estado especificado, que fornece informações associadas durante todo o tempo de vida da operação. A operação não é concluída até que uma mensagem se torna disponível na fila ou que ocorra o tempo limite.</summary>
        <returns>O <see cref="T:System.IAsyncResult" /> que identifica a solicitação assíncrona postada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O processamento assíncrono, você usa <xref:System.Messaging.MessageQueue.BeginPeek%2A> para gerar o <xref:System.Messaging.MessageQueue.PeekCompleted> evento quando uma mensagem fique disponível na fila ou o intervalo de tempo especificado tiver expirado.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> também será gerado se já existir uma mensagem na fila.  
  
 Use essa sobrecarga para associar informações com a operação que será preservada em todo o tempo de vida da operação. O manipulador de eventos pode acessar essas informações ao examinar a <xref:System.IAsyncResult.AsyncState%2A> propriedade do <xref:System.IAsyncResult> que está associado com a operação.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginPeek%2A>, crie um manipulador de eventos que processa os resultados da operação assíncrona e associá-lo com seu representante de evento. <xref:System.Messaging.MessageQueue.BeginPeek%2A> inicia uma operação de espiada assíncrona; o <xref:System.Messaging.MessageQueue> recebe uma notificação por meio do aumento dos o <xref:System.Messaging.MessageQueue.PeekCompleted> evento, quando uma mensagem chega na fila. O <xref:System.Messaging.MessageQueue> , em seguida, pode acessar a mensagem chamando <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> ou recuperando os resultados usando o <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 O <xref:System.Messaging.MessageQueue.BeginPeek%2A> método retorna imediatamente, mas não é possível concluir a operação assíncrona até que o manipulador de eventos é chamado.  
  
 Porque <xref:System.Messaging.MessageQueue.BeginPeek%2A> é assíncrona, você pode chamá-lo para inspecionar a fila sem bloquear o thread de execução atual. Para inspecionar sincronamente a fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método.  
  
 Quando uma operação assíncrona for concluída, você pode chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente no manipulador de eventos para manter recebimento de notificações.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Retorna um <xref:System.IAsyncResult> que identifica a operação assíncrona que o método foi iniciado. Você pode usá-lo <xref:System.IAsyncResult> durante o tempo de vida da operação, embora você geralmente não usá-lo até <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> é chamado. No entanto, se você iniciar várias operações assíncronas, você pode colocar suas <xref:System.IAsyncResult> valores em uma matriz e especifique se deseja aguardar a conclusão de qualquer operação ou de todas as operações. Nesse caso, você usa o <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriedade do <xref:System.IAsyncResult> para identificar a operação concluída.  
  
 Essa sobrecarga Especifica um tempo limite e um objeto de estado. Se o intervalo especificado pela `timeout` parâmetro expira, esse componente aciona o <xref:System.Messaging.MessageQueue.PeekCompleted> eventos. Como não existe nenhuma mensagem, uma chamada subsequente para <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> lançará uma exceção.  
  
 O objeto de estado associa informações de estado com a operação. Por exemplo, se você chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> várias vezes para iniciar várias operações, você pode identificar cada operação por meio de um objeto de estado separado que você definir. Para obter uma ilustração desse cenário, consulte a seção de exemplo.  
  
 Você também pode usar o objeto de estado para passar informações entre os threads de processo. Se um thread é iniciado, mas o retorno de chamada está em um thread diferente em um cenário assíncrono, o objeto de estado é empacotado e passado novamente, juntamente com informações do evento.  
  
 Se <xref:System.Messaging.MessageQueue.CanRead%2A> está `false`, o evento de conclusão é gerado, mas uma exceção será gerada ao chamar <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma operação de espiada assíncrona, usando o caminho da fila ". \myQueue". Ele cria um manipulador de eventos `MyPeekCompleted`e anexa-o para o <xref:System.Messaging.MessageQueue.PeekCompleted> delegado manipulador de eventos. <xref:System.Messaging.MessageQueue.BeginPeek%2A> é chamado, com um tempo limite de um minuto. Cada chamada para <xref:System.Messaging.MessageQueue.BeginPeek%2A> tem um inteiro exclusivo associado que identifica a operação específica. Quando um <xref:System.Messaging.MessageQueue.PeekCompleted> é gerado ou o tempo limite expirou, a mensagem, se houver, é recuperada e seu corpo e o identificador do inteiro específicos da operação são gravados na tela. Em seguida, <xref:System.Messaging.MessageQueue.BeginPeek%2A> é chamado novamente para iniciar uma nova operação de espiada assíncrona com o mesmo tempo de limite e o inteiro associado da operação concluída apenas.  
  
 [!code-cpp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CPP/mqbeginpeek_timeoutstateobject.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CS/mqbeginpeek_timeoutstateobject.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/VB/mqbeginpeek_timeoutstateobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o intervalo de tempo para aguardar uma mensagem se tornar disponível.</param>
        <param name="stateObject">Um objeto de estado, especificado pelo aplicativo, que contém informações associadas à operação assíncrona.</param>
        <param name="callback">O <see cref="T:System.AsyncCallback" /> que receberá a notificação da conclusão da operação assíncrona.</param>
        <summary>Inicia uma operação assíncrona de espiada que tem um tempo limite especificado e um objeto de estado especificado, que fornece informações associadas durante todo o tempo de vida da operação. Essa sobrecarga recebe uma notificação, por meio de um retorno de chamada, da identidade do manipulador de eventos da operação. A operação não é concluída até que uma mensagem se torna disponível na fila ou que ocorra o tempo limite.</summary>
        <returns>O <see cref="T:System.IAsyncResult" /> que identifica a solicitação assíncrona postada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você usar essa sobrecarga, o retorno de chamada especificado no parâmetro de retorno de chamada é invocado diretamente quando uma mensagem fique disponível na fila ou o intervalo de tempo especificado tiver expirado; o <xref:System.Messaging.MessageQueue.PeekCompleted> não é gerado. As outras sobrecargas de <xref:System.Messaging.MessageQueue.BeginPeek%2A> contar com esse componente para gerar o <xref:System.Messaging.MessageQueue.PeekCompleted> eventos.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> também será gerado se já existir uma mensagem na fila.  
  
 O <xref:System.Messaging.MessageQueue.BeginPeek%2A> método retorna imediatamente, mas não é possível concluir a operação assíncrona até que o manipulador de eventos é chamado.  
  
 Porque <xref:System.Messaging.MessageQueue.BeginPeek%2A> é assíncrona, você pode chamá-lo para inspecionar a fila sem bloquear o thread de execução atual. Para inspecionar sincronamente a fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método.  
  
 Quando uma operação assíncrona for concluída, você pode chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente no manipulador de eventos para manter recebimento de notificações.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Retorna um <xref:System.IAsyncResult> que identifica a operação assíncrona que o método foi iniciado. Você pode usá-lo <xref:System.IAsyncResult> durante o tempo de vida da operação, embora você geralmente não usá-lo até <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> é chamado. No entanto, se você iniciar várias operações assíncronas, você pode colocar suas <xref:System.IAsyncResult> valores em uma matriz e especifique se deseja aguardar a conclusão de qualquer operação ou de todas as operações. Nesse caso, você usa o <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriedade do <xref:System.IAsyncResult> para identificar a operação concluída.  
  
 O objeto de estado associa informações de estado com a operação. Por exemplo, se você chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> várias vezes para iniciar várias operações, você pode identificar cada operação por meio de um objeto de estado separado que você definir.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma operação de espiada assíncrona. Os envios de exemplo de código uma mensagem para uma fila de mensagens local, em seguida, chama <xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, passando: um valor de tempo limite de dez segundos; um inteiro exclusivo que identifica essa mensagem específica; e uma nova instância da <xref:System.AsyncCallback> que identifica o manipulador de eventos `MyPeekCompleted`. Quando um <xref:System.Messaging.MessageQueue.PeekCompleted> evento é gerado, o manipulador de eventos exibe a mensagem e grava o corpo da mensagem e o identificador inteiro da mensagem na tela.  
  
 [!code-cpp[MessageQueueBeginPeek#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginPeek/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginPeek#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginPeek/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, cursor, action, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o intervalo de tempo para aguardar uma mensagem se tornar disponível.</param>
        <param name="cursor">Um <see cref="T:System.Messaging.Cursor" /> que mantém uma posição específica na fila de mensagens.</param>
        <param name="action">Um dos valores de <see cref="T:System.Messaging.PeekAction" />. Indica se a mensagem atual ou a próxima na fila de mensagens deve ser espiada.</param>
        <param name="state">Um objeto de estado, especificado pelo aplicativo, que contém informações associadas à operação assíncrona.</param>
        <param name="callback">O <see cref="T:System.AsyncCallback" /> que recebe a notificação de conclusão de operação assíncrona.</param>
        <summary>Inicia uma operação de espiada assíncrona que tem um tempo limite especificado e usa um cursor específico, uma ação de espiada especificada e um objeto de estado especificado. O objeto de estado fornece informações associadas em todo o tempo de vida da operação. Essa sobrecarga recebe uma notificação, por meio de um retorno de chamada, da identidade do manipulador de eventos da operação. A operação não é concluída até que uma mensagem se torna disponível na fila ou que ocorra o tempo limite.</summary>
        <returns>O <see cref="T:System.IAsyncResult" /> que identifica a solicitação assíncrona postada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você usa essa sobrecarga, o retorno de chamada especificado no parâmetro de retorno de chamada é invocado diretamente quando uma mensagem fique disponível na fila ou o intervalo de tempo especificado tiver expirado. O <xref:System.Messaging.MessageQueue.PeekCompleted> não é gerado. As outras sobrecargas de <xref:System.Messaging.MessageQueue.BeginPeek%2A> contar com esse componente para gerar o <xref:System.Messaging.MessageQueue.PeekCompleted> eventos.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> também será gerado se já existir uma mensagem na fila.  
  
 O <xref:System.Messaging.MessageQueue.BeginPeek%2A> método retorna imediatamente, mas não é possível concluir a operação assíncrona até que o manipulador de eventos é chamado.  
  
 Porque <xref:System.Messaging.MessageQueue.BeginPeek%2A> é assíncrona, você pode chamá-lo para inspecionar a fila sem bloquear o thread de execução atual. Para inspecionar sincronamente a fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método.  
  
 Quando uma operação assíncrona for concluída, você pode chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente no manipulador de eventos para manter recebimento de notificações.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Retorna um <xref:System.IAsyncResult> que identifica a operação assíncrona iniciada pelo método. Você pode usá-lo <xref:System.IAsyncResult> durante o tempo de vida da operação, embora você geralmente não usá-lo até <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> é chamado. No entanto, se você iniciar várias operações assíncronas, você pode colocar suas <xref:System.IAsyncResult> valores em uma matriz e especifique se deseja aguardar a conclusão de qualquer operação ou de todas as operações. Nesse caso, use o <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriedade do <xref:System.IAsyncResult> para identificar a operação concluída.  
  
 O objeto de estado associa informações de estado com a operação. Por exemplo, se você chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> várias vezes para iniciar várias operações, você pode identificar cada operação por meio de um objeto de estado separado que você definir.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Um valor diferente de <see langword="PeekAction.Current" /> ou <see langword="PeekAction.Next" /> foi especificado para o parâmetro <paramref name="action" />.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="cursor" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <summary>Inicia uma operação de recepção assíncrona informando o Enfileiramento de Mensagens para começar a receber uma mensagem e notificar o manipulador de eventos quando terminar.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive();" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : unit -&gt; IAsyncResult" Usage="messageQueue.BeginReceive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia uma operação de recebimento assíncrona que não tem um tempo limite. A operação não é concluída até que uma mensagem se torna disponível na fila.</summary>
        <returns>O <see cref="T:System.IAsyncResult" /> que identifica a solicitação assíncrona postada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O processamento assíncrono, você usa <xref:System.Messaging.MessageQueue.BeginReceive%2A> para gerar o <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento quando uma mensagem foi removida da fila.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> também será gerado se já existir uma mensagem na fila.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginReceive%2A>, crie um manipulador de eventos que processa os resultados da operação assíncrona e associá-lo com seu representante de evento. <xref:System.Messaging.MessageQueue.BeginReceive%2A> inicia uma recebimento assíncrona operação; o <xref:System.Messaging.MessageQueue> recebe uma notificação por meio do aumento dos o <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento, quando uma mensagem chega na fila. O <xref:System.Messaging.MessageQueue> , em seguida, pode acessar a mensagem chamando <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 O <xref:System.Messaging.MessageQueue.BeginReceive%2A> método retorna imediatamente, mas não é possível concluir a operação assíncrona até que o manipulador de eventos é chamado.  
  
 Porque <xref:System.Messaging.MessageQueue.BeginReceive%2A> é assíncrona, você pode chamá-lo para receber uma mensagem da fila sem bloquear o thread de execução atual. Para receber assincronamente uma mensagem, use o <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Quando uma operação assíncrona for concluída, você pode chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente no manipulador de eventos para manter recebimento de notificações.  
  
 O <xref:System.IAsyncResult> que <xref:System.Messaging.MessageQueue.BeginReceive%2A> retorna identifica a operação assíncrona que o método foi iniciado. Você pode usá-lo <xref:System.IAsyncResult> durante o tempo de vida da operação, embora você geralmente não usá-lo até <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> é chamado. No entanto, se você iniciar várias operações assíncronas, você pode colocar suas <xref:System.IAsyncResult> valores em uma matriz e especifique se deseja aguardar a conclusão de qualquer operação ou de todas as operações. Nesse caso, você usa o <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriedade do <xref:System.IAsyncResult> para identificar a operação concluída.  
  
 Se <xref:System.Messaging.MessageQueue.CanRead%2A> está `false`, o evento de conclusão é gerado, mas uma exceção será gerada ao chamar <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Não use a chamada assíncrona <xref:System.Messaging.MessageQueue.BeginReceive%2A> com transações. Se você quiser executar uma operação assíncrona transacional, chame <xref:System.Messaging.MessageQueue.BeginPeek%2A>e coloque a transação e (síncrono) <xref:System.Messaging.MessageQueue.Receive%2A> método dentro do manipulador de eventos que você cria para a operação de espiada. O manipulador de eventos pode conter funcionalidade, conforme mostrado no código a seguir em C#.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir encadeia solicitações assíncronas. Ele pressupõe que há uma fila no computador local chamado "myQueue". O `Main` função começa a operação assíncrona que é tratada pelo `MyReceiveCompleted` rotina. `MyReceiveCompleted` processa a mensagem atual e inicia um novo assíncrona operação de recebimento.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 O exemplo de código a seguir enfileira as solicitações assíncronas. A chamada para <xref:System.Messaging.MessageQueue.BeginReceive%2A> usa o <xref:System.IAsyncResult.AsyncWaitHandle%2A> em seu valor de retorno. O `Main` rotina aguarda todas as operações assíncronas ser concluída antes de sair.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_wh.cpp#2)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_wh.cs#2)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_wh.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginReceive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o intervalo de tempo para aguardar uma mensagem se tornar disponível.</param>
        <summary>Inicia uma operação de recebimento assíncrona que tem um tempo limite especificado. A operação não é concluída até que uma mensagem se torna disponível na fila ou que ocorra o tempo limite.</summary>
        <returns>O <see cref="T:System.IAsyncResult" /> que identifica a solicitação assíncrona postada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O processamento assíncrono, você usa <xref:System.Messaging.MessageQueue.BeginReceive%2A> para gerar o <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento quando uma mensagem fique disponível na fila ou o intervalo de tempo especificado tiver expirado.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> também será gerado se já existir uma mensagem na fila.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginReceive%2A>, crie um manipulador de eventos que processa os resultados da operação assíncrona e associá-lo com seu representante de evento. <xref:System.Messaging.MessageQueue.BeginReceive%2A> inicia uma recebimento assíncrona operação; o <xref:System.Messaging.MessageQueue> recebe uma notificação por meio do aumento dos o <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento, quando uma mensagem chega na fila. O <xref:System.Messaging.MessageQueue> , em seguida, pode acessar a mensagem chamando <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> ou ao recuperar os resultados usando o <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 O <xref:System.Messaging.MessageQueue.BeginReceive%2A> método retorna imediatamente, mas não é possível concluir a operação assíncrona até que o manipulador de eventos é chamado.  
  
 Porque <xref:System.Messaging.MessageQueue.BeginReceive%2A> é assíncrona, você pode chamá-lo para receber uma mensagem da fila sem bloquear o thread de execução atual. Para receber assincronamente uma mensagem, use o <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Quando uma operação assíncrona for concluída, você pode chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente no manipulador de eventos para manter recebimento de notificações.  
  
 Se <xref:System.Messaging.MessageQueue.CanRead%2A> está `false`, o evento de conclusão é gerado, mas uma exceção será gerada ao chamar <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 O <xref:System.IAsyncResult> que <xref:System.Messaging.MessageQueue.BeginReceive%2A> retorna identifica a operação assíncrona que o método foi iniciado. Você pode usá-lo <xref:System.IAsyncResult> durante o tempo de vida da operação, embora você geralmente não usá-lo até <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> é chamado. No entanto, se você iniciar várias operações assíncronas, você pode colocar suas <xref:System.IAsyncResult> valores em uma matriz e especifique se deseja aguardar a conclusão de qualquer operação ou de todas as operações. Nesse caso, você usa o <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriedade do <xref:System.IAsyncResult> para identificar a operação concluída.  
  
 Essa sobrecarga Especifica um tempo limite. Se o intervalo especificado pela `timeout` parâmetro expira, esse componente aciona o <xref:System.Messaging.MessageQueue.ReceiveCompleted> eventos. Como não existe nenhuma mensagem, uma chamada subsequente para <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> lançará uma exceção.  
  
 Não use a chamada assíncrona <xref:System.Messaging.MessageQueue.BeginReceive%2A> com transações. Se você quiser executar uma operação assíncrona transacional, chame <xref:System.Messaging.MessageQueue.BeginPeek%2A>e coloque a transação e (síncrono) <xref:System.Messaging.MessageQueue.Receive%2A> método dentro do manipulador de eventos que você cria para a operação de espiada. O manipulador de eventos pode conter funcionalidade, conforme mostrado no código a seguir em C#.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma assíncrona operação de recebimento. O exemplo de código cria um manipulador de eventos `MyReceiveCompleted`e anexa-o para o <xref:System.Messaging.MessageQueue.ReceiveCompleted> delegado manipulador de eventos. Os envios de exemplo de código uma mensagem para uma fila de mensagens local, em seguida, chama <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29>, passando um valor de tempo limite de dez segundos. Quando um <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento é gerado, o manipulador de eventos recebe a mensagem e grava o corpo da mensagem na tela.  
  
 [!code-cpp[MessageQueueBeginReceive1#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive1/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive1#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive1/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido, possivelmente porque ele representa um número negativo.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o intervalo de tempo para aguardar uma mensagem se tornar disponível.</param>
        <param name="stateObject">Um objeto de estado, especificado pelo aplicativo, que contém informações associadas à operação assíncrona.</param>
        <summary>Inicia uma operação de recebimento assíncrona que tem um tempo limite e um objeto de estado especificados, que fornece informações associadas durante o tempo de vida da operação. A operação não é concluída até que uma mensagem se torna disponível na fila ou que ocorra o tempo limite.</summary>
        <returns>O <see cref="T:System.IAsyncResult" /> que identifica a solicitação assíncrona postada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O processamento assíncrono, você usa <xref:System.Messaging.MessageQueue.BeginReceive%2A> para gerar o <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento quando uma mensagem fique disponível na fila ou o intervalo de tempo especificado tiver expirado.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> também será gerado se já existir uma mensagem na fila.  
  
 Use essa sobrecarga para associar informações com a operação que será preservada em todo o tempo de vida da operação. O manipulador de eventos pode detectar essas informações ao examinar a <xref:System.IAsyncResult.AsyncState%2A> propriedade do <xref:System.IAsyncResult> que está associado com a operação.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginReceive%2A>, crie um manipulador de eventos que processa os resultados da operação assíncrona e associá-lo com seu representante de evento. <xref:System.Messaging.MessageQueue.BeginReceive%2A> inicia uma recebimento assíncrona operação; o <xref:System.Messaging.MessageQueue> recebe uma notificação por meio do aumento dos o <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento, quando uma mensagem chega na fila. O <xref:System.Messaging.MessageQueue> , em seguida, pode acessar a mensagem chamando <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> ou ao recuperar os resultados usando o <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 O <xref:System.Messaging.MessageQueue.BeginReceive%2A> método retorna imediatamente, mas não é possível concluir a operação assíncrona até que o manipulador de eventos é chamado.  
  
 Porque <xref:System.Messaging.MessageQueue.BeginReceive%2A> é assíncrona, você pode chamá-lo para receber uma mensagem da fila sem bloquear o thread de execução atual. Para receber assincronamente uma mensagem, use o <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Quando uma operação assíncrona for concluída, você pode chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente no manipulador de eventos para manter recebimento de notificações.  
  
 O <xref:System.IAsyncResult> que <xref:System.Messaging.MessageQueue.BeginReceive%2A> retorna identifica a operação assíncrona que o método foi iniciado. Você pode usá-lo <xref:System.IAsyncResult> durante o tempo de vida da operação, embora você geralmente não usá-lo até <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> é chamado. No entanto, se você iniciar várias operações assíncronas, você pode colocar suas <xref:System.IAsyncResult> valores em uma matriz e especifique se deseja aguardar a conclusão de qualquer operação ou de todas as operações. Nesse caso, você usa o <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriedade do <xref:System.IAsyncResult> para identificar a operação concluída.  
  
 Essa sobrecarga Especifica um tempo limite e um objeto de estado. Se o intervalo especificado pela `timeout` parâmetro expira, esse componente aciona o <xref:System.Messaging.MessageQueue.ReceiveCompleted> eventos. Como não existe nenhuma mensagem, uma chamada subsequente para <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> lançará uma exceção.  
  
 O objeto de estado associa informações de estado com a operação. Por exemplo, se você chamar <xref:System.Messaging.MessageQueue.BeginReceive%2A> várias vezes para iniciar várias operações, você pode identificar cada operação por meio de um objeto de estado separado que você definir.  
  
 Você também pode usar o objeto de estado para passar informações entre os threads de processo. Se um thread é iniciado, mas o retorno de chamada está em um thread diferente em um cenário assíncrono, o objeto de estado é empacotado e passado novamente, juntamente com informações do evento.  
  
 Não use a chamada assíncrona <xref:System.Messaging.MessageQueue.BeginReceive%2A> com transações. Se você quiser executar uma operação assíncrona transacional, chame <xref:System.Messaging.MessageQueue.BeginPeek%2A>e coloque a transação e (síncrono) <xref:System.Messaging.MessageQueue.Receive%2A> método dentro do manipulador de eventos que você cria para a operação de espiada. O manipulador de eventos pode conter funcionalidade, conforme mostrado no código a seguir em C#.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma assíncrona operação de recebimento. O exemplo de código cria um manipulador de eventos `MyReceiveCompleted`e anexa-o para o <xref:System.Messaging.MessageQueue.ReceiveCompleted> delegado manipulador de eventos. Os envios de exemplo de código uma mensagem para uma fila de mensagens local, em seguida, chama <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29>, passando um valor de tempo limite de dez segundos e um inteiro exclusivo que identifica essa mensagem específica. Quando um <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento é gerado, o manipulador de eventos recebe a mensagem e grava o corpo da mensagem e o identificador inteiro da mensagem na tela.  
  
 [!code-cpp[MessageQueueBeginReceive2#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive2/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive2#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive2/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o intervalo de tempo para aguardar uma mensagem se tornar disponível.</param>
        <param name="stateObject">Um objeto de estado, especificado pelo aplicativo, que contém informações associadas à operação assíncrona.</param>
        <param name="callback">O <see cref="T:System.AsyncCallback" /> que receberá a notificação da conclusão da operação assíncrona.</param>
        <summary>Inicia uma operação de recebimento assíncrona que tem um tempo limite e um objeto de estado especificados, que fornece informações associadas durante o tempo de vida da operação. Essa sobrecarga recebe uma notificação, por meio de um retorno de chamada, da identidade do manipulador de eventos da operação. A operação não é concluída até que uma mensagem se torna disponível na fila ou que ocorra o tempo limite.</summary>
        <returns>O <see cref="T:System.IAsyncResult" /> que identifica a solicitação assíncrona postada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você usar essa sobrecarga, o retorno de chamada especificado no parâmetro de retorno de chamada é invocado diretamente quando uma mensagem fique disponível na fila ou o intervalo de tempo especificado tiver expirado; o <xref:System.Messaging.MessageQueue.ReceiveCompleted> não é gerado. As outras sobrecargas de <xref:System.Messaging.MessageQueue.BeginReceive%2A> contar com esse componente para gerar o <xref:System.Messaging.MessageQueue.ReceiveCompleted> eventos.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> também será gerado se já existir uma mensagem na fila.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginReceive%2A>, crie um manipulador de eventos que processa os resultados da operação assíncrona e associá-lo com seu representante de evento. <xref:System.Messaging.MessageQueue.BeginReceive%2A> inicia uma recebimento assíncrona operação; o <xref:System.Messaging.MessageQueue> recebe uma notificação por meio do aumento dos o <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento, quando uma mensagem chega na fila. O <xref:System.Messaging.MessageQueue> , em seguida, pode acessar a mensagem chamando <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> ou ao recuperar os resultados usando o <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 O <xref:System.Messaging.MessageQueue.BeginReceive%2A> método retorna imediatamente, mas não é possível concluir a operação assíncrona até que o manipulador de eventos é chamado.  
  
 Porque <xref:System.Messaging.MessageQueue.BeginReceive%2A> é assíncrona, você pode chamá-lo para receber uma mensagem da fila sem bloquear o thread de execução atual. Para receber assincronamente uma mensagem, use o <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Quando uma operação assíncrona for concluída, você pode chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente no manipulador de eventos para manter recebimento de notificações.  
  
 O <xref:System.IAsyncResult> que <xref:System.Messaging.MessageQueue.BeginReceive%2A> retorna identifica a operação assíncrona que o método foi iniciado. Você pode usá-lo <xref:System.IAsyncResult> durante o tempo de vida da operação, embora você geralmente não usá-lo até <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> é chamado. No entanto, se você iniciar várias operações assíncronas, você pode colocar suas <xref:System.IAsyncResult> valores em uma matriz e especifique se deseja aguardar a conclusão de qualquer operação ou de todas as operações. Nesse caso, você usa o <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriedade do <xref:System.IAsyncResult> para identificar a operação concluída.  
  
 O objeto de estado associa informações de estado com a operação. Por exemplo, se você chamar <xref:System.Messaging.MessageQueue.BeginReceive%2A> várias vezes para iniciar várias operações, você pode identificar cada operação por meio de um objeto de estado separado que você definir.  
  
 Você também pode usar o objeto de estado para passar informações entre os threads de processo. Se um thread é iniciado, mas o retorno de chamada está em um thread diferente em um cenário assíncrono, o objeto de estado é empacotado e passado novamente, juntamente com informações do evento.  
  
 Não use a chamada assíncrona <xref:System.Messaging.MessageQueue.BeginReceive%2A> com transações. Se você quiser executar uma operação assíncrona transacional, chame <xref:System.Messaging.MessageQueue.BeginPeek%2A>e coloque a transação e (síncrono) <xref:System.Messaging.MessageQueue.Receive%2A> método dentro do manipulador de eventos que você cria para a operação de espiada. O manipulador de eventos pode conter funcionalidade, conforme mostrado no código a seguir em C#.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma assíncrona operação de recebimento. Os envios de exemplo de código uma mensagem para uma fila de mensagens local, em seguida, chama <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, passando: um valor de tempo limite de dez segundos; um inteiro exclusivo que identifica essa mensagem específica; e uma nova instância da <xref:System.AsyncCallback> que identifica o manipulador de eventos `MyReceiveCompleted`. Quando um <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento é gerado, o manipulador de eventos recebe a mensagem e grava o corpo da mensagem e o identificador inteiro da mensagem na tela.  
  
 [!code-cpp[MessageQueueBeginReceive3#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive3/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive3#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive3/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, System.Messaging.Cursor cursor, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * System.Messaging.Cursor * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, cursor, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o intervalo de tempo para aguardar uma mensagem se tornar disponível.</param>
        <param name="cursor">Um <see cref="T:System.Messaging.Cursor" /> que mantém uma posição específica na fila de mensagens.</param>
        <param name="state">Um objeto de estado, especificado pelo aplicativo, que contém informações associadas à operação assíncrona.</param>
        <param name="callback">O <see cref="T:System.AsyncCallback" /> que recebe a notificação de conclusão de operação assíncrona.</param>
        <summary>Inicia uma operação de recebimento assíncrona que tem um tempo limite especificado e usa um cursor especificado e um objeto de estado especificado. O objeto de estado fornece informações associadas em todo o tempo de vida da operação. Essa sobrecarga recebe uma notificação, por meio de um retorno de chamada, da identidade do manipulador de eventos da operação. A operação não é concluída até que uma mensagem se torna disponível na fila ou que ocorra o tempo limite.</summary>
        <returns>O <see cref="T:System.IAsyncResult" /> que identifica a solicitação assíncrona postada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você usar essa sobrecarga, o retorno de chamada especificado no parâmetro de retorno de chamada é invocado diretamente quando uma mensagem fique disponível na fila ou o intervalo de tempo especificado tiver expirado; o <xref:System.Messaging.MessageQueue.ReceiveCompleted> não é gerado. As outras sobrecargas de <xref:System.Messaging.MessageQueue.BeginReceive%2A> contar com esse componente para gerar o <xref:System.Messaging.MessageQueue.ReceiveCompleted> eventos.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> também será gerado se já existir uma mensagem na fila.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginReceive%2A>, crie um manipulador de eventos que processa os resultados da operação assíncrona e associá-lo com seu representante de evento. <xref:System.Messaging.MessageQueue.BeginReceive%2A> inicia uma recebimento assíncrona operação; o <xref:System.Messaging.MessageQueue> recebe uma notificação por meio do aumento dos o <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento, quando uma mensagem chega na fila. O <xref:System.Messaging.MessageQueue> , em seguida, pode acessar a mensagem chamando <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> ou ao recuperar os resultados usando o <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 O <xref:System.Messaging.MessageQueue.BeginReceive%2A> método retorna imediatamente, mas não é possível concluir a operação assíncrona até que o manipulador de eventos é chamado.  
  
 Porque <xref:System.Messaging.MessageQueue.BeginReceive%2A> é assíncrona, você pode chamá-lo para receber uma mensagem da fila sem bloquear o thread de execução atual. Para receber assincronamente uma mensagem, use o <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Quando uma operação assíncrona for concluída, você pode chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente no manipulador de eventos para manter recebimento de notificações.  
  
 O <xref:System.IAsyncResult> que <xref:System.Messaging.MessageQueue.BeginReceive%2A> retorna identifica a operação assíncrona que o método foi iniciado. Você pode usá-lo <xref:System.IAsyncResult> durante o tempo de vida da operação, embora você geralmente não usá-lo até <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> é chamado. No entanto, se você iniciar várias operações assíncronas, você pode colocar suas <xref:System.IAsyncResult> valores em uma matriz e especifique se deseja aguardar a conclusão de qualquer operação ou de todas as operações. Nesse caso, use o <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriedade do <xref:System.IAsyncResult> para identificar a operação concluída.  
  
 O objeto de estado associa informações de estado com a operação. Por exemplo, se você chamar <xref:System.Messaging.MessageQueue.BeginReceive%2A> várias vezes para iniciar várias operações, você pode identificar cada operação por meio de um objeto de estado separado que você definir.  
  
 Você também pode usar o objeto de estado para passar informações entre os threads de processo. Se um thread é iniciado, mas o retorno de chamada está em um thread diferente em um cenário assíncrono, o objeto de estado é empacotado e passado novamente, juntamente com informações do evento.  
  
 Não use a chamada assíncrona <xref:System.Messaging.MessageQueue.BeginReceive%2A> com transações. Se você quiser executar uma operação assíncrona transacional, chame <xref:System.Messaging.MessageQueue.BeginPeek%2A>e coloque a transação e (síncrono) <xref:System.Messaging.MessageQueue.Receive%2A> método dentro do manipulador de eventos que você cria para a operação de espiada. O manipulador de eventos pode conter funcionalidade, conforme mostrado no código a seguir em C#.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="cursor" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Messaging.MessageQueue.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanRead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Messaging.MessageQueue" /> pode ser lido.</summary>
        <value>
          <see langword="true" /> Se o <see cref="T:System.Messaging.MessageQueue" /> existe e o aplicativo pode lê-lo; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanRead%2A> Indica se o aplicativo é capaz de inspecionar ou receber mensagens da fila. Se <xref:System.Messaging.MessageQueue.CanRead%2A> está `true`, o <xref:System.Messaging.MessageQueue> possa receber ou espiar mensagens da fila. Caso contrário, ele não é possível.  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A> está `false` se uma fila já está aberta com acesso de leitura exclusivo (ou se ele está aberto com acesso não exclusivo e isso <xref:System.Messaging.MessageQueue> solicita acesso exclusivo), ou se o aplicativo não tem direitos suficientes para acessá-lo. Se seu aplicativo tentar ler de uma fila quando <xref:System.Messaging.MessageQueue.CanRead%2A> é `false`, o acesso foi negado.  
  
 A tabela a seguir mostra se essa propriedade está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.CanRead%2A> propriedade.  
  
 [!code-csharp[MessageQueue#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Messaging.MessageQueue.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanWrite")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se é possível gravar no <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <value>
          <see langword="true" /> Se o <see cref="T:System.Messaging.MessageQueue" /> existe e o aplicativo pode gravar nele; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> Indica se o aplicativo é capaz de enviar mensagens à fila. Se <xref:System.Messaging.MessageQueue.CanWrite%2A> está `true`, o <xref:System.Messaging.MessageQueue> pode enviar mensagens à fila. Caso contrário, ele não é possível.  
  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> está `false` se uma fila já está aberta com acesso de gravação exclusivo (ou se ele está aberto com acesso não exclusivo e isso <xref:System.Messaging.MessageQueue> solicita acesso exclusivo), ou se o aplicativo não tem direitos suficientes para acessá-lo. Se seu aplicativo tentar gravar em uma fila quando <xref:System.Messaging.MessageQueue.CanWrite%2A> é `false`, o acesso foi negado.  
  
 A tabela a seguir mostra se essa propriedade está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.CanWrite%2A> propriedade.  
  
 [!code-csharp[MessageQueue#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public Guid Category { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Category" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Category" />
      <MemberSignature Language="VB.NET" Value="Public Property Category As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Category { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.Category : Guid with get, set" Usage="System.Messaging.MessageQueue.Category" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Category")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a categoria da fila.</summary>
        <value>Um <see cref="T:System.Guid" /> que representa a categoria da fila (enfileiramento de tipo identificador), que permite que um aplicativo categorizar suas filas. O padrão é <see langword="Guid.empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A categoria da fila permite que um aplicativo categorizar suas filas. Por exemplo, você pode colocar todas as filas de cobrança em uma categoria e todas as filas de pedido em outro.  
  
 O <xref:System.Messaging.MessageQueue.Category%2A> propriedade fornece acesso para a propriedade de ID do tipo de serviço de enfileiramento de mensagem (que é leitura/gravação), acessível por meio de **propriedades da fila** caixa de diálogo no Console de gerenciamento do computador. Você pode definir uma nova categoria. Embora você possa usar <xref:System.Guid.NewGuid%2A> para criar um valor de categoria que seja exclusivo em todo o <xref:System.Guid> valores, essa ação é desnecessária. O valor da categoria precisa ser diferente apenas de outras categorias, não de todas as outras <xref:System.Guid> valores. Por exemplo, você pode atribuir {00000000-0000-0000-0000-000000000001} como o <xref:System.Messaging.MessageQueue.Category%2A> para um conjunto de filas e {00000000-0000-0000-0000-000000000002} como o <xref:System.Messaging.MessageQueue.Category%2A> para outro conjunto.  
  
 Não é necessário definir o <xref:System.Messaging.MessageQueue.Category%2A>. O valor pode ser `null`.  
  
 A definição dessa propriedade modifica a fila de enfileiramento de mensagens. Portanto, qualquer outro <xref:System.Messaging.MessageQueue> instâncias são afetadas pela alteração.  
  
 A tabela a seguir mostra se essa propriedade está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.Category%2A> propriedade.  
  
 [!code-csharp[MessageQueue#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A categoria de fila foi definida como um valor inválido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Id" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ClearConnectionCache">
      <MemberSignature Language="C#" Value="public static void ClearConnectionCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearConnectionCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearConnectionCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearConnectionCache();" />
      <MemberSignature Language="F#" Value="static member ClearConnectionCache : unit -&gt; unit" Usage="System.Messaging.MessageQueue.ClearConnectionCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Limpa o cache de conexão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você chama <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, os nomes de formato armazenados no cache são removidos e identificadores abertos e armazenados em cache são fechados.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir chama <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>.  
  
 [!code-csharp[MessageQueue#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageQueue.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos alocados pelo <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Close%2A> libera todos os recursos associados com um <xref:System.Messaging.MessageQueue>, incluindo os recursos compartilhados se apropriado. O sistema novamente adquire estes recursos automaticamente se eles ainda estão disponíveis, por exemplo quando você chama o <xref:System.Messaging.MessageQueue.Send%28System.Object%29> método, como no seguinte código c#.  
  
```csharp  
myMessageQueue.Send("Text 1.");  
myMessageQueue.Close();  
myMessageQueue.Send("Text 2."); //Resources are re-acquired.  
```  
  
 Quando você chama <xref:System.Messaging.MessageQueue.Close%2A>, todos os <xref:System.Messaging.MessageQueue> propriedades que acessem diretamente a fila de enfileiramento de mensagens são limpos. O <xref:System.Messaging.MessageQueue.Path%2A>, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, <xref:System.Messaging.MessageQueue.Formatter%2A>, e <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> todas permanecem como estavam.  
  
 <xref:System.Messaging.MessageQueue.Close%2A> nem sempre Libere a leitura e identificadores de gravação para uma fila, porque eles podem ser compartilhados. Você pode usar qualquer uma das etapas a seguir para garantir que <xref:System.Messaging.MessageQueue.Close%2A> libera os identificadores de leitura e gravação a uma fila:  
  
-   Criar o <xref:System.Messaging.MessageQueue> com acesso exclusivo. Para fazer isso, chame o <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29> ou <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> construtor e defina as `sharedModeDenyReceive` parâmetro para `true`.  
  
-   Criar o <xref:System.Messaging.MessageQueue> com conexão de cache desabilitado. Para fazer isso, chame o <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> construtor e defina o `enableConnectionCache` parâmetro `false`.  
  
-   Desabilite o cache de conexão. Para fazer isso, defina as <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> propriedade para `false`.  
  
 Você deve chamar <xref:System.Messaging.MessageQueue.Close%2A> para uma fila antes de excluir a fila no servidor de enfileiramento de mensagens. Caso contrário, as mensagens enviadas para a fila pode gerar exceções ou aparecem na fila de inatividade.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir fecha uma fila do enfileiramento de mensagens.  
  
 [!code-cpp[MessageQueue.Close#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Close/CPP/mqclose.cpp#1)]
 [!code-csharp[MessageQueue.Close#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Close/CS/mqclose.cs#1)]
 [!code-vb[MessageQueue.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Close/VB/mqclose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria uma nova fila no caminho especificado em um servidor de Enfileiramento de Mensagens.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho da fila a ser criado.</param>
        <summary>Cria uma fila não transacional do serviço de enfileiramento de mensagens no caminho especificado.</summary>
        <returns>Um <see cref="T:System.Messaging.MessageQueue" /> que representa a nova fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para criar uma fila não transacional do enfileiramento de mensagens.  
  
 Para criar uma nova instância dos <xref:System.Messaging.MessageQueue> classe em seu aplicativo e associá-lo a uma fila existente, use o <xref:System.Messaging.MessageQueue.%23ctor%2A> construtor. Para criar uma nova fila no enfileiramento de mensagens, chame <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 A sintaxe para o `path` parâmetro depende do tipo de fila-referências, conforme mostrado na tabela a seguir.  
  
|Tipo de fila|Sintaxe|  
|----------------|------------|  
|Fila pública|`MachineName`\\`QueueName`|  
|Fila particular|`MachineName`\\`Private$`\\`QueueName`|  
  
 Use "." para o computador local. Para obter mais sintaxe, consulte o <xref:System.Messaging.MessageQueue.Path%2A> propriedade.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir cria filas públicas e privadas. Ele envia uma mensagem para filas selecionadas.  
  
 [!code-cpp[MessageQueue.Create_path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_path/CPP/mqcreate.cpp#1)]
 [!code-csharp[MessageQueue.Create_path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_path/CS/mqcreate.cs#1)]
 [!code-vb[MessageQueue.Create_path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_path/VB/mqcreate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="path" /> é <see langword="null" /> ou uma cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Já existe uma fila no caminho especificado.  
  
- ou - 
Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path, bool transactional);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path, bool transactional) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, transactional As Boolean) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path, bool transactional);" />
      <MemberSignature Language="F#" Value="static member Create : string * bool -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create (path, transactional)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactional" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">O caminho da fila a ser criado.</param>
        <param name="transactional">
          <see langword="true" /> para criar uma fila transacional; <see langword="false" /> para criar uma fila não transacional.</param>
        <summary>Cria uma fila transacional ou não transacional do Enfileiramento de Mensagens no caminho especificado.</summary>
        <returns>Um <see cref="T:System.Messaging.MessageQueue" /> que representa a nova fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar essa sobrecarga para criar uma fila transacional no enfileiramento de mensagens. Você pode criar uma fila não transacional, definindo o `transactional` parâmetro para `false` ou chamando a outra sobrecarga de <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Para criar uma nova instância dos <xref:System.Messaging.MessageQueue> classe em seu aplicativo e associá-lo a uma fila existente, use o <xref:System.Messaging.MessageQueue.%23ctor%2A> construtor. Para criar uma nova fila no enfileiramento de mensagens, chame <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 A sintaxe para o `path` parâmetro depende do tipo de fila-referências, conforme mostrado na tabela a seguir.  
  
|Tipo de fila|Sintaxe|  
|----------------|------------|  
|Fila pública|`MachineName`\\`QueueName`|  
|Fila particular|`MachineName`\\`Private$`\\`QueueName`|  
  
 Use "." para o computador local. Para obter mais sintaxe, consulte o <xref:System.Messaging.MessageQueue.Path%2A> propriedade.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir cria filas transacionais públicas e privadas. Ele envia uma mensagem para filas selecionadas.  
  
 [!code-cpp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CPP/mqcreate_transactional.cpp#1)]
 [!code-csharp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CS/mqcreate_transactional.cs#1)]
 [!code-vb[MessageQueue.Create_PathTransactional#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/VB/mqcreate_transactional.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="path" /> é <see langword="null" /> ou uma cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Já existe uma fila no caminho especificado.  
  
- ou - 
Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="CreateCursor">
      <MemberSignature Language="C#" Value="public System.Messaging.Cursor CreateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Cursor CreateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.CreateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCursor () As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Cursor ^ CreateCursor();" />
      <MemberSignature Language="F#" Value="member this.CreateCursor : unit -&gt; System.Messaging.Cursor" Usage="messageQueue.CreateCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Cursor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um novo <see cref="T:System.Messaging.Cursor" /> para a fila de mensagens atual.</summary>
        <returns>Um novo <see cref="T:System.Messaging.Cursor" /> para a fila de mensagens atual. Esse cursor é usado para manter um local específico na fila durante a leitura de mensagens da fila.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Messaging.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CreateTime">
      <MemberSignature Language="C#" Value="public DateTime CreateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreateTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CreateTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreateTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime CreateTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateTime : DateTime" Usage="System.Messaging.MessageQueue.CreateTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CreateTime")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a hora e a data em que a fila foi criada no Enfileiramento de Mensagens.</summary>
        <value>Um <see cref="T:System.DateTime" /> que representa a data e hora em que a fila foi criada.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CreateTime%2A> refere-se para a fila no servidor de enfileiramento de mensagens, não o <xref:System.Messaging.MessageQueue> instância.  
  
 Se a fila existir, essa propriedade representa a hora em que a fila foi criada, ajustado para a hora local do servidor no qual a fila existe.  
  
 A tabela a seguir mostra se essa propriedade está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.CreateTime%2A> propriedade.  
  
 [!code-csharp[MessageQueue#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.LastModifyTime" />
      </Docs>
    </Member>
    <Member MemberName="DefaultPropertiesToSend">
      <MemberSignature Language="C#" Value="public System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultPropertiesToSend As DefaultPropertiesToSend" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::DefaultPropertiesToSend ^ DefaultPropertiesToSend { System::Messaging::DefaultPropertiesToSend ^ get(); void set(System::Messaging::DefaultPropertiesToSend ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultPropertiesToSend : System.Messaging.DefaultPropertiesToSend with get, set" Usage="System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.DefaultPropertiesToSend</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define os valores da propriedade da mensagem a serem usados por padrão quando o aplicativo envia mensagens para a fila.</summary>
        <value>Um <see cref="T:System.Messaging.DefaultPropertiesToSend" /> que contém os valores da propriedade da mensagem Enfileiramento de Mensagens usados quando o aplicativo envia objetos diferentes de instâncias <see cref="T:System.Messaging.Message" /> para a fila.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você envia qualquer objeto que não é do tipo <xref:System.Messaging.Message> para a fila, o <xref:System.Messaging.MessageQueue> insere o objeto em uma mensagem de enfileiramento de mensagens. Nesse momento, o <xref:System.Messaging.MessageQueue> aplica-se a mensagem os valores de propriedade que você especificar o <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriedade. Por outro lado, se você enviar uma <xref:System.Messaging.Message> para a fila, essas propriedades já foram especificadas para a instância em si, então <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> é ignorado para o <xref:System.Messaging.Message>.  
  
 Embora você defina as propriedades por meio de <xref:System.Messaging.MessageQueue> objeto, o <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> refere-se às propriedades das mensagens que são enviadas para a fila, não a própria fila.  
  
 Os valores padrão para as propriedades são mostrados na tabela a seguir.  
  
|Propriedade|Valor padrão|  
|--------------|-------------------|  
|<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>|Zero (0)|  
|<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>|Uma matriz de bytes de comprimento zero|  
|<xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Label%2A>|cadeia de caracteres vazia ("")|  
|<xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>|`false`|  
  
 A tabela a seguir mostra se essa propriedade está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir usa a prioridade de uma mensagem para determinar as propriedades padrão para enviar para a mensagem.  
  
 [!code-cpp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CPP/mqdefaultpropertiestosend.cpp#1)]
 [!code-csharp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CS/mqdefaultpropertiestosend.cs#1)]
 [!code-vb[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/VB/mqdefaultpropertiestosend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Não foi possível definir as propriedades padrão para a fila, possivelmente porque uma das propriedades não é válida.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="T:System.Messaging.EncryptionAlgorithm" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Messaging.MessageQueue.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O local da fila a ser excluída.</param>
        <summary>Exclui uma fila em um servidor de Enfileiramento de Mensagens.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A sintaxe para o `path` parâmetro depende do tipo de fila.  
  
|Tipo de fila|Sintaxe|  
|----------------|------------|  
|Fila pública|`MachineName`\\`QueueName`|  
|Fila particular|`MachineName`\\`Private$`\\`QueueName`|  
  
 Para obter mais sintaxe, consulte o <xref:System.Messaging.MessageQueue.Path%2A> propriedade.  
  
 Como alternativa, você pode usar o <xref:System.Messaging.MessageQueue.FormatName%2A> ou <xref:System.Messaging.MessageQueue.Label%2A> para descrever o caminho da fila.  
  
|Referência|Sintaxe|  
|---------------|------------|  
|Nome do formato|FormatName: [ *nome do formato* ]|  
|Rotular|Label:[ *label* ]|  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir exclui uma fila do enfileiramento de mensagens, se ele existir.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="path" /> é <see langword="null" /> ou uma cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A sintaxe do parâmetro <paramref name="path" /> não é válida.  
  
- ou - 
Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="DenySharedReceive">
      <MemberSignature Language="C#" Value="public bool DenySharedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DenySharedReceive" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberSignature Language="VB.NET" Value="Public Property DenySharedReceive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DenySharedReceive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DenySharedReceive : bool with get, set" Usage="System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DenySharedReceive")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se este <see cref="T:System.Messaging.MessageQueue" /> tem acesso exclusivo para receber mensagens da fila do Enfileiramento de Mensagens.</summary>
        <value>
          <see langword="true" /> Se este <see cref="T:System.Messaging.MessageQueue" /> tem direitos exclusivos para receber mensagens da fila; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> Especifica o modo compartilhado da fila referenciada por este <xref:System.Messaging.MessageQueue>. Definir <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> à `true` para indicar que somente isso <xref:System.Messaging.MessageQueue> devem ter acesso ao espiar ou receber mensagens da fila com especificado <xref:System.Messaging.MessageQueue.Path%2A>. Se outro <xref:System.Messaging.MessageQueue> ou outro aplicativo está associado com o mesmo recurso de fila, essa instância ou aplicativo não conseguirá espiar ou receber mensagens, mas ele ainda pode enviá-los.  
  
 Se <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> é `false`, a fila está disponível para vários aplicativos para enviar, espiar ou receber mensagens.  
  
 A tabela a seguir mostra se essa propriedade está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> propriedade.  
  
 [!code-csharp[MessageQueue#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="messageQueue.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
        <summary>Descarta os recursos (exceto a memória) usados pelo <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> quando tiver terminado de usar o <xref:System.Messaging.MessageQueue>. O <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> método deixa o <xref:System.Messaging.MessageQueue> em um estado inutilizável. Depois de chamar <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>, você deve liberar todas as referências para o <xref:System.Messaging.MessageQueue> para que a memória que ele estava ocupando pode ser recuperada pela coleta de lixo.  
  
 Você deve chamar <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> antes de liberar sua última referência para o <xref:System.Messaging.MessageQueue>. Caso contrário, os recursos a <xref:System.Messaging.MessageQueue> está usando não será liberado até que as chamadas de coleta de lixo a <xref:System.Messaging.MessageQueue> destruidor do objeto.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <Member MemberName="EnableConnectionCache">
      <MemberSignature Language="C#" Value="public static bool EnableConnectionCache { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableConnectionCache" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableConnectionCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableConnectionCache { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableConnectionCache : bool with get, set" Usage="System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se um cache de conexões será mantido pelo aplicativo.</summary>
        <value>
          <see langword="true" /> para criar e usar um cache de conexão; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um cache de conexão é uma lista de referências às estruturas que contêm ler ou gravar nas filas identificadores. Quando <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> está `true`, o <xref:System.Messaging.MessageQueue> empresta alças do cache sempre que você chama <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, ou <xref:System.Messaging.MessageQueue.Receive%2A>, em vez de identificadores abertos de novo. Isso pode melhorar o desempenho. Usando um cache de conexão também separa o <xref:System.Messaging.MessageQueue> contra alterações na topologia da rede.  
  
 Se você criar uma nova conexão para uma fila quando o cache de conexão está cheio, o <xref:System.Messaging.MessageQueue> substitui a estrutura acessada menos recentemente com a nova conexão. Você pode limpar o cache totalmente chamando <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, por exemplo, se os nomes de formato de filas que você está trabalhando com foram alterados para que o anterior de leitura e gravação identificadores não são mais válidos.  
  
 A tabela a seguir mostra se essa propriedade está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> propriedade.  
  
 [!code-csharp[MessageQueue#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionRequired">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionRequired EncryptionRequired { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionRequired EncryptionRequired" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionRequired As EncryptionRequired" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionRequired EncryptionRequired { System::Messaging::EncryptionRequired get(); void set(System::Messaging::EncryptionRequired value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionRequired : System.Messaging.EncryptionRequired with get, set" Usage="System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_EncryptionRequired")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionRequired</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se a fila aceita apenas mensagens não privadas (não criptografadas).</summary>
        <value>Um dos valores de <see cref="T:System.Messaging.EncryptionRequired" />. O padrão é <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você especifica que a criptografia é necessária para as mensagens enviadas para uma fila, somente os corpos das mensagens são criptografados. Os outros membros (por exemplo, o <xref:System.Messaging.Message.Label%2A> e <xref:System.Messaging.Message.SenderId%2A> propriedades) não pode ser criptografada.  
  
 A definição dessa propriedade modifica a fila de enfileiramento de mensagens. Portanto, qualquer outro <xref:System.Messaging.MessageQueue> instâncias são afetadas pela alteração.  
  
 Criptografar uma mensagem torna a mensagem privada. Você pode especificar o requisito de criptografia da fila para ser `None`, `Body`, ou `Optional` definindo a <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> propriedade adequadamente. O <xref:System.Messaging.Message.UseEncryption%2A> configuração da mensagem deve corresponder ao requisito de criptografia da fila. Se a mensagem não é criptografada, mas a fila especifica `Body`, ou se a mensagem for criptografada, mas a fila especifica `None`, a mensagem será rejeitada pela fila. Se o aplicativo de envio solicita uma mensagem de confirmação negativa neste evento, enfileiramento de mensagens indica a rejeição da mensagem para o aplicativo de envio. Se o <xref:System.Messaging.Message.UseDeadLetterQueue%2A> é de propriedade `true`, uma mensagem que falha de criptografia é enviada para a fila de inatividade. Caso contrário, a mensagem será perdida.  
  
 A tabela a seguir mostra se essa propriedade está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> propriedade.  
  
 [!code-csharp[MessageQueue#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="T:System.Messaging.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="EndPeek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndPeek (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndPeek(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndPeek (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndPeek(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndPeek : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndPeek asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">O <see cref="T:System.IAsyncResult" /> que identifica a operação de espiada assíncrona a concluir e da qual recuperar um resultado final.</param>
        <summary>Conclui a operação de espiada assíncrona especificada.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> associado com a operação assíncrona concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando o <xref:System.Messaging.MessageQueue.PeekCompleted> é gerado, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> conclui a operação que foi iniciada pela <xref:System.Messaging.MessageQueue.BeginPeek%2A> chamar. Para fazer isso, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> espia a mensagem.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> pode especificar um tempo limite, o que faz com que o <xref:System.Messaging.MessageQueue.PeekCompleted> evento a ser gerado se o tempo limite ocorre antes que será exibida uma mensagem na fila. Quando um tempo limite ocorre sem uma mensagem que chega na fila, uma chamada subsequente para <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> gera uma exceção.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> é usado para ler a mensagem que causou o <xref:System.Messaging.MessageQueue.PeekCompleted> evento seja acionado.  
  
 Se você quiser continuar assincronamente espiar mensagens, você pode chamar novamente <xref:System.Messaging.MessageQueue.BeginPeek%2A> depois de chamar <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir cria um manipulador de eventos chamado `MyPeekCompleted`, anexa-o para o <xref:System.Messaging.MessageQueue.PeekCompleted> delegado manipulador de eventos e chamadas <xref:System.Messaging.MessageQueue.BeginPeek%2A> para iniciar uma operação de espiada assíncrona na fila que está localizada no caminho ". \myQueue". Quando um <xref:System.Messaging.MessageQueue.PeekCompleted> evento é gerado, o exemplo espia a mensagem e grava seu corpo para a tela. O exemplo, em seguida, chama <xref:System.Messaging.MessageQueue.BeginPeek%2A> novamente para iniciar uma nova operação de espiada assíncrona.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="asyncResult" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A sintaxe do parâmetro <paramref name="asyncResult" /> não é válida.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndReceive (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndReceive(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndReceive(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndReceive asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">O <see cref="T:System.IAsyncResult" /> que identifica a operação de recebimento assíncrono a concluir e da qual recuperar o resultado final.</param>
        <summary>Conclui a operação de recebimento assíncrono especificada.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> associado com a operação assíncrona concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando o <xref:System.Messaging.MessageQueue.ReceiveCompleted> é gerado, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> conclui a operação que foi iniciada pela <xref:System.Messaging.MessageQueue.BeginReceive%2A> chamar. Para fazer isso, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> recebe a mensagem.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> pode especificar um tempo limite, o que faz com que o <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento a ser gerado se o tempo limite ocorre antes que será exibida uma mensagem na fila. Quando um tempo limite ocorre sem uma mensagem que chega na fila, uma chamada subsequente para <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> gera uma exceção.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> é usado para ler (remoção da fila) a mensagem que causou o <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento seja acionado.  
  
 Se você quiser continuar a receber mensagens de maneira assíncrona, você pode chamar novamente <xref:System.Messaging.MessageQueue.BeginReceive%2A> depois de chamar <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir encadeia solicitações assíncronas. Ele pressupõe que há uma fila no computador local chamado "myQueue". O `Main` função começa a operação assíncrona que é tratada pelo `MyReceiveCompleted` rotina. `MyReceiveCompleted` processa a mensagem atual e inicia um novo assíncrona operação de recebimento.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="asyncResult" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A sintaxe do parâmetro <paramref name="asyncResult" /> não é válida.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Messaging.MessageQueue.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">A localização da fila a ser encontrada.</param>
        <summary>Determina se existe uma fila de Enfileiramento de Mensagens no caminho especificado.</summary>
        <returns>
          <see langword="true" /> se existir uma fila com o caminho especificado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.MessageQueue.Exists%28System.String%29> método determina se existe uma fila de enfileiramento de mensagens em um caminho especificado. Não existe um método para determinar se existe uma fila com um nome de formato especificado. Para obter mais informações sobre a sintaxe de nome de formato e outras formas de sintaxe do caminho, consulte o <xref:System.Messaging.MessageQueue.Path%2A> propriedade.)  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> é uma operação cara. Usá-lo apenas quando for necessário dentro do aplicativo.  
  
> [!NOTE]
>  O <xref:System.Messaging.MessageQueue.Exists%28System.String%29> método não dá suporte a <xref:System.Messaging.MessageQueue.FormatName%2A> prefixo.  
  
 A sintaxe para o `path` parâmetro depende do tipo de fila, conforme mostrado na tabela a seguir.  
  
|Tipo de fila|Sintaxe|  
|----------------|------------|  
|Fila pública|`MachineName`\\`QueueName`|  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> não pode ser chamado para verificar a existência de uma fila particular remota.  
  
 Para obter mais sintaxe, consulte o <xref:System.Messaging.MessageQueue.Path%2A> propriedade.  
  
 Como alternativa, você pode usar o <xref:System.Messaging.MessageQueue.Label%2A> para descrever o caminho da fila.  
  
|Referência|Sintaxe|  
|---------------|------------|  
|Rotular|Rótulo: [ `label` ]|  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Não|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir verifica se existe uma fila de enfileiramento de mensagens e, em seguida, exclui-lo.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A sintaxe <paramref name="path" /> não é válida.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Um erro ao acessar um método de Enfileiramento de Mensagens.  
  
- ou - 
O método <see cref="M:System.Messaging.MessageQueue.Exists(System.String)" /> está sendo chamado em uma fila particular remota</exception>
        <exception cref="T:System.InvalidOperationException">O aplicativo usou a sintaxe de nome de formato ao verificar a existência da fila.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="FormatName">
      <MemberSignature Language="C#" Value="public string FormatName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FormatName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.FormatName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FormatName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FormatName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FormatName : string" Usage="System.Messaging.MessageQueue.FormatName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_FormatName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome de fila exclusivo que o Enfileiramento de Mensagens gerou no momento da criação da fila.</summary>
        <value>O nome da fila, que é exclusivo na rede.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.MessageQueue.FormatName%2A> propriedade contém o nome do formato da fila. Serviço de enfileiramento usa o nome de formato para identificar qual fila para abrir e como acessá-la. Ao contrário da maioria das características de uma fila, o nome de formato não é uma propriedade de fila do enfileiramento de aplicativo, portanto, você não pode acessá-lo por meio da ferramenta de gerenciamento do serviço de enfileiramento de mensagens. O nome do formato é simplesmente um nome exclusivo para a fila, que o enfileiramento de mensagens gera quando ele cria a fila ou que o aplicativo gera mais tarde.  
  
 Se você especificar um caminho usando a sintaxe de nome de caminho (como `myComputer\myQueue`) em vez de usar a sintaxe de nome de formato ao ler ou gravar na fila, o controlador de domínio primário (que usa o Active Directory) converte o <xref:System.Messaging.MessageQueue.Path%2A> para o associado<xref:System.Messaging.MessageQueue.FormatName%2A> antes de acessar a fila. Se seu aplicativo estiver trabalhando offline, você deve usar a sintaxe de nome de formato; Caso contrário, o controlador de domínio primário não estará disponível para executar a conversão de caminho.  
  
 A tabela a seguir mostra se essa propriedade está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.FormatName%2A> propriedade.  
  
 [!code-csharp[MessageQueue#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">O <see cref="P:System.Messaging.MessageQueue.Path" /> não foi definido.  
  
- ou - 
Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="T:System.Messaging.MessageQueue" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.MessageQueue.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Formatter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o formatador usado para serializar ou desserializar um objeto do corpo de uma mensagem lida ou gravada na fila.</summary>
        <value>O <see cref="T:System.Messaging.IMessageFormatter" /> que produz um fluxo a ser gravado ou lido do corpo da mensagem. O padrão é <see cref="T:System.Messaging.XmlMessageFormatter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.MessageQueue.Formatter%2A> propriedade contém uma instância de um objeto de formatador, que transforma as mensagens quando o aplicativo lê ou grava na fila.  
  
 Quando o aplicativo envia a mensagem à fila, o formatador serializa o objeto em um fluxo e o insere no corpo da mensagem. Ao ler de uma fila, o formatador desserializa os dados da mensagem para o <xref:System.Messaging.Message.Body%2A> propriedade de um <xref:System.Messaging.Message>.  
  
 O <xref:System.Messaging.XmlMessageFormatter> está acoplado livremente, portanto, não é necessário ter o mesmo objeto de tipo no remetente e receptor ao usar esse formato. O <xref:System.Messaging.ActiveXMessageFormatter> e <xref:System.Messaging.BinaryMessageFormatter> serializar os dados em representação binária. O <xref:System.Messaging.ActiveXMessageFormatter> é usado ao enviar ou receber os componentes COM.  
  
 <xref:System.Messaging.BinaryMessageFormatter> e <xref:System.Messaging.ActiveXMessageFormatter> fornecer a taxa de transferência mais rápida que a <xref:System.Messaging.XmlMessageFormatter>. O <xref:System.Messaging.ActiveXMessageFormatter> permite a interoperabilidade com aplicativos de enfileiramento de mensagens do Visual Basic 6.0.  
  
 Quando seu aplicativo envia mensagens à fila, o <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> só se aplica a essas mensagens que usam as propriedades de mensagem padrão, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>. Se você enviar uma <xref:System.Messaging.Message> para a fila, enfileiramento de mensagens usa o formatador definido na <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propriedade para serializar o corpo em vez disso.  
  
 O <xref:System.Messaging.MessageQueue> classe sempre usará um <xref:System.Messaging.Message> receber ou espiar uma mensagem da fila. A mensagem é desserializada usando o <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propriedade.  
  
 A tabela a seguir mostra se essa propriedade está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra a formatação de um corpo de mensagem usando <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 O exemplo de código a seguir demonstra a formatação de um corpo de mensagem usando <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="GetAllMessages">
      <MemberSignature Language="C#" Value="public System.Messaging.Message[] GetAllMessages ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message[] GetAllMessages() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetAllMessages" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMessages () As Message()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Messaging::Message ^&gt; ^ GetAllMessages();" />
      <MemberSignature Language="F#" Value="member this.GetAllMessages : unit -&gt; System.Messaging.Message[]" Usage="messageQueue.GetAllMessages " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna todas as mensagens na fila.</summary>
        <returns>Uma matriz do tipo <see cref="T:System.Messaging.Message" /> que representa todas as mensagens na fila, na mesma ordem em que são exibidas na fila do serviço de Enfileiramento de Mensagens.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> Retorna um instantâneo estático do mensagens na fila, não dinâmico links a essas mensagens. Portanto, é possível usar a matriz para modificar as mensagens na fila. Se você quiser que a interação em tempo real e dinâmica com a fila (como a capacidade de excluir mensagens), chame o <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> método, que retorna uma lista dinâmica de mensagens na fila.  
  
 Porque <xref:System.Messaging.MessageQueue.GetAllMessages%2A> retorna uma cópia das mensagens na fila no momento em que o método foi chamado, a matriz não reflete novas mensagens que chegam na fila ou mensagens que são removidas da fila.  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> recupera apenas as propriedades não filtradas pelo <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> propriedade.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.GetAllMessages%2A>.  
  
 [!code-cpp[MessageQueue2#21](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#21)]
 [!code-csharp[MessageQueue2#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="messageQueue.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Enumera as mensagens em uma fila. O <see cref="M:System.Messaging.MessageQueue.GetEnumerator" /> foi preterido. Em vez disso, <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /> deve ser usado.</summary>
        <returns>Um <see cref="T:System.Collections.IEnumerator" /> que fornece uma conexão dinâmica para as mensagens na fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.GetEnumerator%2A>.  
  
 [!code-cpp[MessageQueue2#22](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#22)]
 [!code-csharp[MessageQueue2#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMachineId">
      <MemberSignature Language="C#" Value="public static Guid GetMachineId (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetMachineId(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMachineId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineId (machineName As String) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetMachineId(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetMachineId : string -&gt; Guid" Usage="System.Messaging.MessageQueue.GetMachineId machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">O nome do computador que contém a fila sem as duas barras invertidas no início (\\\\).</param>
        <summary>Obtém o identificador do computador no qual a fila referenciada por este <see cref="T:System.Messaging.MessageQueue" /> está localizada.</summary>
        <returns>Um <see cref="T:System.Guid" /> que representa um identificador exclusivo para o computador no qual a fila está localizada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar o identificador de um computador para duas finalidades, entre outros: para ler o diário do computador e para definir os certificados de segurança. No entanto, você não pode chamar <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> para um computador remoto quando você estiver trabalhando offline, porque o aplicativo deve ter acesso ao serviço de diretório no controlador de domínio.  
  
 O identificador do computador (ou o identificador de máquina) é um <xref:System.Guid> que o enfileiramento de mensagens cria quando um computador é adicionado à empresa. Serviço de enfileiramento combina o identificador do computador com o `Machine` e `Journal` palavras-chave para criar o nome do formato do diário de computador que tem a sintaxe `Machine=<computeridentifier>;Journal`. Mensagens do diário de máquina, que também é conhecido como a fila de diário, é uma fila do sistema que armazena cópias das gerados pelo aplicativo quando o <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> é de propriedade `true`.  
  
 Essa sintaxe para o diário é válido somente ao construir o nome do formato da fila. É a sintaxe de nome de caminho `MachineName` \\ `Journal$`.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Não|  
|Computador local e o nome de formato direto|Não|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir chama <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29>.  
  
 [!code-csharp[MessageQueue#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">O identificador do computador não pôde ser recuperado, possivelmente porque o serviço de diretório não está disponível. Por exemplo, se você estiver trabalhando offline.  
  
- ou - 
Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um objeto enumerador para todas as mensagens na fila. O <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" /> foi preterido. Em vez disso, <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /> deve ser usado.</summary>
        <returns>O <see cref="T:System.Messaging.MessageEnumerator" /> mantém as mensagens que estão contidas na fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> cria uma lista dinâmica de todas as mensagens em uma fila. Você pode remover da fila de mensagem na posição atual do enumerador chamando <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> para o <xref:System.Messaging.MessageEnumerator> que <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> retorna.  
  
 Como o cursor é associado com a lista dinâmica de mensagens na fila, a enumeração reflete qualquer modificação que você fizer as mensagens na fila, se a mensagem for além da posição atual do cursor. Por exemplo, o enumerador pode acessar automaticamente uma mensagem de prioridade mais baixa colocada além a posição do cursor atual, mas não uma mensagem de prioridade mais alta inserido antes nessa posição. No entanto, você pode redefinir a enumeração, assim, mover o cursor novamente para o início da lista, chamando <xref:System.Messaging.MessageEnumerator.Reset%2A> para o <xref:System.Messaging.MessageEnumerator>.  
  
 A ordem das mensagens na enumeração reflete sua ordem na fila, para que as mensagens de prioridade mais alta serão exibido antes que aqueles de menor prioridade.  
  
 Se você quiser que um instantâneo estático das mensagens na fila em vez de uma conexão dinâmica a eles, chame <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. Esse método retorna uma matriz de <xref:System.Messaging.Message> objetos que representam as mensagens no momento em que o método foi chamado.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém uma lista dinâmica de mensagens em uma fila e contagens de todas as mensagens com o <xref:System.Messaging.Message.Priority%2A> propriedade definida como <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator2">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator2() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator2 () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator2();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator2 : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator2 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um objeto enumerador para todas as mensagens na fila.</summary>
        <returns>O <see cref="T:System.Messaging.MessageEnumerator" /> mantém as mensagens que estão contidas na fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> cria uma lista dinâmica de todas as mensagens em uma fila. Você pode remover da fila de mensagem na posição atual do enumerador chamando <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> para o <xref:System.Messaging.MessageEnumerator> que <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> retorna.  
  
 Como o cursor é associado com a lista dinâmica de mensagens na fila, a enumeração reflete qualquer modificação que você fizer as mensagens na fila, se a mensagem for além da posição atual do cursor. Por exemplo, o enumerador pode acessar automaticamente uma mensagem de prioridade mais baixa colocada além a posição do cursor atual, mas não uma mensagem de prioridade mais alta inserido antes nessa posição. No entanto, você pode redefinir a enumeração, assim, mover o cursor novamente para o início da lista, chamando <xref:System.Messaging.MessageEnumerator.Reset%2A> para o <xref:System.Messaging.MessageEnumerator>.  
  
 A ordem das mensagens na enumeração reflete sua ordem na fila, para que as mensagens de prioridade mais alta serão exibido antes que aqueles de menor prioridade.  
  
 Se você quiser que um instantâneo estático das mensagens na fila em vez de uma conexão dinâmica a eles, chame <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. Esse método retorna uma matriz de <xref:System.Messaging.Message> objetos que representam as mensagens no momento em que o método foi chamado.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMessageQueueEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria um objeto de enumerador para obter uma lista dinâmica de filas públicas na rede.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator () As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator();" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : unit -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fornece a semântica de cursor somente de avanço para enumerar todas as filas públicas na rede.</summary>
        <returns>Um <see cref="T:System.Messaging.MessageQueueEnumerator" /> que fornece uma lista dinâmica de todas as filas de mensagens públicas na rede.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga de <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> retorna uma enumeração de todas as filas públicas na rede.  
  
 Porque o cursor está associado uma lista dinâmica, a enumeração reflete qualquer modificação que você pode fazer em uma lista de fila para filas, excluído ou adicionado além a posição do cursor atual. Adições ou exclusão de filas localizadas antes da posição do cursor atual não são refletidas. Por exemplo, o enumerador automaticamente pode acessar uma fila acrescentado além da posição do cursor, mas não uma inserido antes nessa posição. No entanto, você pode redefinir a enumeração, assim, mover o cursor novamente para o início da lista, chamando <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> para o <xref:System.Messaging.MessageQueueEnumerator>.  
  
 Não há nenhuma ordem definida de filas em uma rede. Um enumerador não ordená-los, por exemplo, por computador, rótulo, status público ou privado ou qualquer outro critério acessível.  
  
 Se você quiser que um instantâneo estático das filas na rede em vez de uma conexão dinâmica a eles, chame <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> ou <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Cada um desses dois métodos retorna uma matriz de <xref:System.Messaging.MessageQueue> objetos que representam as filas no momento em que o método foi chamado.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Não|  
|Computador local e o nome de formato direto|Não|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir itera em todas as filas de mensagens na rede e examina o caminho para cada fila. Por fim, ele exibe o número de filas públicas na rede.  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator (criteria As MessageQueueCriteria) As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">Um <see cref="T:System.Messaging.MessageQueueCriteria" /> que contém os critérios usados para filtrar as filas de mensagens disponíveis.</param>
        <summary>Fornece a semântica de cursor somente de avanço para enumerar todas as filas públicas na rede que atendem aos critérios especificados.</summary>
        <returns>Um <see cref="T:System.Messaging.MessageQueueEnumerator" /> que fornece uma lista dinâmica de filas de mensagens públicas na rede que cumprem as restrições especificadas pelo parâmetro <paramref name="criteria" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga de <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> retorna uma lista de todas as filas públicas na rede que atendem aos critérios definidos nos critérios de aplicativo. Você pode especificar os critérios para incluir, por exemplo, de fila hora de criação ou modificação, nome do computador, rótulo, categoria ou qualquer combinação desses itens.  
  
 Porque o cursor está associado uma lista dinâmica, a enumeração reflete qualquer modificação que tornar a uma fila que ocorre além a posição do cursor atual. As alterações filas localizadas antes da posição do cursor atual não são refletidas. Por exemplo, o enumerador automaticamente pode acessar uma fila acrescentado além da posição do cursor, mas não uma inserido antes nessa posição. No entanto, você pode redefinir a enumeração, assim, mover o cursor novamente para o início da lista, chamando <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> para o <xref:System.Messaging.MessageQueueEnumerator>.  
  
 Não há nenhuma ordem definida de filas em uma rede. Um enumerador não ordená-los, por exemplo, por computador, rótulo, status público ou privado ou qualquer outro critério acessível.  
  
 Se você quiser um instantâneo estático das filas na rede em vez de uma conexão dinâmica a eles, especifique os critérios para <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> ou chamar <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Cada um desses dois métodos retorna uma matriz de <xref:System.Messaging.MessageQueue> objetos que representam as filas no momento em que o método foi chamado. Chamando <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, ou <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> fornece os mesmos resultados que chamar <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> com os critérios de filtragem de <xref:System.Messaging.MessageQueue.Category%2A>, <xref:System.Messaging.MessageQueue.Label%2A>, e <xref:System.Messaging.MessageQueue.MachineName%2A>, respectivamente.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Não|  
|Computador local e o nome de formato direto|Não|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir itera por meio de filas de mensagens e exibe o caminho de cada fila que foi criada no último dia e que existe no computador "MyComputer".  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CPP/mqgetmessagequeueenumerator_criteria.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CS/mqgetmessagequeueenumerator_criteria.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/VB/mqgetmessagequeueenumerator_criteria.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetPrivateQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPrivateQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPrivateQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPrivateQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPrivateQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPrivateQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPrivateQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">O computador do qual recuperar as filas privativas.</param>
        <summary>Recupera todas as filas privativas no computador especificado.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Messaging.MessageQueue" /> que referenciam as filas privativas recuperadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> recupera um instantâneo estático de filas em um computador especificado.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir recupera as listas de filas.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="machineName" /> é <see langword="null" /> ou uma cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPublicQueues">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera todas as filas públicas na rede.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues () As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues();" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : unit -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera todas as filas públicas na rede.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Messaging.MessageQueue" /> que fazem referência às filas públicas recuperadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga se você quiser uma lista completa de todas as filas públicas na rede. Se você quiser restringir a lista por certos critérios, como <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, ou a hora da última modificação usar outra sobrecarga desse método. (Como alternativa, você pode usar <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, ou <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>.)  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> recupera um instantâneo estático de filas. Para interagir com uma lista dinâmica de filas, use <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Não|  
|Computador local e o nome de formato direto|Não|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir recupera as listas de filas.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues (criteria As MessageQueueCriteria) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">Um <see cref="T:System.Messaging.MessageQueueCriteria" /> que contém os critérios usados para filtrar as filas.</param>
        <summary>Recupera todas as filas públicas na rede que atendem aos critérios especificados.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Messaging.MessageQueue" /> que fazem referência às filas públicas recuperadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você quiser filtrar todas as filas públicas na rede por rótulo, categoria ou nome do computador, o <xref:System.Messaging.MessageQueue> classe contém métodos específicos que fornecem essa funcionalidade (<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, e <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, respectivamente). Use essa sobrecarga para obter uma lista de todas as filas públicas na rede que atender a mais de um desses critérios (por exemplo, se você deseja especificar um rótulo e uma categoria). Você também pode filtrar por critérios de mensagem diferente de <xref:System.Messaging.MessageQueue.Label%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, e <xref:System.Messaging.MessageQueue.MachineName%2A>. Por exemplo, você deve usar essa sobrecarga para filtrar por hora da última modificação em uma fila. Basta criar uma nova instância dos <xref:System.Messaging.MessageQueueCriteria> classe, defina as propriedades adequadas na instância e passar a instância como o `criteria` parâmetro.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> recupera um instantâneo estático de filas. Para interagir com uma lista dinâmica de filas, use <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Não|  
|Computador local e o nome de formato direto|Não|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir recupera as listas de filas.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="T:System.Messaging.MessageQueueCriteria" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByCategory">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByCategory (Guid category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByCategory(valuetype System.Guid category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByCategory (category As Guid) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByCategory(Guid category);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByCategory : Guid -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByCategory category" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="category">Um <see cref="T:System.Guid" /> que agrupa o conjunto de filas a serem recuperadas.</param>
        <summary>Recupera todas as filas públicas na rede que pertencem à categoria especificada.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Messaging.MessageQueue" /> que fazem referência às filas públicas recuperadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para filtrar as filas públicas por categoria. O <xref:System.Messaging.MessageQueue.Category%2A> propriedade fornece acesso para o enfileiramento de mensagens tipo propriedade ID (que é leitura/gravação) de uma determinada fila. Embora você possa usar <xref:System.Guid.NewGuid%2A> para criar um valor de categoria que seja exclusivo em todo o <xref:System.Guid> valores, não é necessário. O valor da categoria precisa ser diferente apenas de outras categorias, não de todas as outras <xref:System.Guid> valores. Por exemplo, você pode atribuir {00000000-0000-0000-0000-000000000001} como o <xref:System.Messaging.MessageQueue.Category%2A> para um conjunto de filas e {00000000-0000-0000-0000-000000000002} como o <xref:System.Messaging.MessageQueue.Category%2A> para outro conjunto.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> recupera um instantâneo estático de filas. Para interagir com uma lista dinâmica de filas, use <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Você pode especificar a categoria como parte do <xref:System.Messaging.MessageQueueCriteria> passar para o método.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Não|  
|Computador local e o nome de formato direto|Não|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir recupera as listas de filas.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByLabel">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByLabel (string label);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByLabel(string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByLabel (label As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByLabel(System::String ^ label);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByLabel : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByLabel label" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="label">Um rótulo que agrupa o conjunto de filas a serem recuperadas.</param>
        <summary>Recupera todas as filas públicas na rede que contêm o rótulo especificado.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Messaging.MessageQueue" /> que fazem referência às filas públicas recuperadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para filtrar as filas públicas por rótulo.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> recupera um instantâneo estático de filas. Para interagir com uma lista dinâmica de filas, use <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Você pode especificar o rótulo como parte do <xref:System.Messaging.MessageQueueCriteria> passar para o método.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Não|  
|Computador local e o nome de formato direto|Não|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir recupera as listas de filas.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="label" /> é <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">O nome do computador que contém o conjunto de filas públicas a serem recuperadas.</param>
        <summary>Recupera todas as filas públicas que residem no computador especificado.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Messaging.MessageQueue" /> que fazem referência às filas públicas no computador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para filtrar as filas públicas por computador.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> recupera um instantâneo estático de filas. Para interagir com uma lista dinâmica de filas, use <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Você pode especificar o nome do computador como parte do <xref:System.Messaging.MessageQueueCriteria> passar para o método.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Não|  
|Computador local e o nome de formato direto|Não|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir recupera as listas de filas.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="machineName" /> tem sintaxe incorreta.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityContext">
      <MemberSignature Language="C#" Value="public static System.Messaging.SecurityContext GetSecurityContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.SecurityContext GetSecurityContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetSecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSecurityContext () As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::SecurityContext ^ GetSecurityContext();" />
      <MemberSignature Language="F#" Value="static member GetSecurityContext : unit -&gt; System.Messaging.SecurityContext" Usage="System.Messaging.MessageQueue.GetSecurityContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera o contexto de segurança que o MSMQ associa ao usuário atual (identidade de thread) no momento desta chamada.</summary>
        <returns>Um objeto <see cref="T:System.Messaging.SecurityContext" /> que contém o contexto de segurança.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Messaging.Message.SecurityContext" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Id { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : Guid" Usage="System.Messaging.MessageQueue.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_GuidId")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o identificador exclusivo de Enfileiramento de Mensagens da fila.</summary>
        <value>Um <see cref="P:System.Messaging.MessageQueue.Id" /> que representa o identificador de mensagem gerado pelo aplicativo de enfileiramento de mensagens.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Conjuntos de enfileiramento de mensagens a <xref:System.Messaging.MessageQueue.Id%2A> propriedade quando ele cria a fila. Essa propriedade só está disponível para filas públicas.  
  
 A tabela a seguir mostra se essa propriedade está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.Id%2A> propriedade.  
  
 [!code-csharp[MessageQueue#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteQueueSize">
      <MemberSignature Language="C#" Value="public static readonly long InfiniteQueueSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 InfiniteQueueSize" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteQueueSize As Long " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly long InfiniteQueueSize;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteQueueSize : int64" Usage="System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que não existe nenhuma restrição de tamanho para uma fila.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse membro é usado com frequência ao definir <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> ou <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Messaging.MessageQueue.InfiniteQueueSize> membro.  
  
 [!code-csharp[MessageQueue#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que não existe nenhum tempo limite para os métodos que espiam ou recebem mensagens.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue> dá suporte a dois tipos de recuperação da mensagem: síncrono e assíncrono. Os métodos síncronos, <xref:System.Messaging.MessageQueue.Peek%2A> e <xref:System.Messaging.MessageQueue.Receive%2A>, fazer com que o thread de processo aguardar um intervalo de tempo especificado por uma nova mensagem chegar na fila. Se o intervalo de tempo especificado for <xref:System.Messaging.MessageQueue.InfiniteTimeout>, o thread de processo permanece bloqueado até que uma nova mensagem esteja disponível. Por outro lado, <xref:System.Messaging.MessageQueue.BeginPeek%2A> e <xref:System.Messaging.MessageQueue.BeginReceive%2A> (os métodos assíncronos), permitem que as tarefas do aplicativo principal continuar em um thread separado, até que uma mensagem chega na fila.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Messaging.MessageQueue.InfiniteTimeout> membro.  
  
 [!code-csharp[MessageQueue#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.MessageQueue.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Label")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a descrição da fila.</summary>
        <value>O rótulo para a fila de mensagens. O padrão é uma cadeia de caracteres vazia ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O comprimento máximo de um rótulo de mensagem de fila é de 124 caracteres.  
  
 O <xref:System.Messaging.MessageQueue.Label%2A> propriedade não precisa ser exclusivo entre todas as filas. No entanto, se várias filas compartilham o mesmo <xref:System.Messaging.MessageQueue.Label%2A>, você não pode usar o <xref:System.Messaging.MessageQueue.Send%28System.Object%29> método para difundir uma mensagem a todos eles. Se você usar a sintaxe do rótulo para o <xref:System.Messaging.MessageQueue.Path%2A> propriedade ao enviar a mensagem, uma exceção será gerada se o <xref:System.Messaging.MessageQueue.Label%2A> não é exclusivo.  
  
 A tabela a seguir mostra se essa propriedade está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.Label%2A> propriedade.  
  
 [!code-csharp[MessageQueue#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O rótulo foi definido como um valor inválido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="LastModifyTime">
      <MemberSignature Language="C#" Value="public DateTime LastModifyTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastModifyTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.LastModifyTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastModifyTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime LastModifyTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.LastModifyTime : DateTime" Usage="System.Messaging.MessageQueue.LastModifyTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_LastModifyTime")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a última vez que as propriedades de uma fila foram modificadas.</summary>
        <value>Um <see cref="T:System.DateTime" /> que indica quando as propriedades de fila foram modificadas pela última vez.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A hora da última modificação inclui quando a fila foi criada e qualquer <xref:System.Messaging.MessageQueue> propriedade que modifica a fila de enfileiramento de mensagens, como <xref:System.Messaging.MessageQueue.BasePriority%2A>. O valor da <xref:System.Messaging.MessageQueue.LastModifyTime%2A> propriedade representa a hora do sistema do computador local.  
  
 Você deve chamar <xref:System.Messaging.MessageQueue.Refresh%2A> antes de obter o <xref:System.Messaging.MessageQueue.LastModifyTime%2A> propriedade; caso contrário, a hora de modificação associado a este <xref:System.Messaging.MessageQueue> podem não ser atuais.  
  
 A tabela a seguir mostra se essa propriedade está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.LastModifyTime%2A> propriedade.  
  
 [!code-csharp[MessageQueue#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CreateTime" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Messaging.MessageQueue.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MachineName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o nome do computador em que a fila do serviço de enfileiramento de mensagens está localizada.</summary>
        <value>O nome do computador no qual a fila está localizada. O padrão do serviço de enfileiramento de mensagens é “.”, o computador local.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.MessageQueue.MachineName%2A> é um componente integrante da sintaxe do nome amigável da fila <xref:System.Messaging.MessageQueue.Path%2A>. A tabela a seguir mostra a sintaxe que você deve usar para uma fila de um tipo especificado quando você deseja identificar o caminho da fila usando seu nome amigável.  
  
|Tipo de fila|Sintaxe|  
|----------------|------------|  
|Fila pública|`MachineName`\\`QueueName`|  
|Fila particular|`MachineName`\\`Private$`\\`QueueName`|  
|Fila de diário|`MachineName`\\`QueueName`\\`Journal$`|  
|Fila de diário da máquina|`MachineName`\\`Journal$`|  
|Fila de inatividade do computador|`MachineName`\\`Deadletter$`|  
|Fila de inatividade transacional do computador|`MachineName`\\`XactDeadletter$`|  
  
 Use "." para o computador local ao especificar o <xref:System.Messaging.MessageQueue.MachineName%2A>. Somente o nome do computador é reconhecido para esta propriedade, por exemplo, `Server0`. O <xref:System.Messaging.MessageQueue.MachineName%2A> propriedade não dá suporte para o formato do endereço IP.  
  
 Se você definir a <xref:System.Messaging.MessageQueue.Path%2A> em termos do <xref:System.Messaging.MessageQueue.MachineName%2A>, o aplicativo gera uma exceção ao trabalhar offline porque o controlador de domínio é necessário para a tradução de caminho. Portanto, você deve usar o <xref:System.Messaging.MessageQueue.FormatName%2A> para o <xref:System.Messaging.MessageQueue.Path%2A> sintaxe ao trabalhar offline.  
  
 O <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, e <xref:System.Messaging.MessageQueue.QueueName%2A> propriedades estão relacionadas. Alterando a <xref:System.Messaging.MessageQueue.MachineName%2A> faz com que a propriedade de <xref:System.Messaging.MessageQueue.Path%2A> propriedade a ser alterada. Ele se baseia na nova <xref:System.Messaging.MessageQueue.MachineName%2A> e o <xref:System.Messaging.MessageQueue.QueueName%2A>. Alterando a <xref:System.Messaging.MessageQueue.Path%2A> (por exemplo, usar a sintaxe de nome de formato) redefine as <xref:System.Messaging.MessageQueue.MachineName%2A> e <xref:System.Messaging.MessageQueue.QueueName%2A> propriedades para referir-se a nova fila. Se o <xref:System.Messaging.MessageQueue.QueueName%2A> propriedade estiver vazia, o <xref:System.Messaging.MessageQueue.Path%2A> é definido como a fila de diário do computador que você especificar.  
  
 A tabela a seguir mostra se essa propriedade está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.MachineName%2A> propriedade.  
  
 [!code-csharp[MessageQueue#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O nome do computador não é válido, possivelmente porque a sintaxe está incorreta.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="MaximumJournalSize">
      <MemberSignature Language="C#" Value="public long MaximumJournalSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumJournalSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumJournalSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumJournalSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumJournalSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumJournalSize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tamanho máximo da fila de diário.</summary>
        <value>O tamanho máximo, em quilobytes, da fila de diário. O padrão do Enfileiramento de Mensagens especifica que não há limite.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> fornece acesso para o limite de armazenamento do diário de enfileiramento de mensagens. Ele é relevante somente quando <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> é `true`. A definição dessa propriedade modifica a fila de enfileiramento de mensagens. Portanto, qualquer outro <xref:System.Messaging.MessageQueue> instâncias são afetadas pela alteração  
  
 Se você armazenar mensagens em um diário ou fila de inatividade, você deve limpar periodicamente a fila para remover as mensagens que não são mais necessários. Contagem de mensagens em uma fila como a cota de mensagem para o computador em que a fila reside. (O administrador define a cota do computador).  
  
 A tabela a seguir mostra se essa propriedade está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> propriedade.  
  
 [!code-csharp[MessageQueue#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O tamanho máximo da fila de diário foi definido para um valor inválido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumQueueSize">
      <MemberSignature Language="C#" Value="public long MaximumQueueSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumQueueSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumQueueSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumQueueSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumQueueSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumQueueSize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tamanho máximo da fila.</summary>
        <value>O tamanho máximo, em quilobytes, da fila. O padrão do Enfileiramento de Mensagens especifica que não há limite.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> fornece acesso ao limite de armazenamento de mensagem enfileiramento de mensagens, que é separado da cota de mensagens do computador que o administrador define. Para obter mais informações sobre a cota de mensagens, consulte <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>.  
  
 A definição dessa propriedade modifica a fila de enfileiramento de mensagens. Portanto, qualquer outro <xref:System.Messaging.MessageQueue> instâncias são afetadas pela alteração  
  
 Se for feita uma tentativa de exceder o tamanho máximo da fila ou a cota de mensagens do computador, as mensagens podem ser perdidas. Quando a cota da fila for atingida, o enfileiramento de mensagens notifica a fila de administração do aplicativo de envio para indicar que a fila está cheia, retornando uma mensagem de confirmação negativa. Serviço de enfileiramento continua a enviar confirmações negativas até que o tamanho total das mensagens na fila fique abaixo do limite.  
  
 A tabela a seguir mostra se essa propriedade está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> propriedade.  
  
 [!code-csharp[MessageQueue#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O tamanho máximo da fila contém um valor negativo.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MessageReadPropertyFilter">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePropertyFilter MessageReadPropertyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessagePropertyFilter MessageReadPropertyFilter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageReadPropertyFilter As MessagePropertyFilter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePropertyFilter ^ MessageReadPropertyFilter { System::Messaging::MessagePropertyFilter ^ get(); void set(System::Messaging::MessagePropertyFilter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MessageReadPropertyFilter : System.Messaging.MessagePropertyFilter with get, set" Usage="System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePropertyFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o filtro de propriedade para receber ou espiar mensagens.</summary>
        <value>O <see cref="T:System.Messaging.MessagePropertyFilter" /> usado pela fila para filtrar o conjunto de propriedades que ela recebe ou espia para cada mensagem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse filtro é um conjunto de valores boolianos, restringindo as propriedades de mensagem que o <xref:System.Messaging.MessageQueue> recebe ou espia. Quando o <xref:System.Messaging.MessageQueue> recebe ou espia uma mensagem da fila de servidor, ele recupera apenas as propriedades para o qual o <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> valor é `true`.  
  
 A seguir mostra os valores de propriedade inicial para o <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> propriedade. Essas configurações são idênticas a chamar <xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A> em um <xref:System.Messaging.MessagePropertyFilter>.  
  
|Propriedade|Valor padrão|  
|--------------|-------------------|  
|<xref:System.Messaging.MessagePropertyFilter.Acknowledgment%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AcknowledgeType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AdministrationQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AppSpecific%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ArrivedTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AttachSenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Authenticated%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderName%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Body%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.ConnectorType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.CorrelationId%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultBodySize%2A>|1024 bytes|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultExtensionSize%2A>|255 bytes|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultLabelSize%2A>|255 bytes|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationSymmetricKey%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DigitalSignature%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.EncryptionAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Extension%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.HashAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Id%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.IsFirstInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.IsLastInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Label%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.MessageType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Priority%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Recoverable%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ResponseQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderCertificate%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderVersion%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SentTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SourceMachine%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToBeReceived%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToReachQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionStatusQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseTracing%2A>|`false`|  
  
 A tabela a seguir mostra se essa propriedade está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> para restringir as propriedades da mensagem recebidas.  
  
 [!code-cpp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CPP/mqmessagereadpropertyfilter.cpp#1)]
 [!code-csharp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CS/mqmessagereadpropertyfilter.cs#1)]
 [!code-vb[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/VB/mqmessagereadpropertyfilter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O filtro é <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="MulticastAddress">
      <MemberSignature Language="C#" Value="public string MulticastAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MulticastAddress" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MulticastAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MulticastAddress { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastAddress : string with get, set" Usage="System.Messaging.MessageQueue.MulticastAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MulticastAddress")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Introduzido no MSMQ 3.0. Obtém ou define o endereço multicast associado à fila.</summary>
        <value>Um <see cref="T:System.String" /> que contém um endereço multicast válido (no formato mostrado abaixo) ou <see langword="null" />, que indica que a fila não está associada a um endereço multicast.  
  
```  
&lt;address&gt;:&lt;port&gt;  
```</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.MessageQueue.MulticastAddress%2A> propriedade é usada para associar a um endereço de multicast que pode ser usado ao enviar mensagens de uma fila não transacional. É possível associar uma fila transacional com um endereço de multicast. Quando o aplicativo de envio envia mensagens para um endereço de multicast, enfileiramento de mensagens envia uma cópia da mensagem para cada fila associada a esse endereço.  
  
 Multicast IP endereços devem estar no intervalo classe D de 224.0.0.0 a 239.255.255.255, que corresponde à configuração os quatro primeiros bits de ordem superior é igual a 1110. No entanto, somente determinados intervalos de endereços nesse intervalo são não reservada e disponível para enviar mensagens de multicast. Para obter a lista mais recente de endereços multicast reservados, consulte o [endereços Multicast do número autoridade IANA (Internet Assigned) da Internet](http://go.microsoft.com/fwlink/?linkid=3859) página da Web. Não há nenhuma restrição no número de porta.  
  
 Se vários computadores de origem estão enviando mensagens de multicast e você desejar uma fila específica para receber mensagens de um único computador de origem, cada computador de origem deve enviar mensagens para uma combinação diferente de número de porta e endereço IP.  
  
 Para desassociar uma fila de um endereço de multicast, defina o <xref:System.Messaging.MessageQueue.MulticastAddress%2A> propriedade como uma cadeia de caracteres de comprimento zero. Não o defina como `null`, pois isso resultará em um <xref:System.ArgumentNullException>.  
  
 A tabela a seguir mostra se essa propriedade está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">O MSMQ 3.0 não está instalado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.Messaging.MessageQueue.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Path")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o caminho da fila. Definir o <see cref="P:System.Messaging.MessageQueue.Path" /> faz com que o <see cref="T:System.Messaging.MessageQueue" /> aponte para uma nova fila.</summary>
        <value>A fila que é referenciada pelo <see cref="T:System.Messaging.MessageQueue" />. O padrão depende do construtor <see cref="M:System.Messaging.MessageQueue.#ctor" /> usado, ele é <see langword="null" /> ou especificado pelo parâmetro <paramref name="path" /> do construtor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A sintaxe para o <xref:System.Messaging.MessageQueue.Path%2A> propriedade depende do tipo de fila-pontos a, conforme mostrado na tabela a seguir.  
  
|Tipo de fila|Sintaxe|  
|----------------|------------|  
|Fila pública|`MachineName`\\`QueueName`|  
|Fila particular|`MachineName`\\`Private$`\\`QueueName`|  
|Fila de diário|`MachineName`\\`QueueName`\\`Journal$`|  
|Fila de diário da máquina|`MachineName`\\`Journal$`|  
|Fila de inatividade do computador|`MachineName`\\`Deadletter$`|  
|Fila de inatividade transacional do computador|`MachineName`\\`XactDeadletter$`|  
  
 Use "." para representar o computador local.  
  
 O <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, e <xref:System.Messaging.MessageQueue.QueueName%2A> propriedades estão relacionadas. Alterando a <xref:System.Messaging.MessageQueue.MachineName%2A> faz com que a propriedade de <xref:System.Messaging.MessageQueue.Path%2A> propriedade a ser alterada. Ele se baseia na nova <xref:System.Messaging.MessageQueue.MachineName%2A> e o <xref:System.Messaging.MessageQueue.QueueName%2A>. Alterando a <xref:System.Messaging.MessageQueue.Path%2A> (por exemplo, usar a sintaxe de nome de formato) redefine as <xref:System.Messaging.MessageQueue.MachineName%2A> e <xref:System.Messaging.MessageQueue.QueueName%2A> propriedades para referir-se a nova fila.  
  
 Como alternativa, você pode usar o <xref:System.Messaging.MessageQueue.FormatName%2A> ou <xref:System.Messaging.MessageQueue.Label%2A> para descrever o caminho da fila, conforme mostrado na tabela a seguir.  
  
|Referência|Sintaxe|Exemplo|  
|---------------|------------|-------------|  
|Nome do formato|`FormatName:` [ *nome do formato* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112|  
|Rotular|`Label:` [ *label* ]|`Label:` TheLabel|  
  
 Se você usar a sintaxe do rótulo para o <xref:System.Messaging.MessageQueue.Path%2A> propriedade ao enviar a mensagem, uma exceção será gerada se o <xref:System.Messaging.MessageQueue.Label%2A> não é exclusivo.  
  
 Para trabalhar offline, você deve usar a sintaxe de nome de formato, em vez da sintaxe do nome amigável da primeira tabela. Caso contrário, uma exceção é gerada porque o controlador de domínio primário (no qual o Active Directory reside) não está disponível para resolver o caminho para o nome do formato.  
  
 Definir um novo caminho fecha a fila de mensagens e libera todos os identificadores.  
  
 A tabela a seguir mostra se essa propriedade está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
> [!NOTE]
>  No modo de grupo de trabalho, você só pode usar as filas particulares. Especifique o caminho usando a sintaxe de fila particular `MachineName` \\ `Private$` \\ `QueueName`.  
  
   
  
## Examples  
 O exemplo de código a seguir cria novos <xref:System.Messaging.MessageQueue> objetos usando vários tipos de sintaxe de nome de caminho. Em cada caso, ele envia uma mensagem para a fila cujo caminho é definido no construtor.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho não é válido, possivelmente porque a sintaxe não é válida.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Peek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <summary>Retorna uma cópia da primeira mensagem na fila sem remover a mensagem da fila.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek();" />
      <MemberSignature Language="F#" Value="member this.Peek : unit -&gt; System.Messaging.Message" Usage="messageQueue.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna sem remover (espia) a primeira mensagem na fila referenciada por este <see cref="T:System.Messaging.MessageQueue" />. O método <see cref="M:System.Messaging.MessageQueue.Peek" /> é síncrono. Portanto, ele bloqueia o thread atual até que uma mensagem se torne disponível.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> que representa a primeira mensagem na fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para inspecionar uma fila ou aguardar até que uma mensagem existe na fila.  
  
 O <xref:System.Messaging.MessageQueue.Peek%2A> método lê, mas não remove a primeira mensagem da fila. Portanto, chamadas repetidas para <xref:System.Messaging.MessageQueue.Peek%2A> retornar a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método, por outro lado, lê e remove a primeira mensagem da fila. Chamadas repetidas para <xref:System.Messaging.MessageQueue.Receive%2A>, portanto, retornar mensagens diferentes.  
  
 Serviço de enfileiramento ordena as mensagens na fila de acordo com o tempo de chegada e prioridade. Uma mensagem mais recente é colocada antes mais antiga somente se ele for de uma prioridade mais alta.  
  
 Use <xref:System.Messaging.MessageQueue.Peek%2A> quando ele é aceitável para o thread atual a ser bloqueada enquanto aguarda uma mensagem chegar na fila. Como essa sobrecarga não especifica um tempo limite, o aplicativo pode aguardar indefinidamente. Se você precisar continuar sem aguardar o processamento de aplicativo, use assíncrona <xref:System.Messaging.MessageQueue.BeginPeek%2A> método. Como alternativa, você pode especificar um tempo limite para uma mensagem chegar na fila usando a sobrecarga de <xref:System.Messaging.MessageQueue.Peek%2A> que especifica um tempo limite.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 Os exemplos a seguir usam o <xref:System.Messaging.MessageQueue.Peek%2A> método em uma fila.  
  
 No primeiro exemplo, o aplicativo aguarda até que uma mensagem fique disponível na fila. Observe que o primeiro exemplo não acessa a mensagem que chega; ela simplesmente pausa o processamento até que uma mensagem chega. Se uma mensagem já existe na fila, ele será retornado imediatamente.  
  
 No segundo exemplo, uma mensagem que contém um aplicativo definido `Order` classe é enviada para a fila e, em seguida, é inspecionada da fila.  
  
 [!code-cpp[MessageQueue.Peek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CPP/mqpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Peek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CS/mqpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.Peek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_noparms/VB/mqpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Peek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo máximo de espera para que a fila contenha uma mensagem.</param>
        <summary>Retorna sem remover (espia) a primeira mensagem na fila referenciada por este <see cref="T:System.Messaging.MessageQueue" />. O método <see cref="M:System.Messaging.MessageQueue.Peek" /> é síncrono e, portanto, bloqueia o thread atual até que uma mensagem fique disponível ou o tempo limite especificado seja atingido.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> que representa a primeira mensagem na fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para inspecionar uma fila ou aguardar um período de tempo até que uma mensagem especificado existe na fila. O método retorna imediatamente se já existe uma mensagem na fila.  
  
 O <xref:System.Messaging.MessageQueue.Peek%2A> método lê, mas não remove a primeira mensagem da fila. Portanto, chamadas repetidas para <xref:System.Messaging.MessageQueue.Peek%2A> retornar a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método, por outro lado, lê e remove a primeira mensagem da fila. Chamadas repetidas para <xref:System.Messaging.MessageQueue.Receive%2A>, portanto, retornar mensagens diferentes.  
  
 Serviço de enfileiramento ordena as mensagens na fila de acordo com o tempo de chegada e prioridade. Uma mensagem mais recente é colocada antes mais antiga somente se ele for de uma prioridade mais alta.  
  
 Use <xref:System.Messaging.MessageQueue.Peek%2A> quando ele é aceitável para o thread atual a ser bloqueada enquanto aguarda uma mensagem chegar na fila. O thread será bloqueado até o período especificado de tempo ou indefinidamente se você indicou <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Se você precisar continuar sem aguardar o processamento de aplicativo, use assíncrona <xref:System.Messaging.MessageQueue.BeginPeek%2A> método.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Messaging.MessageQueue.Peek%2A> método com um tempo limite de zero para verificar se a fila está vazia.  
  
 [!code-cpp[MessageQueue.Peek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CPP/mqpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Peek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CS/mqpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.Peek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_timeout/VB/mqpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido, possivelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction -&gt; System.Messaging.Message" Usage="messageQueue.Peek (timeout, cursor, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo máximo de espera para que a fila contenha uma mensagem.</param>
        <param name="cursor">Um <see cref="T:System.Messaging.Cursor" /> que mantém uma posição específica na fila de mensagens.</param>
        <param name="action">Um dos valores de <see cref="T:System.Messaging.PeekAction" />. Indica se a mensagem atual ou a próxima na fila de mensagens deve ser espiada.</param>
        <summary>Retorna sem remover (espia) a mensagem atual ou a próxima na fila usando o cursor especificado. O método <see cref="M:System.Messaging.MessageQueue.Peek" /> é síncrono e, portanto, bloqueia o thread atual até que uma mensagem fique disponível ou o tempo limite especificado seja atingido.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> que representa uma mensagem na fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para inspecionar uma fila ou aguardar um período de tempo até que uma mensagem especificado existe na fila. O método retorna imediatamente se já existe uma mensagem na fila.  
  
 O <xref:System.Messaging.MessageQueue.Peek%2A> método lê, mas não remove uma mensagem da fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método, por outro lado, lê e remove uma mensagem da fila.  
  
 Use <xref:System.Messaging.MessageQueue.Peek%2A> quando ele é aceitável para o thread atual a ser bloqueada enquanto aguarda uma mensagem chegar na fila. O thread é bloqueado até o período especificado de tempo ou indefinidamente se você indicou <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Se você precisar continuar sem aguardar o processamento de aplicativo, use assíncrona <xref:System.Messaging.MessageQueue.BeginPeek%2A> método.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Um valor diferente de <see langword="PeekAction.Current" /> ou <see langword="PeekAction.Next" /> foi especificado para o parâmetro <paramref name="action" />.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="cursor" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> é inválido. Provavelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.PeekAction" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Espia uma mensagem que corresponde a um identificador de correlação determinado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">O <see cref="P:System.Messaging.Message.CorrelationId" /> da mensagem a espiar.</param>
        <summary>Exibe a mensagem que corresponde ao identificador de correlação especificado e gerará imediatamente uma exceção se nenhuma mensagem com o identificador de correlação especificado existir atualmente na fila.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja <see cref="P:System.Messaging.Message.CorrelationId" /> corresponde ao parâmetro <paramref name="correlationId" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método fica na fila referenciada pela <xref:System.Messaging.MessageQueue> para uma mensagem cuja <xref:System.Messaging.Message.CorrelationId%2A> corresponde à especificada `correlationId` parâmetro. Se nenhuma mensagem for encontrada que corresponda a `correlationID` parâmetro, uma exceção será lançada.  
  
 O <xref:System.Messaging.Message.CorrelationId%2A> propriedade é usada para vincular a uma mensagem enviada para a fila para mensagens de resposta, relatório ou confirmação associadas.  
  
 Dois outros métodos permitem espiar mensagens em uma fila. O <xref:System.Messaging.MessageQueue.Peek%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método é usado para recuperar uma mensagem, especificando seu identificador exclusivo.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir envia e recebe uma mensagem que contém um pedido de e para uma fila. Ele solicita especificamente uma confirmação positiva quando a mensagem original atinge ou é recuperada da fila.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="correlationId" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível localizar a mensagem com o <paramref name="correlationId" /> especificado.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">O <see cref="P:System.Messaging.Message.CorrelationId" /> da mensagem a espiar.</param>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo de espera até que uma nova mensagem esteja disponível para inspeção.</param>
        <summary>Espia a mensagem que corresponde ao identificador de correlação fornecido e aguarda até uma mensagem com o identificador de correlação especificado estar disponível na fila ou até o tempo limite expirar.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja <see cref="P:System.Messaging.Message.CorrelationId" /> corresponde ao parâmetro <paramref name="correlationId" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método fica na fila referenciada pela <xref:System.Messaging.MessageQueue> para uma mensagem cuja <xref:System.Messaging.Message.CorrelationId%2A> corresponde à especificada `correlationId` parâmetro. Se nenhuma mensagem for encontrada que corresponda a `correlationID` parâmetro e nenhuma nova mensagem chega na fila de dentro do período especificado pelo `timeout` parâmetro, uma exceção será lançada.  
  
 O `timeout` parâmetro não especificar o total de tempo para esse método de execução. Em vez disso, ele especifica o tempo de espera por uma nova mensagem chegar na fila. Cada vez que uma nova mensagem chega, esse método examina os <xref:System.Messaging.Message.CorrelationId%2A> da nova mensagem para ver se ele corresponde a `correlationId` parâmetro. Caso contrário, esse método inicia o tempo limite ao longo e aguarda a outra nova mensagem chegue. Portanto, se novas mensagens continuam chegando dentro do período de tempo limite, é possível que esse método continuar em execução indefinidamente, até que o período de tempo limite expire sem quaisquer novas mensagens que chegam, ou até que uma mensagem chega cuja <xref:System.Messaging.Message.CorrelationId%2A> corresponde a `correlationId` parâmetro.  
  
 O <xref:System.Messaging.Message.CorrelationId%2A> propriedade é usada para vincular a uma mensagem enviada para a fila para mensagens de resposta, relatório ou confirmação associadas.  
  
 Dois outros métodos permitem espiar mensagens em uma fila. O <xref:System.Messaging.MessageQueue.Peek%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método é usado para recuperar uma mensagem, especificando seu identificador exclusivo.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#5](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#5)]
 [!code-csharp[MessageQueue2#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="correlationId" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido, possivelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">A mensagem com o <paramref name="correlationId" /> especificado não existe na fila e não chegou antes do tempo limite expirar.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Uma mensagem não chegou antes de o tempo limite expirar.  
  
- ou - 
Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna uma cópia da mensagem que tem o identificador de mensagem especificado sem remover a mensagem da fila.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">O <see cref="P:System.Messaging.Message.Id" /> da mensagem a espiar.</param>
        <summary>Espia a mensagem cujo identificador de mensagem corresponde ao parâmetro <paramref name="id" />.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja propriedade <see cref="P:System.Messaging.Message.Id" /> corresponde ao parâmetro <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> a leitura, sem a remoção da fila, uma mensagem que tem um identificador de mensagem conhecido. O identificador de uma mensagem é exclusivo em toda a empresa de enfileiramento de mensagens, para que haja no máximo uma mensagem na fila que corresponda a determinado `id` parâmetro. Essa sobrecarga gera uma exceção se a fila não contém a mensagem no momento.  
  
 Dois métodos adicionais permitem espiar mensagens em uma fila: <xref:System.Messaging.MessageQueue.Peek%2A> e <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. O <xref:System.Messaging.MessageQueue.Peek%2A> método retorna a primeira mensagem na fila de; <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> retorna uma confirmação, relatório ou mensagem de resposta gerados pelo aplicativo que foi criada como resultado de uma mensagem enviada para a fila.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#6](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#6)]
 [!code-csharp[MessageQueue2#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="id" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não existe nenhuma mensagem com <paramref name="id" /> especificado.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">O <see cref="P:System.Messaging.Message.Id" /> da mensagem a espiar.</param>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo de espera até que uma nova mensagem esteja disponível para inspeção.</param>
        <summary>Espia a mensagem cujo identificador de mensagem corresponde ao parâmetro <paramref name="id" />. Aguarda até que a mensagem seja exibida na fila ou um tempo limite ocorra.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja propriedade <see cref="P:System.Messaging.Message.Id" /> corresponde ao parâmetro <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> a leitura, sem a remoção da fila, uma mensagem que tem um identificador de mensagem conhecido. O identificador de uma mensagem é exclusivo em toda a empresa de enfileiramento de mensagens, para que haja no máximo uma mensagem na fila que corresponda a determinado `id` parâmetro. Essa sobrecarga gera uma exceção se a fila não contém a mensagem no momento, e uma nova mensagem não chega antes que ocorra o tempo limite.  
  
 O `timeout` parâmetro não especificar o total de tempo para esse método de execução. Em vez disso, ele especifica o tempo de espera por uma nova mensagem chegar na fila. Cada vez que uma nova mensagem chega, esse método examina os <xref:System.Messaging.Message.Id%2A> da nova mensagem para ver se ele corresponde a `id` parâmetro. Caso contrário, esse método inicia o tempo limite ao longo e aguarda a outra nova mensagem chegue. Portanto, se novas mensagens continuam chegando dentro do período de tempo limite, é possível que esse método continuar em execução indefinidamente, até que o período de tempo limite expire sem quaisquer novas mensagens que chegam, ou até que uma mensagem chega cuja <xref:System.Messaging.Message.Id%2A> corresponde a `id` parâmetro.  
  
 Dois métodos adicionais permitem espiar mensagens em uma fila: <xref:System.Messaging.MessageQueue.Peek%2A> e <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. O <xref:System.Messaging.MessageQueue.Peek%2A> método retorna a primeira mensagem na fila de; <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> retorna uma confirmação, relatório ou mensagem de resposta gerados pelo aplicativo que foi criada como resultado de uma mensagem enviada para a fila.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#7](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#7)]
 [!code-csharp[MessageQueue2#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="id" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido, possivelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">A mensagem com <paramref name="id" /> especificado não existe na fila e não chegou antes de o período especificado pelo parâmetro <paramref name="timeout" /> expirar.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Introduzido no MSMQ 3.0. Espia uma mensagem específica da fila. A mensagem pode ser especificada por um identificador de pesquisa ou pela sua posição no início ou no final da fila.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">O <see cref="P:System.Messaging.Message.LookupId" /> da mensagem a espiar.</param>
        <summary>Introduzido no MSMQ 3.0. Espiada na mensagem que corresponde ao identificador de pesquisa especificado de uma fila não transacional.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja propriedade <see cref="P:System.Messaging.Message.LookupId" /> corresponde ao parâmetro <paramref name="lookupId" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador de pesquisa conhecidos sem removê-la da fila. Esse método gera uma exceção imediatamente se a mensagem não está na fila.  
  
 O <xref:System.Messaging.Message.LookupId%2A> propriedade de uma mensagem é exclusiva para a fila onde reside a mensagem, portanto, haverá no máximo uma mensagem na fila que corresponde à determinado `lookupId` parâmetro.  
  
 Para ler uma mensagem com um identificador de pesquisa especificado e removê-lo da fila, use o <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> método.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">O MSMQ 3.0 não está instalado.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível localizar a mensagem com o <paramref name="lookupId" /> especificado.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (System.Messaging.MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (action As MessageLookupAction, lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(System::Messaging::MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : System.Messaging.MessageLookupAction * int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId (action, lookupId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="action">Um dos valores <see cref="T:System.Messaging.MessageLookupAction" />, especificando como a mensagem é lida na fila. Especifique um dos seguintes: 
 <see langword="MessageLookupAction.Current" />: espia a mensagem especificada pelo <c>lookupId</c>.  
  
 <see langword="MessageLookupAction.Next" />: espia a mensagem posterior à mensagem especificada pelo <c>lookupId</c>.  
  
 <see langword="MessageLookupAction.Previous" />: espia a mensagem anterior à mensagem especificada pelo <c>lookupId</c>.  
  
 <see langword="MessageLookupAction.First" />: espia a primeira mensagem na fila. O parâmetro <c>lookupId</c> deve ser definido como 0.  
  
 <see langword="MessageLookupAction.Last" />: espia a última mensagem na fila. O parâmetro <c>lookupId</c> deve ser definido como 0.</param>
        <param name="lookupId">O <see cref="P:System.Messaging.Message.LookupId" /> da mensagem na qual espiar, ou 0. 0 é usado para acessar a primeira ou a última mensagem na fila.</param>
        <summary>Introduzido no MSMQ 3.0. Espia uma mensagem específica da fila. A mensagem pode ser especificada por um identificador de pesquisa ou pela sua posição no início ou no final da fila.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> especificado pelos parâmetros <paramref name="action" /> e <paramref name="lookupId" /> passados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador de pesquisa conhecidos sem removê-la da fila. Esse método gera uma exceção imediatamente se a mensagem não está na fila.  
  
 O <xref:System.Messaging.Message.LookupId%2A> propriedade de uma mensagem é exclusiva para a fila onde reside a mensagem, portanto, haverá no máximo uma mensagem na fila que corresponde à determinado `lookupId` parâmetro.  
  
 Para ler uma mensagem com um identificador especificado e removê-lo da fila, use o <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> método.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">O MSMQ 3.0 não está instalado.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível localizar a mensagem com o <paramref name="lookupId" /> especificado.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">O parâmetro <paramref name="action" /> não é um dos membros do <see cref="T:System.Messaging.MessageLookupAction" />.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.PeekCompletedEventHandler PeekCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.PeekCompletedEventHandler PeekCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.PeekCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PeekCompleted As PeekCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::PeekCompletedEventHandler ^ PeekCompleted;" />
      <MemberSignature Language="F#" Value="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " Usage="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_PeekCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.PeekCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando uma mensagem é lida sem ser removida da fila. Este é o resultado da operação assíncrona, <see cref="M:System.Messaging.MessageQueue.BeginPeek" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> é usada no processamento assíncrono para gerar o <xref:System.Messaging.MessageQueue.PeekCompleted> evento quando uma mensagem esteja disponível na fila.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> é usado para concluir a operação iniciada por uma chamada para <xref:System.Messaging.MessageQueue.BeginPeek%2A> e inspecionar a mensagem quando o <xref:System.Messaging.MessageQueue.PeekCompleted> é gerado.  
  
 Quando você cria um <xref:System.Messaging.PeekCompletedEventHandler> delegado, você identificar o método que manipulará o evento. Para associar o evento com o manipulador de eventos, adicione uma instância do delegado ao evento. O manipulador de eventos é chamado sempre que o evento ocorre, a menos que você remova o representante. Para obter mais informações sobre delegados de manipulador de eventos, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 O exemplo de código a seguir cria um manipulador de eventos chamado `MyPeekCompleted`, anexa-o para o <xref:System.Messaging.MessageQueue.PeekCompleted> delegado manipulador de eventos e chamadas <xref:System.Messaging.MessageQueue.BeginPeek%2A> para iniciar uma operação de espiada assíncrona na fila que está localizada no caminho ". \myQueue". Quando um <xref:System.Messaging.MessageQueue.PeekCompleted> evento é gerado, o exemplo espia a mensagem e grava seu corpo para a tela. O exemplo, em seguida, chama <xref:System.Messaging.MessageQueue.BeginPeek%2A> novamente para iniciar uma nova operação de espiada assíncrona  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="public void Purge ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Purge() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Purge" />
      <MemberSignature Language="VB.NET" Value="Public Sub Purge ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Purge();" />
      <MemberSignature Language="F#" Value="member this.Purge : unit -&gt; unit" Usage="messageQueue.Purge " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Exclui todas as mensagens contidas na fila.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Limpar a fila faz com que o enfileiramento de mensagens definir o sinalizador de modificação da fila, que afeta o <xref:System.Messaging.MessageQueue.LastModifyTime%2A> propriedade. As mensagens que são limpos da fila são perdidas; eles não são enviados para a fila de inatividade ou a fila de diário.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.Purge%2A>.  
  
 [!code-cpp[MessageQueue2#29](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#29)]
 [!code-csharp[MessageQueue2#29](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="M:System.Messaging.MessageQueue.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="QueueName">
      <MemberSignature Language="C#" Value="public string QueueName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QueueName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.QueueName" />
      <MemberSignature Language="VB.NET" Value="Public Property QueueName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ QueueName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.QueueName : string with get, set" Usage="System.Messaging.MessageQueue.QueueName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_QueueName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o nome amigável que identifica a fila.</summary>
        <value>O nome que identifica a fila referenciada por essa <see cref="T:System.Messaging.MessageQueue" />. O valor não pode ser <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode combinar as <xref:System.Messaging.MessageQueue.QueueName%2A> com o <xref:System.Messaging.MessageQueue.MachineName%2A> para criar um amigável <xref:System.Messaging.MessageQueue.Path%2A> nome para a fila. A sintaxe para a variação de nome amigável do <xref:System.Messaging.MessageQueue.Path%2A> propriedade depende do tipo de fila, conforme mostrado na tabela a seguir.  
  
|Tipo de fila|Sintaxe|  
|----------------|------------|  
|Fila pública|`MachineName`\\`QueueName`|  
|Fila particular|`MachineName`\\`Private$`\\`QueueName`|  
|Fila de diário|`MachineName`\\`QueueName`\\`Journal$`|  
  
 Use "." para representar o computador local.  
  
 Alterando a <xref:System.Messaging.MessageQueue.QueueName%2A> propriedade afeta a <xref:System.Messaging.MessageQueue.Path%2A> propriedade. Se você definir a <xref:System.Messaging.MessageQueue.QueueName%2A> sem definir o <xref:System.Messaging.MessageQueue.MachineName%2A> propriedade, o <xref:System.Messaging.MessageQueue.Path%2A> propriedade torna-se.\\ `QueueName`. Caso contrário, o <xref:System.Messaging.MessageQueue.Path%2A> se torna `MachineName` \\ `QueueName`.  
  
 A tabela a seguir mostra se essa propriedade está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.QueueName%2A> propriedade.  
  
 [!code-csharp[MessageQueue#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O nome da fila é <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="ReadHandle">
      <MemberSignature Language="C#" Value="public IntPtr ReadHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ReadHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.ReadHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ReadHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadHandle : nativeint" Usage="System.Messaging.MessageQueue.ReadHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReadHandle")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o identificador nativo usado para ler as mensagens da fila de mensagens.</summary>
        <value>Um identificador para o objeto de fila nativo que você pode usar para inspecionar e receber mensagens da fila.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.MessageQueue.ReadHandle%2A> fornece um identificador nativo do Windows para o objeto de fila de mensagem que é usado para inspecionar e receber mensagens da fila. Se você alterar o caminho da fila, o identificador for fechado e reaberto com um novo valor.  
  
 A tabela a seguir mostra se essa propriedade está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <summary>Recebe a primeira mensagem na fila, removendo-a da fila.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive();" />
      <MemberSignature Language="F#" Value="member this.Receive : unit -&gt; System.Messaging.Message" Usage="messageQueue.Receive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recebe a primeira mensagem disponível na fila referenciada pela <see cref="T:System.Messaging.MessageQueue" />. Essa chamada é síncrona e bloqueia a execução do thread atual até que uma mensagem esteja disponível.</summary>
        <returns>Uma <see cref="T:System.Messaging.Message" /> que faz referência à primeira mensagem disponível na fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para receber uma mensagem de uma fila ou aguarde até que haja mensagens na fila.  
  
 O <xref:System.Messaging.MessageQueue.Receive%2A> método permite a leitura síncrona de uma mensagem, portanto, removê-la da fila. As chamadas subsequentes para <xref:System.Messaging.MessageQueue.Receive%2A> retornará as mensagens que seguem na fila ou novas e mensagens de alta prioridade.  
  
 Para ler a primeira mensagem em uma fila sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método. O <xref:System.Messaging.MessageQueue.Peek%2A> método sempre retorna a primeira mensagem na fila, portanto, as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila.  
  
 Usar uma chamada para <xref:System.Messaging.MessageQueue.Receive%2A> quando ele é aceitável para o thread atual a ser bloqueada enquanto aguarda uma mensagem chegar na fila. Porque essa sobrecarga da <xref:System.Messaging.MessageQueue.Receive%2A> método Especifica um tempo limite infinito, o aplicativo pode aguardar indefinidamente. Se o processamento do aplicativo deve continuar sem esperar que a mensagem, considere usar o método assíncrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir recebe uma mensagem de uma fila e produz informações sobre essa mensagem na tela.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">O objeto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Recebe a primeira mensagem disponível na fila transacional referenciada pelo <see cref="T:System.Messaging.MessageQueue" />. Essa chamada é síncrona e bloqueia a execução do thread atual até que uma mensagem esteja disponível.</summary>
        <returns>Uma <see cref="T:System.Messaging.Message" /> que faz referência à primeira mensagem disponível na fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para receber uma mensagem de uma fila transacional usando o contexto de transação interna definido pela `transaction` parâmetro ou aguarde até que há mensagens na fila.  
  
 O <xref:System.Messaging.MessageQueue.Receive%2A> método permite a leitura síncrona de uma mensagem, portanto, removê-la da fila. As chamadas subsequentes para <xref:System.Messaging.MessageQueue.Receive%2A> retornará as mensagens que seguem na fila.  
  
 Como esse método é chamado em uma fila transacional, a mensagem recebida seria retornada para a fila se a transação é anulada. A mensagem não é removida permanentemente da fila até que a transação é confirmada.  
  
 Para ler a primeira mensagem em uma fila sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método. O <xref:System.Messaging.MessageQueue.Peek%2A> método sempre retorna a primeira mensagem na fila, portanto, as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.Peek%2A>. Porque <xref:System.Messaging.MessageQueue.Peek%2A> não remove quaisquer mensagens na fila, não haveria nada para reverter por uma chamada para <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Usar uma chamada para <xref:System.Messaging.MessageQueue.Receive%2A> quando ele é aceitável para o thread atual a ser bloqueada enquanto aguarda uma mensagem chegar na fila. Porque essa sobrecarga da <xref:System.Messaging.MessageQueue.Receive%2A> método Especifica um tempo limite infinito, o aplicativo pode aguardar indefinidamente. Se o processamento do aplicativo deve continuar sem esperar que a mensagem, considere usar o método assíncrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir se conecta a uma fila transacional no computador local e envia uma mensagem à fila. Em seguida, ele recebe a mensagem que contém um pedido. Se ele encontrar uma fila não transacional, ele vai gerar e a exceção e a reversão da transação.  
  
 [!code-cpp[MessageQueue.Receive_transaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CPP/mqreceive_transaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_transaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CS/mqreceive_transaction.cs#1)]
 [!code-vb[MessageQueue.Receive_transaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_transaction/VB/mqreceive_transaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.  
  
- ou - 
A fila é não transacional.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">Um dos valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que descreve o tipo de contexto de transação associado à mensagem.</param>
        <summary>Recebe a primeira mensagem disponível na fila referenciada pela <see cref="T:System.Messaging.MessageQueue" />. Essa chamada é síncrona e bloqueia a execução do thread atual até que uma mensagem esteja disponível.</summary>
        <returns>Uma <see cref="T:System.Messaging.Message" /> que faz referência à primeira mensagem disponível na fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para receber uma mensagem de uma fila usando um contexto de transação definido pelo `transactionType` parâmetro ou aguarde até que há mensagens na fila.  
  
 Especificar `Automatic` para o `transactionType` parâmetro se já houver um contexto de transação externo anexada ao thread de que você deseja usar para receber a mensagem. Especificar `Single` se você quiser receber a mensagem como uma única transação interna. Você pode especificar `None` se você quiser receber uma mensagem de uma fila transacional fora de um contexto de transação.  
  
 O <xref:System.Messaging.MessageQueue.Receive%2A> método permite a leitura síncrona de uma mensagem, portanto, removê-la da fila. As chamadas subsequentes para <xref:System.Messaging.MessageQueue.Receive%2A> retornará as mensagens que seguem na fila.  
  
 Se esse método é chamado para receber uma mensagem de uma fila transacional, a mensagem recebida seria retornada para a fila se a transação é anulada. A mensagem não é removida permanentemente da fila até que a transação é confirmada.  
  
 Para ler a primeira mensagem em uma fila sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método. O <xref:System.Messaging.MessageQueue.Peek%2A> método sempre retorna a primeira mensagem na fila, portanto, as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.Peek%2A>. Porque <xref:System.Messaging.MessageQueue.Peek%2A> não remove quaisquer mensagens na fila, não haveria nada para reverter por uma chamada para <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Usar uma chamada para <xref:System.Messaging.MessageQueue.Receive%2A> quando ele é aceitável para o thread atual a ser bloqueada enquanto aguarda uma mensagem chegar na fila. Porque essa sobrecarga da <xref:System.Messaging.MessageQueue.Receive%2A> método Especifica um tempo limite infinito, o aplicativo pode aguardar indefinidamente. Se o processamento do aplicativo deve continuar sem esperar que a mensagem, considere usar o método assíncrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#9](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#9)]
 [!code-csharp[MessageQueue2#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">O parâmetro <paramref name="transactionType" /> não é um dos membros do <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Receive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo de espera até que uma nova mensagem esteja disponível para inspeção.</param>
        <summary>Recebe a primeira mensagem disponível na fila referenciada pelo <see cref="T:System.Messaging.MessageQueue" /> e aguarda até que uma mensagem esteja disponível na fila ou o tempo limite expire.</summary>
        <returns>Uma <see cref="T:System.Messaging.Message" /> que faz referência à primeira mensagem disponível na fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para receber uma mensagem e retorná-la em um período de tempo especificado se não houver mensagens na fila.  
  
 O <xref:System.Messaging.MessageQueue.Receive%2A> método permite a leitura síncrona de uma mensagem, a remoção da fila. As chamadas subsequentes para <xref:System.Messaging.MessageQueue.Receive%2A> retornará as mensagens que seguem na fila ou novas e mensagens de alta prioridade.  
  
 Para ler a primeira mensagem em uma fila sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método. O <xref:System.Messaging.MessageQueue.Peek%2A> método sempre retorna a primeira mensagem na fila, portanto, as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila.  
  
 Usar uma chamada para <xref:System.Messaging.MessageQueue.Receive%2A> quando ele é aceitável para o thread atual a ser bloqueada enquanto aguarda uma mensagem chegar na fila. O thread será bloqueado para o período de tempo ou indefinidamente se você tiver especificado o valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para o `timeout` parâmetro. Se o processamento do aplicativo deve continuar sem aguardar uma mensagem, considere usar o método assíncrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir recebe uma mensagem de uma fila e produz informações sobre essa mensagem na tela. O exemplo pausa a execução por até cinco segundos enquanto aguarda uma mensagem chegar na fila.  
  
 [!code-cpp[MessageQueue.Receive_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CPP/mqreceive_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Receive_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CS/mqreceive_timeout.cs#1)]
 [!code-vb[MessageQueue.Receive_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_timeout/VB/mqreceive_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido, possivelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Uma mensagem não chegou à fila antes do tempo limite expirar.  
  
- ou - 
Erro ao acessar um método do serviço de Enfileiramento de Mensagens</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo de espera até que uma nova mensagem esteja disponível para inspeção.</param>
        <param name="cursor">Um <see cref="T:System.Messaging.Cursor" /> que mantém uma posição específica na fila de mensagens.</param>
        <summary>Recebe a mensagem atual na fila usando um cursor especificado. Se nenhuma mensagem estiver disponível, esse método aguardará até uma mensagem ficar disponível ou o tempo limite expirar.</summary>
        <returns>Uma <see cref="T:System.Messaging.Message" /> que faz referência à primeira mensagem disponível na fila.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido, possivelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Uma mensagem não chegou à fila antes do tempo limite expirar.  
  
- ou - 
Erro ao acessar um método do serviço de Enfileiramento de Mensagens 
Use essa sobrecarga para receber uma mensagem e retorná-la em um período de tempo especificado se não houver mensagens na fila.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo de espera até que uma nova mensagem esteja disponível para inspeção.</param>
        <param name="transaction">O objeto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Recebe a primeira mensagem disponível na fila transacional referenciada pelo <see cref="T:System.Messaging.MessageQueue" /> e aguarda até que uma mensagem esteja disponível na fila ou o tempo limite expire.</summary>
        <returns>Uma <see cref="T:System.Messaging.Message" /> que faz referência à primeira mensagem disponível na fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para receber uma mensagem de uma fila transacional usando o contexto de transação interna definido pela `transaction` parâmetro e retorno em um período especificado de tempo se houver mensagens na fila.  
  
 O <xref:System.Messaging.MessageQueue.Receive%2A> método permite a leitura síncrona de uma mensagem, portanto, removê-la da fila. As chamadas subsequentes para <xref:System.Messaging.MessageQueue.Receive%2A> retornará as mensagens que seguem na fila.  
  
 Como esse método é chamado em uma fila transacional, a mensagem recebida seria retornada para a fila se a transação é anulada. A mensagem não é removida permanentemente da fila até que a transação é confirmada.  
  
 Para ler a primeira mensagem em uma fila sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método. O <xref:System.Messaging.MessageQueue.Peek%2A> método sempre retorna a primeira mensagem na fila, portanto, as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.Peek%2A>. Porque <xref:System.Messaging.MessageQueue.Peek%2A> não remove quaisquer mensagens na fila, não haveria nada para reverter por uma chamada para <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Usar uma chamada para <xref:System.Messaging.MessageQueue.Receive%2A> quando ele é aceitável para o thread atual a ser bloqueada enquanto aguarda uma mensagem chegar na fila. O thread será bloqueado para o período de tempo ou indefinidamente se você tiver especificado o valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para o `timeout` parâmetro. Se o processamento do aplicativo deve continuar sem aguardar uma mensagem, considere usar o método assíncrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso desse método.  
  
 [!code-cpp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CPP/mqreceive_timeouttransaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CS/mqreceive_timeouttransaction.cs#1)]
 [!code-vb[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/VB/mqreceive_timeouttransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido, possivelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Uma mensagem não chegou à fila antes do tempo limite expirar.  
  
- ou - 
A fila é não transacional.  
  
- ou - 
Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo de espera até que uma nova mensagem esteja disponível para inspeção.</param>
        <param name="transactionType">Um dos valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que descreve o tipo de contexto de transação associado à mensagem.</param>
        <summary>Recebe a primeira mensagem disponível na fila referenciada pela <see cref="T:System.Messaging.MessageQueue" />. Esta chamada é síncrona e aguarda até que uma mensagem esteja disponível na fila ou que o tempo limite expire.</summary>
        <returns>Uma <see cref="T:System.Messaging.Message" /> que faz referência à primeira mensagem disponível na fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para receber uma mensagem de uma fila usando um contexto de transação definido pelo `transactionType` parâmetro e retorno em um período especificado de tempo se houver mensagens na fila.  
  
 Especificar `Automatic` para o `transactionType` parâmetro se já houver um contexto de transação externo anexada ao thread de que você deseja usar para receber a mensagem. Especificar `Single` se você quiser receber a mensagem como uma única transação interna. Você pode especificar `None` se você quiser receber uma mensagem de uma fila transacional fora de um contexto de transação.  
  
 O <xref:System.Messaging.MessageQueue.Receive%2A> método permite a leitura síncrona de uma mensagem, portanto, removê-la da fila. As chamadas subsequentes para <xref:System.Messaging.MessageQueue.Receive%2A> retornará as mensagens que seguem na fila.  
  
 Se esse método é chamado para receber uma mensagem de uma fila transacional, a mensagem recebida seria retornada para a fila se a transação é anulada. A mensagem não é removida permanentemente da fila até que a transação é confirmada.  
  
 Para ler a primeira mensagem em uma fila sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método. O <xref:System.Messaging.MessageQueue.Peek%2A> método sempre retorna a primeira mensagem na fila, portanto, as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.Peek%2A>. Porque <xref:System.Messaging.MessageQueue.Peek%2A> não remove quaisquer mensagens na fila, não haveria nada para reverter por uma chamada para <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Usar uma chamada para <xref:System.Messaging.MessageQueue.Receive%2A> quando ele é aceitável para o thread atual a ser bloqueada enquanto aguarda uma mensagem chegar na fila. O thread será bloqueado para o período de tempo ou indefinidamente se você tiver especificado o valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para o `timeout` parâmetro. Se o processamento do aplicativo deve continuar sem aguardar uma mensagem, considere usar o método assíncrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso desse método.  
  
 [!code-cpp[MessageQueue2#8](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#8)]
 [!code-csharp[MessageQueue2#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido, possivelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">O parâmetro <paramref name="transactionType" /> não é um dos membros do <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Uma mensagem não chegou à fila antes do tempo limite expirar.  
  
- ou - 
Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo de espera até que uma nova mensagem esteja disponível para inspeção.</param>
        <param name="cursor">Um <see cref="T:System.Messaging.Cursor" /> que mantém uma posição específica na fila de mensagens.</param>
        <param name="transaction">O objeto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Recebe a mensagem atual na fila usando um cursor especificado. Se nenhuma mensagem estiver disponível, esse método aguardará até uma mensagem ficar disponível ou o tempo limite expirar.</summary>
        <returns>Um <see cref="T:System.Messaging.Message" /> que faz referência a uma mensagem na fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para receber uma mensagem de uma fila transacional usando o contexto de transação interna definido pela `transaction` parâmetro e retorno em um período especificado de tempo se houver mensagens na fila.  
  
 O <xref:System.Messaging.MessageQueue.Receive%2A> método permite a leitura síncrona de uma mensagem, portanto, removê-la da fila. As chamadas subsequentes para <xref:System.Messaging.MessageQueue.Receive%2A> retornam as mensagens que seguem na fila.  
  
 Como esse método é chamado em uma fila transacional, a mensagem recebida é retornada para a fila se a transação é anulada. A mensagem não é removida permanentemente da fila até que a transação é confirmada.  
  
 Para ler uma mensagem em uma fila sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.Peek%2A>. Porque <xref:System.Messaging.MessageQueue.Peek%2A> não remove quaisquer mensagens na fila, não há nada para reverter por uma chamada para <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Usar uma chamada para <xref:System.Messaging.MessageQueue.Receive%2A> quando ele é aceitável para o thread atual a ser bloqueada enquanto aguarda uma mensagem chegar na fila. O thread está bloqueado para o período de tempo ou indefinidamente se você tiver especificado o valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para o `timeout` parâmetro. Se o processamento do aplicativo deve continuar sem aguardar uma mensagem, considere usar o método assíncrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="cursor" /> é <see langword="null" />.  
  
- ou - 
O parâmetro <paramref name="transaction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> é inválido. Provavelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Uma mensagem não chegou à fila antes do tempo limite expirar.  
  
- ou - 
A fila é não transacional.  
  
- ou - 
Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo de espera até que uma nova mensagem esteja disponível para inspeção.</param>
        <param name="cursor">Um <see cref="T:System.Messaging.Cursor" /> que mantém uma posição específica na fila de mensagens.</param>
        <param name="transactionType">Um dos valores de <see cref="T:System.Messaging.MessageQueueTransactionType" /> que descreve o tipo de contexto de transação associado à mensagem.</param>
        <summary>Recebe a mensagem atual na fila usando um cursor especificado. Se nenhuma mensagem estiver disponível, esse método aguardará até uma mensagem ficar disponível ou o tempo limite expirar.</summary>
        <returns>Um <see cref="T:System.Messaging.Message" /> que faz referência a uma mensagem na fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para receber uma mensagem de uma fila usando um contexto de transação definido pelo `transactionType` parâmetro e retorno em um período especificado de tempo se houver mensagens na fila.  
  
 Especificar `Automatic` para o `transactionType` parâmetro se já houver um contexto de transação externo anexada ao thread de que você deseja usar para receber a mensagem. Especificar `Single` se você quiser receber a mensagem como uma única transação interna. Você pode especificar `None` se você quiser receber uma mensagem de uma fila transacional fora de um contexto de transação.  
  
 O <xref:System.Messaging.MessageQueue.Receive%2A> método permite a leitura síncrona de uma mensagem, portanto, removê-la da fila. As chamadas subsequentes para <xref:System.Messaging.MessageQueue.Receive%2A> retornam as mensagens que seguem na fila.  
  
 Se esse método é chamado para receber uma mensagem de uma fila transacional, a mensagem recebida será retornada para a fila se a transação é anulada. A mensagem não é removida permanentemente da fila até que a transação é confirmada.  
  
 Para ler uma mensagem em uma fila sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.Peek%2A>. Porque <xref:System.Messaging.MessageQueue.Peek%2A> não remove quaisquer mensagens na fila, não há nada para reverter por uma chamada para <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Usar uma chamada para <xref:System.Messaging.MessageQueue.Receive%2A> quando ele é aceitável para o thread atual a ser bloqueada enquanto aguarda uma mensagem chegar na fila. O thread está bloqueado para o período de tempo ou indefinidamente se você tiver especificado o valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para o `timeout` parâmetro. Se o processamento do aplicativo deve continuar sem aguardar uma mensagem, considere usar o método assíncrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="cursor" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> é inválido. Provavelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">O parâmetro <paramref name="transactionType" /> não é um dos membros do <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Uma mensagem não chegou à fila antes do tempo limite expirar.  
  
- ou - 
Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recebe uma mensagem que corresponde a um identificador de correlação determinado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">O <see cref="P:System.Messaging.Message.CorrelationId" /> da mensagem a ser recebida.</param>
        <summary>Recebe a mensagem que corresponde ao identificador de correlação fornecido (de uma fila não transacional) e gera uma exceção imediatamente se nenhuma mensagem com o identificador de correlação existir atualmente na fila.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja <see cref="P:System.Messaging.Message.CorrelationId" /> corresponde ao parâmetro <paramref name="correlationId" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método fica na fila não transacional referenciada pela <xref:System.Messaging.MessageQueue> para uma mensagem cuja <xref:System.Messaging.Message.CorrelationId%2A> corresponde à especificada `correlationId` parâmetro. Se nenhuma mensagem for encontrada que corresponda a `correlationID` parâmetro, uma exceção será lançada. Caso contrário, a mensagem é removida da fila e retornada ao aplicativo.  
  
 O <xref:System.Messaging.Message.CorrelationId%2A> propriedade é usada para vincular a uma mensagem enviada para a fila para mensagens de resposta, relatório ou confirmação associadas.  
  
 Dois outros métodos permitem que você receba mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> método recupera uma mensagem, especificando seu identificador exclusivo.  
  
 Para ler uma mensagem com um identificador de correlação especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método sempre retorna a primeira mensagem na fila, portanto, as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir envia e recebe uma mensagem que contém um pedido de e para uma fila. Ele solicita especificamente uma confirmação positiva quando a mensagem original atinge ou é recuperada da fila.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="correlationId" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível localizar a mensagem com o <paramref name="correlationId" /> especificado.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">O <see cref="P:System.Messaging.Message.CorrelationId" /> da mensagem a ser recebida.</param>
        <param name="transaction">O objeto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Recebe a mensagem que corresponde ao identificador de correlação fornecido (de uma fila transacional) e gera uma exceção imediatamente se nenhuma mensagem com o identificador de correlação existir atualmente na fila.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja <see cref="P:System.Messaging.Message.CorrelationId" /> corresponde ao parâmetro <paramref name="correlationId" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método fica na fila transacional referenciada pela <xref:System.Messaging.MessageQueue> para uma mensagem cuja <xref:System.Messaging.Message.CorrelationId%2A> corresponde à especificada `correlationId` parâmetro. Se nenhuma mensagem for encontrada que corresponda a `correlationID` parâmetro, uma exceção será lançada. Caso contrário, a mensagem é removida da fila e retornada ao aplicativo usando o contexto de transação interna definido pela `transaction` parâmetro.  
  
 Como esse método é chamado em uma fila transacional, a mensagem recebida seria retornada para a fila se a transação é anulada. A mensagem não é removida permanentemente da fila até que a transação é confirmada.  
  
 O <xref:System.Messaging.Message.CorrelationId%2A> propriedade é usada para vincular a uma mensagem enviada para a fila para mensagens de resposta, relatório ou confirmação associadas.  
  
 Dois outros métodos permitem que você receba mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> método é usado para recuperar uma mensagem, especificando seu identificador exclusivo.  
  
 Para ler uma mensagem com um identificador de correlação especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método sempre retorna a primeira mensagem na fila, portanto, as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Porque <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> não remove quaisquer mensagens na fila, não haveria nada a ser revertida se a transação foi anulada.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#14](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#14)]
 [!code-csharp[MessageQueue2#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="correlationId" /> é <see langword="null" />.  
  
- ou - 
O parâmetro <paramref name="transaction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível localizar a mensagem com o <paramref name="correlationId" /> especificado.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A fila é não transacional.  
  
- ou - 
Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">O <see cref="P:System.Messaging.Message.CorrelationId" /> da mensagem a ser recebida.</param>
        <param name="transactionType">Um dos valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que descreve o tipo de contexto de transação associado à mensagem.</param>
        <summary>Recebe a mensagem que corresponde ao identificador de correlação especificado e gerará imediatamente uma exceção se nenhuma mensagem com o identificador de correlação especificado existir atualmente na fila.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja <see cref="P:System.Messaging.Message.CorrelationId" /> corresponde ao parâmetro <paramref name="correlationId" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método fica na fila referenciada pela <xref:System.Messaging.MessageQueue> para uma mensagem cuja <xref:System.Messaging.Message.CorrelationId%2A> corresponde à especificada `correlationId` parâmetro. Se nenhuma mensagem for encontrada que corresponda a `correlationID` parâmetro, uma exceção será lançada. Caso contrário, a mensagem é removida da fila e retornada ao aplicativo usando um contexto de transação definido pelo `transactionType` parâmetro.  
  
 Especificar `Automatic` para o `transactionType` parâmetro se já houver um contexto de transação externo anexada ao thread de que você deseja usar para receber a mensagem. Especificar `Single` se você quiser receber a mensagem como uma única transação interna. Você pode especificar `None` se você quiser receber uma mensagem de uma fila transacional fora de um contexto de transação.  
  
 Se esse método é chamado para receber uma mensagem de uma fila transacional, a mensagem recebida seria retornada para a fila se a transação é anulada. A mensagem não é removida permanentemente da fila até que a transação é confirmada.  
  
 O <xref:System.Messaging.Message.CorrelationId%2A> propriedade é usada para vincular a uma mensagem enviada para a fila para mensagens de resposta, relatório ou confirmação associadas.  
  
 Dois outros métodos permitem que você receba mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> método é usado para recuperar uma mensagem, especificando seu identificador exclusivo.  
  
 Para ler uma mensagem com um identificador de correlação especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método sempre retorna a primeira mensagem na fila, portanto, as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Porque <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> não remove quaisquer mensagens na fila, não haveria nada a ser revertida se a transação foi anulada.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#11](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#11)]
 [!code-csharp[MessageQueue2#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="correlationId" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível localizar a mensagem com o <paramref name="correlationId" /> especificado.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">O parâmetro <paramref name="transactionType" /> não é um dos membros do <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">O <see cref="P:System.Messaging.Message.CorrelationId" /> da mensagem a ser recebida.</param>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo de espera até que uma nova mensagem esteja disponível para inspeção.</param>
        <summary>Recebe a mensagem que corresponde ao identificador de correlação fornecido (de uma fila não transacional) e aguarda até uma mensagem com o identificador de correlação especificado estar disponível na fila ou até o tempo limite expirar.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja <see cref="P:System.Messaging.Message.CorrelationId" /> corresponde ao parâmetro <paramref name="correlationId" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método fica na fila não transacional referenciada pela <xref:System.Messaging.MessageQueue> para uma mensagem cuja <xref:System.Messaging.Message.CorrelationId%2A> corresponde à especificada `correlationId` parâmetro. Esse método retorna imediatamente se a mensagem com o identificador de correlação especificado pelo `correlationId` parâmetro está na fila. Caso contrário, o método aguarda por determinado período de tempo para uma nova mensagem chegar. Se uma nova mensagem não chegou antes do tempo limite expirar, uma exceção é lançada.  
  
 O `timeout` parâmetro não especificar o total de tempo para esse método de execução. Em vez disso, ele especifica o tempo de espera por uma nova mensagem chegar na fila. Cada vez que uma nova mensagem chega, esse método examina os <xref:System.Messaging.Message.CorrelationId%2A> da nova mensagem para ver se ele corresponde a `correlationId` parâmetro. Caso contrário, esse método inicia o tempo limite ao longo e aguarda a outra nova mensagem chegue. Portanto, se novas mensagens continuam chegando dentro do período de tempo limite, é possível que esse método continuar em execução indefinidamente, até que o período de tempo limite expire sem quaisquer novas mensagens que chegam, ou até que uma mensagem chega cuja <xref:System.Messaging.Message.CorrelationId%2A> corresponde a `correlationId` parâmetro.  
  
 O <xref:System.Messaging.Message.CorrelationId%2A> propriedade é usada para vincular a uma mensagem enviada para a fila para mensagens de resposta, relatório ou confirmação associadas.  
  
 Dois outros métodos permitem que você receba mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> método é usado para recuperar uma mensagem, especificando seu identificador exclusivo.  
  
 Para ler uma mensagem com um identificador de correlação especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método sempre retorna a primeira mensagem na fila, portanto, as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#10](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#10)]
 [!code-csharp[MessageQueue2#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="correlationId" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido, possivelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A mensagem com o <paramref name="correlationId" /> especificado não existe na fila e não chegou antes do tempo limite expirar.  
  
- ou - 
Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">O <see cref="P:System.Messaging.Message.CorrelationId" /> da mensagem a ser recebida.</param>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo de espera até que uma nova mensagem esteja disponível para inspeção.</param>
        <param name="transaction">O objeto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Recebe a mensagem que corresponde ao identificador de correlação fornecido (de uma fila transacional) e aguarda até uma mensagem com o identificador de correlação especificado estar disponível na fila ou até o tempo limite expirar.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja <see cref="P:System.Messaging.Message.CorrelationId" /> corresponde ao parâmetro <paramref name="correlationId" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método fica na fila transacional referenciada pela <xref:System.Messaging.MessageQueue> para uma mensagem cuja <xref:System.Messaging.Message.CorrelationId%2A> corresponde à especificada `correlationId` parâmetro. Esse método retorna imediatamente se a mensagem com o identificador de correlação especificado pela `correlationId` parâmetro está na fila, usando o contexto de transação interna definido pela `transaction` parâmetro. Caso contrário, o método aguarda por determinado período de tempo para uma nova mensagem chegar. Se uma nova mensagem não chegou antes do tempo limite expirar, uma exceção é lançada.  
  
 O `timeout` parâmetro não especificar o total de tempo para esse método de execução. Em vez disso, ele especifica o tempo de espera por uma nova mensagem chegar na fila. Cada vez que uma nova mensagem chega, esse método examina os <xref:System.Messaging.Message.CorrelationId%2A> da nova mensagem para ver se ele corresponde a `correlationId` parâmetro. Caso contrário, esse método inicia o tempo limite ao longo e aguarda a outra nova mensagem chegue. Portanto, se novas mensagens continuam chegando dentro do período de tempo limite, é possível que esse método continuar em execução indefinidamente, até que o período de tempo limite expire sem quaisquer novas mensagens que chegam, ou até que uma mensagem chega cuja <xref:System.Messaging.Message.CorrelationId%2A> corresponde a `correlationId` parâmetro.  
  
 Como esse método é chamado em uma fila transacional, a mensagem recebida seria retornada para a fila se a transação é anulada. A mensagem não é removida permanentemente da fila até que a transação é confirmada.  
  
 O <xref:System.Messaging.Message.CorrelationId%2A> propriedade é usada para vincular a uma mensagem enviada para a fila para mensagens de resposta, relatório ou confirmação associadas.  
  
 Dois outros métodos permitem que você receba mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> método é usado para recuperar uma mensagem, especificando seu identificador exclusivo.  
  
 Para ler uma mensagem com um identificador de correlação especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método sempre retorna a primeira mensagem na fila, portanto, as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Porque <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> não remove quaisquer mensagens na fila, não haveria nada a ser revertida se a transação foi anulada.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#13](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#13)]
 [!code-csharp[MessageQueue2#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="correlationId" /> é <see langword="null" />.  
  
- ou - 
O parâmetro <paramref name="transaction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido, possivelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A mensagem com o <paramref name="correlationId" /> especificado não existe na fila e não chegou antes do tempo limite expirar.  
  
- ou - 
A fila é não transacional.  
  
- ou - 
Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">O <see cref="P:System.Messaging.Message.CorrelationId" /> da mensagem a ser recebida.</param>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo de espera até que uma nova mensagem esteja disponível para inspeção.</param>
        <param name="transactionType">Um dos valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que descreve o tipo de contexto de transação associado à mensagem.</param>
        <summary>Recebe a mensagem que corresponde ao identificador de correlação fornecido e aguarda até uma mensagem com o identificador de correlação especificado estar disponível na fila ou até o tempo limite expirar.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja <see cref="P:System.Messaging.Message.CorrelationId" /> corresponde ao parâmetro <paramref name="correlationId" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método fica na fila referenciada pela <xref:System.Messaging.MessageQueue> para uma mensagem cuja <xref:System.Messaging.Message.CorrelationId%2A> corresponde à especificada `correlationId` parâmetro. Esse método retorna imediatamente se a mensagem com o identificador de correlação especificado pela `correlationId` parâmetro está na fila usando um contexto de transação definido pelo `transactionType` parâmetro. Caso contrário, o método aguarda por determinado período de tempo para uma nova mensagem chegar. Se uma nova mensagem não chegou antes do tempo limite expirar, uma exceção é lançada.  
  
 O `timeout` parâmetro não especificar o total de tempo para esse método de execução. Em vez disso, ele especifica o tempo de espera por uma nova mensagem chegar na fila. Cada vez que uma nova mensagem chega, esse método examina os <xref:System.Messaging.Message.CorrelationId%2A> da nova mensagem para ver se ele corresponde a `correlationId` parâmetro. Caso contrário, esse método inicia o tempo limite ao longo e aguarda a outra nova mensagem chegue. Portanto, se novas mensagens continuam chegando dentro do período de tempo limite, é possível que esse método continuar em execução indefinidamente, até que o período de tempo limite expire sem quaisquer novas mensagens que chegam, ou até que uma mensagem chega cuja <xref:System.Messaging.Message.CorrelationId%2A> corresponde a `correlationId` parâmetro. Especificar `Automatic` para o `transactionType` parâmetro se já houver um contexto de transação externo anexada ao thread de que você deseja usar para receber a mensagem. Especificar `Single` se você quiser receber a mensagem como uma única transação interna. Você pode especificar `None` se você quiser receber uma mensagem de uma fila transacional fora de um contexto de transação.  
  
 Se esse método é chamado para receber uma mensagem de uma fila transacional, a mensagem recebida seria retornada para a fila se a transação é anulada. A mensagem não é removida permanentemente da fila até que a transação é confirmada.  
  
 O <xref:System.Messaging.Message.CorrelationId%2A> propriedade é usada para vincular a uma mensagem enviada para a fila para mensagens de resposta, relatório ou confirmação associadas.  
  
 Dois outros métodos permitem que você receba mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> método é usado para recuperar uma mensagem, especificando seu identificador exclusivo.  
  
 Para ler uma mensagem com um identificador de correlação especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método sempre retorna a primeira mensagem na fila, portanto, as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Porque <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> não remove quaisquer mensagens na fila, não haveria nada a ser revertida se a transação foi anulada.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#12](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#12)]
 [!code-csharp[MessageQueue2#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="correlationId" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível localizar a mensagem com o <paramref name="correlationId" /> especificado.</exception>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido, possivelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">O parâmetro <paramref name="transactionType" /> não é um dos membros do <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A mensagem com o <paramref name="correlationId" /> especificado não existe na fila e não chegou antes do tempo limite expirar.  
  
- ou - 
Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recebe a mensagem que corresponde ao identificador especificado, removendo-a da fila.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">O <see cref="P:System.Messaging.Message.Id" /> da mensagem a ser recebida.</param>
        <summary>Recebe a mensagem que corresponde ao identificador fornecido (de uma fila não transacional) e gera uma exceção imediatamente se nenhuma mensagem com o identificador existe atualmente na fila.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja propriedade <see cref="P:System.Messaging.Message.Id" /> corresponde ao parâmetro <paramref name="id" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador conhecido e removê-lo da fila. Esse método gera uma exceção imediatamente se a mensagem não está na fila.  
  
 O <xref:System.Messaging.Message.Id%2A> propriedade de uma mensagem é exclusiva em toda a empresa de enfileiramento de mensagens, portanto, haverá no máximo uma mensagem na fila que corresponde à determinado `id` parâmetro.  
  
 Dois outros métodos permitem que você receba mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> método é usado para recuperar uma confirmação, relatório ou mensagem de resposta gerados pelo aplicativo que foi criada como resultado de uma mensagem enviada para a fila.  
  
 Para ler uma mensagem com um identificador especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método sempre retorna a primeira mensagem na fila, portanto, as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#16](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#16)]
 [!code-csharp[MessageQueue2#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="id" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível localizar a mensagem com o <paramref name="id" /> especificado.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">O <see cref="P:System.Messaging.Message.Id" /> da mensagem a ser recebida.</param>
        <param name="transaction">O objeto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Recebe a mensagem que corresponde ao identificador fornecido (de uma fila transacional) e gera uma exceção imediatamente se nenhuma mensagem com o identificador existe atualmente na fila.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja propriedade <see cref="P:System.Messaging.Message.Id" /> corresponde ao parâmetro <paramref name="id" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador conhecido e removê-lo da fila, usando o contexto de transação interna definido pela `transaction` parâmetro. Esse método lançará uma exceção imediatamente se a mensagem não está na fila  
  
 O <xref:System.Messaging.Message.Id%2A> propriedade de uma mensagem é exclusiva em toda a empresa de enfileiramento de mensagens, portanto, haverá no máximo uma mensagem na fila que corresponde à determinado `id` parâmetro.  
  
 Como esse método é chamado em uma fila transacional, a mensagem recebida seria retornada para a fila se a transação é anulada. A mensagem não é removida permanentemente da fila até que a transação é confirmada.  
  
 Dois outros métodos permitem que você receba mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> método é usado para recuperar uma confirmação, relatório ou mensagem de resposta gerados pelo aplicativo que foi criada como resultado de uma mensagem enviada para a fila.  
  
 Para ler uma mensagem com um identificador especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método sempre retorna a primeira mensagem na fila, portanto, as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Porque <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> não remove quaisquer mensagens na fila, não haveria nada a ser revertida se a transação foi anulada.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#17](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#17)]
 [!code-csharp[MessageQueue2#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="id" /> é <see langword="null" />.  
  
- ou - 
O parâmetro <paramref name="transaction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível localizar a mensagem com o <paramref name="id" /> especificado.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A fila é não transacional.  
  
- ou - 
Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">O <see cref="P:System.Messaging.Message.Id" /> da mensagem a ser recebida.</param>
        <param name="transactionType">Um dos valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que descreve o tipo de contexto de transação associado à mensagem.</param>
        <summary>Recebe a mensagem que corresponde ao identificador especificado e gerará imediatamente uma exceção se nenhuma mensagem com o identificador especificado existir atualmente na fila.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja propriedade <see cref="P:System.Messaging.Message.Id" /> corresponde ao parâmetro <paramref name="id" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador conhecido e removê-lo da fila. Esse método gera uma exceção imediatamente se a mensagem não está na fila. Caso contrário, a mensagem é removida da fila e retornada ao aplicativo usando um contexto de transação definido pelo `transactionType` parâmetro.  
  
 Especificar `Automatic` para o `transactionType` parâmetro se já houver um contexto de transação externo anexada ao thread de que você deseja usar para receber a mensagem. Especificar `Single` se você quiser receber a mensagem como uma única transação interna. Você pode especificar `None` se você quiser receber uma mensagem de uma fila transacional fora de um contexto de transação.  
  
 O <xref:System.Messaging.Message.Id%2A> propriedade de uma mensagem é exclusiva em toda a empresa de enfileiramento de mensagens, portanto, haverá no máximo uma mensagem na fila que corresponde à determinado `id` parâmetro. Se a mensagem com o identificador especificado está em uma fila diferente daquele que está associado a este <xref:System.Messaging.MessageQueue> instância, não será possível encontrar a mensagem.  
  
 Se esse método é chamado para receber uma mensagem de uma fila transacional, a mensagem recebida seria retornada para a fila se a transação é anulada. A mensagem não é removida permanentemente da fila até que a transação é confirmada.  
  
 Dois outros métodos permitem que você receba mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> método é usado para recuperar uma confirmação, relatório ou mensagem de resposta gerados pelo aplicativo que foi criada como resultado de uma mensagem enviada para a fila.  
  
 Para ler uma mensagem com um identificador especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método sempre retorna a primeira mensagem na fila, portanto, as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Porque <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> não remove quaisquer mensagens na fila, não haveria nada a ser revertida se a transação foi anulada.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#15](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#15)]
 [!code-csharp[MessageQueue2#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="id" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível localizar a mensagem com o <paramref name="id" /> especificado.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">O parâmetro <paramref name="transactionType" /> não é um dos membros do <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">O <see cref="P:System.Messaging.Message.Id" /> da mensagem a ser recebida.</param>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo de espera até que uma nova mensagem esteja disponível para inspeção.</param>
        <summary>Recebe a mensagem que corresponde ao identificador fornecido (de uma fila não transacional) e aguarda até uma mensagem com o identificador estar disponível na fila ou tempo limite expirar.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja propriedade <see cref="P:System.Messaging.Message.Id" /> corresponde ao parâmetro <paramref name="id" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador conhecido e removê-lo da fila. Esse método retorna imediatamente se a mensagem com o identificador especificado pelo `id` parâmetro está na fila. Caso contrário, o método aguarda por determinado período de tempo para uma nova mensagem chegar. Se uma nova mensagem não chegou antes do tempo limite expirar, uma exceção é lançada.  
  
 O `timeout` parâmetro não especificar o total de tempo para esse método de execução. Em vez disso, ele especifica o tempo de espera por uma nova mensagem chegar na fila. Cada vez que uma nova mensagem chega, esse método examina os <xref:System.Messaging.Message.Id%2A> da nova mensagem para ver se ele corresponde a `id` parâmetro. Caso contrário, esse método inicia o tempo limite ao longo e aguarda a outra nova mensagem chegue. Portanto, se novas mensagens continuam chegando dentro do período de tempo limite, é possível que esse método continuar em execução indefinidamente, até que o período de tempo limite expire sem quaisquer novas mensagens que chegam, ou até que uma mensagem chega cuja <xref:System.Messaging.Message.Id%2A> corresponde a `id` parâmetro.  
  
 O <xref:System.Messaging.Message.Id%2A> propriedade de uma mensagem é exclusiva em toda a empresa de enfileiramento de mensagens, portanto, haverá no máximo uma mensagem na fila que corresponde à determinado `id` parâmetro.  
  
 Use essa sobrecarga de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> quando ele é aceitável para o thread atual a ser bloqueada enquanto novas mensagens continuam chegando na fila de dentro do período de tempo limite especificado pelo `timeout` parâmetro. O thread será bloqueado pelo menos o determinado período de tempo ou indefinidamente se você tiver especificado o valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para o `timeout` parâmetro, ou se novas mensagens continuam chegando na fila de dentro do período de tempo limite especificado pelo `timeout` parâmetro.  
  
 Dois outros métodos permitem que você receba mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> método é usado para recuperar uma confirmação, relatório ou mensagem de resposta gerados pelo aplicativo que foi criada como resultado de uma mensagem enviada para a fila.  
  
 Para ler uma mensagem com um identificador especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método sempre retorna a primeira mensagem na fila, portanto, as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#20](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#20)]
 [!code-csharp[MessageQueue2#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="id" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido, possivelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Uma mensagem com o <paramref name="id" /> especificado não chegou à fila antes do tempo limite expirar.  
  
- ou - 
Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">O <see cref="P:System.Messaging.Message.Id" /> da mensagem a ser recebida.</param>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo de espera até que uma nova mensagem esteja disponível para inspeção.</param>
        <param name="transaction">O objeto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Recebe a mensagem que corresponde ao identificador fornecido (de uma fila transacional) e aguarda até uma mensagem com o identificador estar disponível na fila ou tempo limite expirar.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja propriedade <see cref="P:System.Messaging.Message.Id" /> corresponde ao parâmetro <paramref name="id" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador conhecido e removê-lo da fila, usando o contexto de transação interna definido pela `transaction` parâmetro. Esse método retorna imediatamente se a mensagem com o identificador especificado pelo `id` parâmetro está na fila. Caso contrário, o método aguarda por determinado período de tempo para uma nova mensagem chegar. Se uma nova mensagem não chegou antes do tempo limite expirar, uma exceção é lançada.  
  
 O `timeout` parâmetro não especificar o total de tempo para esse método de execução. Em vez disso, ele especifica o tempo de espera por uma nova mensagem chegar na fila. Cada vez que uma nova mensagem chega, esse método examina os <xref:System.Messaging.Message.Id%2A> da nova mensagem para ver se ele corresponde a `id` parâmetro. Caso contrário, esse método inicia o tempo limite ao longo e aguarda a outra nova mensagem chegue. Portanto, se novas mensagens continuam chegando dentro do período de tempo limite, é possível que esse método continuar em execução indefinidamente, até que o período de tempo limite expire sem quaisquer novas mensagens que chegam, ou até que uma mensagem chega cuja <xref:System.Messaging.Message.Id%2A> corresponde a `id` parâmetro.  
  
 O <xref:System.Messaging.Message.Id%2A> propriedade de uma mensagem é exclusiva em toda a empresa de enfileiramento de mensagens, portanto, haverá no máximo uma mensagem na fila que corresponde à determinado `id` parâmetro.  
  
 Use essa sobrecarga de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> quando ele é aceitável para o thread atual a ser bloqueada enquanto novas mensagens continuam chegando na fila de dentro do período de tempo limite especificado pelo `timeout` parâmetro. O thread será bloqueado pelo menos o determinado período de tempo ou indefinidamente se você tiver especificado o valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para o `timeout` parâmetro, ou se novas mensagens continuam chegando na fila de dentro do período de tempo limite especificado pelo `timeout` parâmetro.  
  
 Como esse método é chamado em uma fila transacional, a mensagem recebida seria retornada para a fila se a transação é anulada. A mensagem não é removida permanentemente da fila até que a transação é confirmada.  
  
 Dois outros métodos permitem que você receba mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> método é usado para recuperar uma confirmação, relatório ou mensagem de resposta gerados pelo aplicativo que foi criada como resultado de uma mensagem enviada para a fila.  
  
 Para ler uma mensagem com um identificador especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método sempre retorna a primeira mensagem na fila, portanto, as chamadas subsequentes para o método retornarão a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Porque <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> não remove quaisquer mensagens na fila, não haveria nada a ser revertida se a transação foi anulada.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#18](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#18)]
 [!code-csharp[MessageQueue2#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="id" /> é <see langword="null" />.  
  
- ou - 
O parâmetro <paramref name="transaction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido, possivelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Uma mensagem com o <paramref name="id" /> especificado não chegou à fila antes do tempo limite expirar.  
  
- ou - 
A fila é não transacional.  
  
- ou - 
Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">O <see cref="P:System.Messaging.Message.Id" /> da mensagem a ser recebida.</param>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo de espera até que uma nova mensagem esteja disponível para inspeção.</param>
        <param name="transactionType">Um dos valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que descreve o tipo de contexto de transação associado à mensagem.</param>
        <summary>Recebe a mensagem que corresponde ao identificador fornecido e aguarda até uma mensagem com o identificador estar disponível na fila ou tempo limite expirar.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja propriedade <see cref="P:System.Messaging.Message.Id" /> corresponde ao parâmetro <paramref name="id" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador conhecido e removê-lo da fila. Esse método retorna imediatamente se a mensagem com o identificador especificado o `id` parâmetro está na fila usando um contexto de transação definido pelo `transactionType` parâmetro. Caso contrário, o método aguarda por determinado período de tempo para uma nova mensagem chegar. Se uma nova mensagem não chegou antes do tempo limite expirar, uma exceção é lançada.  
  
 O `timeout` parâmetro não especificar o total de tempo para esse método de execução. Em vez disso, ele especifica o tempo de espera por uma nova mensagem chegar na fila. Cada vez que uma nova mensagem chega, esse método examina os <xref:System.Messaging.Message.Id%2A> da nova mensagem para ver se ele corresponde a `id` parâmetro. Caso contrário, esse método inicia o tempo limite ao longo e aguarda a outra nova mensagem chegue. Portanto, se novas mensagens continuam chegando dentro do período de tempo limite, é possível que esse método continuar em execução indefinidamente, até que o período de tempo limite expire sem quaisquer novas mensagens que chegam, ou até que uma mensagem chega cuja <xref:System.Messaging.Message.Id%2A> corresponde a `id` parâmetro.  
  
 Especificar `Automatic` para o `transactionType` parâmetro se já houver um contexto de transação externo anexada ao thread de que você deseja usar para receber a mensagem. Especificar `Single` se você quiser receber a mensagem como uma única transação interna. Você pode especificar `None` se você quiser receber uma mensagem de uma fila transacional fora de um contexto de transação.  
  
 O <xref:System.Messaging.Message.Id%2A> propriedade de uma mensagem é exclusiva em toda a empresa de enfileiramento de mensagens, portanto, haverá no máximo uma mensagem na fila que corresponde à determinado `id` parâmetro. Se a mensagem com o identificador especificado está em uma fila diferente daquele que está associado a este <xref:System.Messaging.MessageQueue> instância, não será possível encontrar a mensagem.  
  
 Use essa sobrecarga de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> quando ele é aceitável para o thread atual a ser bloqueada enquanto novas mensagens continuam chegando na fila de dentro do período de tempo limite especificado pelo `timeout` parâmetro. O thread será bloqueado pelo menos o determinado período de tempo ou indefinidamente se você tiver especificado o valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para o `timeout` parâmetro, ou se novas mensagens continuam chegando na fila de dentro do período de tempo limite especificado pelo `timeout` parâmetro.  
  
 Se esse método é chamado para receber uma mensagem de uma fila transacional, a mensagem recebida seria retornada para a fila se a transação é anulada. A mensagem não é removida permanentemente da fila até que a transação é confirmada.  
  
 Dois outros métodos permitem que você receba mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> método é usado para recuperar uma confirmação, relatório ou mensagem de resposta gerados pelo aplicativo que foi criada como resultado de uma mensagem enviada para a fila.  
  
 Para ler uma mensagem com um identificador especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método sempre retorna a primeira mensagem na fila, portanto, as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Porque <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> não remove quaisquer mensagens na fila, não haveria nada a ser revertida se a transação foi anulada.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#19](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#19)]
 [!code-csharp[MessageQueue2#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="id" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido, possivelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Uma mensagem com o <paramref name="id" /> especificado não chegou à fila antes do tempo limite expirar.  
  
- ou - 
Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">O parâmetro <paramref name="transactionType" /> não é um dos membros do <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Introduzido no MSMQ 3.0. Recebe uma mensagem específica da fila. A mensagem pode ser especificada por um identificador de pesquisa ou pela sua posição no início ou no final da fila.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">O <see cref="P:System.Messaging.Message.LookupId" /> da mensagem a ser recebida.</param>
        <summary>Introduzido no MSMQ 3.0. Recebe a mensagem que corresponde ao identificador de pesquisa especificado de uma fila não transacional.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja propriedade <see cref="P:System.Messaging.Message.LookupId" /> corresponde ao parâmetro <paramref name="lookupId" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador de pesquisa conhecidos e removê-lo da fila. Esse método gera uma exceção imediatamente se a mensagem não está na fila.  
  
 O <xref:System.Messaging.Message.LookupId%2A> propriedade de uma mensagem é exclusiva para a fila onde reside a mensagem, portanto, haverá no máximo uma mensagem na fila que corresponde à determinado `lookupId` parâmetro.  
  
 Para ler uma mensagem com um identificador de pesquisa especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> método.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">O MSMQ 3.0 não está instalado.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível localizar a mensagem com o <paramref name="lookupId" /> especificado.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="action">Um dos valores <see cref="T:System.Messaging.MessageLookupAction" />, especificando como a mensagem é lida na fila. Especifique um dos seguintes: 
 <see langword="MessageLookupAction.Current" />: recebe a mensagem especificada pela <c>lookupId</c> e a remove da fila.  
  
 <see langword="MessageLookupAction.Next" />: recebe a mensagem seguinte à mensagem especificada pela <c>lookupId</c> e a remove da fila.  
  
 <see langword="MessageLookupAction.Previous" />: recebe a mensagem anterior a mensagem especificada pela <c>lookupId</c> e a remove da fila.  
  
 <see langword="MessageLookupAction.First" />: recebe a primeira mensagem na fila e a remove da fila. O parâmetro <c>lookupId</c> deve ser definido como 0.  
  
 <see langword="MessageLookupAction.Last" />: recebe a última mensagem na fila e a remove da fila. O parâmetro <c>lookupId</c> deve ser definido como 0.</param>
        <param name="lookupId">O <see cref="P:System.Messaging.Message.LookupId" /> da mensagem a receber, ou 0. 0 é usado para acessar a primeira ou a última mensagem na fila.</param>
        <param name="transaction">O objeto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Introduzido no MSMQ 3.0. Recebe uma mensagem específica de uma fila transacional. A mensagem pode ser especificada por um identificador de pesquisa ou pela sua posição no início ou no final da fila.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> especificado pelos parâmetros <paramref name="lookupId" /> e <paramref name="action" /> passados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador de pesquisa conhecidos e a removerá da fila usando um contexto de transação definido pelo `transaction` parâmetro. Esse método gera uma exceção imediatamente se a mensagem não está na fila.  
  
 O <xref:System.Messaging.Message.LookupId%2A> propriedade de uma mensagem é exclusiva para a fila onde reside a mensagem, portanto, haverá no máximo uma mensagem na fila que corresponde à determinado `lookupId` parâmetro.  
  
 Como esse método é chamado em uma fila transacional, a mensagem recebida seria retornada para a fila se a transação é anulada. A mensagem não é removida permanentemente da fila até que a transação é confirmada.  
  
 Para ler uma mensagem com um identificador especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> método. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Porque <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> não remove quaisquer mensagens da fila, não haveria nada a ser revertida se a transação foi anulada.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">O MSMQ 3.0 não está instalado.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível localizar a mensagem com o <paramref name="lookupId" /> especificado.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.  
  
- ou - 
A fila é não transacional.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">O parâmetro <paramref name="action" /> não é um dos membros do <see cref="T:System.Messaging.MessageLookupAction" />.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="action">Um dos valores <see cref="T:System.Messaging.MessageLookupAction" />, especificando como a mensagem é lida na fila. Especifique um dos seguintes: 
 <see langword="MessageLookupAction.Current" />: recebe a mensagem especificada pela <c>lookupId</c> e a remove da fila.  
  
 <see langword="MessageLookupAction.Next" />: recebe a mensagem seguinte à mensagem especificada pela <c>lookupId</c> e a remove da fila.  
  
 <see langword="MessageLookupAction.Previous" />: recebe a mensagem anterior a mensagem especificada pela <c>lookupId</c> e a remove da fila.  
  
 <see langword="MessageLookupAction.First" />: recebe a primeira mensagem na fila e a remove da fila. O parâmetro <c>lookupId</c> deve ser definido como 0.  
  
 <see langword="MessageLookupAction.Last" />: recebe a última mensagem na fila e a remove da fila. O parâmetro <c>lookupId</c> deve ser definido como 0.</param>
        <param name="lookupId">O <see cref="P:System.Messaging.Message.LookupId" /> da mensagem a receber, ou 0. 0 é usado para acessar a primeira ou a última mensagem na fila.</param>
        <param name="transactionType">Um dos valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que descreve o tipo de contexto de transação associado à mensagem.</param>
        <summary>Introduzido no MSMQ 3.0. Recebe uma mensagem específica da fila, usando o contexto de transação especificado. A mensagem pode ser especificada por um identificador de pesquisa ou pela sua posição no início ou no final da fila.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> especificado pelos parâmetros <paramref name="action" /> e <paramref name="lookupId" /> passados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador de pesquisa conhecidos e a removerá da fila usando um contexto de transação definido pelo `transactionType` parâmetro. Esse método gera uma exceção imediatamente se a mensagem não está na fila.  
  
 O <xref:System.Messaging.Message.LookupId%2A> propriedade de uma mensagem é exclusiva para a fila onde reside a mensagem, portanto, haverá no máximo uma mensagem na fila que corresponde à determinado `lookupId` parâmetro.  
  
 Para ler uma mensagem com um identificador especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> método. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Porque <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> não remove quaisquer mensagens da fila, não haveria nada a ser revertida se a transação foi anulada.  
  
 Especificar `Automatic` para o `transactionType` parâmetro se já houver um contexto de transação externo anexada ao thread de que você deseja usar para receber a mensagem. Especificar `Single` se você quiser receber a mensagem como uma única transação interna. Você pode especificar `None` se você quiser receber uma mensagem de uma fila transacional fora de um contexto de transação.  
  
 Se esse método é chamado para receber uma mensagem de uma fila transacional, a mensagem recebida seria retornada para a fila se a transação é anulada. A mensagem não é removida permanentemente da fila até que a transação é confirmada.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">O MSMQ 3.0 não está instalado.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível localizar a mensagem com o <paramref name="lookupId" /> especificado.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">O parâmetro <paramref name="action" /> não é um dos membros do <see cref="T:System.Messaging.MessageLookupAction" />.  
  
- ou - 
O parâmetro <paramref name="transactionType" /> não é um dos membros do <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReceiveCompleted As ReceiveCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::ReceiveCompletedEventHandler ^ ReceiveCompleted;" />
      <MemberSignature Language="F#" Value="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " Usage="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReceiveCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.ReceiveCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando uma mensagem foi removida da fila. Esse evento é gerado pela operação assíncrona, <see cref="M:System.Messaging.MessageQueue.BeginReceive" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> é usada no processamento assíncrono para gerar o <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento quando uma mensagem esteja disponível na fila.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> é usado para concluir a operação iniciada por uma chamada para <xref:System.Messaging.MessageQueue.BeginReceive%2A> e inspecionar a mensagem quando o <xref:System.Messaging.MessageQueue.ReceiveCompleted> é gerado.  
  
 Quando você cria um <xref:System.Messaging.ReceiveCompletedEventHandler> delegado, você identificar o método que manipulará o evento. Para associar o evento com o manipulador de eventos, adicione uma instância do delegado ao evento. O manipulador de eventos é chamado sempre que o evento ocorre, a menos que você remova o representante. Para obter mais informações sobre delegados de manipulador de eventos, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 O exemplo de código a seguir cria um manipulador de eventos chamado `MyReceiveCompleted`, anexa-o para o <xref:System.Messaging.MessageQueue.ReceiveCompleted> delegado manipulador de eventos e chamadas <xref:System.Messaging.MessageQueue.BeginReceive%2A> para iniciar uma operação de recebimento assíncrona na fila que está localizada no caminho ". \myQueue". Quando um <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento é gerado, o exemplo recebe a mensagem e grava seu corpo para a tela. O exemplo, em seguida, chama <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente para iniciar um novo assíncrona operação de recebimento.  
  
 [!code-cpp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CPP/mqreceivecompletedeventhandler.cpp#1)]
 [!code-csharp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CS/mqreceivecompletedeventhandler.cs#1)]
 [!code-vb[MessageQueue.ReceiveCompleted#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/VB/mqreceivecompletedeventhandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="messageQueue.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Atualiza as propriedades apresentadas pelo <see cref="T:System.Messaging.MessageQueue" /> para refletir o estado atual do recurso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Refresh%2A> sincroniza as propriedades de um <xref:System.Messaging.MessageQueue> com seu recurso de servidor de enfileiramento de mensagens associado. Se qualquer propriedade, tal como <xref:System.Messaging.MessageQueue.Label%2A> ou <xref:System.Messaging.MessageQueue.Category%2A>, foi alterado no servidor desde a hora a <xref:System.Messaging.MessageQueue> foi criado, <xref:System.Messaging.MessageQueue.Refresh%2A> atualizações o <xref:System.Messaging.MessageQueue> com as novas informações.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.Refresh%2A>.  
  
 [!code-cpp[MessageQueue2#28](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#28)]
 [!code-csharp[MessageQueue2#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ResetPermissions">
      <MemberSignature Language="C#" Value="public void ResetPermissions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetPermissions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ResetPermissions" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetPermissions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetPermissions();" />
      <MemberSignature Language="F#" Value="member this.ResetPermissions : unit -&gt; unit" Usage="messageQueue.ResetPermissions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Redefine a lista de permissões para os valores padrão do sistema operacional. Remove quaisquer permissões de fila que você tenha anexado à lista padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você chama <xref:System.Messaging.MessageQueue.ResetPermissions%2A>, retornar a lista de permissões para seus valores padrão. Em geral, isso concede o criador de fila todas as permissões e apresenta ao grupo todos os seguintes direitos:  
  
-   Obtenha as propriedades da fila.  
  
-   Obtenha as permissões da fila.  
  
-   Grave na fila.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ResetPermissions%2A>.  
  
 [!code-cpp[MessageQueue2#27](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#27)]
 [!code-csharp[MessageQueue2#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Envia um objeto para uma fila.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Send : obj -&gt; unit" Usage="messageQueue.Send obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto a ser enviado à fila.</param>
        <summary>Envia um objeto a uma fila não transacional referenciada por essa <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para enviar uma mensagem que contém o `obj` parâmetro para a fila referenciada pelo <xref:System.Messaging.MessageQueue>. O objeto que você envia para a fila pode ser um <xref:System.Messaging.Message> ou qualquer objeto gerenciado. Se você enviar qualquer objeto diferente de um <xref:System.Messaging.Message>, o objeto é serializado e inserido no corpo da mensagem.  
  
 Se você usar essa sobrecarga para enviar uma mensagem para uma fila transacional, a mensagem será enviada para a fila de inatividade. Se você quiser que a mensagem seja parte de uma transação que contém outras mensagens, use uma sobrecarga que utiliza um <xref:System.Messaging.MessageQueueTransaction> ou <xref:System.Messaging.MessageQueueTransactionType> como um parâmetro.  
  
 Se você não definir a <xref:System.Messaging.MessageQueue.Formatter%2A> propriedade antes de chamar <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, o formatador assume como padrão o <xref:System.Messaging.XmlMessageFormatter>.  
  
 O <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriedade se aplica a qualquer objeto diferente de um <xref:System.Messaging.Message>. Se você especificar, por exemplo, um rótulo ou uma prioridade usando o <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membro, esses valores se aplicam a qualquer mensagem que contém um objeto que não é do tipo <xref:System.Messaging.Message> quando o seu aplicativo a envia para a fila. Ao enviar uma <xref:System.Messaging.Message>, os valores de propriedade definidos para o <xref:System.Messaging.Message> têm precedência sobre <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> e a mensagem <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propriedade tem precedência sobre a fila <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propriedade.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir se conecta a uma fila de mensagens e envia uma mensagem à fila.  
  
 [!code-cpp[MessageQueue.Send_obj#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_obj/CPP/mqsend_generic.cpp#1)]
 [!code-csharp[MessageQueue.Send_obj#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_obj/CS/mqsend_generic.cs#1)]
 [!code-vb[MessageQueue.Send_obj#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_obj/VB/mqsend_generic.vb#1)]  
  
 O exemplo de código a seguir envia um aplicativo definido `Order` de classe para uma fila e, em seguida, recebe uma mensagem da fila.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">A propriedade <see cref="P:System.Messaging.MessageQueue.Path" /> não foi definida.  
  
- ou - 
Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto a ser enviado à fila.</param>
        <param name="transaction">O objeto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Envia um objeto para a fila transacional referenciada por este <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para enviar uma mensagem que contém o `obj` parâmetro para a fila transacional referenciada pela <xref:System.Messaging.MessageQueue>, usando um contexto de transação interna definido pela `transaction` parâmetro. O objeto que você envia para a fila pode ser um <xref:System.Messaging.Message> ou qualquer objeto gerenciado. Se você enviar qualquer objeto diferente de um <xref:System.Messaging.Message>, o objeto é serializado e inserido no corpo da mensagem.  
  
 Se você usar essa sobrecarga para enviar uma mensagem para uma fila não transacional, a mensagem pode ser enviada para a fila de inatividade sem lançar uma exceção.  
  
 Se você não definir a <xref:System.Messaging.MessageQueue.Formatter%2A> propriedade antes de chamar <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, o formatador assume como padrão o <xref:System.Messaging.XmlMessageFormatter>.  
  
 O <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriedade se aplica a qualquer objeto diferente de um <xref:System.Messaging.Message>. Se você especificar, por exemplo, um rótulo ou uma prioridade usando o <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membro, esses valores se aplicam a qualquer mensagem que contém um objeto que não é do tipo <xref:System.Messaging.Message> quando o seu aplicativo a envia para a fila. Ao enviar uma <xref:System.Messaging.Message>, os valores de propriedade definidos para o <xref:System.Messaging.Message> têm precedência sobre <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> e a mensagem <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propriedade tem precedência sobre a fila <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propriedade.  
  
 <xref:System.Messaging.MessageQueueTransaction> é threading apartment ciente, portanto, se seu estado de apartment é `STA`, é possível usar a transação em vários threads. Visual Basic define o estado do thread principal para `STA`, portanto, você deve aplicar a <xref:System.MTAThreadAttribute> no `Main` sub-rotina. Caso contrário, o envio de uma mensagem transacional usando outro thread gerará uma exceção <xref:System.Messaging.MessageQueueException>. Aplicar o <xref:System.MTAThreadAttribute> usando o fragmento a seguir.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir envia uma cadeia de caracteres para uma fila transacional e, em seguida, recebe uma mensagem da fila.  
  
 [!code-cpp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CPP/mqsend_objtransaction.cpp#1)]
 [!code-csharp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CS/mqsend_objtransaction.cs#1)]
 [!code-vb[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/VB/mqsend_objtransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="transaction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A propriedade <see cref="P:System.Messaging.MessageQueue.Path" /> não foi definida.  
  
- ou - 
O aplicativo do serviço de enfileiramento de mensagens indicou um uso incorreto de transações.  
  
- ou - 
Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto a ser enviado à fila.</param>
        <param name="transactionType">Um dos valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que descreve o tipo de contexto de transação associado à mensagem.</param>
        <summary>Envia um objeto para a fila referenciada por esse <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para enviar uma mensagem que contém o `obj` parâmetro para a fila referenciada pela <xref:System.Messaging.MessageQueue>, usando um contexto de transação definido pelo `transactionType` parâmetro. Especificar `Automatic` para o `transactionType` parâmetro se já houver um contexto de transação externo anexada ao thread de que você deseja usar para enviar a mensagem. Especificar `Single` se você quiser enviar a mensagem como uma única transação interna. Você pode especificar `None` se você quiser enviar uma mensagem transacional para um thread não-transacional.  
  
 O objeto que você envia para a fila pode ser um <xref:System.Messaging.Message> ou qualquer objeto gerenciado. Se você enviar qualquer objeto diferente de um <xref:System.Messaging.Message>, o objeto é serializado e inserido no corpo da mensagem.  
  
 Se você não definir a <xref:System.Messaging.MessageQueue.Formatter%2A> propriedade antes de chamar <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, o formatador assume como padrão o <xref:System.Messaging.XmlMessageFormatter>.  
  
 O <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriedade se aplica a qualquer objeto diferente de um <xref:System.Messaging.Message>. Se você especificar, por exemplo, um rótulo ou uma prioridade usando o <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membro, esses valores se aplicam a qualquer mensagem que contém um objeto que não é do tipo <xref:System.Messaging.Message> quando o seu aplicativo a envia para a fila. Ao enviar uma <xref:System.Messaging.Message>, os valores de propriedade definidos para o <xref:System.Messaging.Message> têm precedência sobre <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> e a mensagem <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propriedade tem precedência sobre a fila <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propriedade.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#2)]
 [!code-csharp[MessageQueue2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">O parâmetro <paramref name="transactionType" /> não é um dos membros do <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A propriedade <see cref="P:System.Messaging.MessageQueue.Path" /> não foi definida.  
  
- ou - 
Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string -&gt; unit" Usage="messageQueue.Send (obj, label)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto a ser enviado à fila.</param>
        <param name="label">O rótulo da mensagem.</param>
        <summary>Envia um objeto para a fila não transacional referenciada por este <see cref="T:System.Messaging.MessageQueue" /> e especifica um rótulo para a mensagem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para enviar uma mensagem que contém o `obj` parâmetro para a fila referenciada pelo <xref:System.Messaging.MessageQueue>. Com essa sobrecarga, você pode especificar o rótulo de cadeia de caracteres que identifica a mensagem. O objeto que você envia para a fila pode ser um <xref:System.Messaging.Message>, uma estrutura, um objeto de dados ou qualquer objeto gerenciado. Se você enviar qualquer objeto diferente de um <xref:System.Messaging.Message>, o objeto é serializado e inserido no corpo da mensagem.  
  
 O rótulo da mensagem é diferente do rótulo da fila de mensagem, mas ambos são dependentes do aplicativo e não têm significado para enfileiramento de mensagens de herdar.  
  
 Se você usar essa sobrecarga para enviar uma mensagem para uma fila transacional, a mensagem será enviada para a fila de inatividade. Se você quiser que a mensagem seja parte de uma transação que contém outras mensagens, use uma sobrecarga que utiliza um <xref:System.Messaging.MessageQueueTransaction> ou <xref:System.Messaging.MessageQueueTransactionType> como um parâmetro.  
  
 O <xref:System.Messaging.MessageQueue.Path%2A> propriedade para este <xref:System.Messaging.MessageQueue> instância deve ser especificada antes de enviar a mensagem. Se você não definir a <xref:System.Messaging.MessageQueue.Formatter%2A> propriedade antes de chamar <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, o formatador assume como padrão o <xref:System.Messaging.XmlMessageFormatter>.  
  
 O <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriedade se aplica a qualquer objeto diferente de um <xref:System.Messaging.Message>. Se você especificar, por exemplo, um rótulo ou uma prioridade usando o <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membro, esses valores se aplicam a qualquer mensagem que contém um objeto que não é do tipo <xref:System.Messaging.Message> quando o seu aplicativo a envia para a fila. Ao enviar uma <xref:System.Messaging.Message>, os valores de propriedade definidos para o <xref:System.Messaging.Message> têm precedência sobre <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> e a mensagem <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propriedade tem precedência sobre a fila <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propriedade.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29>.  
  
 [!code-cpp[MessageQueue2#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue2#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="label" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A propriedade <see cref="P:System.Messaging.MessageQueue.Path" /> não foi definida.  
  
- ou - 
Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, label, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto a ser enviado à fila.</param>
        <param name="label">O rótulo da mensagem.</param>
        <param name="transaction">O objeto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Envia um objeto para a fila transacional referenciada por este <see cref="T:System.Messaging.MessageQueue" /> e especifica um rótulo para a mensagem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para enviar uma mensagem que contém o `obj` parâmetro para a fila transacional referenciada pela <xref:System.Messaging.MessageQueue>, usando um contexto de transação interna definido pela `transaction` parâmetro. Com essa sobrecarga, você pode especificar o rótulo de cadeia de caracteres que identifica a mensagem. O objeto que você envia para a fila pode ser um <xref:System.Messaging.Message>, uma estrutura, um objeto de dados ou qualquer objeto gerenciado. Se você enviar qualquer objeto diferente de um <xref:System.Messaging.Message>, o objeto é serializado e inserido no corpo da mensagem.  
  
 O rótulo da mensagem é diferente do rótulo da fila de mensagem, mas ambos são dependentes do aplicativo e não têm significado para enfileiramento de mensagens de herdar.  
  
 Se você usar essa sobrecarga para enviar uma mensagem para uma fila não transacional, a mensagem pode ser enviada para a fila de inatividade sem lançar uma exceção.  
  
 Se você não definir a <xref:System.Messaging.MessageQueue.Formatter%2A> propriedade antes de chamar <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, o formatador assume como padrão o <xref:System.Messaging.XmlMessageFormatter>.  
  
 O <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriedade se aplica a qualquer objeto diferente de um <xref:System.Messaging.Message>. Se você especificar, por exemplo, um rótulo ou uma prioridade usando o <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membro, esses valores se aplicam a qualquer mensagem que contém um objeto que não é do tipo <xref:System.Messaging.Message> quando o seu aplicativo a envia para a fila. Ao enviar uma <xref:System.Messaging.Message>, os valores de propriedade definidos para o <xref:System.Messaging.Message> têm precedência sobre <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> e a mensagem <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propriedade tem precedência sobre a fila <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propriedade  
  
 <xref:System.Messaging.MessageQueueTransaction> é threading apartment ciente, portanto, se seu estado de apartment é `STA`, é possível usar a transação em vários threads. Visual Basic define o estado do thread principal para `STA`, portanto, você deve aplicar a <xref:System.MTAThreadAttribute> no `Main` sub-rotina. Caso contrário, o envio de uma mensagem transacional usando outro thread gerará uma exceção <xref:System.Messaging.MessageQueueException>. Aplicar o <xref:System.MTAThreadAttribute> usando o fragmento a seguir.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#4](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#4)]
 [!code-csharp[MessageQueue2#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="label" /> é <see langword="null" />.  
  
- ou - 
O parâmetro <paramref name="transaction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A propriedade <see cref="P:System.Messaging.MessageQueue.Path" /> não foi definida.  
  
- ou - 
O aplicativo do serviço de enfileiramento de mensagens indicou um uso incorreto de transação.  
  
- ou - 
Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, label, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto a ser enviado à fila.</param>
        <param name="label">O rótulo da mensagem.</param>
        <param name="transactionType">Um dos valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que descreve o tipo de contexto de transação associado à mensagem.</param>
        <summary>Envia um objeto para a fila referenciada por esse <see cref="T:System.Messaging.MessageQueue" /> e especifica um rótulo para a mensagem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para enviar uma mensagem que contém o `obj` parâmetro para a fila referenciada pela <xref:System.Messaging.MessageQueue>, usando um contexto de transação definido pelo `transactionType` parâmetro. Especificar `Automatic` para o `transactionType` parâmetro se já houver um contexto de transação externo anexada ao thread de que você deseja usar para enviar a mensagem. Especificar `Single` se você quiser enviar a mensagem como uma única transação interna. Você pode especificar `None` se você quiser enviar uma mensagem transacional para um thread não-transacional.  
  
 O objeto que você envia para a fila pode ser um <xref:System.Messaging.Message> ou qualquer objeto gerenciado. Se você enviar qualquer objeto diferente de um <xref:System.Messaging.Message>, o objeto é serializado e inserido no corpo da mensagem. Com essa sobrecarga, você pode especificar o rótulo de cadeia de caracteres que identifica a mensagem.  
  
 O rótulo da mensagem é diferente do rótulo da fila de mensagem, mas ambos são dependentes do aplicativo e não têm significado para enfileiramento de mensagens de herdar.  
  
 Se você não definir a <xref:System.Messaging.MessageQueue.Formatter%2A> propriedade antes de chamar <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, o formatador assume como padrão o <xref:System.Messaging.XmlMessageFormatter>.  
  
 O <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriedade se aplica a qualquer objeto diferente de um <xref:System.Messaging.Message>. Se você especificar, por exemplo, um rótulo ou uma prioridade usando o <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membro, esses valores se aplicam a qualquer mensagem que contém um objeto que não é do tipo <xref:System.Messaging.Message> quando o seu aplicativo a envia para a fila. Ao enviar uma <xref:System.Messaging.Message>, os valores de propriedade definidos para o <xref:System.Messaging.Message> têm precedência sobre <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>e a mensagem <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propriedade tem precedência sobre a fila <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propriedade.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#3](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#3)]
 [!code-csharp[MessageQueue2#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="label" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueTransaction">O aplicativo do serviço de enfileiramento de mensagens indicou um uso incorreto de transação.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">O parâmetro <paramref name="transactionType" /> não é um dos membros do <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A propriedade <see cref="P:System.Messaging.MessageQueue.Path" /> não foi definida.  
  
- ou - 
Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetPermissions">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adiciona permissões ao conjunto atual. Isso controla quem tem direitos de acesso a propriedades da fila e mensagens na fila.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.AccessControlList dacl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.AccessControlList dacl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (dacl As AccessControlList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::AccessControlList ^ dacl);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.AccessControlList -&gt; unit" Usage="messageQueue.SetPermissions dacl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dacl" Type="System.Messaging.AccessControlList" />
      </Parameters>
      <Docs>
        <param name="dacl">Um <see cref="T:System.Messaging.AccessControlList" /> que contém uma ou mais entradas de controle de acesso que especificam os objetos de confiança e as permissões a serem concedidas.</param>
        <summary>Atribui direitos de acesso à fila com base no conteúdo de uma lista de controle de acesso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para conceder, negar ou revogar os direitos por meio de uma coleção de entradas de controle de acesso para especificar as informações de objeto de confiança e permissões. Isso é usado, por exemplo, para conceder permissões a vários usuários ao mesmo tempo.  
  
 O objeto de confiança que você especifica quando constrói o `ace` parâmetro pode ser um usuário individual, um grupo de usuários ou um computador. Se o objeto de confiança é um indivíduo, use o formato `DOMAIN` \\ `user`. Você pode especificar "." para o objeto de confiança indicar o computador local.  
  
 As permissões atribuídas por meio de <xref:System.Messaging.MessageQueue.SetPermissions%2A> adicionar direitos à lista existente. Por padrão, o criador de uma fila pública ou privada tem controle total e o grupo de domínio que todo mundo tem permissão para obter as propriedades de fila, obter permissões e gravar na fila. Quando você chama <xref:System.Messaging.MessageQueue.SetPermissions%2A>, as informações de permissões de usuário e são acrescentadas à parte inferior da lista existente.  
  
 O sistema examina cada <xref:System.Messaging.AccessControlEntry> em sequência até que ocorra um dos seguintes eventos:  
  
-   Um acesso negado <xref:System.Messaging.AccessControlEntry> nega explicitamente os direitos de acesso solicitado para um dos objetos de confiança mencionados no token de acesso do thread.  
  
-   Um ou mais permissão de acesso <xref:System.Messaging.AccessControlEntry> itens para objetos de confiança explicitamente listados no token de acesso do thread concedem os direitos de acesso solicitado.  
  
-   Todos os <xref:System.Messaging.AccessControlEntry> itens foram verificados e não há ainda pelo menos um acesso solicitado à direita que não foi explicitamente permitido, caso em que o acesso é negado implicitamente.  
  
 Ao construir o `dacl` parâmetro, adicione <xref:System.Messaging.AccessControlEntry> instâncias do seu <xref:System.Messaging.AccessControlList> coleção. Quando você constrói cada entrada de controle de acesso, você pode especificar os direitos de acesso genérico ou padrão. Os direitos para uma fila podem ser qualquer combinação das seguintes opções:  
  
-   Excluir  
  
-   Segurança de leitura  
  
-   Segurança de gravação  
  
-   Sincronizar  
  
-   Modificar proprietário  
  
-   Ler  
  
-   Write  
  
-   Executar  
  
-   Necessária  
  
-   Todos  
  
-   Nenhum  
  
 Esses direitos são um conjunto de sinalizadores de bit que você pode combinar usando o operador OR de bit a bit.  
  
-   Controle total  
  
-   Excluir mensagem  
  
-   Receber mensagem  
  
-   Espiar mensagem  
  
-   Receber mensagens do diário  
  
-   Obter propriedades de fila  
  
-   Definir propriedades de fila  
  
-   Obter permissões  
  
-   Definir permissões  
  
-   Assumir a propriedade de fila  
  
-   Gravar mensagem  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29>.      
  
 [!code-cpp[MessageQueue2#26](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#26)]
 [!code-csharp[MessageQueue2#26](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.AccessControlList" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.MessageQueueAccessControlEntry ace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.MessageQueueAccessControlEntry ace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (ace As MessageQueueAccessControlEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::MessageQueueAccessControlEntry ^ ace);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.MessageQueueAccessControlEntry -&gt; unit" Usage="messageQueue.SetPermissions ace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ace" Type="System.Messaging.MessageQueueAccessControlEntry" />
      </Parameters>
      <Docs>
        <param name="ace">Um <see cref="T:System.Messaging.MessageQueueAccessControlEntry" /> que especifica um usuário, um tipo de acesso e um tipo de permissão.</param>
        <summary>Atribui direitos de acesso para a fila com base no conteúdo de uma entrada de controle de acesso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para conceder, negar ou revogar os direitos por meio de uma entrada de controle de acesso para especificar o objeto de confiança e informações de direitos.  
  
 O objeto de confiança que você especifica quando constrói o `ace` parâmetro pode ser um usuário individual, um grupo de usuários ou um computador. Se o objeto de confiança é um indivíduo, use o formato `DOMAIN` \\ `user`. Você pode especificar "." para o objeto de confiança indicar o computador local.  
  
 As permissões atribuídas por meio de <xref:System.Messaging.MessageQueue.SetPermissions%2A> adicionar direitos à lista existente. Por padrão, o criador de uma fila pública ou privada tem controle total e o grupo de domínio que todo mundo tem permissão para obter as propriedades de fila, obter permissões e gravar na fila. Quando você chama <xref:System.Messaging.MessageQueue.SetPermissions%2A>, as informações de permissões de usuário e são acrescentadas à parte inferior da lista existente.  
  
 O sistema examina cada <xref:System.Messaging.AccessControlEntry> em sequência até que ocorra um dos seguintes eventos:  
  
-   Um acesso negado <xref:System.Messaging.AccessControlEntry> nega explicitamente os direitos de acesso solicitado para um dos objetos de confiança mencionados no token de acesso do thread.  
  
-   Um ou mais permissão de acesso <xref:System.Messaging.AccessControlEntry> itens para objetos de confiança explicitamente listados no token de acesso do thread concedem os direitos de acesso solicitado.  
  
-   Todos os <xref:System.Messaging.AccessControlEntry> itens foram verificados e não há ainda pelo menos um acesso solicitado à direita que não foi explicitamente permitido, caso em que o acesso é negado implicitamente.  
  
 Os direitos para uma fila, que você especificar na `rights` parâmetro quando você constrói sua <xref:System.Messaging.MessageQueueAccessControlEntry>, pode ser qualquer combinação das seguintes opções:  
  
-   Controle total  
  
-   Excluir mensagem  
  
-   Receber mensagem  
  
-   Espiar mensagem  
  
-   Receber mensagens do diário  
  
-   Obter propriedades de fila  
  
-   Definir propriedades de fila  
  
-   Obter permissões  
  
-   Definir permissões  
  
-   Assumir a propriedade de fila  
  
-   Gravar mensagem  
  
 O `rights` parâmetro especificado no construtor para o `ace` parâmetro é um sinalizador do <xref:System.Messaging.MessageQueueAccessRights> enumeração. Ele representa um conjunto de sinalizadores de bit que você pode combinar usando o operador bit a bit ou quando você compila o `rights` parâmetro.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29>.  
  
 [!code-cpp[MessageQueue2#24](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#24)]
 [!code-csharp[MessageQueue2#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.MessageQueueAccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights -&gt; unit" Usage="messageQueue.SetPermissions (user, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
      </Parameters>
      <Docs>
        <param name="user">O indivíduo, grupo ou computador que obtém direitos adicionais para a fila.</param>
        <param name="rights">Um <see cref="T:System.Messaging.MessageQueueAccessRights" /> que indica o conjunto de direitos para a fila que o Enfileiramento de Mensagens atribui ao <c>usuário</c> passado.</param>
        <summary>Fornece os direitos de acesso especificados a um computador, grupo ou usuário.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para conceder os direitos especificados para um usuário individual. O usuário pode ser qualquer objeto de confiança válido, o que inclui usuários individuais, grupos de usuários ou um computador. Se o usuário é um indivíduo, use o formato `DOMAIN` \\ `user` para o `user` parâmetro. Você pode especificar "." para o `user` parâmetro para indicar o computador local.  
  
 As permissões atribuídas por meio de <xref:System.Messaging.MessageQueue.SetPermissions%2A> adicionar direitos à lista existente. Por padrão, o criador de uma fila pública ou privada tem controle total e o grupo de domínio que todo mundo tem permissão para obter as propriedades de fila, obter permissões e gravar na fila. Quando você chama <xref:System.Messaging.MessageQueue.SetPermissions%2A>, as informações de permissões de usuário e são acrescentadas à parte inferior da lista existente.  
  
 O sistema examina cada <xref:System.Messaging.AccessControlEntry> em sequência até que ocorra um dos seguintes eventos:  
  
-   Um acesso negado <xref:System.Messaging.AccessControlEntry> nega explicitamente os direitos de acesso solicitado para um dos objetos de confiança mencionados no token de acesso do thread.  
  
-   Um ou mais permissão de acesso <xref:System.Messaging.AccessControlEntry> itens para objetos de confiança explicitamente listados no token de acesso do thread concedem os direitos de acesso solicitado.  
  
-   Todos os <xref:System.Messaging.AccessControlEntry> itens foram verificados e não há ainda pelo menos um acesso solicitado à direita que não foi explicitamente permitido, caso em que o acesso é negado implicitamente.  
  
 Os direitos para uma fila especificada no `rights` parâmetro, pode ser qualquer combinação das seguintes opções:  
  
-   Controle total  
  
-   Excluir mensagem  
  
-   Receber mensagem  
  
-   Espiar mensagem  
  
-   Receber mensagens do diário  
  
-   Obter propriedades de fila  
  
-   Definir propriedades de fila  
  
-   Obter permissões  
  
-   Definir permissões  
  
-   Assumir a propriedade de fila  
  
-   Gravar mensagem  
  
 O <xref:System.Messaging.MessageQueueAccessRights> enumeração representa um conjunto de sinalizadores de bit que você pode combinar usando o operador bit a bit ou para criar o `rights` parâmetro.  
  
 Com essa sobrecarga, você só pode conceder permissões; Você não pode revogar ou negar. Você deve usar uma sobrecarga diferente conceder explicitamente qualquer <xref:System.Messaging.AccessControlEntryType> diferente de `Allow`.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29>.  
  
 [!code-cpp[MessageQueue2#23](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#23)]
 [!code-csharp[MessageQueue2#23](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <paramref name="user" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights, System.Messaging.AccessControlEntryType entryType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights, valuetype System.Messaging.AccessControlEntryType entryType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights, entryType As AccessControlEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights, System::Messaging::AccessControlEntryType entryType);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights * System.Messaging.AccessControlEntryType -&gt; unit" Usage="messageQueue.SetPermissions (user, rights, entryType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
        <Parameter Name="entryType" Type="System.Messaging.AccessControlEntryType" />
      </Parameters>
      <Docs>
        <param name="user">O indivíduo, grupo ou computador que obtém direitos adicionais para a fila.</param>
        <param name="rights">Um <see cref="T:System.Messaging.MessageQueueAccessRights" /> que indica o conjunto de direitos para a fila que o Enfileiramento de Mensagens atribui ao <c>usuário</c> passado.</param>
        <param name="entryType">Um <see cref="T:System.Messaging.AccessControlEntryType" /> que especifica se as permissões especificadas pelo parâmetro <c>direitos</c> serão concedidas, negadas ou revogadas.</param>
        <summary>Fornece a um computador, grupo ou usuário os direitos de acesso especificados, com o tipo de controle de acesso especificado (permitir, negar, revogar ou definir).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para conceder, negar ou revogar os direitos especificados para um usuário individual. O usuário pode ser qualquer objeto de confiança válido, o que inclui usuários individuais, grupos de usuários ou um computador. Se o usuário é um indivíduo, use o formato `DOMAIN` \\ `user` para o `user` parâmetro. Você pode especificar "." para o `user` parâmetro para indicar o computador local.  
  
 As permissões atribuídas por meio de <xref:System.Messaging.MessageQueue.SetPermissions%2A> adicionar direitos à lista existente. Por padrão, o criador de uma fila pública ou privada tem controle total e o grupo de domínio que todo mundo tem permissão para obter as propriedades de fila, obter permissões e gravar na fila. Quando você chama <xref:System.Messaging.MessageQueue.SetPermissions%2A>, as informações de permissões de usuário e são acrescentadas à parte inferior da lista existente.  
  
 O sistema examina cada <xref:System.Messaging.AccessControlEntry> em sequência até que ocorra um dos seguintes eventos:  
  
-   Um acesso negado <xref:System.Messaging.AccessControlEntry> nega explicitamente os direitos de acesso solicitado para um dos objetos de confiança mencionados no token de acesso do thread.  
  
-   Um ou mais permissão de acesso <xref:System.Messaging.AccessControlEntry> itens para objetos de confiança explicitamente listados no token de acesso do thread concedem os direitos de acesso solicitado.  
  
-   Todos os <xref:System.Messaging.AccessControlEntry> itens foram verificados e não há ainda pelo menos um acesso solicitado à direita que não foi explicitamente permitido, caso em que o acesso é negado implicitamente.  
  
 Os direitos para uma fila especificada no `rights` parâmetro, pode ser qualquer combinação das seguintes opções:  
  
-   Controle total  
  
-   Excluir mensagem  
  
-   Receber mensagem  
  
-   Espiar mensagem  
  
-   Receber mensagens do diário  
  
-   Obter propriedades de fila  
  
-   Definir propriedades de fila  
  
-   Obter permissões  
  
-   Definir permissões  
  
-   Assumir a propriedade de fila  
  
-   Gravar mensagem  
  
 O <xref:System.Messaging.MessageQueueAccessRights> enumeração representa um conjunto de sinalizadores de bit que você pode combinar usando o operador bit a bit ou para criar o `rights` parâmetro.  
  
 A tabela a seguir mostra se este método está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29>.  
  
 [!code-cpp[MessageQueue2#25](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#25)]
 [!code-csharp[MessageQueue2#25](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.AccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_SynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o objeto que realiza marshal da chamada do manipulador de eventos resultante de um evento <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> ou <see cref="E:System.Messaging.MessageQueue.PeekCompleted" />.</summary>
        <value>Um <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, que representa o objeto que controla a chamada do manipulador de eventos resultante de uma <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> ou <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> eventos. O padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Messaging.MessageQueue.ReceiveCompleted> ou <xref:System.Messaging.MessageQueue.PeekCompleted> resultam de uma <xref:System.Messaging.MessageQueue.BeginReceive%2A> ou <xref:System.Messaging.MessageQueue.BeginPeek%2A> solicitar, respectivamente, para um thread específico. Normalmente, o <xref:System.Messaging.MessageQueue.SynchronizingObject%2A> é definido quando seu componente relacionado é colocado dentro um controle ou um formulário, porque esses componentes são associados a um thread específico.  
  
 Normalmente, o objeto de sincronização realiza marshaling de uma chamada de método em um único thread.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Transactional">
      <MemberSignature Language="C#" Value="public bool Transactional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Transactional" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Transactional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transactional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Transactional { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Transactional : bool" Usage="System.Messaging.MessageQueue.Transactional" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Transactional")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a fila aceita apenas as transações.</summary>
        <value>
          <see langword="true" /> se a fila aceita apenas mensagens enviadas como parte de uma transação; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mensagens transacionais refere-se para o acoplamento de várias mensagens relacionadas em uma única transação. Envio de mensagens como parte de uma transação assegura que as mensagens sejam entregues na ordem, entregues somente uma vez e recuperado com êxito da sua fila de destino.  
  
 Se uma fila é transacional, ele aceita apenas mensagens que são enviadas como parte de uma transação. No entanto, uma mensagem não transacional pode ser enviada ou recebida de uma fila de transação local sem usar explicitamente transacional <xref:System.Messaging.MessageQueueTransaction.Begin%2A>, <xref:System.Messaging.MessageQueueTransaction.Commit%2A>, e <xref:System.Messaging.MessageQueueTransaction.Abort%2A> sintaxe. Se uma mensagem não transacional é enviada para uma fila transacional, esse componente cria uma mensagem única transação para ele, exceto no caso de fazer referência a uma fila em um computador remoto usando um nome de formato direto. Nessa situação, se você não especificar um contexto de transação ao enviar uma mensagem, ela não é criada para você e a mensagem será enviada para a fila de inatividade.  
  
 Se você enviar uma mensagem não transacional a uma fila transacional, você não poderá reverter a mensagem em caso de uma exceção.  
  
 <xref:System.Messaging.MessageQueueTransaction> é threading apartment ciente, portanto, se seu estado de apartment é `STA`, é possível usar a transação em vários threads. Visual Basic define o estado do thread principal para `STA`, portanto, você deve aplicar a <xref:System.MTAThreadAttribute> no `Main` sub-rotina. Caso contrário, o envio de uma mensagem transacional usando outro thread gerará uma exceção <xref:System.Messaging.MessageQueueException>. Aplicar o <xref:System.MTAThreadAttribute> usando o fragmento a seguir.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 A tabela a seguir mostra se essa propriedade está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.Transactional%2A> propriedade.  
  
 [!code-csharp[MessageQueue#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Begin" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Commit" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Abort" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_UseJournalQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se as mensagens recebidas são copiadas para a fila de diário.</summary>
        <value>
          <see langword="true" /> Se as mensagens recebidas da fila são copiadas para a sua fila de diário; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando o aplicativo de enfileiramento de mensagens cria uma nova fila do aplicativo, ele automaticamente cria uma fila de diário associado no mesmo local. A fila de diário é usada para rastrear as mensagens removidas de uma fila. A definição dessa propriedade modifica a fila de enfileiramento de mensagens. Portanto, qualquer outro <xref:System.Messaging.MessageQueue> instâncias são afetadas pela alteração.  
  
 A fila de diário não rastreia mensagens removidas da fila porque seu o timer de tempo de recebimento expirou, nem acompanha mensagens limpas da fila usando um serviço de diretório enfileiramento de mensagens (informações Store ou do Active Directory).  
  
 Aplicativos não podem enviar mensagens para filas de diário; eles são limitados a acesso somente leitura dessas filas. Além disso, enfileiramento de mensagens nunca remove as mensagens das filas de diário. O aplicativo usando a fila deve limpar essas mensagens por recebê-los ou limpar a fila.  
  
 A tabela a seguir mostra se essa propriedade está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> propriedade.  
  
 [!code-csharp[MessageQueue#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="WriteHandle">
      <MemberSignature Language="C#" Value="public IntPtr WriteHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int WriteHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.WriteHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriteHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr WriteHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteHandle : nativeint" Usage="System.Messaging.MessageQueue.WriteHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém identificador nativo utilizado para enviar mensagens para a fila de mensagens.</summary>
        <value>Um identificador para o objeto de fila nativo que você pode usar para enviar mensagens à fila.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.MessageQueue.WriteHandle%2A> fornece um identificador nativo do Windows para o objeto de fila de mensagem que é usado para enviar mensagens à fila. Se você alterar o caminho da fila, o identificador for fechado e reaberto com um novo valor.  
  
 A tabela a seguir mostra se essa propriedade está disponível em vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">A fila de mensagens não está disponível para gravação.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
  </Members>
</Type>