<Type Name="Message" FullName="System.Messaging.Message">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9fe96c4f161160bdcc92c281cb6929789524dc9a" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53515693" /></Metadata><TypeSignature Language="C#" Value="public class Message : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Message extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.Message" />
  <TypeSignature Language="VB.NET" Value="Public Class Message&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Message : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Message = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Concede acesso às propriedades necessárias para definir uma mensagem de Enfileiramento de Mensagens.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Messaging.Message> espiar ou receber mensagens de uma fila, ou ter controle refinado sobre as propriedades da mensagem ao enviar uma mensagem para uma fila de classe.  
  
 <xref:System.Messaging.MessageQueue> usa o <xref:System.Messaging.Message> classe quando ele inspeciona ou recebe mensagens de filas, porque tanto o <xref:System.Messaging.MessageQueue.Peek%2A?displayProperty=nameWithType> e <xref:System.Messaging.MessageQueue.Receive%2A?displayProperty=nameWithType> métodos criam uma nova instância do <xref:System.Messaging.Message> de classe e defina as propriedades da instância. O <xref:System.Messaging.Message> se aplicam as propriedades somente leitura da classe para recuperar mensagens de uma fila, enquanto as propriedades de leitura/gravação se aplicam a enviar e recuperar mensagens. Quando <xref:System.Messaging.MessageQueue> espia ou recebe uma mensagem de uma fila, seu <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> propriedade determina quais das propriedades da mensagem são recuperados.  
  
 O <xref:System.Messaging.MessageQueue> da classe <xref:System.Messaging.MessageQueue.Send%2A> método permite que você especifique qualquer tipo de objeto para uma mensagem que está sendo enviada para essa fila. Você pode usar o <xref:System.Messaging.MessageQueue> da instância <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriedade para especificar as configurações para mensagens genéricas enviadas para a fila. Os tipos de configurações incluem o formatador, rótulo, criptografia e autenticação. Você também pode especificar valores para apropriado <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membros quando coordenar o seu aplicativo de mensagens para responder às mensagens de confirmação e o relatório. Usando um <xref:System.Messaging.Message> instância para enviar uma mensagem à fila oferece a flexibilidade para acessar e modificar muitas dessas propriedades - para uma única mensagem ou em uma base por mensagem. <xref:System.Messaging.Message> as propriedades têm precedência sobre <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>.  
  
 Mensagem de dados é armazenada na <xref:System.Messaging.Message.Body%2A> propriedade e, em uma extensão menor, o <xref:System.Messaging.Message.AppSpecific%2A> e <xref:System.Messaging.Message.Extension%2A> propriedades. Quando os dados da mensagem são criptografados, serializados ou desserializados, somente o conteúdo do <xref:System.Messaging.Message.Body%2A> propriedade são afetados.  
  
 O conteúdo do <xref:System.Messaging.Message.Body%2A> propriedade são serializados quando a mensagem é enviada usando o <xref:System.Messaging.Message.Formatter%2A> propriedade que você especificar. O conteúdo serializado é encontrado no <xref:System.Messaging.Message.BodyStream%2A> propriedade. Você também pode definir o <xref:System.Messaging.Message.BodyStream%2A> propriedade diretamente, por exemplo, para enviar um arquivo como o conteúdo de dados de uma mensagem. Você pode alterar o <xref:System.Messaging.Message.Body%2A> ou <xref:System.Messaging.Message.Formatter%2A> propriedades a qualquer momento antes de enviar a mensagem e os dados serão serializadas corretamente ao chamar <xref:System.Messaging.MessageQueue.Send%2A>.  
  
 As propriedades definidas pela <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=nameWithType> propriedade se aplica somente a mensagens que não são do tipo <xref:System.Messaging.Message>. Se você especificar o <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriedade para um <xref:System.Messaging.MessageQueue>, o identicamente nomeado propriedades em um <xref:System.Messaging.Message> instância enviou a causa dessa fila essas propriedades padrão a serem ignorados.  
  
 Para obter uma lista de valores de propriedade inicial para uma instância do <xref:System.Messaging.Message>, consulte o <xref:System.Messaging.Message.%23ctor%2A> construtor.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra a formatação de um corpo de mensagem usando <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 O exemplo de código a seguir demonstra a formatação de um corpo de mensagem usando <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Messaging.Message" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Messaging.Message" /> com um corpo vazio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para criar uma nova instância do <xref:System.Messaging.Message> classe que tem um corpo vazio.  
  
 Especifique o <xref:System.Messaging.Message.Body%2A> propriedade ou o <xref:System.Messaging.Message.BodyStream%2A> propriedade antes de enviar o <xref:System.Messaging.Message> objeto. O <xref:System.Messaging.Message.Body%2A> propriedade pode ser qualquer objeto que pode ser serializado, como uma cadeia de caracteres de texto, um objeto de estrutura, uma instância da classe ou um objeto inserido.  
  
 A menos que você escreva o conteúdo da mensagem diretamente para o <xref:System.Messaging.Message.BodyStream%2A> propriedade, defina o <xref:System.Messaging.Message.Formatter%2A> propriedade antes de enviar a mensagem. O corpo é serializado usando o <xref:System.Messaging.Message.Formatter%2A> o valor da propriedade no momento a <xref:System.Messaging.MessageQueue.Send%2A> método é chamado no <xref:System.Messaging.MessageQueue> instância.  
  
 O <xref:System.Messaging.XmlMessageFormatter> está acoplado livremente, portanto, não é necessário ter o mesmo objeto de tipo no remetente e receptor ao usar esse formato. O <xref:System.Messaging.ActiveXMessageFormatter> e <xref:System.Messaging.BinaryMessageFormatter> serializar os dados em representação binária. O <xref:System.Messaging.ActiveXMessageFormatter> é usado ao enviar ou receber os componentes COM.  
  
 A tabela a seguir mostra os valores de propriedade inicial para uma instância do <xref:System.Messaging.Message>.  
  
|Propriedade|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider versão 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`null`|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Uma cadeia de caracteres vazia ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Uma matriz de bytes de comprimento zero|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Uma matriz de bytes de comprimento zero|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Uma matriz de bytes de comprimento zero|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Uma cadeia de caracteres vazia ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Uma matriz de bytes de comprimento zero|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 O exemplo de código a seguir envia duas mensagens de prioridades diferentes para a fila e recupera-los posteriormente.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body);" />
      <MemberSignature Language="F#" Value="new System.Messaging.Message : obj -&gt; System.Messaging.Message" Usage="new System.Messaging.Message body" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="body">O objeto a ser serializado no corpo da mensagem.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Messaging.Message" /> usando o <see cref="T:System.Messaging.XmlMessageFormatter" /> para serializar o objeto especificado no corpo da mensagem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para criar uma nova instância dos <xref:System.Messaging.Message> classe que contém o <xref:System.Messaging.Message.Body%2A> especificado pelo `body` parâmetro. O `body` parâmetro pode ser qualquer objeto que pode ser serializado, como uma cadeia de caracteres de texto, um objeto de estrutura, uma instância da classe ou um objeto inserido. O corpo é serializado usando o <xref:System.Messaging.XmlMessageFormatter> a menos que você altere o <xref:System.Messaging.Message.Formatter%2A> propriedade antes do <xref:System.Messaging.Message> é enviada. Se você alterar o <xref:System.Messaging.Message.Body%2A> ou <xref:System.Messaging.Message.Formatter%2A> propriedade a qualquer momento antes de chamar <xref:System.Messaging.MessageQueue.Send%2A>, a mensagem será serializada de acordo com o novo valor da propriedade.  
  
 O <xref:System.Messaging.XmlMessageFormatter> está acoplado livremente, portanto, não é necessário ter o mesmo objeto de tipo no remetente e receptor ao usar esse formato. O <xref:System.Messaging.ActiveXMessageFormatter> e <xref:System.Messaging.BinaryMessageFormatter> serializar os dados em representação binária. O <xref:System.Messaging.ActiveXMessageFormatter> é usado ao enviar ou receber os componentes COM.  
  
 A tabela a seguir mostra os valores de propriedade inicial para uma instância do <xref:System.Messaging.Message>.  
  
|Propriedade|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider versão 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|O parâmetro `body`.|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Uma cadeia de caracteres vazia ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Uma matriz de bytes de comprimento zero|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Uma matriz de bytes de comprimento zero|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Uma matriz de bytes de comprimento zero|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Uma cadeia de caracteres vazia ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Uma matriz de bytes de comprimento zero|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma nova fila, envia uma mensagem que contém um pedido a ele e, em seguida, irá recuperá-lo.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body, System.Messaging.IMessageFormatter formatter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body, class System.Messaging.IMessageFormatter formatter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object, formatter As IMessageFormatter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body, System::Messaging::IMessageFormatter ^ formatter);" />
      <MemberSignature Language="F#" Value="new System.Messaging.Message : obj * System.Messaging.IMessageFormatter -&gt; System.Messaging.Message" Usage="new System.Messaging.Message (body, formatter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
        <Parameter Name="formatter" Type="System.Messaging.IMessageFormatter" />
      </Parameters>
      <Docs>
        <param name="body">O objeto a ser serializado no corpo da mensagem.</param>
        <param name="formatter">Um <see cref="T:System.Messaging.IMessageFormatter" /> que especifica o formatador com o qual o corpo da mensagem é serializado.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Messaging.Message" /> usando o formatador especificado para serializar o objeto especificado no corpo da mensagem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para criar uma nova instância da <xref:System.Messaging.Message> classe que contém o <xref:System.Messaging.Message.Body%2A> especificado pelo `body` parâmetro e que usa qualquer formatador válido para serializar o corpo. O `body` parâmetro é qualquer objeto que pode ser serializado, como uma cadeia de caracteres de texto, um objeto de estrutura, uma instância da classe ou um objeto inserido. Se você alterar o <xref:System.Messaging.Message.Body%2A> ou <xref:System.Messaging.Message.Formatter%2A> propriedade a qualquer momento antes de chamar <xref:System.Messaging.MessageQueue.Send%2A>, a mensagem será serializada de acordo com o novo valor da propriedade.  
  
 O <xref:System.Messaging.XmlMessageFormatter> está acoplado livremente, portanto, não é necessário ter o mesmo objeto de tipo no remetente e receptor ao usar esse formato. O <xref:System.Messaging.ActiveXMessageFormatter> e <xref:System.Messaging.BinaryMessageFormatter> serializar os dados em representação binária. O <xref:System.Messaging.ActiveXMessageFormatter> é usado ao enviar ou receber os componentes COM.  
  
 A tabela a seguir mostra os valores de propriedade inicial para uma instância do <xref:System.Messaging.Message>.  
  
|Propriedade|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider versão 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|O parâmetro `body`.|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Uma cadeia de caracteres vazia ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Uma matriz de bytes de comprimento zero|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Uma matriz de bytes de comprimento zero|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Uma matriz de bytes de comprimento zero|  
|<xref:System.Messaging.Message.Formatter%2A>|O parâmetro `formatter`.|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Uma cadeia de caracteres vazia ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Uma matriz de bytes de comprimento zero|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="AcknowledgeType">
      <MemberSignature Language="C#" Value="public System.Messaging.AcknowledgeTypes AcknowledgeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.AcknowledgeTypes AcknowledgeType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AcknowledgeType" />
      <MemberSignature Language="VB.NET" Value="Public Property AcknowledgeType As AcknowledgeTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::AcknowledgeTypes AcknowledgeType { System::Messaging::AcknowledgeTypes get(); void set(System::Messaging::AcknowledgeTypes value); };" />
      <MemberSignature Language="F#" Value="member this.AcknowledgeType : System.Messaging.AcknowledgeTypes with get, set" Usage="System.Messaging.Message.AcknowledgeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgeType")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.AcknowledgeTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tipo de mensagem de confirmação a ser retornada para o aplicativo de envio.</summary>
        <value>Um dos valores <see cref="T:System.Messaging.AcknowledgeTypes" /> que representa ambos os tipos de mensagens de confirmação postadas pelo sistema na fila de administração e as condições nas quais as confirmações são retornadas para o aplicativo de envio. O padrão é <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.Message.AcknowledgeType%2A> propriedade especifica o tipo de solicitado pelo aplicativo de envio de mensagens de confirmação. Defina o <xref:System.Messaging.Message.AcknowledgeType%2A> propriedade antes de enviar a mensagem de solicitação de notificação de determinadas ocorrências - por exemplo, uma mensagem de alcançar a fila de destino, uma mensagem que está sendo recuperada ou impedindo que uma mensagem atingir ou que está sendo recuperado de tempo limite a fila de destino.  
  
 Serviço de enfileiramento retorna notificação enviando mensagens de confirmação para o <xref:System.Messaging.Message.AdministrationQueue%2A> propriedade especificada pela mensagem original. Uma mensagem de confirmação <xref:System.Messaging.Message.Acknowledgment%2A> propriedade indica o tipo de confirmação de que ele representa. Por exemplo, se uma mensagem de confirmação foi enviada porque uma mensagem não alcançou o destino antes do <xref:System.Messaging.Message.TimeToReachQueue%2A> intervalo expirou, o <xref:System.Messaging.Message.Acknowledgment%2A> propriedade da mensagem de confirmação conteria o valor `ReachQueueTimeout`.  
  
   
  
## Examples  
 O exemplo de código a seguir envia e recebe uma mensagem contendo um pedido de e para uma fila. Ele solicita especificamente uma confirmação positiva quando a mensagem original atinge ou é recuperada da fila.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A mensagem é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.AcknowledgeType" />.</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="Acknowledgment">
      <MemberSignature Language="C#" Value="public System.Messaging.Acknowledgment Acknowledgment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.Acknowledgment Acknowledgment" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Acknowledgment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Acknowledgment As Acknowledgment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Acknowledgment Acknowledgment { System::Messaging::Acknowledgment get(); };" />
      <MemberSignature Language="F#" Value="member this.Acknowledgment : System.Messaging.Acknowledgment" Usage="System.Messaging.Message.Acknowledgment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgement")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.Acknowledgment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a classificação da confirmação que esta mensagem representa.</summary>
        <value>Um dos valores de enumeração <see cref="T:System.Messaging.Acknowledgment" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você recebe uma mensagem de uma fila de administração, leia o <xref:System.Messaging.Message.Acknowledgment%2A> propriedade para verificar o status da mensagem original.  
  
 Quando uma mensagem é enviada para a fila de destino, o enfileiramento de mensagens pode ser solicitado para postar uma mensagem de confirmação. Essa mensagem pode indicar, por exemplo, se a mensagem chegou e foi recuperada dentro do tempo limite especificado, ou pode indicar o que deu errado no caso de falha de entrega. A fila de destino retorna mensagens de confirmação e envia-os para a fila de administração especificada na mensagem original <xref:System.Messaging.Message.AdministrationQueue%2A> propriedade. O <xref:System.Messaging.Message.Id%2A> propriedade de uma mensagem de confirmação identifica a mensagem de confirmação, e não a mensagem original. Você pode encontrar o identificador da mensagem original na confirmação <xref:System.Messaging.Message> da instância <xref:System.Messaging.Message.CorrelationId%2A> propriedade.  
  
 Se este <xref:System.Messaging.Message> instância representa uma mensagem de confirmação, o <xref:System.Messaging.Message.Acknowledgment%2A> propriedade especifica o tipo de confirmação. Caso contrário, o <xref:System.Messaging.Message.Acknowledgment%2A> propriedade contém o valor `Normal`.  
  
 Use o <xref:System.Messaging.Message.AcknowledgeType%2A> propriedade da mensagem original para especificar as circunstâncias sob as quais confirmações serão retornadas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A mensagem não foi enviada. Essa propriedade só pode ser lida em mensagens recuperadas de uma fila.  
  
- ou - 
A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />.</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="AdministrationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue AdministrationQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue AdministrationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AdministrationQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property AdministrationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ AdministrationQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AdministrationQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.AdministrationQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAdministrationQueue")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a fila que recebe as mensagens de confirmação que o Enfileiramento de Mensagens gera.</summary>
        <value>O <see cref="T:System.Messaging.MessageQueue" /> que especifica a fila de administração usada para mensagens de confirmação geradas pelo sistema. O padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A fila especificada no <xref:System.Messaging.Message.AdministrationQueue%2A> propriedade pode ser qualquer fila não transacional. As mensagens de confirmação enviadas para a fila de administração podem indicar se a mensagem original alcançou a fila de destino e se ela foi removida da fila.  
  
 Quando o <xref:System.Messaging.Message.AcknowledgeType%2A> propriedade tiver qualquer valor diferente de `None`, o aplicativo de envio deve especificar a fila a ser usada como a fila de administração.  
  
   
  
## Examples  
 O exemplo de código a seguir envia e recebe uma mensagem contendo um pedido de e para uma fila. Ele solicita especificamente uma confirmação positiva quando a mensagem original atinge ou é recuperada da fila.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.AdministrationQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="AppSpecific">
      <MemberSignature Language="C#" Value="public int AppSpecific { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AppSpecific" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AppSpecific" />
      <MemberSignature Language="VB.NET" Value="Public Property AppSpecific As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AppSpecific { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.AppSpecific : int with get, set" Usage="System.Messaging.Message.AppSpecific" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAppSpecific")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define informações adicionais específicas do aplicativo.</summary>
        <value>Informações específicas ao aplicativo. O padrão é zero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.Message.AppSpecific%2A> propriedade contém informações específicas do aplicativo que você pode usar para organizar os diferentes tipos de mensagens. Por exemplo, você pode usar índices específicos do aplicativo. É responsabilidade do aplicativo para interpretar <xref:System.Messaging.Message.AppSpecific%2A> informações de propriedade.  
  
 Sempre que possível, você deve incluir dados de mensagem no corpo da mensagem, em vez do <xref:System.Messaging.Message.AppSpecific%2A> propriedade.  
  
 Ao trabalhar com filas externas, use o <xref:System.Messaging.Message.Extension%2A> propriedade para especificar as propriedades de mensagem que não existem no enfileiramento de mensagens. Assim como acontece com o <xref:System.Messaging.Message.AppSpecific%2A> propriedade, é responsabilidade do aplicativo para entender o conteúdo do <xref:System.Messaging.Message.Extension%2A> propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.AppSpecific" />.</exception>
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="ArrivedTime">
      <MemberSignature Language="C#" Value="public DateTime ArrivedTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ArrivedTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ArrivedTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ArrivedTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ArrivedTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ArrivedTime : DateTime" Usage="System.Messaging.Message.ArrivedTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgArrivedTime")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a hora em que a mensagem chegou na fila de destino.</summary>
        <value>Um <see cref="T:System.DateTime" /> que representa a hora de chegada da mensagem na fila de destino. O tempo é ajustado de GMT para a hora local do computador no qual reside a fila de destino.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A mensagem <xref:System.Messaging.Message.TimeToBeReceived%2A> propriedade indica quão rapidamente a mensagem deve ser recebida da fila de destino. O <xref:System.Messaging.Message.TimeToBeReceived%2A> inicia o temporizador de propriedade quando a mensagem é enviada, não quando a mensagem chega na fila.  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma mensagem <xref:System.Messaging.Message.ArrivedTime%2A> propriedade.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A mensagem não foi enviada. Essa propriedade só pode ser lida em mensagens recuperadas de uma fila.  
  
- ou - 
A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.ArrivedTime" />.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
      </Docs>
    </Member>
    <Member MemberName="AttachSenderId">
      <MemberSignature Language="C#" Value="public bool AttachSenderId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AttachSenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AttachSenderId" />
      <MemberSignature Language="VB.NET" Value="Public Property AttachSenderId As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AttachSenderId { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AttachSenderId : bool with get, set" Usage="System.Messaging.Message.AttachSenderId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAttachSenderId")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se a ID do remetente deve ser anexada à mensagem.</summary>
        <value><see langword="true" /> Se o <see cref="P:System.Messaging.Message.SenderId" /> deve ser anexado à mensagem; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.Message.SenderId%2A> propriedade é uma matriz de bytes que representa o identificador do usuário remetente. A ID de remetente é definida pelo enfileiramento de mensagens e é usada pelo Gerenciador de fila de recebimento para verificar se o remetente tem direitos de acesso a uma fila.  
  
 A ausência do remetente que ID é uma indicação pelo aplicativo de envio que enfileiramento de mensagens não deve validar o remetente da mensagem nem verificar o acesso do remetente de direitos para a fila de recebimento. O <xref:System.Messaging.Message.SenderId%2A> é confiável somente se a mensagem foi autenticada quando ela chegou à fila de destino. A mensagem será rejeitada quando ele atinge a fila de destino, se a fila aceita apenas mensagens autenticadas e qualquer um de <xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A> ou o <xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A> é de propriedade `false`.  
  
> [!CAUTION]
>  Se uma mensagem for rejeitada, ele é enviados para a fila de inatividade (se <xref:System.Messaging.Message.UseDeadLetterQueue%2A> é `true`), ou ele será ignorado. Você pode solicitar confirmações quando uma mensagem de falha alcançar uma fila. Caso contrário, quando <xref:System.Messaging.Message.UseDeadLetterQueue%2A> é `false` a mensagem pode ser perdida sem aviso.  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma mensagem <xref:System.Messaging.Message.AttachSenderId%2A> propriedade.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.AttachSenderId" />.</exception>
        <altmember cref="P:System.Messaging.Message.SenderId" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="Authenticated">
      <MemberSignature Language="C#" Value="public bool Authenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticated" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Authenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Authenticated : bool" Usage="System.Messaging.Message.Authenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticated")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a mensagem foi autenticada.</summary>
        <value><see langword="true" /> Se a autenticação foi solicitada para a mensagem quando ela foi inserida na fila; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.Message.Authenticated%2A> propriedade é usada somente pelo aplicativo enquanto ele está interagindo com a mensagem e tentar determinar se a autenticação foi solicitada. Se a mensagem está na fila, a mensagem foi autenticada. Por outro lado, se o <xref:System.Messaging.Message.Authenticated%2A> é de propriedade `true`, Gerenciador de fila de recebimento autenticado a mensagem quando ela recebeu essa mensagem.  
  
 Não é possível determinar se uma mensagem de falha na autenticação examinando suas propriedades. Serviço de enfileiramento descarta mensagens que falham na autenticação antes que sejam entregues à fila. No entanto, você pode solicitar que uma mensagem de confirmação ser enviado se uma falha de entrega impede que a mensagem que chega na fila.  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma mensagem <xref:System.Messaging.Message.Authenticated%2A> propriedade.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A mensagem não foi enviada. Essa propriedade só pode ser lida em mensagens recuperadas de uma fila.  
  
- ou - 
A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.Authenticated" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderName">
      <MemberSignature Language="C#" Value="public string AuthenticationProviderName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AuthenticationProviderName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderName" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AuthenticationProviderName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationProviderName : string with get, set" Usage="System.Messaging.Message.AuthenticationProviderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o nome do provedor criptográfico usado para gerar a assinatura digital da mensagem.</summary>
        <value>O nome do provedor criptográfico usado para gerar a assinatura digital da mensagem. O padrão é Microsoft Base Cryptographic Provider versão 1.0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, você usa o <xref:System.Messaging.Message.AuthenticationProviderName%2A> ao trabalhar com filas estrangeiras. Serviço de enfileiramento requer o nome do provedor de autenticação e o tipo de provedor de autenticação do provedor criptográfico (provedor de autenticação) para validar as assinaturas digitais de mensagens enviadas para uma fila externa e mensagens passadas à mensagem Enfileiramento de mensagens de uma fila externa.  
  
 Ao enviar uma mensagem, sempre defina as <xref:System.Messaging.Message.AuthenticationProviderName%2A> e <xref:System.Messaging.Message.ConnectorType%2A> propriedades juntas. Quando a mensagem é enviada, enfileiramento de mensagens ignora o nome do provedor de autenticação, se o tipo de conector também não estiver definido.  
  
 O <xref:System.Messaging.Message.AuthenticationProviderName%2A> propriedade não pode ser `null`, mas pode ser uma cadeia de caracteres vazia ("").  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Não foi possível definir a propriedade <see cref="P:System.Messaging.Message.AuthenticationProviderName" />.  
  
- ou - 
A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.AuthenticationProviderName" />.</exception>
        <exception cref="T:System.ArgumentException">O <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> foi definido como <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderType">
      <MemberSignature Language="C#" Value="public System.Messaging.CryptographicProviderType AuthenticationProviderType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.CryptographicProviderType AuthenticationProviderType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderType" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderType As CryptographicProviderType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::CryptographicProviderType AuthenticationProviderType { System::Messaging::CryptographicProviderType get(); void set(System::Messaging::CryptographicProviderType value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationProviderType : System.Messaging.CryptographicProviderType with get, set" Usage="System.Messaging.Message.AuthenticationProviderType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderType")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.CryptographicProviderType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tipo de provedor de criptografia usado para gerar a assinatura digital da mensagem.</summary>
        <value>Um dos valores de <see cref="T:System.Messaging.CryptographicProviderType" />. O padrão é <see langword="RSA_FULL" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, você usa o <xref:System.Messaging.Message.AuthenticationProviderType%2A> propriedade ao trabalhar com filas estrangeiras para especificar quais serviços de criptografia o provedor está associado uma mensagem. Serviço de enfileiramento requer o nome do provedor de autenticação e o tipo de provedor de autenticação do provedor criptográfico (provedor de autenticação) para validar as assinaturas digitais de mensagens enviadas para uma fila externa e mensagens passadas à mensagem Enfileiramento de mensagens de uma fila externa.  
  
 Somente `RsaFull` se destina a ser usado com o sistema de mensagens.  
  
 Ao enviar uma mensagem, sempre defina as <xref:System.Messaging.Message.AuthenticationProviderType%2A> e <xref:System.Messaging.Message.ConnectorType%2A> propriedades juntas. Quando a mensagem é enviada, enfileiramento de mensagens ignora o tipo de provedor de autenticação, se o tipo de conector também não estiver definido.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Não foi possível definir a propriedade <see cref="P:System.Messaging.Message.AuthenticationProviderType" />.  
  
- ou - 
A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.AuthenticationProviderType" />.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.CryptographicProviderType" />
      </Docs>
    </Member>
    <Member MemberName="Body">
      <MemberSignature Language="C#" Value="public object Body { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Body" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Body" />
      <MemberSignature Language="VB.NET" Value="Public Property Body As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Body { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Body : obj with get, set" Usage="System.Messaging.Message.Body" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o conteúdo da mensagem.</summary>
        <value>Um objeto que especifica os conteúdos da mensagem. O objeto pode ser uma cadeia de caracteres, uma data, uma moeda, um número, uma matriz de bytes ou qualquer objeto gerenciado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A mensagem <xref:System.Messaging.Message.Body%2A> propriedade geralmente contém os dados associados com a mensagem. Embora você também pode enviar dados específicos do aplicativo <xref:System.Messaging.Message.AppSpecific%2A> e <xref:System.Messaging.Message.Extension%2A> propriedades, você deve incluir dados da mensagem no <xref:System.Messaging.Message.Body%2A> da mensagem sempre que possível. Somente o <xref:System.Messaging.Message.Body%2A> conteúdo de propriedade é serializado ou criptografado.  
  
 O <xref:System.Messaging.Message.Body%2A> propriedade pode conter qualquer objeto cujo tamanho não exceda 4 MB. Se você usar <xref:System.Messaging.MessageQueue.Send%2A?displayProperty=nameWithType> para enviar qualquer objeto que não é do tipo <xref:System.Messaging.Message> para o <xref:System.Messaging.MessageQueue>, esse objeto estarão localizado no <xref:System.Messaging.Message.Body%2A> propriedade do <xref:System.Messaging.Message> instância retornada pela <xref:System.Messaging.MessageQueue.Peek%2A> ou <xref:System.Messaging.MessageQueue.Receive%2A>.  
  
 O argumento de cadeia de caracteres em `MessageQueue.Send("hello.")` é um exemplo de um objeto genérico.  
  
 O <xref:System.Messaging.Message.BodyType%2A> propriedade indica o tipo de informação que é armazenado no corpo da mensagem. Serviço de enfileiramento usa essas informações para identificar o tipo do <xref:System.Messaging.Message.Body%2A> conteúdo da propriedade.  
  
 Especifique o <xref:System.Messaging.Message.Body%2A> propriedade ou o <xref:System.Messaging.Message.BodyStream%2A> propriedade antes de enviar o <xref:System.Messaging.Message> objeto. O <xref:System.Messaging.Message.Body%2A> propriedade pode ser qualquer objeto serializável, como uma cadeia de caracteres de texto, o objeto de estrutura, a instância da classe ou o objeto inserido.  
  
 A menos que você escreva o conteúdo da mensagem diretamente para o <xref:System.Messaging.Message.BodyStream%2A> propriedade, defina o <xref:System.Messaging.Message.Formatter%2A> propriedade antes de enviar a mensagem. Quando o <xref:System.Messaging.MessageQueue.Send%2A> método é chamado em de <xref:System.Messaging.MessageQueue> instância, o corpo é serializada usando o formatador contido no <xref:System.Messaging.Message.Formatter%2A> propriedade. Se você envia a mensagem sem especificar um valor para o <xref:System.Messaging.Message.Formatter%2A> propriedade, o formatador padrão é <xref:System.Messaging.XmlMessageFormatter>.  
  
> [!NOTE]
>  A tentativa de definir o corpo de uma mensagem para <xref:System.Decimal.MaxValue> fará com que um <xref:System.OverflowException> quando o `Send` método da <xref:System.Messaging.MessageQueue> classe é chamado e o <xref:System.Messaging.ActiveXMessageFormatter> é usado.  
  
   
  
## Examples  
 O exemplo de código a seguir envia duas mensagens de prioridades diferentes para a fila e recupera-los posteriormente.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Messaging.Message.Formatter" /> é <see langword="null" />.  
  
- ou - 
A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.Body" />.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream BodyStream { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BodyStream" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyStream" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ BodyStream { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BodyStream : System.IO.Stream with get, set" Usage="System.Messaging.Message.BodyStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyStream")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define as informações no corpo da mensagem.</summary>
        <value>Um <see cref="T:System.IO.Stream" /> que contém as informações serializadas incluídas no <see cref="P:System.Messaging.Message.Body" /> da mensagem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O corpo de uma mensagem pode consistir de qualquer tipo de informações - por exemplo, uma cadeia de caracteres, uma data, moeda, um número, uma matriz de bytes ou qualquer objeto gerenciado. Essa informação é serializada em um <xref:System.IO.Stream> a serem passados para a fila.  
  
 Especifique o <xref:System.Messaging.Message.Body%2A> propriedade ou o <xref:System.Messaging.Message.BodyStream%2A> propriedade antes de enviar o <xref:System.Messaging.Message> objeto. Se você definir a <xref:System.Messaging.Message.Body%2A> propriedade, o conteúdo é serializado no <xref:System.Messaging.Message.BodyStream%2A> propriedade. No entanto, você pode optar por escrever o <xref:System.Messaging.Message.BodyStream%2A> propriedade diretamente. Isso é útil, por exemplo, quando você deseja abrir uma conexão para um arquivo e transmitir seu conteúdo como o corpo da mensagem.  
  
 A menos que você escreva o conteúdo da mensagem diretamente para o <xref:System.Messaging.Message.BodyStream%2A> propriedade, defina o <xref:System.Messaging.Message.Formatter%2A> propriedade antes de enviar a mensagem. Quando o <xref:System.Messaging.MessageQueue.Send%2A> método é chamado em de <xref:System.Messaging.MessageQueue> instância, o corpo é serializada usando o formatador contido no <xref:System.Messaging.Message.Formatter%2A> propriedade. Se você envia a mensagem sem especificar um valor para o <xref:System.Messaging.Message.Formatter%2A> propriedade, o formatador padrão é <xref:System.Messaging.XmlMessageFormatter>.  
  
 Se você definir a <xref:System.Messaging.Message.UseEncryption%2A> propriedade para `true` para o corpo desta mensagem, a mensagem será criptografada quando enviado, não quando você definir o <xref:System.Messaging.Message.Body%2A> propriedade. Portanto, o <xref:System.Messaging.Message.BodyStream%2A> propriedade nunca é criptografada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.Body" />.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyType">
      <MemberSignature Language="C#" Value="public int BodyType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BodyType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyType" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyType As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BodyType { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BodyType : int with get, set" Usage="System.Messaging.Message.BodyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyType")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tipo de dados que o corpo da mensagem contém.</summary>
        <value>O verdadeiro tipo do corpo da mensagem, como uma cadeia de caracteres, uma data, uma moeda ou um número.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Serviço de enfileiramento reconhece o conteúdo do corpo como um objeto ou como um fluxo serializado. O <xref:System.Messaging.Message.BodyType%2A> propriedade indica o tipo do objeto dentro de <xref:System.Messaging.Message.Body%2A> propriedade da mensagem.  
  
 O <xref:System.Messaging.XmlMessageFormatter> executa a associação entre tipos nativos e o objeto no corpo da mensagem. Se você usar o <xref:System.Messaging.XmlMessageFormatter>, os conjuntos de formatador de <xref:System.Messaging.Message.BodyType%2A> propriedade para você.  
  
 Outros formatadores podem fornecer funcionalidade de associação também, conforme mostrado no código a seguir em C#.  
  
```  
message.Formatter = new ActiveXMessageFormatter();  
object myObject message.Body;  
if (myObject is string) {  
}  
if (myObject is int) {  
}  
if (myObject is float) {  
}  
```  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma mensagem <xref:System.Messaging.Message.BodyType%2A> propriedade.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.Body" />.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ConnectorType">
      <MemberSignature Language="C#" Value="public Guid ConnectorType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ConnectorType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ConnectorType" />
      <MemberSignature Language="VB.NET" Value="Public Property ConnectorType As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid ConnectorType { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectorType : Guid with get, set" Usage="System.Messaging.Message.ConnectorType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgConnectorType")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se algumas propriedades de mensagem geralmente definidas pelo Enfileiramento de Mensagens foram definidas pelo aplicativo de envio.</summary>
        <value>Um <see cref="T:System.Guid" /> definido pelo aplicativo e usado em conjunto com aplicativos de conector ou criptografia de mensagens. Isso <see cref="T:System.Guid" /> permite que um aplicativo de recebimento interpretar as propriedades da mensagem que foram definidos pelo aplicativo de envio, mas que geralmente são definidas pelo enfileiramento de mensagens.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Requer o serviço de enfileiramento de <xref:System.Messaging.Message.ConnectorType%2A> propriedade ser definida sempre que um aplicativo define uma propriedade de mensagem que é normalmente definida pelo enfileiramento de mensagens. Um aplicativo normalmente usa um <xref:System.Messaging.Message.ConnectorType%2A> nos dois casos a seguir:  
  
-   Sempre que um aplicativo conector transmite uma mensagem. O <xref:System.Messaging.Message.ConnectorType%2A> informa os aplicativos de envio e recebimento como interpretar as propriedades de segurança e de confirmação da mensagem.  
  
-   Sempre que o aplicativo de envio, em vez de enfileiramento de mensagens, criptografa uma mensagem. O <xref:System.Messaging.Message.ConnectorType%2A> informa ao enfileiramento de mensagens para usar o <xref:System.Messaging.Message.DestinationSymmetricKey%2A> valor da propriedade para descriptografar a mensagem.  
  
 Você deve definir o <xref:System.Messaging.Message.ConnectorType%2A> propriedade se você definir qualquer uma das seguintes propriedades (caso contrário, a fila ignora essas propriedades quando a mensagem é enviada):  
  
-   <xref:System.Messaging.Message.AuthenticationProviderName%2A>  
  
-   <xref:System.Messaging.Message.AuthenticationProviderType%2A>  
  
-   <xref:System.Messaging.Message.DestinationSymmetricKey%2A>  
  
-   <xref:System.Messaging.Message.DigitalSignature%2A>  
  
-   <xref:System.Messaging.Message.MessageType%2A>  
  
-   <xref:System.Messaging.Message.SenderId%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.ConnectorType" />.</exception>
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DestinationSymmetricKey" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.Message.SenderId" />
      </Docs>
    </Member>
    <Member MemberName="CorrelationId">
      <MemberSignature Language="C#" Value="public string CorrelationId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CorrelationId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.CorrelationId" />
      <MemberSignature Language="VB.NET" Value="Public Property CorrelationId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CorrelationId { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CorrelationId : string with get, set" Usage="System.Messaging.Message.CorrelationId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgCorrelationId")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o identificador de mensagem usado por mensagens de confirmação, relatório e resposta para fazer referência à mensagem original.</summary>
        <value>O identificador de mensagem especificado pela propriedade <see cref="P:System.Messaging.Message.Id" /> da mensagem original. O identificador de correlação é usado pelo serviço de enfileiramento de mensagens ao gerar uma mensagem de confirmação ou de relatório e por um aplicativo quando ele gera uma mensagem de resposta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando o enfileiramento de mensagens gera uma mensagem de confirmação ou de relatório, ele usa a propriedade do identificador de correlação para especificar o identificador da mensagem da mensagem original. Dessa forma, o identificador de correlação vincula a mensagem de confirmação ou de relatório para a mensagem original.  
  
 O aplicativo de envio, em seguida, pode corresponder a confirmação ou relatório com a mensagem original usando o <xref:System.Messaging.Message.CorrelationId%2A> propriedade para identificar a mensagem original <xref:System.Messaging.Message.Id%2A> propriedade.  
  
 Aplicativos do conector também devem definir o <xref:System.Messaging.Message.CorrelationId%2A> propriedade das mensagens de confirmação e o relatório para o identificador da mensagem da mensagem original.  
  
 Quando seu aplicativo envia uma mensagem de resposta para o aplicativo de envio, você pode definir o <xref:System.Messaging.Message.CorrelationId%2A> propriedade da mensagem de resposta para o identificador da mensagem da mensagem original. O aplicativo de envio, em seguida, pode corresponder a sua mensagem de resposta para a mensagem que foi enviada.  
  
   
  
## Examples  
 O exemplo de código a seguir envia e recebe uma mensagem que contém um pedido de e para uma fila. Ele solicita especificamente uma confirmação positiva quando a mensagem original atinge ou é recuperada da fila.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.CorrelationId" />.</exception>
        <exception cref="T:System.ArgumentException">O <see cref="P:System.Messaging.Message.CorrelationId" /> é <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DestinationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue DestinationQueue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue DestinationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationQueue" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DestinationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ DestinationQueue { System::Messaging::MessageQueue ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DestinationQueue : System.Messaging.MessageQueue" Usage="System.Messaging.Message.DestinationQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationQueue")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a fila de destino pretendida para uma mensagem.</summary>
        <value>Um <see cref="T:System.Messaging.MessageQueue" /> que especifica a fila de destino pretendido da mensagem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.Message.DestinationQueue%2A> propriedade é mais comumente usada para determinar o destino original de uma mensagem que chegaram em uma fila de diário ou inatividade. Normalmente, você não precisa examinar essa propriedade, pois você normalmente recupera a mensagem da fila de destino.  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma mensagem <xref:System.Messaging.Message.DestinationQueue%2A> propriedade.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A mensagem não foi enviada. Essa propriedade só pode ser lida em mensagens recuperadas de uma fila.  
  
- ou - 
A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.DestinationQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="DestinationSymmetricKey">
      <MemberSignature Language="C#" Value="public byte[] DestinationSymmetricKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DestinationSymmetricKey" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationSymmetricKey" />
      <MemberSignature Language="VB.NET" Value="Public Property DestinationSymmetricKey As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DestinationSymmetricKey { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DestinationSymmetricKey : byte[] with get, set" Usage="System.Messaging.Message.DestinationSymmetricKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationSymmetricKey")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a chave simétrica usada para criptografar mensagens criptografadas por aplicativos ou mensagens enviadas para filas externas.</summary>
        <value>Uma matriz de valores de byte que especifica a chave simétrica de destino usada para criptografar a mensagem. O padrão é uma matriz de comprimento zero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dois cenários exigem que você use o <xref:System.Messaging.Message.DestinationSymmetricKey%2A> propriedade. A primeira é quando seu aplicativo, em vez de enfileiramento de mensagens, criptografa uma mensagem. A segunda é quando você envia uma mensagem criptografada para um sistema de enfileiramento de mensagens que não seja de enfileiramento de mensagens.  
  
 Antes de definir essa propriedade, você deve criptografar a chave simétrica com a chave pública do Gerenciador de fila de recebimento. Quando você envia uma mensagem criptografada pelo aplicativo, o Gerenciador de fila de recebimento usa a chave simétrica para descriptografar a mensagem antes de enviá-lo para a fila de destino.  
  
 Se você enviar uma mensagem para uma fila externa, a mensagem é recebida pela primeira vez pelo aplicativo conector apropriado, que encaminha a mensagem criptografada com a chave simétrica anexada ao aplicativo de destino. Em seguida, é responsabilidade do aplicativo de recebimento para descriptografar a mensagem usando a chave simétrica.  
  
 Quando você define o <xref:System.Messaging.Message.DestinationSymmetricKey%2A> propriedade, você também deve definir o <xref:System.Messaging.Message.ConnectorType%2A> propriedade. Quando a mensagem é enviada, enfileiramento de mensagens ignora a <xref:System.Messaging.Message.DestinationSymmetricKey%2A> propriedade se o <xref:System.Messaging.Message.ConnectorType%2A> propriedade também não é definida.  
  
 O <xref:System.Messaging.Message.DestinationSymmetricKey%2A> propriedade tem um tamanho máximo da matriz de 256.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.DestinationSymmetricKey" />.</exception>
        <exception cref="T:System.ArgumentException">O <see cref="P:System.Messaging.Message.DestinationSymmetricKey" /> é <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="DigitalSignature">
      <MemberSignature Language="C#" Value="public byte[] DigitalSignature { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DigitalSignature" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DigitalSignature" />
      <MemberSignature Language="VB.NET" Value="Public Property DigitalSignature As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DigitalSignature { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DigitalSignature : byte[] with get, set" Usage="System.Messaging.Message.DigitalSignature" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgDigitalSignature")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a assinatura digital que o Enfileiramento de Mensagens usa ao autenticar a mensagem.</summary>
        <value>Uma matriz de valores de byte que especifica a assinatura digital de 1.0 de enfileiramento de mensagem usada para autenticar a mensagem. O padrão é uma matriz de comprimento zero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Serviço de enfileiramento usa a assinatura digital ao autenticar mensagens que foram enviadas pelo enfileiramento de mensagens versão 1.0. Na maioria dos casos, enfileiramento de mensagens gera e define o <xref:System.Messaging.Message.DigitalSignature%2A> propriedade quando o aplicativo de envio solicita autenticação. O aplicativo de recebimento usa essa propriedade para recuperar a assinatura digital anexada à mensagem.  
  
 Você só pode usar o <xref:System.Messaging.Message.DigitalSignature%2A> propriedade ao executar a versão 2.0 do enfileiramento de mensagens. O aplicativo de envio deve especificar a assinaturas de versão 1.0 de enfileiramento de mensagens ao solicitar a autenticação. Se o aplicativo de envio envia uma assinatura de versão 2.0 do enfileiramento de mensagens, esta propriedade contém um buffer de quatro bytes, cada contendo zero.  
  
 O <xref:System.Messaging.Message.DigitalSignature%2A> propriedade, junto com o <xref:System.Messaging.Message.SenderCertificate%2A> propriedade, também é usado por aplicativos de conector quando uma mensagem é enviada. Nesse cenário, o conector aplicativo - em vez de enfileiramento de mensagens - gera a assinatura digital, o que ele se baseia no certificado de usuário que está enviando a mensagem.  
  
 O <xref:System.Messaging.Message.DigitalSignature%2A> propriedade tem um tamanho máximo da matriz de 256.  
  
 Quando você define o <xref:System.Messaging.Message.DigitalSignature%2A> propriedade, você também deve definir o <xref:System.Messaging.Message.ConnectorType%2A> propriedade. Quando uma mensagem é enviada, enfileiramento de mensagens ignora a <xref:System.Messaging.Message.DigitalSignature%2A> propriedade se o <xref:System.Messaging.Message.ConnectorType%2A> propriedade também não é definida.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.DigitalSignature" />.</exception>
        <exception cref="T:System.ArgumentException">A propriedade <see cref="P:System.Messaging.Message.DigitalSignature" /> é <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionAlgorithm EncryptionAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionAlgorithm EncryptionAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.EncryptionAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionAlgorithm As EncryptionAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionAlgorithm EncryptionAlgorithm { System::Messaging::EncryptionAlgorithm get(); void set(System::Messaging::EncryptionAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionAlgorithm : System.Messaging.EncryptionAlgorithm with get, set" Usage="System.Messaging.Message.EncryptionAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgEncryptionAlgorithm")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o algoritmo de criptografia usado para criptografar o corpo de uma mensagem privada.</summary>
        <value>Um dos valores de enumeração <see cref="T:System.Messaging.EncryptionAlgorithm" />. O padrão é <see langword="RC2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se uma mensagem for privada (criptografada), ele é criptografado antes de ser enviado e descriptografado após o recebimento. O <xref:System.Messaging.Message.EncryptionAlgorithm%2A> propriedade especifica o algoritmo usado para criptografar o corpo da mensagem de uma mensagem privada.  
  
 Uma fila pode exigir entrada mensagens ser criptografadas. Se um aplicativo envia uma mensagem de (não particular) não criptografadas para uma fila que aceita apenas mensagens privadas ou se ele envia uma mensagem privada para uma fila que aceita apenas mensagens de não-particular, a fila rejeitará a mensagem. O aplicativo de envio pode solicitar que uma mensagem de confirmação negativa retornado nesse caso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.EncryptionAlgorithm" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="T:System.Messaging.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="Extension">
      <MemberSignature Language="C#" Value="public byte[] Extension { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Extension" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Extension" />
      <MemberSignature Language="VB.NET" Value="Public Property Extension As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Extension { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Extension : byte[] with get, set" Usage="System.Messaging.Message.Extension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgExtension")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define informações adicionais definidas pelo aplicativo associadas à mensagem.</summary>
        <value>Uma matriz de valores de byte que fornece informações definidas pelo aplicativo associadas à mensagem. O padrão é uma matriz de comprimento zero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.Message.Extension%2A> propriedade fornece para informações definidas pelo aplicativo, como um objeto binário grande, que está associado com a mensagem. É responsabilidade do aplicativo de recebimento para interpretar o conteúdo a <xref:System.Messaging.Message.Extension%2A> propriedade.  
  
 Sempre que possível, você deve incluir dados da mensagem na <xref:System.Messaging.Message.Body%2A> propriedade da mensagem, em vez do <xref:System.Messaging.Message.Extension%2A> propriedade.  
  
 Ao trabalhar com filas externas, use o <xref:System.Messaging.Message.Extension%2A> propriedade para especificar as propriedades de mensagem que não existem no enfileiramento de mensagens.  
  
 Existe uma fila externa em um sistema de enfileiramento de mensagens que não seja de enfileiramento de mensagens da Microsoft. Serviço de enfileiramento se comunica com essas filas por meio de um aplicativo conector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.Extension" />.</exception>
        <exception cref="T:System.ArgumentException">A propriedade <see cref="P:System.Messaging.Message.Extension" /> é <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.Message.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o formatador usado para serializar ou desserializar um objeto do corpo da mensagem.</summary>
        <value>O <see cref="T:System.Messaging.IMessageFormatter" /> que produz um fluxo a ser gravado ou lido do corpo da mensagem. O padrão é <see cref="T:System.Messaging.XmlMessageFormatter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Messaging.Message.Formatter%2A> propriedade durante a leitura e gravação de uma mensagem. Quando uma mensagem é enviada à fila, o formatador que serializa o <xref:System.Messaging.Message.Body%2A> propriedade em um fluxo que pode ser enviado para a fila de mensagens. Ao ler de uma fila, o formatador desserializa os dados da mensagem para o <xref:System.Messaging.Message.Body%2A> propriedade.  
  
 A menos que você escreva o conteúdo da mensagem diretamente para o <xref:System.Messaging.Message.BodyStream%2A> propriedade, defina o <xref:System.Messaging.Message.Formatter%2A> propriedade antes de enviar a mensagem. Quando o <xref:System.Messaging.MessageQueue.Send%2A> método é chamado em de <xref:System.Messaging.MessageQueue> instância, o corpo é serializada usando o formatador contido no <xref:System.Messaging.Message.Formatter%2A> propriedade. Se você envia a mensagem sem especificar um valor para o <xref:System.Messaging.Message.Formatter%2A> propriedade, o formatador padrão é <xref:System.Messaging.XmlMessageFormatter>.  
  
 O <xref:System.Messaging.XmlMessageFormatter> está acoplado livremente, portanto, não é necessário ter o mesmo objeto de tipo no remetente e receptor ao usar esse formato. O <xref:System.Messaging.ActiveXMessageFormatter> e <xref:System.Messaging.BinaryMessageFormatter> serializar os dados em representação binária. O <xref:System.Messaging.ActiveXMessageFormatter> é usado ao enviar ou receber os componentes COM.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra a formatação de um corpo de mensagem usando <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 O exemplo de código a seguir demonstra a formatação de um corpo de mensagem usando <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A propriedade <see cref="P:System.Messaging.Message.Formatter" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.MessageQueue.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.HashAlgorithm HashAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.HashAlgorithm HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property HashAlgorithm As HashAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::HashAlgorithm HashAlgorithm { System::Messaging::HashAlgorithm get(); void set(System::Messaging::HashAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.HashAlgorithm : System.Messaging.HashAlgorithm with get, set" Usage="System.Messaging.Message.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgHashAlgorithm")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.HashAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o algoritmo de hash que o Enfileiramento de Mensagens usa ao autenticar uma mensagem ou criar uma assinatura digital para uma mensagem.</summary>
        <value>Um dos valores de enumeração <see cref="T:System.Messaging.HashAlgorithm" />. Para o Windows XP, o padrão é <see langword="SHA" />. Caso contrário, o padrão é <see langword="MD5" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No computador de origem, o enfileiramento de mensagens usa o algoritmo de hash durante a criação de uma assinatura digital para uma mensagem. O Gerenciador de fila de destino, em seguida, usa o mesmo algoritmo de hash para autenticar a mensagem quando ela é recebida.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.HashAlgorithm" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public string Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Id { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : string" Usage="System.Messaging.Message.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgId")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o identificador da mensagem.</summary>
        <value>O identificador exclusivo da mensagem, que é gerado pelo Enfileiramento de Mensagens.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Serviço de enfileiramento gera um identificador de mensagem quando a mensagem é enviada. O identificador é composto de 20 bytes e inclui dois itens: a máquina <xref:System.Guid> do computador de envio e um identificador exclusivo para a mensagem no computador. A combinação dos dois itens produz um identificador de mensagem que é exclusivo na rede.  
  
 Serviço de enfileiramento gera identificadores de mensagem para todas as mensagens - incluindo mensagens de confirmação e o relatório. Em geral, uma mensagem de confirmação é enviada pelo enfileiramento de mensagens em reação a de chegada ou a falha de uma mensagem original, enviada. Você pode encontrar o <xref:System.Messaging.Message.Id%2A> valor da propriedade da mensagem original na <xref:System.Messaging.Message.CorrelationId%2A> propriedade de uma mensagem de confirmação.  
  
 Você também pode usar o <xref:System.Messaging.Message.Id%2A> propriedade ao enviar uma mensagem de resposta para uma fila de resposta. Para incluir o identificador da mensagem original em uma mensagem de resposta, defina as <xref:System.Messaging.Message.CorrelationId%2A> propriedade da mensagem de resposta para o <xref:System.Messaging.Message.Id%2A> propriedade da mensagem original. O aplicativo que lê a mensagem de resposta, em seguida, pode usar o identificador de correlação da mensagem de resposta para identificar a mensagem original.  
  
   
  
## Examples  
 O exemplo de código a seguir envia e recebe uma mensagem contendo um pedido de e para uma fila. Ele solicita especificamente uma confirmação positiva quando a mensagem original atinge ou é recuperada da fila.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A mensagem não foi enviada. Essa propriedade só pode ser lida em mensagens recuperadas de uma fila.  
  
- ou - 
A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.Id" />.</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.Message.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.Message.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que não existe tempo limite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A> e <xref:System.Messaging.Message.TimeToReachQueue%2A> requerem um valor que especifica um tempo limite. Para o primeiro, o tempo limite é o tempo máximo permitido para uma mensagem a ser recebida da fila. Para o último, o tempo limite é o tempo permitido para uma mensagem chegar à fila. Em ambos os casos, você pode especificar o tempo limite como um número de segundos ou usar <xref:System.Messaging.Message.InfiniteTimeout> para indicar que nenhum tempo limite existe.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Messaging.Message.InfiniteTimeout> campo.  
  
  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
      </Docs>
    </Member>
    <Member MemberName="IsFirstInTransaction">
      <MemberSignature Language="C#" Value="public bool IsFirstInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFirstInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsFirstInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFirstInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFirstInTransaction { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFirstInTransaction : bool" Usage="System.Messaging.Message.IsFirstInTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgIsFirstInTransaction")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a mensagem foi a primeira mensagem enviada em uma transação.</summary>
        <value><see langword="true" /> Se a mensagem foi a primeira mensagem enviada em uma transação; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recebendo o uso de aplicativos a <xref:System.Messaging.Message.IsFirstInTransaction%2A> propriedade para verificar se uma mensagem foi a primeira mensagem enviada em uma única transação para uma única fila.  
  
 Essa propriedade está disponível apenas com o enfileiramento de mensagens versão 2.0 e posterior.  
  
 Para verificar os limites de transação, você pode usar o <xref:System.Messaging.Message.IsFirstInTransaction%2A> propriedade juntamente com outras duas propriedades: <xref:System.Messaging.Message.IsLastInTransaction%2A> e <xref:System.Messaging.Message.TransactionId%2A>. Use o primeiro para verificar se uma mensagem foi a última mensagem enviada na transação e use a última opção para recuperar o identificador da transação.  
  
 Se apenas uma mensagem é enviada em uma transação, o <xref:System.Messaging.Message.IsFirstInTransaction%2A> e <xref:System.Messaging.Message.IsLastInTransaction%2A> propriedades são definidas como `true`.  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma mensagem <xref:System.Messaging.Message.IsFirstInTransaction%2A> propriedade.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A mensagem não foi enviada. Essa propriedade só pode ser lida em mensagens recuperadas de uma fila.  
  
- ou - 
A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.IsFirstInTransaction" />.</exception>
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="IsLastInTransaction">
      <MemberSignature Language="C#" Value="public bool IsLastInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLastInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsLastInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLastInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLastInTransaction { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLastInTransaction : bool" Usage="System.Messaging.Message.IsLastInTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgIsLastInTransaction")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a mensagem foi a última mensagem enviada em uma transação.</summary>
        <value><see langword="true" /> Se a mensagem foi a última mensagem enviada em uma única transação; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recebendo o uso de aplicativos a <xref:System.Messaging.Message.IsLastInTransaction%2A> propriedade para verificar se uma mensagem foi a última mensagem enviada em uma única transação para uma única fila.  
  
 Essa propriedade está disponível apenas com o enfileiramento de mensagens versão 2.0 e posterior.  
  
 Para verificar os limites de transação, você pode usar o <xref:System.Messaging.Message.IsLastInTransaction%2A> propriedade juntamente com outras duas propriedades: <xref:System.Messaging.Message.IsFirstInTransaction%2A> e <xref:System.Messaging.Message.TransactionId%2A>. Use o primeiro para verificar se uma mensagem foi a primeira mensagem enviada na transação e use a última opção para recuperar o identificador da transação.  
  
 Se apenas uma mensagem é enviada em uma transação, o <xref:System.Messaging.Message.IsFirstInTransaction%2A> e <xref:System.Messaging.Message.IsLastInTransaction%2A> propriedades são definidas como `true`.  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma mensagem <xref:System.Messaging.Message.IsLastInTransaction%2A> propriedade.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A mensagem não foi enviada. Essa propriedade só pode ser lida em mensagens recuperadas de uma fila.  
  
- ou - 
A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.IsLastInTransaction" />.</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.Message.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgLabel")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define uma cadeia de caracteres Unicode definida pelo aplicativo que descreve a mensagem.</summary>
        <value>O rótulo da mensagem. O padrão é uma cadeia de caracteres vazia ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar um rótulo de mensagem para várias finalidades. Por exemplo, você pode usá-lo para fins de exibição ou seletivamente processar mensagens com base no valor do rótulo. O rótulo não precisa ser exclusivo entre as mensagens.  
  
 Fila de mensagens e a mensagem rótulos representam um valor definido pelo aplicativo que pode ajudar a identificam a fila ou mensagem em termos legível por humanos. É responsabilidade do aplicativo para interpretar o conteúdo de rótulo, que não têm nenhum significado intrínseco para o aplicativo de enfileiramento de mensagens.  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma mensagem <xref:System.Messaging.Message.Label%2A> propriedade.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.Label" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName="LookupId">
      <MemberSignature Language="C#" Value="public long LookupId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LookupId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.LookupId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LookupId As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LookupId { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LookupId : int64" Usage="System.Messaging.Message.LookupId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Introduzido no MSMQ 3.0. Obtém o identificador de pesquisa da mensagem.</summary>
        <value>O identificador de pesquisa da mensagem, que é gerado pelo Enfileiramento de Mensagens e é exclusivo da fila em que a mensagem reside.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.Message.LookupId%2A> propriedade fornece acesso somente leitura ao identificador de pesquisa da mensagem. O identificador de pesquisa, introduzido no MSMQ 3.0, é um identificador de 64 bits que é gerado pelo enfileiramento de mensagens e atribuído a cada mensagem quando a mensagem é colocada na fila. O identificador de pesquisa não é o mesmo que o identificador de mensagem que é gerado quando a mensagem é enviada.  
  
 Serviço de enfileiramento gera um identificador de pesquisa para todas as mensagens são colocadas em qualquer fila, incluindo os gerados pelo aplicativo de destino, administração e filas de relatórios, bem como diário gerados pelo sistema, aceitas, conector e filas de saída. Em outras palavras, isso inclui a ambas as mensagens enviadas por aplicativos de envio e pelo enfileiramento de mensagens. O identificador de pesquisa é exclusivo para a fila e não tem nenhum significado fora da fila.  
  
 Se uma mensagem é enviada para várias filas de destino, ou se uma cópia de uma mensagem é armazenada em um diário de computador ou fila, cada cópia da mensagem terá seu próprio identificador de pesquisa quando ele é colocado na respectiva fila.  
  
 O <xref:System.Messaging.Message.LookupId%2A> propriedade só pode ser lida em mensagens recuperadas de uma fila.  
  
 Um identificador de pesquisa é usado para ler uma mensagem específica na fila. Depois que o identificador de pesquisa de uma mensagem for conhecido, o aplicativo de recebimento pode chamar o <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> ou <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> função para ir diretamente para essa mensagem e inspecionar ou recuperá-la da fila, ao contrário de cursores deve começar no início da fila e Navegue até o final da fila,  
  
 Como obter os identificadores de pesquisa das mensagens na fila é de responsabilidade do aplicativo. Uma abordagem possível para obter os identificadores de pesquisa é criar um gatilho da fila de destino que chama um componente que armazena em cache os identificadores de cada mensagem conforme eles são colocados na fila.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">O MSMQ 3.0 não está instalado.</exception>
        <exception cref="T:System.InvalidOperationException">A mensagem não foi enviada. Essa propriedade só pode ser lida em mensagens recuperadas de uma fila.  
  
- ou - 
A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.LookupId" />.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="MessageType">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageType MessageType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessageType MessageType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.MessageType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MessageType As MessageType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageType MessageType { System::Messaging::MessageType get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageType : System.Messaging.MessageType" Usage="System.Messaging.Message.MessageType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgMessageType")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tipo de mensagem: <see langword="Normal" />, <see langword="Acknowledgment" /> ou <see langword="Report" />.</summary>
        <value>Um dos valores de <see cref="P:System.Messaging.Message.MessageType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Serviço de enfileiramento normalmente define essa propriedade quando ele envia a mensagem. Uma mensagem de enfileiramento de mensagens pode ser um dos seguintes tipos:  
  
-   `Normal`, que é uma mensagem típica enviada de um aplicativo para uma fila ou uma mensagem de resposta retornados para o aplicativo de envio.  
  
-   `Acknowledgement`, que o enfileiramento de mensagens gera sempre que o aplicativo de envio solicita uma. Por exemplo, o enfileiramento de mensagens pode gerar mensagens de positivas ou negativas para indicar que a mensagem original chegou ou foi lido. Serviço de enfileiramento retorna a mensagem de confirmação apropriada para a fila de administração especificada pelo aplicativo de envio.  
  
-   `Report`, que o enfileiramento de mensagens gera sempre que uma fila de relatórios é definida na fonte de Gerenciador de fila. Quando o rastreamento está habilitado, enfileiramento de mensagens envia uma mensagem de relatório para a fila de enfileiramento de mensagens de relatório sempre que a mensagem original entra ou sai de um servidor de enfileiramento de mensagens.  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma mensagem <xref:System.Messaging.Message.MessageType%2A> propriedade.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A mensagem não foi enviada. Essa propriedade só pode ser lida em mensagens recuperadas de uma fila.  
  
- ou - 
A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.MessageType" />.</exception>
        <altmember cref="T:System.Messaging.MessageType" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessagePriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As MessagePriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePriority Priority { System::Messaging::MessagePriority get(); void set(System::Messaging::MessagePriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Messaging.MessagePriority with get, set" Usage="System.Messaging.Message.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgPriority")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a prioridade da mensagem, que determina o local na fila em que a mensagem foi colocada.</summary>
        <value>Um dos valores <see cref="T:System.Messaging.MessagePriority" /> que representa os níveis de prioridade de mensagens não transacionais. O padrão é <see langword="Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.Message.Priority%2A> propriedade afeta como enfileiramento lida com a mensagem enquanto ele estiver em trânsito e após ele atingir seu destino. Mensagens de prioridade mais alta são dada preferência durante o roteamento e inseridas em direção à frente da fila de destino. Mensagens com a mesma prioridade são colocadas na fila de acordo com a hora de chegada.  
  
 Você pode definir uma prioridade significativa apenas para mensagens não transacionais. Serviço de enfileiramento define automaticamente a prioridade de mensagens transacionais para `Lowest`, que faz com que a prioridade da mensagem transacional a serem ignorados.  
  
   
  
## Examples  
 O exemplo de código a seguir envia duas mensagens de prioridades diferentes para a fila e recupera-los posteriormente.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.Priority" />.</exception>
        <altmember cref="T:System.Messaging.MessagePriority" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.MessageQueue.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="Recoverable">
      <MemberSignature Language="C#" Value="public bool Recoverable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Recoverable" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Recoverable" />
      <MemberSignature Language="VB.NET" Value="Public Property Recoverable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Recoverable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Recoverable : bool with get, set" Usage="System.Messaging.Message.Recoverable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgRecoverable")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se há garantia de que a mensagem seja entregue no caso de um problema de rede ou falha do computador.</summary>
        <value><see langword="true" /> se a entrega da mensagem for assegurada (por meio do salvamento da mensagem em disco enquanto trafegam); <see langword="false" /> se a entrega não for assegurada. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.Message.Recoverable%2A> propriedade indica se a entrega de uma mensagem é garantida - mesmo que um computador trave enquanto a mensagem estiver em trânsito para a fila de destino.  
  
 Se a entrega de uma mensagem é garantida, a mensagem é armazenada localmente em cada etapa ao longo da rota, até que a mensagem com êxito é encaminhada para o próximo computador. Definindo o <xref:System.Messaging.Message.Recoverable%2A> propriedade para `true` poderia afetar a taxa de transferência.  
  
 Se a mensagem for transacional, enfileiramento de mensagens automaticamente trata a mensagem como recuperável, independentemente do valor de <xref:System.Messaging.Message.Recoverable%2A> propriedade.  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma mensagem <xref:System.Messaging.Message.Recoverable%2A> propriedade.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.Recoverable" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="ResponseQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue ResponseQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue ResponseQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ResponseQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property ResponseQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ ResponseQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResponseQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.ResponseQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgResponseQueue")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a fila que recebe mensagens de resposta geradas por aplicativo.</summary>
        <value>O <see cref="T:System.Messaging.MessageQueue" /> para qual resposta gerados pelo aplicativo as mensagens são retornadas. O padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.Message.ResponseQueue%2A> propriedade identifica a fila que recebe mensagens de resposta geradas por aplicativo, que o aplicativo de recebimento retorna para o aplicativo de envio. O aplicativo de envio Especifica as filas de resposta quando o aplicativo envia suas mensagens. Nenhuma fila disponível pode ser especificada como uma fila de resposta.  
  
 As mensagens retornadas para a fila de resposta são específicas do aplicativo. O aplicativo deve definir o conteúdo de mensagens, bem como a ação entrem após o recebimento de uma mensagem.  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma mensagem <xref:System.Messaging.Message.ResponseQueue%2A> propriedade.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.ResponseQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
      </Docs>
    </Member>
    <Member MemberName="SecurityContext">
      <MemberSignature Language="C#" Value="public System.Messaging.SecurityContext SecurityContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.SecurityContext SecurityContext" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Property SecurityContext As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::SecurityContext ^ SecurityContext { System::Messaging::SecurityContext ^ get(); void set(System::Messaging::SecurityContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityContext : System.Messaging.SecurityContext with get, set" Usage="System.Messaging.Message.SecurityContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o contexto de segurança para uma mensagem.</summary>
        <value>Um <see cref="T:System.Messaging.SecurityContext" /> objeto que contém o contexto de segurança para uma mensagem, se a propriedade tiver sido definida previamente; caso contrário, NULL.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SenderCertificate">
      <MemberSignature Language="C#" Value="public byte[] SenderCertificate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Property SenderCertificate As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderCertificate { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SenderCertificate : byte[] with get, set" Usage="System.Messaging.Message.SenderCertificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderCertificate")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o certificado de segurança usado para autenticar mensagens.</summary>
        <value>Uma matriz de valores de byte que representa um certificado de segurança, enfileiramento de mensagens usa para verificar o remetente da mensagem. O padrão é uma matriz de comprimento zero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O aplicativo de recebimento usa o <xref:System.Messaging.Message.SenderCertificate%2A> propriedade quando a mensagem inclui um certificado de segurança externas.  
  
 O enfileiramento pode autenticar uma mensagem usando um certificado de segurança internos ou externos. Serviço de enfileiramento fornece certificados internos, que são usados para verificar a integridade da mensagem. Uma autoridade de certificação fornece um certificado externo, que pode ser acessado por meio de <xref:System.Messaging.Message.SenderCertificate%2A> propriedade da mensagem. Além de permitir que o enfileiramento de mensagens autenticar a mensagem, um certificado externo permite que o aplicativo de recebimento verificar o remetente. Um certificado interno tem nenhum valor utilizável para um aplicativo de recebimento.  
  
 Um certificado externo deve ser registrado com o serviço de diretório do sistema de enfileiramento de mensagens. Um certificado externo contém informações sobre a autoridade de certificação, o usuário do certificado, o período de validade do certificado, a chave pública do usuário, certificado e a assinatura da autoridade de certificação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.SenderCertificate" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
      </Docs>
    </Member>
    <Member MemberName="SenderId">
      <MemberSignature Language="C#" Value="public byte[] SenderId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderId As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderId { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SenderId : byte[]" Usage="System.Messaging.Message.SenderId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderId")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o identificador do usuário remetente.</summary>
        <value>Uma matriz de valores de bytes que identifica o remetente. O Gerenciador de Fila de recebimento usa o identificador quando autentica a mensagem para verificar o remetente da mensagem e os direitos de acesso do remetente à fila.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o <xref:System.Messaging.Message.AttachSenderId%2A> é de propriedade `false`, o identificador do remetente especificado no <xref:System.Messaging.Message.SenderId%2A> propriedade não está anexada à mensagem quando ela é enviada. Isso indica ao enfileiramento de mensagens que o remetente não deve ser validado quando ele envia a mensagem à fila de destino. Se o <xref:System.Messaging.Message.AttachSenderId%2A> é de propriedade `true`, o <xref:System.Messaging.Message.SenderId%2A> valor da propriedade é confiável somente se a mensagem foi autenticada. Use o <xref:System.Messaging.Message.Authenticated%2A> propriedade em conjunto com o <xref:System.Messaging.Message.SenderId%2A> propriedade para verificar os direitos de acesso do remetente.  
  
 Um aplicativo conector é um aplicativo que usa um servidor de conector para fornecer comunicação entre o enfileiramento de mensagens e outros sistemas de enfileiramento de mensagens. Serviço de enfileiramento requer que os aplicativos de conector para fornecer a identificação do remetente. Você deve definir o <xref:System.Messaging.Message.ConnectorType%2A> propriedade ao enviar uma mensagem por meio de um aplicativo conector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A mensagem não foi enviada. Essa propriedade só pode ser lida em mensagens recuperadas de uma fila.  
  
- ou - 
A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.SenderId" />.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
      </Docs>
    </Member>
    <Member MemberName="SenderVersion">
      <MemberSignature Language="C#" Value="public long SenderVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 SenderVersion" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderVersion As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long SenderVersion { long get(); };" />
      <MemberSignature Language="F#" Value="member this.SenderVersion : int64" Usage="System.Messaging.Message.SenderVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderVersion")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a versão do Enfileiramento de Mensagens usado para enviar a mensagem.</summary>
        <value>A versão do serviço de enfileiramento de mensagens usado para enviar a mensagem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.Message.SenderVersion%2A> propriedade é importante para determinados recursos. Por exemplo, o processamento de transações é suportado somente pelo Message Queuing 2.0 e posteriores, e assinaturas digitais são usadas para autenticar as mensagens enviadas pelo MSMQ 1.0.  
  
 Os conjuntos de Gerenciador de fila de envio de <xref:System.Messaging.Message.SenderVersion%2A> propriedade quando a mensagem é enviada.  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma mensagem <xref:System.Messaging.Message.SenderVersion%2A> propriedade.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A mensagem não foi enviada. Essa propriedade só pode ser lida em mensagens recuperadas de uma fila.  
  
- ou - 
A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.SenderVersion" />.</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="SentTime">
      <MemberSignature Language="C#" Value="public DateTime SentTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime SentTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SentTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SentTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime SentTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.SentTime : DateTime" Usage="System.Messaging.Message.SentTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSentTime")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a data e a hora no computador de envio em que a mensagem foi enviada pelo gerenciador de fila de origem.</summary>
        <value>Um <see cref="T:System.DateTime" /> que representa a hora em que a mensagem foi enviada.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.Message.SentTime%2A> propriedade é ajustada para a hora local do computador no qual essa instância da <xref:System.Messaging.Message> classe foi criada. Esse fuso horário pode ser diferente das filas de origem e de destino.  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma mensagem <xref:System.Messaging.Message.SentTime%2A> propriedade.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A mensagem não foi enviada. Essa propriedade só pode ser lida em mensagens recuperadas de uma fila.  
  
- ou - 
A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.SentTime" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SourceMachine">
      <MemberSignature Language="C#" Value="public string SourceMachine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SourceMachine" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SourceMachine" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SourceMachine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SourceMachine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SourceMachine : string" Usage="System.Messaging.Message.SourceMachine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSourceMachine")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o computador que originou a mensagem.</summary>
        <value>O nome do computador do qual a mensagem foi enviada.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O formato do <xref:System.Messaging.Message.SourceMachine%2A> propriedade não inclui anterior duas barras "/" (\\\\). Por exemplo, `myServer` é válido <xref:System.Messaging.Message.SourceMachine%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma mensagem <xref:System.Messaging.Message.SourceMachine%2A> propriedade.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A mensagem não foi enviada. Essa propriedade só pode ser lida em mensagens recuperadas de uma fila.  
  
- ou - 
A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.SourceMachine" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Não foi possível acessar o serviço de diretório ou informações do computador.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="TimeToBeReceived">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToBeReceived { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToBeReceived" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToBeReceived" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToBeReceived As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToBeReceived { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToBeReceived : TimeSpan with get, set" Usage="System.Messaging.Message.TimeToBeReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToBeReceived")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.TimeoutConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a quantidade máxima de tempo para a mensagem a ser recebida da fila de destino.</summary>
        <value>O tempo total para uma mensagem enviada ser recebida da fila de destino. O padrão é <see cref="F:System.Messaging.Message.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.Message.TimeToBeReceived%2A> propriedade especifica o tempo total para uma mensagem enviada ser recebida da fila de destino. O limite de tempo inclui o tempo gasto na introdução para a fila de destino e o tempo gasto aguardando na fila antes que a mensagem é recebida.  
  
> [!CAUTION]
>  Ao usar computadores cliente dependentes, certifique-se de que o relógio no computador cliente é sincronizado com o relógio do servidor que está executando o enfileiramento de mensagens. Caso contrário, um comportamento imprevisível pode resultar ao enviar uma mensagem cuja <xref:System.Messaging.Message.TimeToBeReceived%2A> propriedade não é <xref:System.Messaging.Message.InfiniteTimeout>.  
  
 Se o intervalo especificado pelo <xref:System.Messaging.Message.TimeToBeReceived%2A> propriedade expira antes que a mensagem é removida da fila, enfileiramento de mensagens descartará a mensagem em uma das duas maneiras. Se a mensagem <xref:System.Messaging.Message.UseDeadLetterQueue%2A> é de propriedade `true`, a mensagem é enviada para a fila de inatividade. Se <xref:System.Messaging.Message.UseDeadLetterQueue%2A> é `false`, a mensagem será ignorada.  
  
 Você pode definir a mensagem <xref:System.Messaging.Message.AcknowledgeType%2A> propriedade para solicitar que o serviço de enfileiramento de mensagens envia uma mensagem de confirmação negativa de volta para o aplicativo de envio se a mensagem não será recuperada antes do temporizador expirar.  
  
 Se o valor especificado pela <xref:System.Messaging.Message.TimeToBeReceived%2A> propriedade é menor que o valor especificado pela <xref:System.Messaging.Message.TimeToReachQueue%2A> propriedade, <xref:System.Messaging.Message.TimeToBeReceived%2A> terá precedência.  
  
 Quando várias mensagens são enviadas em uma única transação, enfileiramento de mensagens usa o <xref:System.Messaging.Message.TimeToBeReceived%2A> propriedade da primeira mensagem.  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma mensagem <xref:System.Messaging.Message.TimeToBeReceived%2A> propriedade.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.TimeToBeReceived" />.</exception>
        <exception cref="T:System.ArgumentException">O valor especificado para <see cref="P:System.Messaging.Message.TimeToBeReceived" /> é inválido.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TimeToReachQueue">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToReachQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToReachQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToReachQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToReachQueue As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToReachQueue { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToReachQueue : TimeSpan with get, set" Usage="System.Messaging.Message.TimeToReachQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToReachQueue")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.TimeoutConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a quantidade máxima de tempo para a mensagem chegar à fila.</summary>
        <value>O tempo limite para a mensagem chegar à fila de destino, a partir do momento a mensagem é enviada. O padrão é <see cref="F:System.Messaging.Message.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o intervalo especificado pelo <xref:System.Messaging.Message.TimeToReachQueue%2A> propriedade expira antes que a mensagem atinge seu destino, enfileiramento de mensagens descartará a mensagem em uma das duas maneiras. Se a mensagem <xref:System.Messaging.Message.UseDeadLetterQueue%2A> é de propriedade `true`, a mensagem é enviada para a fila de inatividade. Se <xref:System.Messaging.Message.UseDeadLetterQueue%2A> é `false`, a mensagem será ignorada  
  
 Você pode definir uma mensagem de he <xref:System.Messaging.Message.AcknowledgeType%2A> propriedade para solicitar que o serviço de enfileiramento de mensagens envia uma mensagem de confirmação negativa de volta para o aplicativo de envio se a mensagem não chegou antes do temporizador expirar.  
  
 Se o <xref:System.Messaging.Message.TimeToReachQueue%2A> estiver definida como 0 segundo, o enfileiramento de mensagens tenta uma vez enviar a mensagem para seu destino - se a fila está esperando a mensagem. Se a fila for local, a mensagem chega sempre-lo.  
  
 Se o valor especificado pela <xref:System.Messaging.Message.TimeToReachQueue%2A> propriedade é maior que o valor especificado pela <xref:System.Messaging.Message.TimeToBeReceived%2A> propriedade, <xref:System.Messaging.Message.TimeToBeReceived%2A> terá precedência.  
  
 Quando várias mensagens são enviadas em uma única transação, enfileiramento de mensagens usa o <xref:System.Messaging.Message.TimeToReachQueue%2A> propriedade da primeira mensagem.  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma mensagem <xref:System.Messaging.Message.TimeToReachQueue%2A> propriedade.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.TimeToReachQueue" />.</exception>
        <exception cref="T:System.ArgumentException">O valor especificado para <see cref="P:System.Messaging.Message.TimeToReachQueue" /> é inválido. Pode representar um número negativo.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransactionId">
      <MemberSignature Language="C#" Value="public string TransactionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransactionId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransactionId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransactionId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TransactionId : string" Usage="System.Messaging.Message.TransactionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionId")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o identificador para a transação da qual a mensagem fazia parte.</summary>
        <value>O identificador da transação associada à mensagem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recebendo o uso de aplicativos a <xref:System.Messaging.Message.TransactionId%2A> propriedade para verificar se uma mensagem foi enviada como parte de uma transação específica. O identificador da transação contém o identificador do computador de envio (primeiros 16 bits) seguido por um número de sequência de transação de 4 bytes.  
  
 Essa propriedade está disponível apenas para o enfileiramento de mensagens versão 2.0 e posterior.  
  
 Identificadores de transação não têm garantia de ser exclusivo, pois os números de sequência de transação não são persistentes, e eles recomeçar novamente em 2 <sup>20</sup>. Serviço de enfileiramento apenas garante que as transações subsequentes tenham números de sequência de transação diferente.  
  
 Você pode usar o <xref:System.Messaging.Message.TransactionId%2A> propriedade juntamente com o <xref:System.Messaging.Message.IsFirstInTransaction%2A> e <xref:System.Messaging.Message.IsLastInTransaction%2A> propriedades para verificar os limites de transação.  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma mensagem <xref:System.Messaging.Message.TransactionId%2A> propriedade.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A mensagem não foi enviada. Essa propriedade só pode ser lida em mensagens recuperadas de uma fila.  
  
- ou - 
A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.TransactionId" />.</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="TransactionStatusQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue TransactionStatusQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue TransactionStatusQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionStatusQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionStatusQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ TransactionStatusQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionStatusQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.TransactionStatusQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionStatusQueue")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a fila de status de transação no computador de origem.</summary>
        <value>A fila de status de transação no computador de origem, que é usado para enviar mensagens de confirmação de volta para o aplicativo de envio. O padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.Message.TransactionStatusQueue%2A> propriedade identifica a fila transacional no computador de origem que recebe confirmações de recebimento de leitura de aplicativos do conector. O enfileiramento define a propriedade e aplicativos de conector para usar a propriedade ao recuperar mensagens transacionais enviadas para filas estrangeiras.  
  
 Existe uma fila externa em um sistema de enfileiramento de mensagens que não seja de enfileiramento de mensagens da Microsoft. Serviço de enfileiramento se comunica com essas filas por meio de um aplicativo conector.  
  
 O aplicativo connector pode usar a fila de status de transação para enviar mensagens de confirmação de volta para o aplicativo de envio. A fila de status de transação deve receber essas confirmações, mesmo se o aplicativo de envio não solicita outras confirmações.  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma mensagem <xref:System.Messaging.Message.TransactionStatusQueue%2A> propriedade.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A mensagem não foi enviada. Essa propriedade só pode ser lida em mensagens recuperadas de uma fila.  
  
- ou - 
A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.TransactionStatusQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
      </Docs>
    </Member>
    <Member MemberName="UseAuthentication">
      <MemberSignature Language="C#" Value="public bool UseAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UseAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseAuthentication { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseAuthentication : bool with get, set" Usage="System.Messaging.Message.UseAuthentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseAuthentication")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se a mensagem foi (ou deve ser) autenticada antes de ser enviada.</summary>
        <value><see langword="true" /> se o aplicativo de envio tiver solicitado a autenticação para a mensagem; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.Message.UseAuthentication%2A> propriedade especifica se a mensagem precisa ser autenticado. Se o aplicativo de envio solicita autenticação, enfileiramento de mensagens cria uma assinatura digital e usa-o para assinar a mensagem quando ela é enviada e autenticar a mensagem quando ela é recebida.  
  
 Se <xref:System.Messaging.Message.UseAuthentication%2A> é `false` e uma mensagem é enviada a uma fila que aceita apenas mensagens autenticadas, a mensagem será rejeitada quando ele chega à fila.  
  
 Não é possível determinar se uma mensagem de falha na autenticação examinando suas propriedades. Serviço de enfileiramento descarta tais mensagens antes que sejam entregues à fila. No entanto, você pode solicitar que uma mensagem de confirmação ser enviado se uma falha de entrega impede que uma mensagem que chega na fila.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.UseAuthentication" />.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
      </Docs>
    </Member>
    <Member MemberName="UseDeadLetterQueue">
      <MemberSignature Language="C#" Value="public bool UseDeadLetterQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDeadLetterQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseDeadLetterQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseDeadLetterQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseDeadLetterQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDeadLetterQueue : bool with get, set" Usage="System.Messaging.Message.UseDeadLetterQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseDeadLetterQueue")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se uma cópia da mensagem que não pôde ser entregue deve ser enviada a uma fila de mensagens mortas.</summary>
        <value><see langword="true" /> Se a falha de entrega de mensagens deve resultar em uma cópia da mensagem sendo enviada para uma fila de inatividade; Caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.Message.UseJournalQueue%2A> e <xref:System.Messaging.Message.UseDeadLetterQueue%2A> propriedades que especificam como o enfileiramento de mensagens acompanha uma mensagem. Se <xref:System.Messaging.Message.UseDeadLetterQueue%2A> é `true`, falha de entrega (de uma mensagem não transacional), faz com que a mensagem a ser enviada para a fila de inatividade não transacional no computador que não foi possível entregar a mensagem. Falha de entrega pode ser causada por um temporizador de mensagem expirando, por exemplo.  
  
 No caso de falha de entrega para uma mensagem transacional, enfileiramento de mensagens envia a mensagem para a fila de inatividade transacional no computador de origem em todos os casos negativos e em dúvida.  
  
 Quando você armazena as mensagens em uma fila de inatividade, você deve limpar a fila periodicamente para remover as mensagens que não são mais necessários. Mensagens armazenadas na contagem de filas em relação à cota de tamanho para o computador em que a fila reside. A cota do computador é definida pelo administrador e refere-se ao tamanho alocado para o armazenamento de mensagens no computador inteiro, não apenas em uma única fila.  
  
 Você não crie um diário ou fila de inatividade. Esses são ambas as filas do sistema que o enfileiramento de mensagens gera.  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma mensagem <xref:System.Messaging.Message.UseDeadLetterQueue%2A> propriedade.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.UseDeadLetterQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="UseEncryption">
      <MemberSignature Language="C#" Value="public bool UseEncryption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseEncryption" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseEncryption" />
      <MemberSignature Language="VB.NET" Value="Public Property UseEncryption As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseEncryption { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseEncryption : bool with get, set" Usage="System.Messaging.Message.UseEncryption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseEncryption")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se a mensagem deve ser tornada privada.</summary>
        <value><see langword="true" /> para exigir que o enfileiramento de mensagens criptografar a mensagem; Caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se uma mensagem for privada, seu corpo é criptografado antes de ser enviado e descriptografado quando ela é recebida. Para enviar uma mensagem privada, o aplicativo de envio deve especificar que a criptografia ser usada e, opcionalmente, o algoritmo de criptografia.  
  
 Ao enviar mensagens particulares, seu aplicativo não precisa executar a criptografia de mensagem. O enfileiramento pode criptografar o corpo da mensagem para você, se seu aplicativo está enviando mensagens dentro de uma empresa do Microsoft Windows 2000, que tem acesso ao serviço de diretório. Ao receber mensagens privadas, o Gerenciador de fila de recebimento sempre descriptografa o corpo da mensagem.  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma mensagem <xref:System.Messaging.Message.UseEncryption%2A> propriedade.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.UseEncryption" />.</exception>
        <altmember cref="P:System.Messaging.Message.EncryptionAlgorithm" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.Message.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseJournalQueue")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se uma cópia da mensagem deve ser mantida em um diário de computador no computador de origem.</summary>
        <value><see langword="true" /> para exigir que uma cópia de uma mensagem ser mantida no diário de computador do computador de origem após a mensagem tiver sido transmitidos com êxito (do computador de origem para o próximo servidor); Caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.Message.UseJournalQueue%2A> e <xref:System.Messaging.Message.UseDeadLetterQueue%2A> propriedades que especificam como o enfileiramento de mensagens acompanha uma mensagem. Se <xref:System.Messaging.Message.UseJournalQueue%2A> é `true`, em seguida, uma cópia é mantida no diário do computador no computador de origem em cada etapa que uma mensagem é transmitida.  
  
 A mensagem enviada somente é copiada para a fila de diário, se a fila de destino estiver em um computador remoto. Se o destino estiver no computador local, a mensagem é enviada diretamente para a fila; Não há nenhuma etapa intermediária para exigir o registro no diário.  
  
 Quando você armazena mensagens em uma fila do diário, limpe a fila periodicamente para remover as mensagens que não são mais necessários. Mensagens armazenadas na contagem de filas de diário em relação à cota para o computador em que a fila reside. (A cota do computador é definida pelo administrador).  
  
 Você não crie um diário ou fila de inatividade. Esses são ambas as filas do sistema que o enfileiramento de mensagens gera.  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma mensagem <xref:System.Messaging.Message.UseJournalQueue%2A> propriedade.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.UseJournalQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="UseTracing">
      <MemberSignature Language="C#" Value="public bool UseTracing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseTracing" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseTracing" />
      <MemberSignature Language="VB.NET" Value="Public Property UseTracing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseTracing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseTracing : bool with get, set" Usage="System.Messaging.Message.UseTracing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseTracing")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se uma mensagem deve ser rastreada enquanto ela se aproxima da sua fila de destino.</summary>
        <value><see langword="true" /> se cada etapa intermediária feita pela mensagem original for roteada para a fila de destino, será gerado um relatório a ser enviado para a fila de relatórios do sistema; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.Message.UseTracing%2A> propriedade especifica se é necessário rastrear a rota de uma mensagem conforme ela se aproxima da sua fila de destino. Se `true`, uma mensagem de relatório (gerada pelo enfileiramento de mensagens) é enviada para uma fila de relatórios sempre que a mensagem passa por um servidor de roteamento do enfileiramento de mensagens. A fila de relatórios é especificada pela fonte de Gerenciador de fila. Filas de relatórios não estão limitadas a mensagens de relatório geradas pelo enfileiramento de mensagens; as mensagens geradas pelo aplicativo também podem ser enviadas para filas de relatório.  
  
 Usando o rastreamento envolve Configurando o Active Directory e especificando uma fila de relatórios para a empresa de enfileiramento de mensagens. O administrador configura essas configurações.  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma mensagem <xref:System.Messaging.Message.UseTracing%2A> propriedade.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A fila de mensagens é filtrada para ignorar a propriedade <see cref="P:System.Messaging.Message.UseTracing" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
      </Docs>
    </Member>
  </Members>
</Type>