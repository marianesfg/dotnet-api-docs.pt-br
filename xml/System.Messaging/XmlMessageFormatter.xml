<Type Name="XmlMessageFormatter" FullName="System.Messaging.XmlMessageFormatter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e9b5b367df928ff6d7a99dc28208e2d881b64249" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37478889" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XmlMessageFormatter : ICloneable, System.Messaging.IMessageFormatter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlMessageFormatter extends System.Object implements class System.ICloneable, class System.Messaging.IMessageFormatter" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.XmlMessageFormatter" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlMessageFormatter&#xA;Implements ICloneable, IMessageFormatter" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlMessageFormatter : ICloneable, System::Messaging::IMessageFormatter" />
  <TypeSignature Language="F#" Value="type XmlMessageFormatter = class&#xA;    interface IMessageFormatter&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Messaging.IMessageFormatter</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Serializes and deserializes objects to or from the body of a message, using the XML format based on the XSD schema definition.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.XmlMessageFormatter> é o formatador padrão que uma instância de <xref:System.Messaging.MessageQueue> usa para serializar mensagens gravadas na fila. Quando você cria uma instância do <xref:System.Messaging.MessageQueue>, uma instância do <xref:System.Messaging.XmlMessageFormatter> é criado para você e associado a <xref:System.Messaging.MessageQueue>. Você pode especificar um formatador diferente criá-lo em seu código e atribuindo-o para o <xref:System.Messaging.MessageQueue.Formatter%2A> propriedade de seu <xref:System.Messaging.MessageQueue>.  
  
 Padrão de uma fila <xref:System.Messaging.XmlMessageFormatter> instância pode ser usada para gravar na fila, mas ele não pode ser usado para ler na fila até que você definir o <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> ou <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> propriedade no formatador. Você pode definir um ou ambos os valores na instância de formatador de padrão, ou você pode criar uma nova instância do formatador e defina os valores automaticamente, passando-os como argumentos em apropriado <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> construtor.  
  
 Ao especificar <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> em vez de <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, tipo existência é verificada em tempo de compilação, em vez da hora de leitura, reduzindo a possibilidade de erro. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> requer que cada entrada seja totalmente qualificado, especificando seu nome de assembly. Além disso, ao trabalhar com várias versões simultâneas, o número de versão deve ser anexado para o nome do tipo de destino também.  
  
 O <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriedades informar ao formatador quais esquemas para tentar corresponder ao desserializar uma mensagem. Isso permite que o formatador interpretar o corpo da mensagem.  
  
 A instância serializada no corpo da mensagem deve estar em conformidade com um dos esquemas representados na matriz de tipo. Quando você ler a mensagem usando o <xref:System.Messaging.MessageQueue.Receive%2A> método, o método cria um objeto do tipo que corresponde ao esquema identificado e lê o corpo da mensagem para ele.  
  
 Apenas uma das duas propriedades deve ser definida durante a leitura da fila, mas você pode definir ambos. O conjunto de tipos é o conjunto combinado de duas propriedades. A decisão de qual propriedade a ser usada é específica para seu aplicativo. Se o corpo da mensagem contém um tipo cujo esquema não corresponde a nenhum dos tipos na matriz para uma das propriedades, uma exceção será lançada quando a mensagem é lida.  
  
 O <xref:System.Messaging.XmlMessageFormatter> é um componente crucial de acoplamento fraco de mensagens baseadas em XML. A utilitário XSD.exe usa que o formato XML é usado para gerar o esquema XML, como quando você usa o utilitário para serializar uma classe usada por seu aplicativo. A classe deve ter um construtor padrão.  
  
 O formato é usado novamente o processo inverso quando o utilitário gera uma classe com base no esquema você distribuir para descrever seus dados de classe. O uso do utilitário e o esquema XML que ele gera permite que você evite redistributing.dll arquivos toda vez que você recompilar uma classe depois que a implementação de sua classe foi alterado. Desde que o esquema não é alterada no cliente ou servidor, outras alterações em ambos os lados não afetam a outra.  
  
   
  
## Examples  
 O exemplo de código a seguir inclui três partes de código: um componente de servidor, uma classe ordem e o código do cliente. A classe order pode ser usada pelo utilitário XSD.exe para gerar o esquema que o servidor reconhece dentro de mensagens de entrada. O esquema é um arquivo XML formatado que descreve a "forma" da classe. Esse esquema, em seguida, pode ser usado no lado do cliente para gerar uma classe de pedido de cliente específico que compartilha o mesmo esquema que a classe de servidor.  
  
 O exemplo de código a seguir representa um componente de servidor que recebe pedidos por meio de uma fila de mensagens. O corpo da mensagem deve ser um objeto de pedido cujo esquema corresponde à classe {1&gt;Order.CS&lt;1 abaixo. O processo de servidor ou aplicativo desserializa a ordem.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlMessageFormatter Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source.cs#1)]
 [!code-vb[Classic XmlMessageFormatter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source.vb#1)]  
  
 O exemplo de código a seguir representa a classe de ordem que fornece um esquema para os objetos de ordem que o aplicativo no servidor recebe e desserializa.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic XmlMessageFormatter Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source2.cs#2)]
 [!code-vb[Classic XmlMessageFormatter Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source2.vb#2)]  
  
 Qualquer aplicativo cliente que interage com o aplicativo no servidor deve enviar mensagens para o servidor pelas informações de serialização em uma classe de ordem definida localmente no corpo da mensagem. A classe ordem definida localmente deve ter o mesmo esquema que a classe ordem definida pelo servidor no qual o aplicativo no servidor tenta desserializar o corpo da mensagem. O utilitário XSD.exe permite que o Gerenciador do aplicativo no servidor de criar e distribuir o esquema que o cliente deve usar para serializar mensagens enviadas para o servidor.  
  
 Quando o Gerenciador do aplicativo cliente recebe o esquema para a classe de ordem, o utilitário XSD.exe é usado novamente para gerar uma classe de ordem de clientes específicos do esquema. É essa classe que é usada no exemplo de código cliente abaixo, a classe de ordem do servidor não (o utilitário XSD.exe faz com que a classe de esquema gerado ter o mesmo nome que a classe original). Essa nova classe ordem é usado para serializar a ordem no corpo da mensagem.  
  
 O exemplo de código a seguir é o lado do cliente de processamento, usado para serializar um pedido e enviar as informações associadas com a ordem em uma fila. O código associa informações de Item, a quantidade e o endereço de elementos do esquema que foram gerados para a classe {1&gt;Order.CS&lt;1 pelo utilitário XSD.exe. Um pedido é enviado para a fila de pedidos no computador local.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source3.cpp#3)]
 [!code-csharp[Classic XmlMessageFormatter Example#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source3.cs#3)]
 [!code-vb[Classic XmlMessageFormatter Example#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source3.vb#3)]  
  
 Depois que o esquema é gerado da classe ordem no servidor, você pode modificar a classe. A menos que as alterações de esquema, você não precisa redistribuir o esquema. Depois de distribuído o esquema e gerado de uma classe de ordem do lado do cliente, essa classe de cliente também pode ser modificado independentemente de classe de ordem do servidor, desde que o próprio esquema não será modificado. As duas classes se tornam acoplados de forma flexível.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
    <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
    <altmember cref="T:System.Messaging.IMessageFormatter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Messaging.XmlMessageFormatter" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Messaging.XmlMessageFormatter" /> class, without target types set.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga do construtor é usada com mais frequência ao gravar na fila, como tipos de destino não são necessários durante a gravação.  
  
 Para ler uma mensagem de uma fila usando uma instância de <xref:System.Messaging.XmlMessageFormatter> criado usando este construtor, você deve definir o <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> ou <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriedades para o formatador Saiba quais tipos para tentar desserializar.  
  
 Quando você cria um novo <xref:System.Messaging.MessageQueue>, um padrão <xref:System.Messaging.XmlMessageFormatter> instância é criada, sem o conjunto de tipos de destino. Assim como acontece com um formatador criado com esse construtor, você deve definir os tipos de destino para essa instância de formatador se você quiser ler na fila.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (string[] targetTypeNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string[] targetTypeNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypeNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;System::String ^&gt; ^ targetTypeNames);" />
      <MemberSignature Language="F#" Value="new System.Messaging.XmlMessageFormatter : string[] -&gt; System.Messaging.XmlMessageFormatter" Usage="new System.Messaging.XmlMessageFormatter targetTypeNames" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypeNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="targetTypeNames">An array of type <see cref="T:System.String" /> that specifies the set of possible types that will be deserialized by the formatter from the message provided. These values must be fully qualified, for example, "MyNamespace.MyOrders, MyOrdersAssemblyName".</param>
        <summary>Initializes a new instance of the <see cref="T:System.Messaging.XmlMessageFormatter" /> class, setting target types passed in as an array of (fully qualified) string values.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os construtores com parâmetros de tipo de destino são usados com mais frequência durante a leitura da fila. Ao escrever, não é necessário especificar os tipos de destino.  
  
 Essa sobrecarga da <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> construtor define o <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> propriedade para os valores passados através da matriz a `targetTypeNames` parâmetro. Definir essa propriedade permite uma <xref:System.Messaging.MessageQueue> usando este <xref:System.Messaging.XmlMessageFormatter> instância para ler as mensagens que contêm objetos de tipos.  
  
 Tanto a <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriedades informar ao formatador quais esquemas para tentar corresponder ao desserializar uma mensagem. Isso permite que o formatador interpretar o corpo da mensagem.  
  
 A instância serializada no corpo da mensagem deve estar em conformidade com um dos esquemas representados na matriz de tipo. Quando você ler a mensagem usando o <xref:System.Messaging.MessageQueue.Receive%2A> método, o método cria um objeto do tipo que corresponde ao esquema identificado e lê o corpo da mensagem para ele.  
  
 Apenas uma das duas propriedades deve ser definida durante a leitura da fila, mas você pode definir ambos. O conjunto de tipos é o conjunto combinado de duas propriedades. A decisão de qual delas usar é específica para seu aplicativo. Se o corpo da mensagem contém um tipo cujo esquema não corresponde a nenhum dos tipos na matriz para uma das propriedades, uma exceção será lançada em tempo de leitura.  
  
   
  
## Examples  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="targetTypeNames" /> parameter is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (Type[] targetTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type[] targetTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;Type ^&gt; ^ targetTypes);" />
      <MemberSignature Language="F#" Value="new System.Messaging.XmlMessageFormatter : Type[] -&gt; System.Messaging.XmlMessageFormatter" Usage="new System.Messaging.XmlMessageFormatter targetTypes" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="targetTypes">An array of type <see cref="T:System.Type" /> that specifies the set of possible types that will be deserialized by the formatter from the message provided.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Messaging.XmlMessageFormatter" /> class, setting target types passed in as an array of object types.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os construtores com parâmetros de tipo de destino são usados com mais frequência durante a leitura da fila. Ao escrever, não é necessário especificar os tipos de destino.  
  
 Essa sobrecarga da <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> construtor define o <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriedade para os valores passados através da matriz a `targetTypes` parâmetro. Definir essa propriedade permite uma <xref:System.Messaging.MessageQueue> usando este <xref:System.Messaging.XmlMessageFormatter> instância para ler as mensagens que contêm objetos dos tipos dados.  
  
 Tanto a <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriedades informar ao formatador quais esquemas para tentar corresponder ao desserializar uma mensagem. Isso permite que o formatador interpretar o corpo da mensagem.  
  
 A instância serializada no corpo da mensagem deve estar em conformidade com um dos esquemas representados na matriz de tipo. Quando você ler a mensagem usando o <xref:System.Messaging.MessageQueue.Receive%2A> método, o método cria um objeto do tipo que corresponde ao esquema identificado e lê o corpo da mensagem para ele.  
  
 Apenas uma das duas propriedades deve ser definida durante a leitura da fila, mas você pode definir ambos. O conjunto de tipos é o conjunto combinado de duas propriedades. A decisão de qual delas usar é específica para seu aplicativo. Se o corpo da mensagem contém um tipo cujo esquema não corresponde a nenhum dos tipos na matriz para uma das propriedades, uma exceção será lançada em tempo de leitura.  
  
 Ao especificar <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> em vez de <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, tipo existência é verificada em tempo de compilação, em vez da hora de leitura, reduzindo a possibilidade de erro. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> requer que cada entrada seja totalmente qualificado, especificando seu nome de assembly. Além disso, ao trabalhar com várias versões simultâneas, o número de versão deve ser anexado para o nome do tipo de destino também.  
  
 Ao usar <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, você pode adicionar cada objeto (por exemplo, `MyClass`) à lista de uma maneira demonstrada pelo código a seguir em C#.  
  
```  
TargetTypes = new Type[]{typeof(MyClass)}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="targetTypes" /> parameter is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanRead(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanRead(System::Messaging::Message ^ message);" />
      <MemberSignature Language="F#" Value="abstract member CanRead : System.Messaging.Message -&gt; bool&#xA;override this.CanRead : System.Messaging.Message -&gt; bool" Usage="xmlMessageFormatter.CanRead message" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">The <see cref="T:System.Messaging.Message" /> to inspect.</param>
        <summary>Determines whether the formatter can deserialize the message.</summary>
        <returns>
          <see langword="true" /> if the XML formatter can deserialize the message; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> é chamado, o formatador tenta determinar se o conteúdo da mensagem é algo que ele pode desserializar. O formatador pode desserializar apenas a mensagem se o tipo no corpo da mensagem tem o mesmo esquema como um dos tipos na matriz representada pela <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriedades. <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> Retorna `false` nas duas seguintes circunstâncias:  
  
-   A mensagem não foi formatada usando o <xref:System.Messaging.XmlMessageFormatter>.  
  
-   O esquema do corpo da mensagem não está entre aqueles listados em ambos os <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> ou <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriedade.  
  
 O <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriedades informar ao formatador quais tipos de objetos deve ser capaz de desserializar. Se qualquer tipo está ausente na lista, ainda é encontrado dentro da mensagem <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> retorna `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Neither the <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> nor <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> property has been set.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="message" /> parameter is <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="xmlMessageFormatter.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates an instance of the <see cref="T:System.Messaging.XmlMessageFormatter" /> class whose read/write properties (the sets of target types) are the same as the current <see cref="T:System.Messaging.XmlMessageFormatter" /> instance.</summary>
        <returns>An object whose properties are identical to those of this <see cref="T:System.Messaging.XmlMessageFormatter" /> instance, but whose metadata does not specify it to be a formatter class instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método cria uma cópia do formatador e a inicializa todas as suas propriedades para os valores desse <xref:System.Messaging.XmlMessageFormatter> objeto.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.IMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public object Read (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Read(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Read(System::Messaging::Message ^ message);" />
      <MemberSignature Language="F#" Value="abstract member Read : System.Messaging.Message -&gt; obj&#xA;override this.Read : System.Messaging.Message -&gt; obj" Usage="xmlMessageFormatter.Read message" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Read(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">The <see cref="T:System.Messaging.Message" />, in XML format, to deserialize.</param>
        <summary>Reads the contents from the given message and creates an object that contains the deserialized message.</summary>
        <returns>The deserialized message.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tanto a <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriedades informar ao formatador quais esquemas para tentar corresponder ao desserializar uma mensagem. Uma dessas propriedades deve ser definida antes que a mensagem pode ser desserializada.  
  
 A instância serializada no corpo da mensagem deve estar em conformidade com um dos esquemas representados na matriz de tipo. Quando você ler a mensagem usando o <xref:System.Messaging.MessageQueue.Receive%2A> método, o método cria um objeto do tipo que corresponde ao esquema identificado e lê o corpo da mensagem para ele.  
  
 Os tipos de destino não deve ser especificado para gravar na fila.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Neither the <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> nor <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> property has been set.  -or-  The instance serialized in the message body does not comply with any of the schemas represented by the types in the <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> and <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> properties.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="message" /> parameter is <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypeNames">
      <MemberSignature Language="C#" Value="public string[] TargetTypeNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] TargetTypeNames" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypeNames As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ TargetTypeNames { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetTypeNames : string[] with get, set" Usage="System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypeNames")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies the set of possible types that will be deserialized by the formatter from the message provided.</summary>
        <value>Uma matriz do tipo <see cref="T:System.String" /> que especifica os tipos de objetos a serem desserializados do corpo da mensagem ao ler a mensagem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tanto a <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriedades informar ao formatador quais esquemas para tentar corresponder ao desserializar uma mensagem. Isso permite que o formatador interpretar o corpo da mensagem.  
  
 A instância serializada no corpo da mensagem deve estar em conformidade com um dos esquemas representados na matriz de tipo. Quando você ler a mensagem usando o <xref:System.Messaging.MessageQueue.Receive%2A> método, o método cria um objeto do tipo que corresponde ao esquema identificado e lê o corpo da mensagem para ele.  
  
 Apenas uma das duas propriedades deve ser definida durante a leitura da fila, mas você pode definir ambos. O conjunto de tipos é o conjunto combinado de duas propriedades. A decisão de qual propriedade a ser usada é específica para seu aplicativo. Se o corpo da mensagem contém um tipo cujo esquema não corresponde a nenhum dos tipos na matriz para uma das propriedades, uma exceção será lançada quando a mensagem é lida.  
  
 <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> requer que cada entrada seja totalmente qualificado, especificando seu nome de assembly. Além disso, ao trabalhar com várias versões simultâneas, o número de versão deve ser anexado para o nome do tipo de destino também.  
  
 Os tipos de destino só são necessários durante a leitura da fila. O <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriedades não precisam ser definidas para gravar na fila.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> property is <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypes">
      <MemberSignature Language="C#" Value="public Type[] TargetTypes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] TargetTypes" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypes As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Type ^&gt; ^ TargetTypes { cli::array &lt;Type ^&gt; ^ get(); void set(cli::array &lt;Type ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetTypes : Type[] with get, set" Usage="System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypes")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies the set of possible types that will be deserialized by the formatter from the message provided.</summary>
        <value>Uma matriz do tipo <see cref="T:System.Type" /> que especifica os tipos de objetos a serem desserializados do corpo da mensagem ao ler a mensagem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tanto a <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriedades informar ao formatador quais esquemas para tentar corresponder ao desserializar uma mensagem. Isso permite que o formatador interpretar o corpo da mensagem.  
  
 A instância serializada no corpo da mensagem deve estar em conformidade com um dos esquemas representados na matriz de tipo. Quando você ler a mensagem usando o <xref:System.Messaging.MessageQueue.Receive%2A> método, o método cria um objeto do tipo que corresponde ao esquema identificado e lê o corpo da mensagem para ele.  
  
 Apenas uma das duas propriedades deve ser definida durante a leitura da fila, mas você pode definir ambos. O conjunto de tipos é o conjunto combinado de duas propriedades. A decisão de qual propriedade a ser usada é específica para seu aplicativo. Se o corpo da mensagem contém um tipo cujo esquema não corresponde a nenhum dos tipos na matriz para uma das propriedades, uma exceção será lançada quando a mensagem é lida.  
  
 Os tipos de destino só são necessários durante a leitura da fila. O <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriedades não precisam ser definidas para gravar na fila.  
  
 Ao especificar <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> em vez de <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, tipo existência é verificada em tempo de compilação, em vez da hora de leitura, reduzindo a possibilidade de erro.  
  
 Ao usar <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, você pode adicionar cada objeto (por exemplo, `MyClass`) à lista de uma maneira demonstrada pelo código do c# `TargetTypes = new Type[]{typeof(MyClass), typeof (MyOtherClass)};`.  
  
   
  
## Examples  
 O exemplo de código a seguir envia e recebe uma mensagem que contém um pedido de e para uma fila.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> property is <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (System.Messaging.Message message, object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(class System.Messaging.Message message, object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(System::Messaging::Message ^ message, System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Write : System.Messaging.Message * obj -&gt; unit&#xA;override this.Write : System.Messaging.Message * obj -&gt; unit" Usage="xmlMessageFormatter.Write (message, obj)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Write(System.Messaging.Message,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="message">The <see cref="T:System.Messaging.Message" /> whose <see cref="P:System.Messaging.Message.Body" /> property will contain the serialized object.</param>
        <param name="obj">The <see cref="T:System.Object" /> to be serialized into the message body.</param>
        <summary>Serializes an object into the body of the message.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os tipos de destino não precisam ser especificados para gravar na fila conforme eles devem ser durante a leitura. O <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> ou <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriedade é usada pelo formatador apenas ao desserializar uma mensagem.  
  
 O <xref:System.Messaging.XmlMessageFormatter> utiliza o <xref:System.Xml.Serialization.XmlSerializer> classe, que define o que pode ser serializado. Somente propriedades públicas e campos públicos podem ser serializadas. Estruturas, as estruturas com matrizes e matrizes de estruturas são todos serializável, desde que não usam o estilo codificado com o protocolo SOAP.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="message" /> parameter is <see langword="null" />.  -or-  The <paramref name="obj" /> parameter is <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      </Docs>
    </Member>
  </Members>
</Type>