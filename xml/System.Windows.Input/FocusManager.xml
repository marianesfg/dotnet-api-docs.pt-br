<Type Name="FocusManager" FullName="System.Windows.Input.FocusManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3e7633bcfb28b07f3d778ed9a8c90b61872b1eaf" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53518410" /></Metadata><TypeSignature Language="C#" Value="public static class FocusManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit FocusManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.FocusManager" />
  <TypeSignature Language="VB.NET" Value="Public Class FocusManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class FocusManager abstract sealed" />
  <TypeSignature Language="F#" Value="type FocusManager = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornece um conjunto de métodos estáticos, propriedades anexadas e eventos para determinar e definir escopos de foco e para definir o elemento focalizado dentro do escopo.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No Windows Presentation Foundation (WPF) há dois conceitos referentes ao foco: foco do teclado e foco lógico.  
  
 O foco do teclado se refere ao elemento que está recebendo atualmente entrada do teclado.  Pode haver apenas um elemento com foco do teclado.  Esse elemento com foco do teclado tem <xref:System.Windows.IInputElement.IsKeyboardFocused%2A> definido como `true`.  <xref:System.Windows.Input.Keyboard.FocusedElement%2A?displayProperty=nameWithType> Retorna o elemento com foco do teclado.  
  
 Foco lógico pertence ao <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> dentro de um escopo de foco específico.  
  
 Um escopo de foco é um elemento de contêiner que controla o <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> dentro de seu escopo.  Por padrão, o <xref:System.Windows.Window> classe é um escopo de foco são a <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ContextMenu>, e <xref:System.Windows.Controls.ToolBar> classes.  Tem um elemento que é um escopo de foco <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> definido como `true`.  
  
 Pode haver vários elementos com foco lógico, mas só pode haver um elemento com foco lógico dentro de um escopo de foco simples.  Não necessariamente um elemento com foco lógico tem o foco do teclado, mas um elemento com foco do teclado terá foco lógico.  É possível definir um escopo de foco dentro de um escopo de foco.  Nesse caso, o escopo de foco do pai e o escopo de foco filho podem ter um <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType>.  
  
 O cenário a seguir ilustra como o foco do teclado e foco lógico alterar em um aplicativo WPF que tem um <xref:System.Windows.Window> com um <xref:System.Windows.Controls.TextBox> e uma <xref:System.Windows.Controls.Menu> que tem um <xref:System.Windows.Controls.MenuItem>.  Quando o foco do teclado muda do <xref:System.Windows.Controls.TextBox> para o <xref:System.Windows.Controls.MenuItem>, o <xref:System.Windows.Controls.TextBox> foco do teclado perdas, mas mantém o foco lógico para o <xref:System.Windows.Window> escopo de foco.  O <xref:System.Windows.Controls.MenuItem> obtém o foco do teclado e obtém foco lógico para o <xref:System.Windows.Controls.Menu> escopo de foco.  Quando o foco do teclado retorna para a raiz <xref:System.Windows.Window>, o elemento <xref:System.Windows.Window> escopo de foco com foco lógico obterá o foco do teclado, que nesse caso é o <xref:System.Windows.Controls.TextBox>.  O <xref:System.Windows.Controls.TextBox> agora tem o foco do teclado e foco lógico.  O <xref:System.Windows.Controls.MenuItem> perde o foco do teclado mas manterá o foco lógico para o <xref:System.Windows.Controls.Menu> escopo de foco.  
  
 O valor padrão de <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> em um <xref:System.Windows.Window>, <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ToolBar>, e <xref:System.Windows.Controls.ContextMenu> é `true`.  
  
 Para obter mais informações sobre o foco, consulte a [visão geral de entrada](~/docs/framework/wpf/advanced/input-overview.md) e o [visão geral do foco](~/docs/framework/wpf/advanced/focus-overview.md).  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddGotFocusHandler">
      <MemberSignature Language="C#" Value="public static void AddGotFocusHandler (System.Windows.DependencyObject element, System.Windows.RoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddGotFocusHandler(class System.Windows.DependencyObject element, class System.Windows.RoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.AddGotFocusHandler(System.Windows.DependencyObject,System.Windows.RoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddGotFocusHandler (element As DependencyObject, handler As RoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddGotFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::RoutedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddGotFocusHandler : System.Windows.DependencyObject * System.Windows.RoutedEventHandler -&gt; unit" Usage="System.Windows.Input.FocusManager.AddGotFocusHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.RoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">O <see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> que escuta esse evento.</param>
        <param name="handler">O manipulador de eventos a ser adicionado.</param>
        <summary>Adiciona um manipulador ao evento anexado <see cref="E:System.Windows.Input.FocusManager.GotFocus" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLostFocusHandler">
      <MemberSignature Language="C#" Value="public static void AddLostFocusHandler (System.Windows.DependencyObject element, System.Windows.RoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddLostFocusHandler(class System.Windows.DependencyObject element, class System.Windows.RoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.AddLostFocusHandler(System.Windows.DependencyObject,System.Windows.RoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddLostFocusHandler (element As DependencyObject, handler As RoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddLostFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::RoutedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddLostFocusHandler : System.Windows.DependencyObject * System.Windows.RoutedEventHandler -&gt; unit" Usage="System.Windows.Input.FocusManager.AddLostFocusHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.RoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">O <see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> que escuta esse evento.</param>
        <param name="handler">O manipulador de eventos a ser adicionado.</param>
        <summary>Adiciona um manipulador ao evento anexado <see cref="E:System.Windows.Input.FocusManager.LostFocus" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusedElement">
      <MemberSignature Language="C#" Value="see GetFocusedElement, and SetFocusedElement" />
      <MemberSignature Language="ILAsm" Value="see GetFocusedElement, and SetFocusedElement" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.FocusManager.FocusedElement" />
      <MemberSignature Language="VB.NET" Value="see GetFocusedElement, and SetFocusedElement" />
      <MemberSignature Language="F#" Value="see GetFocusedElement, and SetFocusedElement" Usage="see GetFocusedElement, and SetFocusedElement" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se o elemento ao qual essa propriedade está anexado tem foco lógico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Input.FocusManager.FocusedElement%2A> é o elemento que tem foco lógico para um escopo de foco específico.  Esse objeto pode ou não ter o foco do teclado.  O foco do teclado refere-se ao elemento que recebe entrada do teclado.  Para obter mais informações sobre o foco, o foco do teclado e foco lógico, consulte o [visão geral de entrada](~/docs/framework/wpf/advanced/input-overview.md).  
  
 <xref:System.Windows.Input.FocusManager.GetFocusedElement%2A> e <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A> pode ser usado para obter e definir o elemento focalizado dentro do escopo de foco especificado.  
  
<a name="dependencyPropertyInfo_FocusedElement"></a>   
## <a name="dependency-property-information"></a>Informações da propriedade de dependência  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Input.FocusManager.FocusedElementProperty>|  
|Propriedades de metadados definido como `true`|Nenhum|  
  
   
  
## Examples  
 O exemplo a seguir mostra como fazer um <xref:System.Windows.Controls.Button> o elemento focalizado.  
  
 [!code-xml[markupsnippets#MarkupFocusManagerFocusedElementXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/MarkupSnippets/CSharp/Window1.xaml#markupfocusmanagerfocusedelementxaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusedElementProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusedElementProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusedElementProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.FocusManager.FocusedElementProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusedElementProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusedElementProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusedElementProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.FocusManager.FocusedElementProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade <see cref="P:System.Windows.Input.FocusManager.FocusedElement" /> anexada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFocusedElement">
      <MemberSignature Language="C#" Value="public static System.Windows.IInputElement GetFocusedElement (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.IInputElement GetFocusedElement(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.GetFocusedElement(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFocusedElement (element As DependencyObject) As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::IInputElement ^ GetFocusedElement(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetFocusedElement : System.Windows.DependencyObject -&gt; System.Windows.IInputElement" Usage="System.Windows.Input.FocusManager.GetFocusedElement element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">O elemento com o foco lógico no escopo de foco especificado.</param>
        <summary>Obtém o elemento com o foco lógico dentro do escopo de foco especificado.</summary>
        <returns>O elemento no escopo de foco especificado com foco lógico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Input.FocusManager.FocusedElement%2A> é o elemento que tem foco lógico para um escopo de foco específico.  Esse objeto pode ou não ter o foco do teclado.  O foco do teclado refere-se ao elemento que recebe entrada do teclado.  Para obter mais informações sobre o foco, o foco do teclado e foco lógico, consulte o [visão geral de entrada](~/docs/framework/wpf/advanced/input-overview.md).  
  
 Se `element` não é um escopo de foco, este método retornará `null`.  
  
 Use <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A>, para especificar o elemento com foco lógico dentro de um escopo de foco especificado.  
  
   
  
## Examples  
 O exemplo a seguir define o elemento com foco lógico usando o <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A> e ele obtém o elemento com foco lógico usando o <xref:System.Windows.Input.FocusManager.GetFocusedElement%2A>.  
  
 [!code-csharp[focussnippets#FocusGetSetFocusedElement](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSnippets/CSharp/Window1.xaml.cs#focusgetsetfocusedelement)]
 [!code-vb[focussnippets#FocusGetSetFocusedElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSnippets/visualbasic/window1.xaml.vb#focusgetsetfocusedelement)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="element" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFocusScope">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyObject GetFocusScope (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyObject GetFocusScope(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.GetFocusScope(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFocusScope (element As DependencyObject) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyObject ^ GetFocusScope(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetFocusScope : System.Windows.DependencyObject -&gt; System.Windows.DependencyObject" Usage="System.Windows.Input.FocusManager.GetFocusScope element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">O elemento do qual obter o escopo de foco mais próximo.</param>
        <summary>Determina o ancestral mais próximo do elemento especificado que tem <see cref="P:System.Windows.Input.FocusManager.IsFocusScope" /> definido como <see langword="true" />.</summary>
        <returns>O escopo do foco do elemento especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor padrão de <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> em um <xref:System.Windows.Window>, <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ToolBar>, <xref:System.Windows.Controls.ContextMenu> é `true`.  
  
 Um escopo de foco é um elemento de contêiner que controla o <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> dentro de seu escopo.  Por padrão, o <xref:System.Windows.Window> classe é um escopo de foco são a <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ContextMenu>, e <xref:System.Windows.Controls.ToolBar> classes.  Tem um elemento que é um escopo de foco <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> definido como `true`.  
  
 Para obter mais informações sobre o foco, o foco do teclado e foco lógico, consulte o [visão geral de entrada](~/docs/framework/wpf/advanced/input-overview.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="element" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetIsFocusScope">
      <MemberSignature Language="C#" Value="public static bool GetIsFocusScope (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GetIsFocusScope(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.GetIsFocusScope(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIsFocusScope (element As DependencyObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GetIsFocusScope(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetIsFocusScope : System.Windows.DependencyObject -&gt; bool" Usage="System.Windows.Input.FocusManager.GetIsFocusScope element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">O elemento do qual ler a propriedade anexada.</param>
        <summary>Determina se o <see cref="T:System.Windows.DependencyObject" /> especificado é um escopo de foco.</summary>
        <returns><see langword="true" /> se <see cref="P:System.Windows.Input.FocusManager.IsFocusScope" /> é definido como <see langword="true" /> no elemento especificado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um escopo de foco é um elemento de contêiner que controla o <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> dentro de seu escopo.  Por padrão, o <xref:System.Windows.Window> classe é um escopo de foco são a <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ContextMenu>, e <xref:System.Windows.Controls.ToolBar> classes.  Tem um elemento que é um escopo de foco <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> definido como `true`.  
  
 Para obter mais informações sobre o foco, o foco do teclado e foco lógico, consulte o [visão geral de entrada](~/docs/framework/wpf/advanced/input-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="see AddGotFocusHandler, and RemoveGotFocusHandler" />
      <MemberSignature Language="ILAsm" Value="see AddGotFocusHandler, and RemoveGotFocusHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.FocusManager.GotFocus" />
      <MemberSignature Language="VB.NET" Value="see AddGotFocusHandler, and RemoveGotFocusHandler" />
      <MemberSignature Language="F#" Value="see AddGotFocusHandler, and RemoveGotFocusHandler" Usage="see AddGotFocusHandler, and RemoveGotFocusHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ocorre quando um elemento tem o foco.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.FocusManager.GotFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.FocusManager.GotFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica o evento <see cref="E:System.Windows.Input.FocusManager.GotFocus" /> anexado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocusScope">
      <MemberSignature Language="C#" Value="see GetIsFocusScope, and SetIsFocusScope" />
      <MemberSignature Language="ILAsm" Value="see GetIsFocusScope, and SetIsFocusScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.FocusManager.IsFocusScope" />
      <MemberSignature Language="VB.NET" Value="see GetIsFocusScope, and SetIsFocusScope" />
      <MemberSignature Language="F#" Value="see GetIsFocusScope, and SetIsFocusScope" Usage="see GetIsFocusScope, and SetIsFocusScope" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se o elemento ao qual essa propriedade está anexada é um escopo de foco.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um escopo de foco é um elemento de contêiner que controla o <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> dentro de seu escopo.  Por padrão, o <xref:System.Windows.Window> classe é um escopo de foco são a <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ContextMenu>, e <xref:System.Windows.Controls.ToolBar> classes.  Tem um elemento que é um escopo de foco <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> definido como `true`.  
  
 Para obter mais informações sobre o foco, o foco do teclado e foco lógico, consulte o [visão geral de entrada](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="dependencyPropertyInfo_IsFocusScope"></a>   
## <a name="dependency-property-information"></a>Informações da propriedade de dependência  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Input.FocusManager.IsFocusScopeProperty>|  
|Propriedades de metadados definido como `true`|Nenhum|  
  
   
  
## Examples  
 O exemplo a seguir faz uma <xref:System.Windows.Controls.StackPanel> um escopo de foco.  
  
 [!code-xml[markupsnippets#MarkupIsFocusScopeXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/MarkupSnippets/CSharp/Window1.xaml#markupisfocusscopexaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocusScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFocusScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFocusScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.FocusManager.IsFocusScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsFocusScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsFocusScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsFocusScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.FocusManager.IsFocusScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade <see cref="P:System.Windows.Input.FocusManager.IsFocusScope" /> anexada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor padrão de <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> em um <xref:System.Windows.Window>, <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ToolBar>, <xref:System.Windows.Controls.ContextMenu> é `true`.  
  
 Um escopo de foco é um elemento de contêiner que controla o <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> dentro de seu escopo.  Por padrão, o <xref:System.Windows.Window> classe é um escopo de foco são a <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ContextMenu>, e <xref:System.Windows.Controls.ToolBar> classes.  Tem um elemento que é um escopo de foco <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> definido como `true`.  
  
 Para obter mais informações sobre o foco, o foco do teclado e foco lógico, consulte o [visão geral de entrada](~/docs/framework/wpf/advanced/input-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="see AddLostFocusHandler, and RemoveLostFocusHandler" />
      <MemberSignature Language="ILAsm" Value="see AddLostFocusHandler, and RemoveLostFocusHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.FocusManager.LostFocus" />
      <MemberSignature Language="VB.NET" Value="see AddLostFocusHandler, and RemoveLostFocusHandler" />
      <MemberSignature Language="F#" Value="see AddLostFocusHandler, and RemoveLostFocusHandler" Usage="see AddLostFocusHandler, and RemoveLostFocusHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ocorre quando um elemento perde o foco.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.FocusManager.LostFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.FocusManager.LostFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica o evento <see cref="E:System.Windows.Input.FocusManager.LostFocus" /> anexado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveGotFocusHandler">
      <MemberSignature Language="C#" Value="public static void RemoveGotFocusHandler (System.Windows.DependencyObject element, System.Windows.RoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveGotFocusHandler(class System.Windows.DependencyObject element, class System.Windows.RoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.RemoveGotFocusHandler(System.Windows.DependencyObject,System.Windows.RoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveGotFocusHandler (element As DependencyObject, handler As RoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveGotFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::RoutedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveGotFocusHandler : System.Windows.DependencyObject * System.Windows.RoutedEventHandler -&gt; unit" Usage="System.Windows.Input.FocusManager.RemoveGotFocusHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.RoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">O <see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> que escuta esse evento.</param>
        <param name="handler">O manipulador de eventos a ser removido.</param>
        <summary>Remove um manipulador para o evento anexado <see cref="E:System.Windows.Input.FocusManager.GotFocus" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveLostFocusHandler">
      <MemberSignature Language="C#" Value="public static void RemoveLostFocusHandler (System.Windows.DependencyObject element, System.Windows.RoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveLostFocusHandler(class System.Windows.DependencyObject element, class System.Windows.RoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.RemoveLostFocusHandler(System.Windows.DependencyObject,System.Windows.RoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveLostFocusHandler (element As DependencyObject, handler As RoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveLostFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::RoutedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveLostFocusHandler : System.Windows.DependencyObject * System.Windows.RoutedEventHandler -&gt; unit" Usage="System.Windows.Input.FocusManager.RemoveLostFocusHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.RoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">O <see cref="T:System.Windows.UIElement" /> ou <see cref="T:System.Windows.ContentElement" /> que escuta esse evento.</param>
        <param name="handler">O manipulador de eventos a ser removido.</param>
        <summary>Remove um manipulador para o evento anexado <see cref="E:System.Windows.Input.FocusManager.LostFocus" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetFocusedElement">
      <MemberSignature Language="C#" Value="public static void SetFocusedElement (System.Windows.DependencyObject element, System.Windows.IInputElement value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFocusedElement(class System.Windows.DependencyObject element, class System.Windows.IInputElement value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.SetFocusedElement(System.Windows.DependencyObject,System.Windows.IInputElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFocusedElement (element As DependencyObject, value As IInputElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFocusedElement(System::Windows::DependencyObject ^ element, System::Windows::IInputElement ^ value);" />
      <MemberSignature Language="F#" Value="static member SetFocusedElement : System.Windows.DependencyObject * System.Windows.IInputElement -&gt; unit" Usage="System.Windows.Input.FocusManager.SetFocusedElement (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.IInputElement" />
      </Parameters>
      <Docs>
        <param name="element">O escopo do foco no qual o elemento especificado se torna <see cref="P:System.Windows.Input.FocusManager.FocusedElement" />.</param>
        <param name="value">O elemento a receber foco lógico.</param>
        <summary>Determina o foco lógico no elemento especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Input.FocusManager.FocusedElement%2A> é o elemento que tem foco lógico para o escopo de foco específico.  Esse objeto pode ou não ter o foco do teclado.  O foco do teclado refere-se ao elemento que recebe entrada do teclado.  Para obter mais informações sobre o foco, o foco do teclado e foco lógico, consulte o [visão geral de entrada](~/docs/framework/wpf/advanced/input-overview.md).  
  
 É possível especificar um escopo de foco é um ancestral do escopo de foco, que o elemento está no.  Por exemplo, se um <xref:System.Windows.Controls.StackPanel> é um escopo de foco e seu pai <xref:System.Windows.Window> é um escopo de foco, um <xref:System.Windows.Controls.TextBox> filho a <xref:System.Windows.Controls.StackPanel> poderia especificar o <xref:System.Windows.Window> como o escopo de foco ao chamar <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A>.  O <xref:System.Windows.Controls.TextBox> é, em seguida, <xref:System.Windows.Input.FocusManager.FocusedElement%2A> para ambos os <xref:System.Windows.Window> concentre-se o escopo e o <xref:System.Windows.Controls.StackPanel> escopo de foco.  
  
 <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A> fornecerá o foco lógico ao elemento especificado no escopo de foco especificado e tenta dar o foco do teclado de elemento.  
  
   
  
## Examples  
 O exemplo a seguir define o elemento com foco lógico usando o <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A> e ele obtém o elemento com foco lógico usando o <xref:System.Windows.Input.FocusManager.GetFocusedElement%2A>.  
  
 [!code-csharp[focussnippets#FocusGetSetFocusedElement](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSnippets/CSharp/Window1.xaml.cs#focusgetsetfocusedelement)]
 [!code-vb[focussnippets#FocusGetSetFocusedElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSnippets/visualbasic/window1.xaml.vb#focusgetsetfocusedelement)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetIsFocusScope">
      <MemberSignature Language="C#" Value="public static void SetIsFocusScope (System.Windows.DependencyObject element, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetIsFocusScope(class System.Windows.DependencyObject element, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.SetIsFocusScope(System.Windows.DependencyObject,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetIsFocusScope (element As DependencyObject, value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetIsFocusScope(System::Windows::DependencyObject ^ element, bool value);" />
      <MemberSignature Language="F#" Value="static member SetIsFocusScope : System.Windows.DependencyObject * bool -&gt; unit" Usage="System.Windows.Input.FocusManager.SetIsFocusScope (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="element">O elemento para criar um escopo de foco.</param>
        <param name="value"><see langword="true" /> se <paramref name="element" /> é um escopo de foco; caso contrário, <see langword="false" />.</param>
        <summary>Define o <see cref="T:System.Windows.DependencyObject" /> especificado como um escopo de foco.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um escopo de foco é um elemento de contêiner que controla o <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> dentro de seu escopo.  Por padrão, o <xref:System.Windows.Window> classe é um escopo de foco são a <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ContextMenu>, e <xref:System.Windows.Controls.ToolBar> classes.  Tem um elemento que é um escopo de foco <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> definido como `true`.  
  
 Para obter mais informações sobre o foco, o foco do teclado e foco lógico, consulte o [visão geral de entrada](~/docs/framework/wpf/advanced/input-overview.md).  
  
   
  
## Examples  
 O exemplo a seguir faz um elemento de um escopo de foco usando <xref:System.Windows.Input.FocusManager.SetIsFocusScope%2A>.  
  
 [!code-csharp[focussnippets#FocusSetIsFocusScope](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSnippets/CSharp/Window1.xaml.cs#focussetisfocusscope)]
 [!code-vb[focussnippets#FocusSetIsFocusScope](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSnippets/visualbasic/window1.xaml.vb#focussetisfocusscope)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>