<Type Name="PersonalizationProvider" FullName="System.Web.UI.WebControls.WebParts.PersonalizationProvider">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6820a22ca9c6491458338c5f48a307db8cbc9dc9" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37538289" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class PersonalizationProvider : System.Configuration.Provider.ProviderBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit PersonalizationProvider extends System.Configuration.Provider.ProviderBase" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PersonalizationProvider&#xA;Inherits ProviderBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class PersonalizationProvider abstract : System::Configuration::Provider::ProviderBase" />
  <TypeSignature Language="F#" Value="type PersonalizationProvider = class&#xA;    inherit ProviderBase" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Configuration.Provider.ProviderBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Implements the basic functionality for a personalization provider.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Isso é a classe base abstrata que define a funcionalidade necessária de um provedor de personalização. Um provedor de personalização carrega e armazena os dados de personalização em nome de um <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> instância.  
  
 A classe base define o comportamento padrão para um número de métodos; somente os métodos que lidam especificamente com o armazenamento de dados subjacente são marcadas como abstratos. Isso permite que um desenvolvedor escreva um provedor personalizado para interagir com um armazenamento de dados específico, sem a necessidade de reimplementar a funcionalidade padrão usada pelo <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> classe.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Você pode derivar de <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" /> e fornecem implementações para apenas os métodos abstratos definidos nessa classe. Os métodos abstratos lidam especificamente com Salvar e carregar dados para um armazenamento de dados físico e com a administração do repositório de dados. Um provedor personalizado deve ser capaz de manipular as informações de personalização de uma maneira que distingue <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> dados de <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> dados. Além disso, um provedor deve segmentar os dados de personalização por página, bem como pelo aplicativo.  Implementações de <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" /> acoplado a implementações de <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" /> porque alguns métodos do provedor de personalização retornam instâncias de <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />-as classes derivadas. Para facilitar o desenvolvimento de provedores personalizados, o <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" /> classe base inclui uma implementação padrão da lógica de personalização e a lógica de serialização/desserialização que é usada diretamente pelo <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> classe. Como resultado, a criação de um provedor personalizado exclusivamente para a finalidade de trabalhar com um armazenamento de dados diferentes só requer a implementação dos seguintes métodos abstratos:- <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.GetCountOfState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery)" /> -esse método precisa ser capaz de contar o número de linhas de dados de personalização em o banco de dados para os parâmetros de consulta fornecido.  - <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" /> -Dado o caminho e nome de usuário, esse método carrega duas de objetos binários grandes (BLOBs) do banco de dados: um BLOB para dados compartilhados e outro para dados de usuário. Se você fornecer o nome de usuário e o caminho, você não precisa de <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> controle para acessar as informações de página que podem fornecer as informações de caminho/nome de usuário.  - <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String)" /> - Ao receber o caminho e nome de usuário, este exclui do método correspondente de linha no banco de dados. Se você fornecer o nome de usuário e o caminho, você não precisa de <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> controle para acessar as informações de página que podem fornecer as informações de caminho/nome de usuário.  - <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[])" /> -Dado o caminho e nome de usuário, esse método salva o BLOB fornecido para o banco de dados. Se você fornecer o nome de usuário e o caminho, você não precisa de <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> controle para acessar as informações de página que podem fornecer as informações de caminho/nome de usuário.  Em todos esses métodos, se apenas um caminho for fornecido, que indica que os dados de personalização compartilhadas para a página estão sendo operados. Se um caminho e um nome de usuário são passadas para um método, em seguida, os dados de personalização de usuário para a página devem ser afetados. No caso de <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" />, os dados compartilhados para o caminho especificado devem sempre ser carregados e, opcionalmente, os dados de personalização de usuário para o caminho devem também ser carregados se o nome de usuário não for <see langword="null" />.  Todos os outros métodos abstratos destinam-se apenas para uso em aplicativos administrativos e não são usados pela infraestrutura de Web Parts em tempo de execução. Para obter um exemplo de uma implementação de um provedor de personalização, consulte o <see cref="T:System.Web.UI.WebControls.WebParts.SqlPersonalizationProvider" /> classe.</para>
    </block>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.SqlPersonalizationProvider" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PersonalizationProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PersonalizationProvider();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Como esse é um construtor para uma classe abstrata, você deve substituir esse método para criar uma instância de uma classe que herda dessa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public abstract string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets or sets the name of the application configured for the provider.</summary>
        <value>O aplicativo configurado para o provedor de personalização.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se um nome de aplicativo não for especificado no arquivo de configuração usando o [elemento providers para personalização de Web Parts (ASP.NET Settings Schema)](http://msdn.microsoft.com/library/51363b49-eafa-4b9c-b9d0-80086b385195) o valor de atributo a <xref:System.Web.Hosting.HostingEnvironment.ApplicationVirtualPath%2A> propriedade é usada.  
  
> [!CAUTION]
>  Como uma única instância do provedor de personalização padrão é usada para todas as solicitações atendidas por um <xref:System.Web.HttpApplication> do objeto, você pode ter várias solicitações em execução simultaneamente, cada tentativa de definir o <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> valor da propriedade. O <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> propriedade não é thread-safe para várias gravações e alterando o <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> valor da propriedade pode resultar em comportamento inesperado para vários usuários de um aplicativo. É recomendável que você evite código permitindo que os usuários definam o <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> propriedade, a menos que necessário. Definindo o <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> propriedade pode ser necessária, por exemplo, em um aplicativo administrativo que gerencia os dados de personalização para vários aplicativos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSupportedUserCapabilities">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.IList CreateSupportedUserCapabilities ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.IList CreateSupportedUserCapabilities() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.CreateSupportedUserCapabilities" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateSupportedUserCapabilities () As IList" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::IList ^ CreateSupportedUserCapabilities();" />
      <MemberSignature Language="F#" Value="abstract member CreateSupportedUserCapabilities : unit -&gt; System.Collections.IList&#xA;override this.CreateSupportedUserCapabilities : unit -&gt; System.Collections.IList" Usage="personalizationProvider.CreateSupportedUserCapabilities " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a list of <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" /> objects that represent the set of known capabilities used by the Web Parts control set.</summary>
        <returns>An <see cref="T:System.Collections.IList" /> that represents the set of known capabilities used by the Web Parts control set.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atualmente, esse método retorna uma lista que contém os dois recursos: <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability> e <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ModifyStateUserCapability>. Esses são os recursos padrão que podem ser definidos na [autorização elemento para personalização de Web Parts (ASP.NET Settings Schema)](http://msdn.microsoft.com/library/d190d4ff-1445-4ee1-88eb-9737c7aa1434) elemento dentro do [elemento de personalização de Web Parts (ASP.NET Esquema de configurações)](http://msdn.microsoft.com/library/3d77da55-73ce-46ce-97cf-7d2abcaada09) elemento do[webParts Element (ASP.NET Settings Schema)](http://msdn.microsoft.com/library/90af5acc-5a80-4b39-bba7-74afd06b167c) seção de configuração. Se você optar por implementar uma infraestrutura de personalização customizados, você pode substituir esse método e definir seu próprio conjunto de funcionalidades relacionadas a autorização.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetermineInitialScope">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.PersonalizationScope DetermineInitialScope (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, System.Web.UI.WebControls.WebParts.PersonalizationState loadedState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope DetermineInitialScope(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, class System.Web.UI.WebControls.WebParts.PersonalizationState loadedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.DetermineInitialScope(System.Web.UI.WebControls.WebParts.WebPartManager,System.Web.UI.WebControls.WebParts.PersonalizationState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::PersonalizationScope DetermineInitialScope(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::Web::UI::WebControls::WebParts::PersonalizationState ^ loadedState);" />
      <MemberSignature Language="F#" Value="abstract member DetermineInitialScope : System.Web.UI.WebControls.WebParts.WebPartManager * System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; System.Web.UI.WebControls.WebParts.PersonalizationScope&#xA;override this.DetermineInitialScope : System.Web.UI.WebControls.WebParts.WebPartManager * System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; System.Web.UI.WebControls.WebParts.PersonalizationScope" Usage="personalizationProvider.DetermineInitialScope (webPartManager, loadedState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationScope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="loadedState" Type="System.Web.UI.WebControls.WebParts.PersonalizationState" />
      </Parameters>
      <Docs>
        <param name="webPartManager">The <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> that manages the personalization information.</param>
        <param name="loadedState">The personalization state information.</param>
        <summary>Determines whether the initial personalization scope should be <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> or <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> scope.</summary>
        <returns>A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> indicating whether the current personalization scope is <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> or <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método determina se o escopo atual deve ser <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> ou <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>, dada uma referência a um <xref:System.Web.UI.WebControls.WebParts.WebPartManager> informações que já foi carregadas de anteriormente no ciclo de vida de personalização de estado de controle e personalização. Essas informações são usadas por um <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> instância para as tarefas subsequentes relacionadas à personalização.  
  
 As regras a seguir são usadas para determinar o escopo de personalização:  
  
-   Escopo será considerado inicialmente <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>.  
  
-   Se a conta de usuário em execução no momento não é autenticada, o escopo é definido como <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>.  
  
-   Se a conta de usuário em execução no momento é autenticada, o processamento adicional ocorre na ordem de precedência:  
  
    -   Se a página estiver no modo de postback, a solicitação de página contém informações de escopo de um processamento anterior da página. Se essas informações de escopo indicam que <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> escopo foi usado e, em seguida, o escopo é avaliada como <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>.  
  
    -   Se a página em execução no momento tinha controle transferida a ele partir de outra página (por exemplo, se a transferência de controle ocorreu devido ao chamar o <xref:System.Web.HttpServerUtility.Transfer%2A> método; Observe que essa verificação específica não ocorre para postagem entre as páginas) e se o anteriormente executar a página tinha um <xref:System.Web.UI.WebControls.WebParts.WebPartManager> instância, o escopo é definido como o valor da `Personalization.Scope` propriedade do anterior <xref:System.Web.UI.WebControls.WebParts.WebPartManager> instância.  
  
    -   Se os critérios anteriores não forem atendidos, o escopo é avaliada como o valor da <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.InitialScope%2A> propriedade atual <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle.  
  
 Depois que as avaliações anteriores foram feitas, e se o escopo for avaliado como <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> definir o escopo, o processamento seguinte ocorre:  
  
-   Se a conta de usuário em execução no momento tem o <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability> capacidade, o escopo permanece definido como <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>.  
  
-   Se a conta de usuário em execução no momento não tem o <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability> funcionalidade e, em seguida, o escopo é redefinido como <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>.  
  
-   Se o resultado de todas as avaliações de escopo anterior for <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>, esse resultado é armazenado como um campo oculto na página em execução no momento. Esse é o mecanismo pelo qual uma página pode reproduzir a avaliação de escopo durante postbacks subsequentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartManager" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The page associated with <paramref name="webPartManager" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DetermineUserCapabilities">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary DetermineUserCapabilities (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionary DetermineUserCapabilities(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.DetermineUserCapabilities(System.Web.UI.WebControls.WebParts.WebPartManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionary ^ DetermineUserCapabilities(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager);" />
      <MemberSignature Language="F#" Value="abstract member DetermineUserCapabilities : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; System.Collections.IDictionary&#xA;override this.DetermineUserCapabilities : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; System.Collections.IDictionary" Usage="personalizationProvider.DetermineUserCapabilities webPartManager" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Parameters>
      <Docs>
        <param name="webPartManager">The <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> managing the personalization information.</param>
        <summary>Returns a dictionary containing <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" /> instances that represent the personalization-related capabilities of the currently executing user account.</summary>
        <returns>An <see cref="T:System.Collections.IDictionary" /> containing zero or more <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" /> instances if the user account is authenticated, or <see langword="null" /> if the executing user account is not authenticated.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão desse método consome as informações a [autorização elemento para personalização de Web Parts (ASP.NET Settings Schema)](http://msdn.microsoft.com/library/d190d4ff-1445-4ee1-88eb-9737c7aa1434) elemento dentro a [personalização elemento para Web Parts (ASP.NET Settings Schema)](http://msdn.microsoft.com/library/3d77da55-73ce-46ce-97cf-7d2abcaada09) elemento do[webParts Element (ASP.NET Settings Schema)](http://msdn.microsoft.com/library/90af5acc-5a80-4b39-bba7-74afd06b167c) seção de configuração no arquivo Machine. config ou Web. config para determinar um usuário do autorizado a recursos.  
  
 Os recursos no dicionário serão membros do <xref:System.Collections.IList> objeto retornado pela <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.CreateSupportedUserCapabilities%2A> método, que incluem atualmente o <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability> capacidade e o <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ModifyStateUserCapability> funcionalidade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The page associated with <paramref name="webPartManager" /> is <see langword="null" />.  \- or -  The request associated with the page is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartManager" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindState">
      <MemberSignature Language="C#" Value="public abstract System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection FindState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query, int pageIndex, int pageSize, out int totalRecords);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection FindState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, class System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query, int32 pageIndex, int32 pageSize, [out] int32&amp; totalRecords) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.FindState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery,System.Int32,System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function FindState (scope As PersonalizationScope, query As PersonalizationStateQuery, pageIndex As Integer, pageSize As Integer, ByRef totalRecords As Integer) As PersonalizationStateInfoCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Web::UI::WebControls::WebParts::PersonalizationStateInfoCollection ^ FindState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, System::Web::UI::WebControls::WebParts::PersonalizationStateQuery ^ query, int pageIndex, int pageSize, [Runtime::InteropServices::Out] int % totalRecords);" />
      <MemberSignature Language="F#" Value="abstract member FindState : System.Web.UI.WebControls.WebParts.PersonalizationScope * System.Web.UI.WebControls.WebParts.PersonalizationStateQuery * int * int *  -&gt; System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" Usage="personalizationProvider.FindState (scope, query, pageIndex, pageSize, totalRecords)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="query" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />
        <Parameter Name="pageIndex" Type="System.Int32" />
        <Parameter Name="pageSize" Type="System.Int32" />
        <Parameter Name="totalRecords" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="scope">A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> with the personalization information to be queried. This value cannot be <see langword="null" />.</param>
        <param name="query">A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" /> containing a query. This value can be <see langword="null" />.</param>
        <param name="pageIndex">The location where the query starts.</param>
        <param name="pageSize">The number of records to return.</param>
        <param name="totalRecords">The total number of records available.</param>
        <summary>When overridden in a derived class, returns a collection containing zero or more <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" />-derived objects based on scope and specific query parameters.</summary>
        <returns>A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" /> containing zero or more <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" />-derived objects.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é a definição abstrata de um método administrativo para consultar os dados de personalização. Implementações derivadas devem seguir a lógica descrita abaixo.  
  
 O conjunto de itens retornados é restrito pelo `pageIndex` e `pageSize` parâmetros, onde `pageSize` define o número de registros a serem retornados e `pageIndex` define quais registros a serem retornados. Por exemplo, uma `pageIndex` igual a 0 e uma `pageSize` de 25 retornaria as primeiros 25 ocorrências, enquanto um `pageIndex` de 1 e um `pageSize` de 25 retornaria ocorrências 26 a 50. Se você quiser recuperar todos os registros disponíveis, defina `pageIndex` como 0 e `pageSize` para <xref:System.Int32.MaxValue>.  
  
 O <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo>-objetos derivados são retornados em ordem alfabética e classificados por uma combinação de suas <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo.Path%2A> e <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.Username%2A> valores de propriedade, em ordem crescente.  
  
 Esse método passa caracteres curinga de consulta para o armazenamento de dados subjacente. Suporte para caracteres curinga depende atualmente como cada provedor lida com caracteres como um asterisco (*), um símbolo de porcentagem (%) ou um sublinhado (_).  
  
 Normalmente, para os armazenamentos de dados compatíveis com SQL, você pode executar uma pesquisa curinga em um caminho parcial com o caractere curinga que aparece no início, final ou no meio do texto da cadeia de caracteres de pesquisa no <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> propriedade. Por exemplo, para localizar todos os caminhos que começam com "~/vdir", o <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> propriedade seria definida como "~/vdir%".  
  
 Da mesma forma, uma pesquisa de curinga em um nome de usuário parcial pode ter o caractere curinga a aparecer em qualquer ponto na cadeia de texto do <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> propriedade. Por exemplo, para localizar todos os nomes de usuário que começam com "John", o <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> parâmetro seria semelhante a "John %".  
  
 As restrições de consulta a seguir se aplicam:  
  
-   Se apenas `scope` for fornecido, e `query` é `null` ou todas as propriedades na `query` retornar `null` ou valores padrão, todos os registros correspondentes indicado `scope` parâmetro são retornados.  
  
-   Se o <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> není `null`, os registros retornados também são filtrados com base em caminhos correspondentes a <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> valor.  
  
-   Se o <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> propriedade não é `null`, os registros retornados também são nomes de usuário com base em filtrado que correspondem do <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> valor da propriedade.  
  
-   Se o <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> propriedade não é igual a <xref:System.DateTime.MaxValue>, em seguida, os registros retornados também são filtrados para retornar somente os registros associados com usuários inativos. A comparação inclui registros onde o <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A> propriedade é menor que ou igual ao <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> propriedade.  
  
 Observe que esse método não valida combinações de parâmetros de consulta. Por exemplo, o código pode solicitar um conjunto de registros de estado de personalização associados com um nome de usuário específico no escopo compartilhado. Como os nomes de usuário não são associados com informações compartilhadas, a coleção retornada estariam vazia.  
  
 Combinações de parâmetros que têm o potencial de retornar uma coleção vazia não incluem:  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> o escopo em combinação com o <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> propriedade.  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> o escopo em combinação com os valores para qualquer ou todos os <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>, <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>, e <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> propriedades.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCountOfState">
      <MemberSignature Language="C#" Value="public abstract int GetCountOfState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCountOfState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, class System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.GetCountOfState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCountOfState (scope As PersonalizationScope, query As PersonalizationStateQuery) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCountOfState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, System::Web::UI::WebControls::WebParts::PersonalizationStateQuery ^ query);" />
      <MemberSignature Language="F#" Value="abstract member GetCountOfState : System.Web.UI.WebControls.WebParts.PersonalizationScope * System.Web.UI.WebControls.WebParts.PersonalizationStateQuery -&gt; int" Usage="personalizationProvider.GetCountOfState (scope, query)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="query" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />
      </Parameters>
      <Docs>
        <param name="scope">A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> of the personalization information to be queried. This value cannot be <see langword="null" />.</param>
        <param name="query">A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" /> containing a query. This value can be <see langword="null" />.</param>
        <summary>When overridden in a derived class, returns the number of rows in the underlying data store that exist within the specified scope.</summary>
        <returns>The number of rows in the underlying data store that exist for the specified <paramref name="scope" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é a definição abstrata de um método administrativo para recuperar contagens de dados de personalização. Implementações derivadas devem seguir a lógica descrita abaixo.  
  
 Esse método passa caracteres curinga de consulta para o armazenamento de dados subjacente. Suporte para caracteres curinga depende atualmente como cada provedor lida com caracteres como um asterisco (*), um símbolo de porcentagem (%) ou um sublinhado (_).  
  
 Normalmente, para os armazenamentos de dados compatíveis com SQL, você pode executar uma pesquisa curinga em um caminho parcial com o caractere curinga que aparece no início, final ou no meio do texto da cadeia de caracteres de pesquisa no <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> propriedade. Por exemplo, para localizar todos os caminhos que começam com "~/vdir", o <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> propriedade seria definida como "~/vdir%".  
  
 Da mesma forma, uma pesquisa de curinga em um nome de usuário parcial pode ter o caractere curinga a aparecer em qualquer ponto na cadeia de texto do <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> propriedade. Por exemplo, para localizar todos os nomes de usuário que começam com "John", o <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> parâmetro seria semelhante a "John %".  
  
 As restrições de consulta a seguir se aplicam:  
  
-   Se apenas `scope` for fornecido, e `query` é `null` ou todas as propriedades na `query` retornar `null` ou valores padrão, todos os registros correspondentes indicado `scope` parâmetro são contados.  
  
-   Se o <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> propriedade não é `null`, os registros contados também são filtrados com base em caminhos correspondentes a <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> valor.  
  
-   Se o <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> propriedade não é `null`, os registros contados também são nomes de usuário com base em filtrado que correspondem do <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> valor da propriedade.  
  
-   Se o <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> propriedade não é igual a <xref:System.DateTime.MaxValue>, em seguida, os registros contados também são filtrados para retornar somente os registros associados com usuários inativos. A comparação inclui registros onde o <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A> propriedade é menor que ou igual ao <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> propriedade.  
  
 Observe que esse método não valida combinações de parâmetros de consulta. Por exemplo, o código pode solicitar uma contagem de registros de estado de personalização associados com um nome de usuário específico no escopo compartilhado. Porque os nomes de usuário não estão associados com informações compartilhadas, a contagem retornada deve ser zero.  
  
 Combinações de parâmetros que têm o potencial de retornar uma contagem diferente de zero incluem:  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> o escopo em combinação com o <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> propriedade.  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> o escopo em combinação com os valores para qualquer ou todos os <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>, <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>, e <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> propriedades.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPersonalizationBlobs">
      <MemberSignature Language="C#" Value="protected abstract void LoadPersonalizationBlobs (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, ref byte[] sharedDataBlob, ref byte[] userDataBlob);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadPersonalizationBlobs(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, unsigned int8[]&amp; sharedDataBlob, unsigned int8[]&amp; userDataBlob) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void LoadPersonalizationBlobs(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName, cli::array &lt;System::Byte&gt; ^ % sharedDataBlob, cli::array &lt;System::Byte&gt; ^ % userDataBlob);" />
      <MemberSignature Language="F#" Value="abstract member LoadPersonalizationBlobs : System.Web.UI.WebControls.WebParts.WebPartManager * string * string *  *  -&gt; unit" Usage="personalizationProvider.LoadPersonalizationBlobs (webPartManager, path, userName, sharedDataBlob, userDataBlob)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="sharedDataBlob" Type="System.Byte[]&amp;" RefType="ref" />
        <Parameter Name="userDataBlob" Type="System.Byte[]&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="webPartManager">The <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> managing the personalization data.</param>
        <param name="path">The path for personalization information to be used as the retrieval key.</param>
        <param name="userName">The user name for personalization information to be used as the retrieval key.</param>
        <param name="sharedDataBlob">The returned data for the <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> scope.</param>
        <param name="userDataBlob">The returned data for the <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> scope.</param>
        <summary>When overridden in a derived class, loads raw personalization data from the underlying data store.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Classes que derivam de <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider> e implemente esse método deve usar o `webPartManager`, `path`, e `username` parâmetros como chaves de recuperação. Independentemente de como os dados são armazenados no armazenamento de dados (alguns armazenamentos de dados podem executar algum tipo de armazenamento inteligente), a personalização de dados devem ser retornados como um conjunto empacotado de bytes em duas matrizes. Os dados retornados devem estar de acordo com as regras a seguir:  
  
-   Os dados para o <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> escopo sempre deve ser retornado no `sharedDataBlob` parâmetro.  
  
-   Dependendo dos valores de chave, <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> dados são retornados no `userDataBlob` parâmetro. Um não -`null` de valor para o `userName` parâmetro indica que <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> dados também devem ser recuperados.  
  
 Um provedor de personalização que deriva <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider> e implementa esse método pode otimizar as interações com seu armazenamento de dados recuperar todos os dados de personalização em uma única viagem de ida e, em vez de recuperar <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> e <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> dados em duas Separe as viagens de ida e volta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPersonalizationState">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.PersonalizationState LoadPersonalizationState (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, bool ignoreCurrentUser);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.PersonalizationState LoadPersonalizationState(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, bool ignoreCurrentUser) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::PersonalizationState ^ LoadPersonalizationState(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, bool ignoreCurrentUser);" />
      <MemberSignature Language="F#" Value="abstract member LoadPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager * bool -&gt; System.Web.UI.WebControls.WebParts.PersonalizationState&#xA;override this.LoadPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager * bool -&gt; System.Web.UI.WebControls.WebParts.PersonalizationState" Usage="personalizationProvider.LoadPersonalizationState (webPartManager, ignoreCurrentUser)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="ignoreCurrentUser" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="webPartManager">The <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> managing the personalization data.</param>
        <param name="ignoreCurrentUser">A <see cref="T:System.Boolean" /> indicating whether the user name should be passed to the personalization provider.</param>
        <summary>Loads the raw data from the underlying data store and converts that data into a <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" /> object.</summary>
        <returns>A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" /> containing personalization data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é usado pelo ponto de entrada principal de <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> classe para carregar os dados de personalização. A implementação padrão carrega os dados brutos do armazenamento de dados subjacente (funcionalidade é implementada em provedores derivadas) e, em seguida, converte os dados brutos em um <xref:System.Web.UI.WebControls.WebParts.PersonalizationState> instância.  
  
 Se o `ignoreCurrentUser` parâmetro é `true`, nenhum nome de usuário é passado para o <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs%2A> método. Um provedor de personalização pode optar por interpretar isso como o que significa que esse estado de personalização apenas com um <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> escopo deve ser recuperado do armazenamento de dados subjacente.  
  
 Quando o <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Load%2A> método está sendo executado, ele chama o <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState%2A> método, e há três tipos de erros de desserialização podem ocorrer como o estado está sendo carregado. Quando esses erros específicos ocorrer, nenhuma exceção é lançada, e os eventos de erro são registrados em vez disso, pelo recurso de monitoramento de integridade (para obter informações sobre a integridade do monitoramento e acessando os logs criados por ele, consulte [visão geral sobre monitoramento de integridade do ASP.NET ](http://msdn.microsoft.com/library/e003f224-70fe-4cd8-a71a-2dc81e2d7e4c)). Eventos de erro a ser gravado no log de desserialização a causa de três cenários a seguir:  
  
-   Uma falha ao tentar desserializar um tipo de propriedade que usa uma cadeia de caracteres <xref:System.ComponentModel.TypeConverter>.  
  
-   Uma falha na tentativa de desserializar um tipo de propriedade que usa a serialização binária.  
  
-   Uma falha na tentativa de desserializar uma propriedade de tipo porque não é possível criar uma instância do tipo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="webPartManager" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The page associated with <paramref name="webPartManager" /> is <see langword="null" />.  \- or -  The request associated with the page is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetPersonalizationBlob">
      <MemberSignature Language="C#" Value="protected abstract void ResetPersonalizationBlob (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ResetPersonalizationBlob(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void ResetPersonalizationBlob(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName);" />
      <MemberSignature Language="F#" Value="abstract member ResetPersonalizationBlob : System.Web.UI.WebControls.WebParts.WebPartManager * string * string -&gt; unit" Usage="personalizationProvider.ResetPersonalizationBlob (webPartManager, path, userName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="webPartManager">The <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> managing the personalization data.</param>
        <param name="path">The path for personalization information to be used as the data store key.</param>
        <param name="userName">The user name for personalization information to be used as the data store key.</param>
        <summary>When overridden in a derived class, deletes raw personalization data from the underlying data store.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Classes que derivam de <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider> e implemente esse método deve usar o `webPartManager`, `path`, e `userName` parâmetros como chaves de armazenamento. Implementações derivadas devem modificar o repositório de dados para que os dados de personalização para chaves de armazenamento fornecido é efetivamente excluídos. Cabe as implementações derivadas sobre como eles fisicamente fazer isso.  
  
 O provedor de personalização derivado deve ser capaz de distinguir os dados de personalização em uma base por página. Além disso, para o estado de uma determinada página, o provedor de personalização deve ser capaz de distinguir entre <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> e <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> definir o escopo de dados. Se um não -`null` nome de usuário é fornecido, em seguida, aplica-se a operação de redefinição para o <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> escopo; caso contrário, a operação de redefinição aplica-se para o <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> escopo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetPersonalizationState">
      <MemberSignature Language="C#" Value="public virtual void ResetPersonalizationState (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetPersonalizationState(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetPersonalizationState(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager);" />
      <MemberSignature Language="F#" Value="abstract member ResetPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; unit&#xA;override this.ResetPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; unit" Usage="personalizationProvider.ResetPersonalizationState webPartManager" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Parameters>
      <Docs>
        <param name="webPartManager">The <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> managing the personalization data.</param>
        <summary>Resets personalization data to the underlying data store.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é usado pelo ponto de entrada principal de <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> classe para redefinir os dados de personalização. A implementação padrão usa a <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle para determinar o caminho e nome de usuário para os dados a serem redefinidas. A implementação do padrão, em seguida, chama o <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartManager" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPartManager" /> is not associated with a page.  \- or -  The page is not associated with an in-progress <see cref="T:System.Web.HttpRequest" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetState">
      <MemberSignature Language="C#" Value="public abstract int ResetState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, string[] paths, string[] usernames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ResetState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, string[] paths, string[] usernames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.String[],System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ResetState (scope As PersonalizationScope, paths As String(), usernames As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int ResetState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, cli::array &lt;System::String ^&gt; ^ paths, cli::array &lt;System::String ^&gt; ^ usernames);" />
      <MemberSignature Language="F#" Value="abstract member ResetState : System.Web.UI.WebControls.WebParts.PersonalizationScope * string[] * string[] -&gt; int" Usage="personalizationProvider.ResetState (scope, paths, usernames)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="paths" Type="System.String[]" />
        <Parameter Name="usernames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="scope">A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> of the personalization information to be reset. This value cannot be <see langword="null" />.</param>
        <param name="paths">The paths for personalization information to be deleted.</param>
        <param name="usernames">The user names for personalization information to be deleted.</param>
        <summary>When overridden in a derived class, deletes personalization state from the underlying data store based on the specified parameters.</summary>
        <returns>The number of rows deleted.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é a definição abstrata de um método administrativo para a exclusão de dados de personalização. Implementações derivadas devem seguir a lógica descrita abaixo.  
  
 Não há pesquisas com caractere curinga têm suporte por esse método. Se o provedor de personalização expõe dados de um armazenamento de dados de reconhecimento de transação, esse método deve executar suas operações como uma única transação atômica.  
  
 As seguintes combinações de parâmetros são permitidas:  
  
-   O `scope` parâmetro é definido, e todos os outros parâmetros são definidos como `null`. Essa combinação exclui todos os dados de personalização de Web Parts associados com o escopo de personalização indicado pelo `scope`.  
  
-   O `scope` parâmetro for definido e o `paths` parâmetro contém pelo menos um valor. Essa combinação exclui todos os dados de personalização de Web Parts para o caminho especificado ou os caminhos no escopo de personalização, indicado pelo `scope`.  
  
-   O `scope` parâmetro é definido como <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>, o `paths` parâmetro está definido e contém apenas um valor e o `usernames` parâmetro contém pelo menos um valor. Essa combinação exclui todos os dados de Web Parts para o caminho especificado que está associado com o usuário ou usuários contidos na personalização de usuário `usernames`.  
  
-   O `scope` parâmetro é definido como <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>, o `paths` parâmetro for definido como `null`e o `usernames` parâmetro contém pelo menos um valor. Essa combinação exclui dados de Web Parts, personalização de todos os por usuário em todos os caminhos, associados ao usuário ou usuários contidos no `usernames`.  
  
 Qualquer outra combinação de valores de parâmetro é inválida e gerará um <xref:System.ArgumentException> exceção. Especificamente, as seguintes combinações de dois não são permitidas:  
  
-   O `usernames` parâmetro não pode ser fornecido quando `scope` é definido como <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>.  
  
-   O `paths` parâmetro não pode conter mais de uma entrada quando o `usernames` parâmetro não é `null`.  
  
 Qualquer `paths` e `usernames` contidos dentro das respectivas matrizes de valores de parâmetro devem atender aos seguintes regras de validação. Se nenhuma regra de validação falhar por qualquer membro de matrizes de parâmetro, um <xref:System.ArgumentException> exceção é lançada. As regras de validação são:  
  
-   `null` valores não são permitidos.  
  
-   Uma cadeia de caracteres vazia ("") não é permitido. Parâmetros devem ser quebrados antes de executar uma verificação de cadeia de caracteres vazia.  
  
-   O `usernames` parâmetro não pode conter vírgulas (,).  
  
-   O comprimento do `paths` parâmetro não pode ser maior que 256 caracteres para um banco de dados SQL.  
  
-   O comprimento do `usernames` parâmetro não pode ser maior que 256 caracteres para um banco de dados SQL.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetUserState">
      <MemberSignature Language="C#" Value="public abstract int ResetUserState (string path, DateTime userInactiveSinceDate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ResetUserState(string path, valuetype System.DateTime userInactiveSinceDate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetUserState(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ResetUserState (path As String, userInactiveSinceDate As DateTime) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int ResetUserState(System::String ^ path, DateTime userInactiveSinceDate);" />
      <MemberSignature Language="F#" Value="abstract member ResetUserState : string * DateTime -&gt; int" Usage="personalizationProvider.ResetUserState (path, userInactiveSinceDate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userInactiveSinceDate" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">The path of the personalization data to be deleted. This value can be <see langword="null" /> but cannot be an empty string ("").</param>
        <param name="userInactiveSinceDate">The date indicating the last time a Web site user changed personalization data.</param>
        <summary>When overridden in a derived class, deletes Web Parts personalization data from the underlying data store based on the specified parameters.</summary>
        <returns>The number of rows deleted from the underlying data store.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é a definição abstrata de um método administrativo para a exclusão de dados de personalização. Observe que esse método afeta apenas os dados de personalização de usuário e dados não compartilhada.  
  
 Implementações derivadas devem seguir a lógica descrita abaixo:  
  
-   O `path` parâmetro não pode conter caracteres curinga.  
  
-   Se o provedor expõe dados de um armazenamento de dados de reconhecimento de transação, esse método deve executar suas operações em uma única transação atômica.  
  
-   Se o `path` parâmetro é não -`null`, em seguida, somente os registros personalização por usuário associado `path` serão excluídos.  
  
-   Somente o registros personalização por usuário está associado aos usuários que são considerados inativos desde a data indicada no `userInactiveSinceDate` parâmetro será excluído. Especificamente, registros em que <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A> é menor que ou igual a <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> são excluídos.  
  
-   Se ambos os parâmetros forem fornecidos, os registros que correspondem a ambas as restrições são excluídos.  
  
-   O `path` parâmetro pode ser `null`.  
  
-   O `path` parâmetro não pode ser uma cadeia de caracteres vazia. Ele deve ser cortado antes de executar essa verificação.  
  
-   A propriedade <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> não pode ser `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SavePersonalizationBlob">
      <MemberSignature Language="C#" Value="protected abstract void SavePersonalizationBlob (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, byte[] dataBlob);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SavePersonalizationBlob(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, unsigned int8[] dataBlob) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void SavePersonalizationBlob(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName, cli::array &lt;System::Byte&gt; ^ dataBlob);" />
      <MemberSignature Language="F#" Value="abstract member SavePersonalizationBlob : System.Web.UI.WebControls.WebParts.WebPartManager * string * string * byte[] -&gt; unit" Usage="personalizationProvider.SavePersonalizationBlob (webPartManager, path, userName, dataBlob)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="dataBlob" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="webPartManager">The <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> managing the personalization data.</param>
        <param name="path">The path for personalization information to be used as the data store key.</param>
        <param name="userName">The user name for personalization information to be used as the key.</param>
        <param name="dataBlob">The byte array of data to be saved.</param>
        <summary>When overridden in a derived class, saves raw personalization data to the underlying data store.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é a definição abstrata do método usado para salvar dados brutos de personalização no armazenamento de dados subjacente.  
  
 As implementações derivadas devem usar o `webPartManager`, `path`, e `userName` parâmetros como chaves de armazenamento. O provedor de personalização derivado deve ser capaz de distinguir os dados de personalização em uma base por página. Além disso, para o estado de uma determinada página, o provedor deve ser capaz de distinguir entre <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> e <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> escopo. Se um não -`null` nome de usuário for fornecido, o `dataBlob` parâmetro está sendo <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> escopo; caso contrário, o `dataBlob` parâmetro deve para estar no <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> escopo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SavePersonalizationState">
      <MemberSignature Language="C#" Value="public virtual void SavePersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SavePersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationState)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SavePersonalizationState (state As PersonalizationState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SavePersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationState ^ state);" />
      <MemberSignature Language="F#" Value="abstract member SavePersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; unit&#xA;override this.SavePersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; unit" Usage="personalizationProvider.SavePersonalizationState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationState" />
      </Parameters>
      <Docs>
        <param name="state">A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" /> containing personalization data to be saved.</param>
        <summary>Saves personalization data to a data store.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é usado pelo ponto de entrada principal de <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> classe para salvar os dados de personalização.  
  
 A implementação padrão desse método usa os métodos de implementação interna de <xref:System.Web.UI.WebControls.WebParts.PersonalizationState> empacotar os dados de personalização em uma matriz de bytes. Se os resultados desta remessa criar um byte vazio (porque a extração da propriedade resultou em nenhum dado de personalização) da matriz, a implementação padrão chama o <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob%2A> método. Caso contrário, a implementação padrão chama o <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="state" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="state" /> object being saved has a different type from the <paramref name="state" /> object that was returned by the <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager,System.Boolean)" /> method.</exception>
      </Docs>
    </Member>
  </Members>
</Type>