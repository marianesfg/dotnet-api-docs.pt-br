<Type Name="WebPartManager" FullName="System.Web.UI.WebControls.WebParts.WebPartManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9547ea91f11aaf1618012121bb5893b5e180940a" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51911023" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class WebPartManager : System.Web.UI.Control, System.Web.UI.INamingContainer, System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit WebPartManager extends System.Web.UI.Control implements class System.Web.UI.INamingContainer, class System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
  <TypeSignature Language="VB.NET" Value="Public Class WebPartManager&#xA;Inherits Control&#xA;Implements INamingContainer, IPersonalizable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebPartManager : System::Web::UI::Control, System::Web::UI::INamingContainer, System::Web::UI::WebControls::WebParts::IPersonalizable" />
  <TypeSignature Language="F#" Value="type WebPartManager = class&#xA;    inherit Control&#xA;    interface INamingContainer&#xA;    interface IPersonalizable" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.Control</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.UI.INamingContainer</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.WebControls.WebParts.IPersonalizable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.WebParts.WebPartManagerDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Web.UI.NonVisualControl</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Web.UI.ParseChildren(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Web.UI.PersistChildren(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Web.UI.ViewStateModeById</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.WebParts.WebPartManagerDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Serve como a classe central do conjunto de controles de Web Parts, gerenciando todos os controles, funcionalidade e eventos de Web Parts que ocorrem em uma página da Web.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle age como o Centro de controle ou hub de um aplicativo Web Parts. Deve haver um – e apenas um –<xref:System.Web.UI.WebControls.WebParts.WebPartManager> instância de controle de cada página que usa controles de Web Parts. Assim como acontece com a maioria dos aspectos de aplicativos de Web Parts, o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle funciona somente com os usuários autenticados. Além disso, sua funcionalidade funciona quase que totalmente com controles de servidor que residem em zonas de Web Parts que herdam a <xref:System.Web.UI.WebControls.WebParts.WebZone> classe. Controles de servidor que residem em uma página fora essas zonas podem ter muito pouca funcionalidade de Web Parts ou interação com o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle.  
  
 Como o hub para a funcionalidade de Web Parts em uma página, o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle executa os tipos de tarefas descritas na tabela a seguir.  
  
|Categoria de tarefa|O que faz o controle|  
|-------------------|---------------------------|  
|Controles de Web Parts de acompanhamento|Mantém o controle de muitos tipos diferentes de controles em uma página que fornecem recursos de Web Parts, incluindo <xref:System.Web.UI.WebControls.WebParts.WebPart> controles, conexões, zonas e outras pessoas.|  
|Adicionar e remover controles de Web Parts|Fornece os métodos para adicionar, excluir e fechando <xref:System.Web.UI.WebControls.WebParts.WebPart> controles em uma página.|  
|Administrando conexões|Cria conexões entre os controles e monitora as conexões, bem como os processos de adicionar e removê-los.|  
|Personalizando controles e páginas|Permite aos usuários mover controles para locais diferentes em uma página e inicia os modos de exibição em que os usuários podem editar a aparência, propriedades e comportamento de controles. Mantém as configurações de personalização específicas de usuário em cada página.|  
|Alternando entre diferentes exibições de página|Alterna entre os diferentes modos de exibição especializados da página, uma página de forma que os usuários podem realizar determinadas tarefas como alterar o layout de página ou controles de edição.|  
|Gerando eventos de ciclo de vida de Web Parts|Define, gera e permite que os desenvolvedores para manipular eventos de ciclo de vida de controles de Web Parts, como quando os controles são adicionados, movidos, conectados ou excluídos.|  
|Ativando a importação e exportação de controles|Exporta fluxos XML que contêm o estado das propriedades de <xref:System.Web.UI.WebControls.WebParts.WebPart> controla e permite que os usuários importar os arquivos para a conveniência na Personalizando controles complexos em outras páginas ou sites.|  
  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe tem um grande conjunto de propriedades. Consistente com o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> função de acompanhar outros controles, ele tem um número de propriedades que fazem referência a coleções de controles de Web Parts ou outros objetos especiais de Web Parts. O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>, e <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> propriedades são todas as coleções usadas pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle para seu controle e outros tarefas de gerenciamento.  
  
 Outro grupo de propriedades contém avisos personalizáveis que se aplicam em determinados cenários em que ocorrem em um aplicativo de Web Parts. Isso inclui o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>, o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>e o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A> propriedades.  
  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe substitui algumas de suas propriedades herdadas de base, que são usadas por muitos controles de servidor Web. Isso inclui o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A>, e <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> propriedades.  
  
 Por fim, há um grupo de propriedades úteis para acessar o estado atual do aplicativo. O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> propriedade indica o modo de exibição atual é de uma página no. O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A> propriedade indica se um controle tem permissão para processar o script do lado do cliente, que é relevante em situações em que os usuários podem ter navegadores com diferentes capacidades ou tem o script seja desativado. O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> propriedade é útil para fazer referência a uma classe de utilitário que contém as chamadas para um número de métodos importantes de Web Parts que são usados para casos de extensibilidade. Ocultando as chamadas para esses métodos em uma classe separada (o <xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> classe), o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> API da classe é simplificada. O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> propriedade fornece acesso aos objetos de personalização que armazenam as configurações de personalização dos usuários e persistir esses dados no armazenamento permanente. O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> propriedade indica qual <xref:System.Web.UI.WebControls.WebParts.WebPart> controle em uma página está selecionado no momento pelo usuário ou o aplicativo. O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> propriedade indica se os dados de personalização personalizadas em um <xref:System.Web.UI.WebControls.WebParts.WebPart> controle foi alterado.  
  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle contém cinco modos de exibição internos ou modos de exibição de uma página da Web. Os desenvolvedores podem estender esse recurso, a criação de modos de exibição personalizado ao estender tipos, como o <xref:System.Web.UI.WebControls.WebParts.WebZone> classe ou o <xref:System.Web.UI.WebControls.WebParts.ToolZone> classe. Os usuários podem alternar uma página em vários modos de exibição, desde que o tipo apropriado de controles que correspondem a um modo de exibição em questão estão presentes em uma página.  
  
> [!NOTE]
>  É possível estender esse recurso para que os usuários podem alternar para um modo de exibição personalizado sem a necessidade de uma zona correspondente na página. No entanto, o comportamento padrão é que os modos de exibição correspondem às zonas.  
  
 Os modos de exibição padrão são representados por campos públicos no <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe. A tabela a seguir resume os campos e os modos de exibição que eles se referem. O modo de exibição atual de uma página, conforme observado acima, sempre é referenciado na <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> propriedade e o conjunto de modos de exibição que é possível em uma página específica, considerando o tipo de zonas que estão presentes na página, está contida no <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> propriedade.  
  
|Campo|Detalhes do modo de exibição|  
|-----------|--------------------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>|O modo de exibição de usuário normal de uma página da Web; o padrão e o modo de exibição mais comuns.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>|O modo de exibição em que os usuários podem reorganizar ou excluir os controles para alterar o layout da página.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>|O modo de exibição em que uma interface de usuário (IU) edição se torna visível; os usuários podem editar a aparência, propriedades e comportamento dos controles que são visíveis no modo de navegação normal.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>|O modo de exibição na qual um catálogo de interface do usuário se torna visível; os usuários podem adicionar controles a uma página de catálogos de controles disponíveis.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>|O modo de exibição em que uma conexão da interface do usuário se torna visível; os usuários podem se conectar, gerenciar ou desconectar conexões entre os controles.|  
  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle também contém um número de eventos que são críticas no ciclo de vida de páginas de Web Parts e controles. Esses eventos fornecem controle programático preciso sobre o comportamento de controles de Web Parts. A maioria dos métodos pertencem diretamente ao <xref:System.Web.UI.WebControls.WebParts.WebPart> controles (ou outros controles de servidor ou de usuário que são colocados nos <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zonas para que eles podem se comportar como <xref:System.Web.UI.WebControls.WebParts.WebPart> controles). No entanto, alguns eventos pertencem ao estado da página ou as conexões da página. A tabela a seguir lista os eventos disponíveis e resume suas finalidades.  
  
> [!NOTE]
>  Em todos os casos na tabela a seguir, a palavra "controle" se refere a um <xref:System.Web.UI.WebControls.WebParts.WebPart> controle ou qualquer controle de servidor que reside em uma zona e é empacotado com um <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> objeto em tempo de execução.  
  
|evento|Descrição|  
|-----------|-----------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>|Ocorre imediatamente antes de um controle é adicionado a uma página para verificar se ele está autorizado.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>|Ocorre depois que todas as conexões em uma página foram ativadas.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>|Ocorre pouco antes do processo de ativação de todas as conexões em uma página.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged>|Ocorre depois que o modo de exibição atual de uma página foi alterado.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging>|Ocorre pouco antes do processo de alteração do modo de exibição de uma página.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>|Ocorre depois que a seleção de um controle foi cancelada.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>|Ocorre pouco antes do processo de cancelar a seleção de um controle.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>|Ocorre depois que um controle foi adicionado a uma zona.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding>|Ocorre pouco antes do processo de adicionar um controle a uma zona.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>|Ocorre depois que um controle foi fechado (removida de uma página).|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>|Ocorre pouco antes do processo de fechamento de um controle.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>|Ocorre depois que uma instância de um controle dinâmico (aquele que foi criado por meio de programação ou adicionados a partir de um catálogo) foi excluída permanentemente.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>|Ocorre pouco antes do processo de exclusão de um controle dinâmico.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>|Ocorre depois que um controle foi movido dentro da zona ou para outra zona.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>|Ocorre pouco antes do processo de mover um controle.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>|Ocorre depois que dois controles selecionados para participar de uma conexão estabelecida a conexão.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>|Ocorre pouco antes do processo de conectar dois controles.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>|Ocorre depois que dois controles conectados foram desconectados.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>|Ocorre pouco antes do processo de desconexão de dois controles.|  
  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle tem vários métodos para gerenciar páginas de Web Parts. Um grande conjunto de métodos, não listados aqui, são métodos cujos nomes assumem a forma on*EventName*. Esses métodos normalmente acionar seu evento associado e fornecer o evento com um manipulador de tipo <xref:System.Web.UI.WebControls.WebParts.WebPartEventHandler>. A maioria desses métodos pode ser substituída por desenvolvedores que herdam a <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe. Além disso, os desenvolvedores de páginas podem fornecer manipuladores personalizados para os eventos associados a esses métodos. Por exemplo, no caso do <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> evento, um desenvolvedor de página poderia adicionar uma `OnWebPartAdded` atributo para o `<asp:webpartmanager>` elemento na marcação de uma página da Web e atribua-o nome de um método personalizado para o atributo para fornecer manipulação personalizada para o evento. O atributo corresponde à <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A> método e esse padrão básico funciona para a maioria dos eventos de Web Parts e seus métodos associados de manipulação de eventos.  
  
 Além disso, o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle tem métodos que sejam específicos para a tarefa de gerenciamento <xref:System.Web.UI.WebControls.WebParts.WebPart> controles (e controles de servidor ou usuário usado como <xref:System.Web.UI.WebControls.WebParts.WebPart> controles). Esses métodos incluem <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>, e <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>.  
  
 Outro conjunto de métodos é especializado para conexões. Isso inclui métodos como <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>, e <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>.  
  
 Por fim, alguns <xref:System.Web.UI.WebControls.WebParts.WebPartManager> métodos se concentrar na funcionalidade de personalização. Elas incluem <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A> e <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A>.  
  
 Para obter mais informações sobre outros <xref:System.Web.UI.WebControls.WebParts.WebPartManager> métodos que são acessíveis por meio de <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> propriedade, consulte a documentação para o <xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> classe.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso programático e declarativo do <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle.  
  
 O exemplo de código tem quatro partes:  
  
-   Um controle de usuário que permite que você altere os modos de exibição em uma página de Web Parts.  
  
-   Uma página da Web que contém dois personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controles que podem ser conectados, e um `<asp:webpartmanager>` elemento.  
  
-   Um arquivo de código fonte que contém dois personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controles e uma interface personalizada.  
  
-   Uma explicação de como o exemplo funciona em um navegador.  
  
 O controle de usuário tem um controle de lista suspensa que mostra os possíveis modos de exibição em uma página, considerando os controles de Web Parts que estão presentes na página. Na página da Web para este exemplo de código, esse controle de usuário é declarado logo abaixo do <xref:System.Web.UI.WebControls.WebParts.WebPartManager> elemento na marcação da página e há um `Register` diretiva na parte superior da página da Web para registrar o controle. Para obter detalhes sobre como exibem os modos e uma descrição do código-fonte nesse controle, consulte [instruções passo a passo: alterando modos de exibir em uma página de Web Parts](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/DisplayModeMenuVB.ascx#6)]  
  
 Contém a marcação declarativa para a página da Web `Register` diretivas para o controle de usuário e os controles personalizados. Há um `<asp:webpartmanager>` elemento, um `<asp:webpartzone>` elemento para conter os controles personalizados e um `<asp:connectionszone>` elemento. A página também contém algum código embutido que trata os eventos relacionados à conexão para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controlar; você pode ver o efeito desse código conforme você se conectar e desconectar controles.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 A terceira parte do exemplo é o código-fonte para os controles. Observe que há uma interface denominada `IZipCode`, e essa interface é implementada no `ZipCodeWebPart` classe. Essa classe tem um método de retorno de chamada especial chamado `ProvideIZipCode` que serve como um provedor. O outro tipo, chamado `WeatherWebPart`, também é implementado com um método especial chamado `GetIZipCode`, que permite que o controle atuar como um consumidor de outro controle.  
  
 Para o exemplo de código seja executado, você deve compilar este código-fonte. Você pode compilá-lo explicitamente e coloque o assembly resultante na pasta Bin do seu site da Web ou cache de assembly global. Como alternativa, você pode colocar o código-fonte na pasta App_Code de seu site, onde ele será compilado dinamicamente no tempo de execução. Este exemplo de código pressupõe que você compilou o código-fonte em um assembly e o `Register` o nome do assembly faz referência a diretiva na página da Web. Para um passo a passo que demonstra como compilar, consulte [instruções passo a passo: desenvolvendo e usando um controle de servidor Web personalizado](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/ZipCodeComponent.vb#2)]  
  
 Depois que você carregar a página da Web em um navegador, clique o **modo de exibição** controle de lista suspensa e selecione **Connect** para alternar a página para o modo de conexão. Conectar-se o modo usa a `<asp:connectionszone>` elemento para que você possa criar conexões entre controles. No modo de conexão, clique na seta para baixo na barra de título do **CEP** para ativar o menu de verbos de controle e, em seguida, clique em **Connect**. Depois que a conexão da interface do usuário for exibida, clique no **criar uma conexão com um consumidor** link. Uma célula é exibida com um controle de lista suspensa. Selecione **controle de clima** na lista suspensa e clique **Connect** para concluir a conexão dos dois controles. Clique em **feche**e, em seguida, usar o **modo de exibição** lista suspensa para retornar a página para o modo de navegação normal. Você pode digitar um CEP e o controle do consumidor será atualizado com o valor inserido. Porque o `ZipCode` propriedade foi marcada com o `Personalizable` atributo no código-fonte, o valor dessa propriedade será mantido nas sessões do navegador, poupando assim o valor inserido pelo usuário. Um controle mais sofisticado do consumidor pode pegar as informações de código postal, pesquisar informações meteorológicas baseadas no código e exibi-lo a um usuário.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>O <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> controle foi projetado para ser estendido. Porque ele é para que o site central para aplicativos de Web Parts, quando você deseja estender um tipo específico ou controle no conjunto de controles de Web Parts, em muitos casos, você também deve estender o <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> de classe, porque é provável que você tem alguma propriedade ou método que é necessário para tornar  seu tipo personalizado funcionam no contexto de um aplicativo Web Parts. Documentação de referência de Web Parts (consulte <see cref="N:System.Web.UI.WebControls.WebParts" />), ao discutir como estender uma Web Parts de tipo, com frequência menções o que precisa ser feito para estender o <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe também ou mostra como estendê-lo em um exemplo de código.</para>
    </block>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />
    <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebPartManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebPartManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.%23ctor%2A> construtor inicializa diversas variáveis importantes usadas pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle. Uma atribuição que afeta diretamente a todas as páginas de Web Parts é o fato de que o modo de exibição de página padrão é definido como modo de procura (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActivateConnections">
      <MemberSignature Language="C#" Value="protected virtual void ActivateConnections ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ActivateConnections() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ActivateConnections ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ActivateConnections();" />
      <MemberSignature Language="F#" Value="abstract member ActivateConnections : unit -&gt; unit&#xA;override this.ActivateConnections : unit -&gt; unit" Usage="webPartManager.ActivateConnections " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ativa todas as conexões, em uma página da Web, que estejam inativas no momento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> método é chamado em cada solicitação para uma página para ativar as conexões existentes entre <xref:System.Web.UI.WebControls.WebParts.WebPart> e outros controles de servidor que residem em <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zonas. Em alguns casos, para a instância, se houver um conflito nas conexões que está sendo ativadas, esse método por sua vez chama o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> método para encerrar a conexão um problema. Durante o processo de desconexão de <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> é gerado. Normalmente os desenvolvedores podem cancelar este evento, mas no caso em que isso é um conflito entre as conexões não pode ser cancelada, pois o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle precisa resolver o conflito para concluir o processo de ativação de conexões. Para obter detalhes, consulte <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart AddWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPart AddWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPart ^ AddWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberSignature Language="F#" Value="member this.AddWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.WebPartZoneBase * int -&gt; System.Web.UI.WebControls.WebParts.WebPart" Usage="webPartManager.AddWebPart (webPart, zone, zoneIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">O <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (ou o controle de servidor ou usuário) a ser adicionado a uma página da Web ou aberto em uma página.</param>
        <param name="zone">O <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> ao qual a <c>webPart</c> está sendo adicionada.</param>
        <param name="zoneIndex">Um inteiro que representa a posição ordinal que a <c>webPart</c> ocupa na <c>zona</c>, em relação a outros controles na <c>zona</c>.</param>
        <summary>Fornece o método programático padrão para adicionar controles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> a uma página da Web.</summary>
        <returns>Um controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> que foi adicionado à página.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> método é usado para adicionar novos dinâmico <xref:System.Web.UI.WebControls.WebParts.WebPart> controla a uma página e para reabrir controles estáticos ou dinâmicos que anteriormente foram fechados em uma página. Quando o método é chamado para adicionar um novo controle, ele cria, na verdade, uma cópia do controle referenciado no `webPart` parâmetro. Uma nova ID é gerada para a cópia do controle, para que os desenvolvedores devem referenciar o <xref:System.Web.UI.WebControls.WebParts.WebPart> controle retornado do método para obter o novo valor de ID. Quando o método é chamado para reabrir um controle fechado anteriormente, ele retorna uma referência direta para o controle referenciado pela `webPart` parâmetro.  
  
> [!IMPORTANT]
>  Você sempre deve usar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> método, em vez de <xref:System.Web.UI.ControlCollection.Add%2A> método da coleção de controles referenciada pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A?displayProperty=nameWithType> propriedade a ser adicionada <xref:System.Web.UI.WebControls.WebParts.WebPart> controla por meio de programação para a página, como usando o <xref:System.Web.UI.ControlCollection.Add%2A> método lança uma exceção. Para adicionar um controle que não é um <xref:System.Web.UI.WebControls.WebParts.WebPart> controle (em outras palavras, um controle de servidor que será encapsulado com um <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> controle em tempo de execução), primeiro você deve chamar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> método para criar o controle e, em seguida, chamar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> método para adicionar o controle. Para ver uma demonstração dessa abordagem, consulte a seção de exemplo.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> método para adicionar um controle de servidor por meio de programação para uma página. A marcação da página contém um vazio `<asp:webpartzone>` elemento e um `<asp:webpartmanager>` elemento. Na primeira vez que o **adicionar calendário** botão é clicado, o código no evento manipulador cria um <xref:System.Web.UI.WebControls.Calendar> controlar e adiciona-a uma região como um <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> do objeto, chamar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> método.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> é <see langword="null" />.  
  
\- ou - 
 <paramref name="zone" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="zone" /> não está registrado na coleção de zonas do controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.  
  
\- ou - 
 <paramref name="webPart" /> já está no <paramref name="zone" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor do <paramref name="zoneIndex" /> é menor que zero.</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="AuthorizeWebPart">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AuthorizeWebPart As WebPartAuthorizationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventHandler ^ AuthorizeWebPart;" />
      <MemberSignature Language="F#" Value="member this.AuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler " Usage="member this.AuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o método <see cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" /> é chamado para determinar se um <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou um controle de servidor pode ser adicionado a uma página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> evento ocorre sempre que um <xref:System.Web.UI.WebControls.WebParts.WebPart> controle está sendo adicionado a uma página. Há uma série de cenários comuns em que um controle pode ser adicionado a uma página. Para obter uma descrição completa desses, consulte a seção comentários para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> método. Quando um controle é adicionado, ele deve ser verificado para ver se seu <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriedade foi definida e, nesse caso, se o controle está autorizado a ser adicionado à página.  
  
 Os desenvolvedores podem criar manipuladores de eventos para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> evento, para fornecer filtragem para controles. Se um controle <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> valor da propriedade não atende aos critérios de código de manipulador de eventos, o controle não é adicionado à página.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir um manipulador de evento personalizado para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> evento, que automaticamente substitui o padrão <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> método.  
  
 O código a `mgr1_AuthorizeWebPart` método verifica se os controles na página têm seus respectivos <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> valores de propriedade é definida como `user` e, nesse caso, retorna `true`, que significa que eles serão autorizados e adicionados à página. Isso pressupõe que a abordagem padrão é permitir aos usuários exibir controles com uma página no escopo de personalização de usuário. No entanto, observe que no exemplo a um dos controles tem seu <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> o valor da propriedade é definida como `admin`. Os desenvolvedores podem colocar esse filtro em um controle especializado que foi projetado para somente a usuários administrativos ver. Esse controle falhará na verificação de autorização durante o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> evento e não será exibida. Observe que os controles que não têm a propriedade definida são exibidos também; eles são considerados não deve para ser parte de um cenário de filtragem porque seus <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriedades não estão definidas.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="AvailableTransformers">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AvailableTransformers As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ AvailableTransformers { System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AvailableTransformers : System.Web.UI.WebControls.WebParts.TransformerTypeCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma coleção de objetos <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> que estão disponíveis para uso na criação de conexões de Web Parts entre controles de servidor.</summary>
        <value>Um <see cref="T:System.Web.UI.WebControls.WebParts.TransformerTypeCollection" /> que contém um conjunto de <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> objetos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade usa o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A> método para criar a coleção. Por padrão, ele lê os transformadores disponíveis do arquivo de configuração de aplicativo.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/d98cfd0f-ebd6-4871-89d5-abbd2cdef67b">Visão geral de conexões de partes da Web</related>
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartConnecting (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartConnecting(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartConnecting(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member BeginWebPartConnecting : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit&#xA;override this.BeginWebPartConnecting : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.BeginWebPartConnecting webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">O controle para o qual a conexão está sendo formada.</param>
        <summary>Inicia o processo de conexão de dois controles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A> método existe para que o processo de formar conexões entre controles pode ser feito em estágios distintos, oferecendo aos desenvolvedores mais controle sobre o processo de conexão. O método executa um conjunto de verificações iniciais para garantir que `webPart` está em um estado em que uma conexão pode ser legitimamente formada. Se `webPart` passa todas as verificações, em seguida, é definido como o controle selecionado no momento (consulte a <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> propriedade), e o processo de conexão pode continuar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O modo de exibição atual na página não é <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> está fechado.  
  
\- ou - 
 <paramref name="webPart" /> não faz parte da coleção <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />.  
  
-ou- 
 <paramref name="webPart" /> é igual ao controle <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />.</exception>
        <block subset="none" type="overrides">
          <para>Os desenvolvedores que precisam estender o <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> controle pode desejar substituir esse método em uma classe derivada. Uma abordagem seria chamar o método base e, em seguida, adicione algum tratamento personalizado adicional; ou você talvez queira personalizar completamente o processo de iniciar uma conexão entre controles. Por exemplo, você talvez queira verificar se determinados dados estão disponíveis antes de criar a conexão.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartEditing (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartEditing(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartEditing(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member BeginWebPartEditing : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit&#xA;override this.BeginWebPartEditing : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.BeginWebPartEditing webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">O controle a ser editado.</param>
        <summary>Inicia o processo de edição de um controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> método existe para que o processo de edição de controles pode ser feito em estágios distintos, oferecendo aos desenvolvedores mais controle sobre o processo. O método executa um conjunto de verificações iniciais para garantir que `webPart` está em um estado em que ele pode ser editado. Se `webPart` passa todas as verificações, em seguida, é definido como o controle selecionado no momento (consulte a <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> propriedade), e o processo de edição pode continuar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O modo de exibição atual na página não é <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> está fechado.  
  
\- ou - 
 <paramref name="webPart" /> não faz parte da coleção <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />.  
  
-ou- 
 <paramref name="webPart" /> é igual ao controle <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />.</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="BrowseDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BrowseDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ BrowseDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable BrowseDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa o modo de exibição padrão para páginas que contêm controles de Web Parts. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> referências de campo personalizado <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> objeto que é criado e contido pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle. Como esse é um objeto estático, você pode consultá-lo diretamente por meio de <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe sem a necessidade de uma instância do controle.  
  
 Quando uma página que contém as Web Parts controla pela primeira vez, ela está em <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> (modo de procura) por padrão. Quando os usuários simplesmente estiver navegando, como em uma página da Web normal, a página permanece no modo de procura. Se os usuários desejam personalizar uma página de layout, controles, aparência ou comportamento, é preciso alternar a página em um dos modos de exibição especializados disponíveis por meio de <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> propriedade.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como trabalhar com o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> campo por meio de programação. O código preenche uma lista suspensa com os modos de exibição com suporte, que nesse caso, são procurar e design. Observe que, no `Page_PreRender` método, o código verifica se o atual <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> estiver definida como <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>. Nesse caso, `Label1` estarão visíveis e se não estiver, `Label1` ficará oculta.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/CS/wpmgrBrowseDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/VB/wpmgrBrowseDisplayModevb.aspx#1)]  
  
 Depois de carregar a página em um navegador, você está no modo de procura por padrão. Observe o rótulo na página que indica que você está no modo de procura. Use o controle de lista suspensa para alternar a página para o modo de design. Observe que, por causa do código a `Page_PreRender` agora o método, o rótulo está oculto.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Modos de exibição de página de Web Parts</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CanConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Verifica os controles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> que participarão de uma conexão a fim determinar se eles são capazes de ser conectados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> método é usado para determinar se dois <xref:System.Web.UI.WebControls.WebParts.WebPart> controles podem ser conectados. O método normalmente é usado como uma verificação condicional antes de chamar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> método.  
  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> método verifica um número de critérios que devem ser atendidos antes de dois controles podem formar uma conexão. A lista a seguir resume os principais critérios para fazer uma conexão. Se todos esses critérios (além de algumas condições internas adicionais) forem atendidas, o método retorna `true`, que significa que os controles podem ser conectados:  
  
-   Os controles de provedor e consumidor não podem ser `null`, e eles devem estar contidos na coleção de controles referenciada pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> propriedade.  
  
-   O provedor e consumidor não podem ser o mesmo controle. Em outras palavras uma <xref:System.Web.UI.WebControls.WebParts.WebPart> controle não pode se conectar a mesmo.  
  
-   O <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint> objetos (pontos de conexão) para o provedor e o consumidor não podem ser `null`.  
  
-   O provedor e consumidor não podem ser fechados (nenhum dos controles <xref:System.Web.UI.WebControls.WebParts.WebPart.IsClosed%2A> propriedade pode ser `true`).  
  
-   O <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.ControlType%2A> propriedade do controle de ponto de conexão deve corresponder ao tipo de controle do consumidor e provedor.  
  
-   Os pontos de conexão devem estar habilitados (suas <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.GetEnabled%2A> métodos devem retornar `true`).  
  
-   Cada ponto de conexão deve não ser feita uma tentativa formar a mais conexões do que o que é especificado em seu próprio <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.AllowsMultipleConnections%2A> propriedade.  
  
-   Se um <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> objeto (transformador) é necessário para conectar controles incompatíveis, ele não pode ser `null`. No entanto, se os controles já forem compatíveis, deve ser o transformador `null`.  
  
-   O transformador (se usado) deve ser referenciado no <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A> coleção.  
  
-   O transformador (se usado) deve ter interfaces que são compatíveis com o provedor e o consumidor, de modo que ele pode transformar dados entre os dois controles. As interfaces secundárias do consumidor e provedor também devem ser compatíveis.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberSignature Language="F#" Value="member this.CanConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint -&gt; bool" Usage="webPartManager.CanConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">O controle que fornece dados ao <c>consumidor</c> quando os controles estão conectados.</param>
        <param name="providerConnectionPoint">Um <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> que permite que o <c>provedor</c> participe de uma conexão.</param>
        <param name="consumer">O controle que recebe dados do <c>provedor</c> quando os controles estão conectados.</param>
        <param name="consumerConnectionPoint">Um <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> que funciona como um método de retorno de chamada para que o <c>consumidor</c> possa participar de uma conexão.</param>
        <summary>Verifica os controles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> que participarão de uma conexão para determinar se eles são capazes de ser conectados, quando os controles de consumidor e provedor têm interfaces compatíveis e um objeto <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> não é necessário.</summary>
        <returns>Um valor booliano que indica se <paramref name="provider" /> e <paramref name="consumer" /> podem ser conectados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é usado para conectar-se `provider` e `consumer` quando ambos os controles têm conexão compatível aponte tipos, para que um <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> objeto não é necessário. Você talvez queira usar esse método para verificar se os dois controles podem ser conectados antes de chamar <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> para criar uma conexão programática.  
  
 Essa sobrecarga usa a mesma implementação como o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29> sobrecarga de método, a única exceção, sendo que essa sobrecarga não exige um transformador.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar esse método.  
  
 O exemplo de código tem quatro partes:  
  
-   Um controle de usuário que permite que você altere os modos de exibição em uma página de Web Parts.  
  
-   Uma página da Web que contém dois personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controles que podem ser conectados, uma `<asp:webpartmanager>` elemento e algum código de manipulação de eventos que cria uma conexão usando o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> método.  
  
-   Um arquivo de código fonte que contém dois personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controles e uma interface personalizada.  
  
-   Uma explicação de como o exemplo funciona em um navegador.  
  
 A primeira parte do exemplo de código é o controle de usuário para alterar modos de exibição. Você pode obter o código-fonte para o controle de usuário da seção do exemplo da <xref:System.Web.UI.WebControls.WebParts.WebPartManager> visão geral da classe. Para obter mais informações sobre modos de exibição e como funciona o controle de usuário, consulte [instruções passo a passo: alterando modos de exibir em uma página de Web Parts](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Contém a marcação declarativa para a página da Web `Register` diretivas para o controle de usuário e os controles personalizados. Há um `<asp:webpartmanager>` elemento, um `<asp:webpartzone>` elemento para conter os controles personalizados e um `<asp:connectionszone>` elemento. Observe que, no `Page_Load` método, o código verifica se a conexão pode ser feita e, nesse caso, define um provedor, um consumidor e seus pontos de conexão do respectivo e, em seguida, adiciona uma nova conexão para o conjunto de conexões estáticas referenciado pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>propriedade.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 A terceira parte do exemplo é o código-fonte para os controles. Ele contém uma interface e dois personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controla, um que atua como um provedor e o outro como um consumidor. Porque eles têm pontos de conexão compatíveis (eles reconhecem o `IZipCode` interface), um transformador não é necessária para fazer a conexão. Para o exemplo de código seja executado, você deve compilar este código-fonte. Você pode compilá-lo explicitamente e coloque o assembly resultante na pasta Bin do seu site da Web ou cache de assembly global. Como alternativa, você pode colocar o código-fonte na pasta App_Code de seu site, onde ele será compilado dinamicamente no tempo de execução. Para um passo a passo que demonstra como compilar, consulte [instruções passo a passo: desenvolvendo e usando um controle de servidor Web personalizado](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/ZipCodeComponent.vb#2)]  
  
 Depois que você carregar a página da Web em um navegador, clique o **modo de exibição** controle de lista suspensa e selecione **Connect** para alternar a página para o modo de conexão. Conectar-se o modo usa a `<asp:connectionszone>` elemento para que você possa criar conexões entre controles. No modo de conexão, clique na seta para baixo na barra de título do **CEP** para ativar o menu de verbos de controle e, em seguida, clique em **Connect**. Depois que a interface do usuário de conexão (IU) for exibida, observe que uma conexão já foi criado pelo código contido no `Page_Load` método.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberSignature Language="F#" Value="abstract member CanConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; bool&#xA;override this.CanConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; bool" Usage="webPartManager.CanConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint, transformer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">O controle que fornece dados ao <c>consumidor</c> quando os controles estão conectados.</param>
        <param name="providerConnectionPoint">Um <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> que funciona como um método de retorno de chamada para que o <c>provedor</c> possa participar de uma conexão.</param>
        <param name="consumer">O controle que recebe dados do <c>provedor</c> quando os controles estão conectados.</param>
        <param name="consumerConnectionPoint">Um <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> que funciona como um método de retorno de chamada para que o <c>consumidor</c> possa participar de uma conexão.</param>
        <param name="transformer">Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> que permite que um <c>provedor</c> e um <c>consumidor</c> incompatíveis se conectem.</param>
        <summary>Verifica os controles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> que participarão de uma conexão para determinar se eles são capazes de conexão e serem conectados e usa um objeto <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> para criar a conexão entre um provedor e um consumidor incompatíveis.</summary>
        <returns>Um valor booliano que indica se <paramref name="provider" /> e <paramref name="consumer" /> podem formar uma conexão.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é usado para conectar-se `provider` e `consumer` quando ambos os controles têm conexão incompatível aponte tipos, para que um <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> objeto é necessário. Você talvez queira usar esse método para verificar se os dois controles podem ser conectados antes de chamar <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> para criar uma conexão programática.  
  
 Essa sobrecarga usa a mesma implementação como o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29> sobrecarga de método, a única exceção, sendo que essa sobrecarga requer um transformador.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CatalogDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CatalogDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ CatalogDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable CatalogDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa o modo de exibição usado para adicionar controles de servidor de um catálogo de controles a uma página da Web. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> referências de campo personalizado <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> objeto que é criado e contido pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle. Como esse é um objeto estático, você pode consultá-lo diretamente por meio de <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe sem a necessidade de uma instância do controle.  
  
 Quando os usuários desejam adicionar controles a uma página, se um catálogo de controles de servidor estiver disponível, eles podem alternar a página para <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> (modo de catálogo) e a interface do usuário do catálogo (UI) é exibida. A interface do usuário para um catálogo de Web Parts é fornecido por um <xref:System.Web.UI.WebControls.WebParts.CatalogZoneBase> controle de zona. Os desenvolvedores adicionar essa zona para a página em tempo de design e, em seguida, adicionar controles de servidor para a zona, para que os usuários poderão adicionar esses controles para suas páginas em tempo de execução. Depois que o desenvolvedor adicionou esses controles, o modo de catálogo se torna um modo de exibição com suporte na página porque há os controles necessários habilitar o modo de catálogo.  
  
 Quando um usuário alterna de uma página de catálogo modo, a zona e todos os controles de servidor que foram adicionados a ele se tornam visíveis, e o usuário pode selecionar controles a partir do catálogo para adicionar à página, ou remova os controles de página. Depois que os controles foram adicionados à página, eles aparecem no modo de navegação normal e a página é atualizada.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como trabalhar com o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> campo por meio de programação. O código preenche uma lista suspensa com os modos de exibição com suporte para a página, neste caso são procurar, o design e o catálogo. O modo de catálogo está disponível devido a `<asp:CatalogZone>` elemento e seus elementos filho na página da Web. Observe que, no `Page_PreRender` método, o código verifica se o atual <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> estiver definida como <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>. Nesse caso, `Label1` estarão visíveis e se não estiver, `Label1` ficará oculta.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/CS/wpmgrCatalogDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/VB/wpmgrCatalogDisplayModevb.aspx#1)]  
  
 Depois de carregar a página em um navegador, você está no modo de procura por padrão. Observe que o rótulo da página está oculto. Use o controle de lista suspensa para alternar a página para o modo de catálogo. Observe que, por causa do código no `Page_PreRender` método, o rótulo agora está visível. Você pode selecionar o controle no catálogo e adicioná-lo a qualquer uma das duas regiões na página.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Modos de exibição de página de Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="CheckRenderClientScript">
      <MemberSignature Language="C#" Value="protected virtual bool CheckRenderClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool CheckRenderClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CheckRenderClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CheckRenderClientScript () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool CheckRenderClientScript();" />
      <MemberSignature Language="F#" Value="abstract member CheckRenderClientScript : unit -&gt; bool&#xA;override this.CheckRenderClientScript : unit -&gt; bool" Usage="webPartManager.CheckRenderClientScript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verifica os recursos do navegador que está fazendo a solicitação e o valor da propriedade <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" /> para determinar se o script de cliente deve ser renderizado.</summary>
        <returns>Um valor booliano que indica se o script de cliente deve ser renderizado.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="CloseProviderWarning">
      <MemberSignature Language="C#" Value="public virtual string CloseProviderWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CloseProviderWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CloseProviderWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CloseProviderWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CloseProviderWarning : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um aviso que é exibido quando um usuário fecha um controle que atua como um provedor para outros controles em uma conexão.</summary>
        <value>Uma cadeia de caracteres que contém a mensagem de aviso. O padrão é uma mensagem específicas de cultura fornecida pelo .NET Framework.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um usuário fecha um <xref:System.Web.UI.WebControls.WebParts.WebPart> controlar, normalmente, nenhuma mensagem é exibida. Para obter mais informações sobre o que significa para fechar um controle, consulte o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> método.  
  
 No entanto, quando um controle está conectado a outro controle e está agindo como um provedor de dados para o outro controle, uma mensagem de aviso padrão é exibida quando um usuário de tenta fechar o controle. A mensagem informa aos usuários que um controle do provedor está prestes a fechar, que significa que controla conectado a esse provedor como consumidores deixará de ter todos os dados para consumir. O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> propriedade permite aos desenvolvedores personalizar a mensagem de aviso é exibida ao usuário.  
  
 Se um desenvolvedor de página atribui um valor de cadeia de caracteres vazia ou nula para essa propriedade, nenhuma caixa de mensagem de aviso será exibida quando um usuário fecha um <xref:System.Web.UI.WebControls.WebParts.WebPart> controle que é um provedor.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> propriedade para exibir um aviso personalizado para os usuários.  
  
 O exemplo de código tem quatro partes:  
  
-   Um controle de usuário que permite que você altere os modos de exibição em uma página de Web Parts.  
  
-   Um arquivo de código fonte que contém dois personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controles e uma interface personalizada.  
  
-   Uma página da Web que contém dois personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controles que podem ser conectados e um `<asp:webpartmanager>` elemento.  
  
-   Uma explicação de como o exemplo funciona em um navegador.  
  
 O código a seguir contém somente a parte da página da Web do exemplo. Também será necessário o controle de usuário personalizada e o código-fonte para os controles personalizados mencionados acima. Obter esses dois itens da seção do exemplo da <xref:System.Web.UI.WebControls.WebParts.WebPartManager> visão geral da classe.  
  
 O código de página da Web a seguir demonstra como atribuir uma mensagem de aviso personalizado para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> propriedade na marcação declarativa no `<asp:webpartmanager>` elemento.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 Depois que você carregar a página da Web em um navegador, clique o **modo de exibição** controle de lista suspensa e selecione **Connect** para alternar a página para o modo de conexão. Conectar-se o modo usa a `<asp:connectionszone>` elemento para que você possa criar conexões entre controles. No modo de conexão, clique na seta para baixo na barra de título do **CEP** para ativar o menu de verbos de controle e, em seguida, clique em **Connect**. Depois que a interface do usuário de conexão (IU) for exibida, clique no **criar uma conexão com um consumidor** link. Uma célula é exibida com um controle de lista suspensa. Selecione **controle de clima** na lista suspensa e clique **Connect** para concluir a conexão dos dois controles. Clique em **feche**e, em seguida, usar o **modo de exibição** lista suspensa para retornar a página para o modo de navegação normal. Por fim, clique no menu de verbos para o **CEP** controle (que é o controle de provedor neste caso) e selecione **fechar**. Uma mensagem personalizada você atribuiu para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> propriedade é exibida.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="CloseWebPart">
      <MemberSignature Language="C#" Value="public void CloseWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CloseWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.CloseWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.CloseWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou controle de servidor que está sendo fechado em uma <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</param>
        <summary>Fecha um controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> de forma que ele não seja renderizado em uma página da Web, mas que possa ser reaberto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> método Remove um <xref:System.Web.UI.WebControls.WebParts.WebPart> ou outro controle de servidor para que ele não é renderizado na página da Web que continha originalmente. O controle fechado é adicionado a um <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> object, que mantém uma referência para o controle fechado e torna possível para o controle a ser restaurado para a página. Um fechados <xref:System.Web.UI.WebControls.WebParts.WebPart> controle ainda aparece na coleção referenciada pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> propriedade.  
  
 Fechar um controle é diferente de excluí-lo. Controles fechados ainda estão disponíveis a ser restaurado para uma página, mas uma instância de controle excluído é removida permanentemente e nunca poderão ser restaurada. Independentemente se um <xref:System.Web.UI.WebControls.WebParts.WebPart> ou controle de servidor é estático (declarado na marcação de uma página) ou dinâmico (adicionado à página programaticamente ou por um usuário de um catálogo de Web Parts), ele pode ser fechado e reaberto em uma página.  
  
 Normalmente, os usuários podem fechar um <xref:System.Web.UI.WebControls.WebParts.WebPart> controle clicando em seu menu de verbos e selecionando o verbo fechar. Um controle pode também ser fechado chamando diretamente os <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> método e passá-lo uma referência ao `webPart`.  
  
 Em uma página em que <xref:System.Web.UI.WebControls.WebParts.WebPart> controles foram fechados, se um desenvolvedor declara um `<asp:catalogzone>` elemento e dentro dele, adiciona um `<asp:pagecatalogpart>` elemento, ele fornece uma interface do usuário simples (UI) para que os usuários restaurem controles fechados para a página em tempo de execução. Os usuários podem alternar a página em modo de exibição de catálogo e os controles fechados serão exibido no catálogo de página. Os usuários podem selecionar controles fechados e adicioná-los para a página em qualquer posição que quiserem e, em seguida, os controles selecionados são restaurados para a página e renderizados como normais.  
  
 Quando o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> método é chamado, ele gera vários eventos: <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> (se houver vários controles), e <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> (se houver controles conectados). Normalmente os desenvolvedores podem cancelar esses eventos, mas em alguns casos, não é possível cancelá-las. Para obter detalhes, consulte a documentação para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>, e <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> eventos.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> método.  
  
 O exemplo de código tem quatro partes:  
  
-   Um controle de usuário que permite que você altere os modos de exibição de página.  
  
-   Um personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controle.  
  
-   Uma página da Web.  
  
-   Uma explicação de como o exemplo funciona em um navegador.  
  
 A primeira parte do exemplo de código é o controle de usuário para alterar modos de exibição. Você pode obter o código-fonte para o controle de usuário da seção do exemplo da <xref:System.Web.UI.WebControls.WebParts.WebPartManager> visão geral da classe. Para obter mais informações sobre modos de exibição e como funciona o controle de usuário, consulte [instruções passo a passo: alterando modos de exibir em uma página de Web Parts](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 A segunda parte do exemplo de código é personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controle. Para o exemplo de código seja executado, você deve compilar este código-fonte. Você pode compilá-lo explicitamente e coloque o assembly resultante na pasta Bin do seu site da Web ou cache de assembly global. Como alternativa, você pode colocar o código-fonte na pasta App_Code de seu site, onde ele será compilado dinamicamente no tempo de execução. Este exemplo usa a abordagem de compilação dinâmica; Portanto, não há nenhuma `Assembly` de atributo no `Register` diretriz para esse controle na parte superior da página da Web. Para um passo a passo que demonstra como compilar, consulte [instruções passo a passo: desenvolvendo e usando um controle de servidor Web personalizado](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/textdisplaywebpart.vb#3)]  
  
 A terceira parte do exemplo de código é a página da Web. A página contém um <xref:System.Web.UI.WebControls.WebParts.CatalogZone> zona, com um <`asp:pagecatalogpart>` elemento declarado dentro dele. Isso é o que irá conter fechado <xref:System.Web.UI.WebControls.WebParts.WebPart> controlar e permitir que os usuários para adicioná-lo de volta para a página. O `Button1_Click` método chama diretamente o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> método para fechar o personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controlar, embora um usuário também pode fechar o controle por meio do menu de verbos.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/closeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/closeWebPartVB.aspx#1)]  
  
 Depois de carregar a página em um navegador, feche o personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controle clicando no menu de verbos (o símbolo de seta) no cabeçalho do controle e, em seguida, clicando em **fechar**. Agora, altere a página para modo de catálogo, selecionando **catálogo** na **modo de exibição** controle de lista suspensa. O catálogo de página é exibida com o controle fechado. Selecione a caixa de seleção ao lado do controle fechado, clique em **Add** para adicioná-lo para a página e, em seguida, clique em **fechar** para retornar a página para o modo de procura. O controle é restaurado para a página. Agora fechá-lo novamente, desta vez clicando o **WebPart fechar** botão.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> não está na coleção <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />.  
  
\- ou - 
 <paramref name="webPart" /> é um controle compartilhado e já foi fechado por outro usuário.</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowClose" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ConnectDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ ConnectDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable ConnectDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa o modo de exibição usado para exibir uma UI (interface do usuário) especial para os usuários gerenciarem as conexões entre controles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> referências de campo personalizado <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> objeto que é criado e contido pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle. Como esse é um objeto estático, você pode consultá-lo diretamente por meio de <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe sem a necessidade de uma instância do controle.  
  
 Quando os usuários desejam gerenciar conexões entre <xref:System.Web.UI.WebControls.WebParts.WebPart> controles em uma página da Web, se um <xref:System.Web.UI.WebControls.WebParts.ConnectionsZone> zona foi declarada na página, eles podem alternar a página para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> modo. O modo de exibição do connect exibe uma interface do usuário especial para gerenciar as conexões, que inclui a capacidade de conectar ou desconectar controles e editar os detalhes das conexões existentes.  
  
 Se você deseja fornecer aos usuários a capacidade de gerenciar conexões com a interface do usuário fornecida pelo conjunto de controles de Web Parts, você deve declarar um `<asp:connectionszone>` elemento na marcação de uma página. Ao contrário de elementos para os outros tipos de <xref:System.Web.UI.WebControls.WebParts.WebZone> zonas, você não precisa adicionar quaisquer outras marcas dentro desse elemento; você simplesmente declarar o elemento por si só.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> modo.  
  
 O exemplo de código tem três partes:  
  
-   Um arquivo de origem que contém uma interface e personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controles que podem formar uma conexão.  
  
-   Uma página da Web que fornece uma interface do usuário da conexão e demonstra o trabalho com o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> modo.  
  
-   Uma explicação de como executar o exemplo.  
  
 A primeira parte do exemplo de código é um arquivo de origem que contém uma interface e dois personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controles que são projetados para que eles podem ser conectados. Para o exemplo de código seja executado, você deve compilar este código-fonte. Você pode compilá-lo explicitamente e coloque o assembly resultante na pasta Bin do seu site da Web ou cache de assembly global. Como alternativa, você pode colocar o código-fonte na pasta App_Code de seu site, onde ele será compilado dinamicamente no tempo de execução. Este exemplo de código usa a abordagem de compilação dinâmica. Para um passo a passo que demonstra como compilar, consulte [instruções passo a passo: desenvolvendo e usando um controle de servidor Web personalizado](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ZipCodeComponent.vb#2)]  
  
 A segunda parte do exemplo é uma página da Web que hospeda os controles personalizados. Dentro do servidor `<script>` marcas na página são vários métodos que preenchem uma lista suspensa com os modos de exibição disponíveis na página. Um usuário pode selecioná-los na lista suspensa para alterar o modo de exibição da página. Um dos modos de exibição disponíveis é conectar-se o modo de exibição, porque um `<asp:connectionszone>` elemento é declarado na marcação da página. Observe que esse elemento não contém outros elementos filho; ele existe somente para habilitar o gerenciamento de conexão da interface do usuário para usuários.  
  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> modo aparece neste exemplo em dois locais. Primeiro, do `Page_Init` método, o modo de exibição do connect é adicionado à lista suspensa dos modos de exibição, como o código executa loops por meio da coleção referenciada no <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> propriedade. Segundo, o `Page_PreRender` método verifica o modo de exibição atual na página, e se o modo atual é <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>, será exibida uma mensagem em uma <xref:System.Web.UI.WebControls.Label> controle.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ConnectDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ConnectDisplayModeVB.aspx#1)]  
  
 Depois de carregar a página em um navegador, clique na lista suspensa e selecione **Connect** para alternar a página em modo de exibição do connect. Observe que uma mensagem é exibida, informando que a página estiver no modo de exibição de conectar-se. Agora, clique no menu de verbos (um símbolo de seta) na barra de título de um dos <xref:System.Web.UI.WebControls.WebParts.WebPart> controles e depois clique em **Connect** no menu de verbos. Após a conexão a interface do usuário for exibida, clique no link para criar uma conexão. Use a lista suspensa dentro a conexão da interface do usuário que aparece, selecione o controle que participam de conexão e clique no **Connect** botão. A conexão é estabelecida. Clique o **fechar** botão e, em seguida, use a lista suspensa na parte superior da página para retornar a página para procurar o modo de exibição.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Modos de exibição de página de Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="Connections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ Connections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connections : System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma referência à coleção de todas as conexões atuais em uma página da Web.</summary>
        <value>Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" /> que contém um conjunto de <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> objetos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> propriedade fornece uma maneira de acessar o conjunto atual de conexões em uma página. A coleção em si é somente leitura, e os desenvolvedores que desejam manipular uma conexão específica da coleção devem usar <xref:System.Web.UI.WebControls.WebParts.WebPartManager> métodos como <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> e <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso programático e declarativo do <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle.  
  
 O exemplo de código tem quatro partes:  
  
-   Um controle de usuário que permite que você altere os modos de exibição em uma página de Web Parts.  
  
-   Uma página da Web que contém dois personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controles que podem ser conectados, e um `<asp:webpartmanager>` elemento.  
  
-   Um arquivo de código fonte que contém dois personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controles e uma interface personalizada.  
  
-   Uma explicação de como o exemplo funciona em um navegador.  
  
 O código a seguir contém somente a parte da página da Web do exemplo. Também será necessário o controle de usuário personalizada e o código-fonte para os controles personalizados mencionados acima. Obter esses dois itens da seção do exemplo da <xref:System.Web.UI.WebControls.WebParts.WebPartManager> visão geral da classe.  
  
 O código de página da Web a seguir demonstra como usar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> propriedade por meio de programação para obter a contagem de conexões atuais em uma página. Observe que no `<script>` seção de marca, o código para manipular dois eventos para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controlar os acessos a <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> propriedade para obter a contagem.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 Depois que você carregar a página da Web em um navegador, clique o **modo de exibição** controle de lista suspensa e selecione **Connect** para alternar a página para o modo de conexão. Conectar-se o modo usa a `<asp:connectionszone>` elemento para que você possa criar conexões entre controles. No modo de conexão, clique na seta para baixo na barra de título do **CEP** para ativar o menu de verbos de controle e, em seguida, clique em **Connect**. Depois que exibe a interface do usuário de conexão (UI), clique no **criar uma conexão com um consumidor** link. Uma célula é exibida com um controle de lista suspensa. Selecione **controle de clima** na lista suspensa e clique **Connect** para concluir a conexão dos dois controles. Clique em **feche**e, em seguida, usar o **modo de exibição** lista suspensa para retornar a página para o modo de navegação normal. Observe que um rótulo agora exibe o número de conexões e o número de <xref:System.Web.UI.WebControls.WebParts.WebPart> controles. Se agora você retornar para o modo de conexão e desconectar-se os dois controles, quando você retornar para o modo, procurar conteúdo do rótulo deve ser atualizado e não deve haver nenhuma conexão.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivated">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivated" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivated;" />
      <MemberSignature Language="F#" Value="member this.ConnectionsActivated : EventHandler " Usage="member this.ConnectionsActivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre depois que todas as conexões de Web Parts atuais em uma página não estejam apenas conectadas, mas já tenham começado a compartilhar ativamente dados entre os controles de consumidor e provedor envolvidos em cada conexão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No ciclo de vida de conexões, esse evento ocorre após a conclusão de uma página de seu processo de carregamento. Isso também ocorre após o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> evento, que indica apenas que o <xref:System.Web.UI.WebControls.WebParts.WebPart> ou controles de servidor envolvidos em uma conexão específica se conectou com êxito. Em casos em que há várias conexões em uma página, o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated> método indica que todas as conexões de Web Parts válidas em uma página agora são capazes de compartilhar dados e Active Directory. Sabendo que todas as conexões estão ativas, os desenvolvedores podem executar qualquer número de tarefas, incluindo a notificação de usuários do status de todas as conexões, notificando os controles de consumidor para processar e exibir dados de seus fornecedores e assim por diante.  
  
 Esse evento está associado com o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A> método, que gera o evento e permite aos desenvolvedores criar manipuladores personalizados para o evento.  
  
 Os desenvolvedores de páginas podem criar um manipulador personalizado para o evento adicionando o `OnConnectionsActivated` de atributo para o `<asp:webpartmanager>` os elementos na página e, em seguida, atribuir um nome de método personalizado para o atributo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivating">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivating" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivating As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivating;" />
      <MemberSignature Language="F#" Value="member this.ConnectionsActivating : EventHandler " Usage="member this.ConnectionsActivating : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre durante o processo de ativação de todas as conexões de Web Parts estabelecidas em uma página da Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No ciclo de vida de conexões, esse evento ocorre como uma página está Concluindo o processo de carregamento imediatamente antes o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> método é chamado. Isso é diferente dos <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> evento, que envolve uma conexão específica entre <xref:System.Web.UI.WebControls.WebParts.WebPart> ou outros controles de servidor. O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> evento ocorre quando todas as conexões possíveis em uma página tem sido conectadas e estão prestes a ser ativado.  
  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> evento está associado a <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> método, que gera o evento. Os desenvolvedores de controle que desejam estender o tipo de conexões que podem ser adicionados a uma página poderia substituir protegido <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> método e ativar tipos adicionais de conexões.  
  
 Os desenvolvedores de páginas podem criar um manipulador personalizado para o evento adicionando o `OnConnectionsActivating` de atributo para o `<asp:webpartmanager>` os elementos na página e, em seguida, atribuir um nome de método personalizado para o atributo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria uma conexão entre dois controles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (ou outros controles de servidor capazes de formar conexões) que residem em uma zona <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> método de uma conexão entre quaisquer dois formulários <xref:System.Web.UI.WebControls.WebParts.WebPart> controles que podem ser conectados. Antes de chamar esse método para criar uma conexão, você também poderá chamar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> método em uma verificação condicional para garantir que os controles de atender os requisitos para formar uma conexão.  
  
> [!NOTE]
>  Também é possível criar uma conexão entre dois controles de servidor que não são <xref:System.Web.UI.WebControls.WebParts.WebPart> controles. Em geral, os dois controles precisaria ser controles personalizados do servidor (por exemplo, os controles que herdam de <xref:System.Web.UI.WebControls.WebControl> ou controles de servidor ASP.NET existentes) para que você pode adicionar os membros necessários. Os controles também teria que atender aos requisitos especificados abaixo.  
  
 Qualquer tipo de cenário de conexão entre dois controles deve atender aos requisitos a seguir para ser capaz de se conectar:  
  
-   Cada controle reside em um <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zona (ele não precisa ser a mesma zona).  
  
-   Conforme implementado no conjunto de controles de Web Parts, o controle em uma conexão do provedor implementa uma interface como um método público que serve como um retorno de chamada para o provedor e tem um `ConnectionProvider` atributo de metadados no método de para identificá-lo como uma conexão de provedor do ponto. Porque o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> método que recupera pontos de conexão de provedor é virtual, um derivado <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle não precisa necessariamente usar o mesmo atributo de metadados.  
  
-   Conforme implementado no conjunto de controles de Web Parts, o controle do consumidor em uma conexão também tem um método especial que permite que ele obtenha uma referência para a interface que é exposta no método de retorno de chamada do provedor e o consumidor tem um `ConnectionConsumer` atributo de metadados em aponte o método de para identificá-lo como uma conexão de consumidor. Porque o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> método para que os pontos de conexão do consumidor recupera é virtual, um derivado <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle não precisa necessariamente usar o mesmo atributo de metadados.  
  
-   Os métodos de retorno de chamada devem ser compatíveis, em que o consumidor pode usar o tipo de interface fornecido no método de retorno de chamada do provedor (o que significa que o consumidor e provedor podem compartilhar dados diretamente) ou o desenvolvedor deve usar um <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> objeto Transforme os dados do provedor em um formulário que o consumidor pode usar.  
  
    > [!IMPORTANT]
    >  Quando você não precisa um transformador, use o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29> sobrecarga de método. Quando você precisa de um transformador, use o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29> sobrecarga de método.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberSignature Language="F#" Value="member this.ConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint -&gt; System.Web.UI.WebControls.WebParts.WebPartConnection" Usage="webPartManager.ConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">Um controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> que tem a função de fornecer dados para outro controle conectado.</param>
        <param name="providerConnectionPoint">Um método que serve como um método de retorno de chamada para a conexão. Conforme implementado no conjunto de controles de Web Parts, esse é um método público no <c>provedor</c> que é marcado com um atributo de metadados <see langword="ConnectionProvider" />.</param>
        <param name="consumer">Um controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> que tem a função de receber de dados do <c>provedor</c> e, em seguida, processá-lo ou exibi-lo.</param>
        <param name="consumerConnectionPoint">Um método que se conecta com <c>providerConnectionPoint</c> para receber os dados para a conexão. Conforme implementado no conjunto de controles de Web Parts, esse é um método público no <c>consumidor</c> que é marcado com um atributo de metadados <see langword="ConnectionConsumer" />.</param>
        <summary>Cria uma conexão entre dois controles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> usando apenas as referências aos controles e seus objetos <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> especificados.</summary>
        <returns>Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> que contém as diversas informações sobre o provedor e o consumidor necessários para uma conexão.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga é usada para conectar controles quando seus pontos de conexão são suficientemente compatíveis que eles possam se conectar sem usar um <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> objeto. Quando essa sobrecarga do método é chamada, ele simplesmente passa a chamada para a versão sobrecarregada do método e passa `null` para o parâmetro que exija um <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> objeto.  
  
 Quando você tenta conectar dois controles de forma programática, você pode usar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> método em uma verificação condicional para determinar se os controles podem ser conectados diretamente.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar esse método para criar uma conexão de forma programática. Para o necessário para executar o exemplo de código completo, consulte a seção exemplo o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> visão geral da classe. Esse exemplo, você precisará o código-fonte para o controle de usuário que permite que você altere os modos de exibição da página e o código-fonte para dois personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controles.  
  
 O código para a página da Web que hospeda os dois controles da seguinte maneira. A página usa `Register` diretivas na parte superior para declarar o controle de usuário e os controles personalizados. Os controles personalizados são referenciados declarativamente dentro um `<asp:webpartzone>` elemento. O código que manipula a `Button1_Click` método cria uma conexão entre os controles usando o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> método.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 Depois de carregar a página em um navegador, clique o **conectar-se controles de Web Part** botão para formar a conexão. Em seguida, você pode inserir alguns dados na caixa de texto e clique no **insira o código postal de 5 dígitos** botão para demonstrar que os controles estão conectados e que os dados digitados no primeiro controle são atualizados no segundo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A coleção de coleções dinâmicas do controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> é somente leitura.</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberSignature Language="F#" Value="abstract member ConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; System.Web.UI.WebControls.WebParts.WebPartConnection&#xA;override this.ConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; System.Web.UI.WebControls.WebParts.WebPartConnection" Usage="webPartManager.ConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint, transformer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> que tem a função de fornecer dados para outro controle conectado.</param>
        <param name="providerConnectionPoint">Um método público no <c>provedor</c> que é marcado com um atributo de metadados <see langword="ConnectionProvider" /> e serve como um método de retorno de chamada para a conexão.</param>
        <param name="consumer">Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> que tem a função de receber de dados do <c>provedor</c> ou do <c>transformador</c> e, em seguida, processá-lo ou exibi-lo.</param>
        <param name="consumerConnectionPoint">Um método público no <c>consumidor</c> que é marcado com um atributo de metadados <see langword="ConnectionConsumer" /> e conecta-se com <c>providerConnectionPoint</c> para receber os dados para a conexão.</param>
        <param name="transformer">Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> que permite uma conexão entre dois controles, convertendo os dados do <c>provedor</c> para um formato que <c>consumidor</c> possa processar.</param>
        <summary>Cria uma conexão entre dois controles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> usando as referências aos controles, seus objetos <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> especificados e um objeto <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />.</summary>
        <returns>Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> que contém as informações sobre o provedor, o consumidor e o transformador, necessárias para uma conexão.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga é usada para conectar controles quando seus pontos de conexão são incompatíveis. A incompatibilidade ocorre quando `consumer` implementa uma interface diferente que `provider` como seu ponto de conexão. O transformador converte os dados em um tipo que possa ser compreendido pela `consumer`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">As conexões já foram ativadas em <see cref="E:System.Web.UI.Control.PreRender" />.</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public override System.Web.UI.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Controls As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ControlCollection ^ Controls { System::Web::UI::ControlCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Controls : System.Web.UI.ControlCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a coleção de todos os <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />, servidores ou controles de usuário que estão contidos em zonas <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> em uma página da Web e são gerenciados pelo controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <value>Um <see cref="T:System.Web.UI.ControlCollection" /> que contém todos os controles gerenciados pelo <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> controle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A> propriedade não faz referência os outros controles que são referenciados pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controlar, como os vários controles, de zona <xref:System.Web.UI.WebControls.WebParts.EditorPart> ou <xref:System.Web.UI.WebControls.WebParts.CatalogPart> controles e outros.  
  
 Essa propriedade é usada pelo conjunto de controles de Web Parts e na maioria das situações de desenvolvimento, que ele não se destina a ser chamado a partir do código. Por esse motivo, embora a propriedade é pública, ele está oculto do IntelliSense. Os desenvolvedores que desejam acessar a coleção de <xref:System.Web.UI.WebControls.WebParts.WebPart> ou outros controles de servidor gerenciados pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle deve usar seu <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> propriedade.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="CopyWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPart CopyWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart CopyWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ CopyWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member CopyWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.WebPart&#xA;override this.CopyWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.WebPart" Usage="webPartManager.CopyWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">O <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou controle de servidor a ser copiado.</param>
        <summary>Usado pelo conjunto de controles de Web Parts para criar uma cópia de um <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou controle de servidor com a finalidade de adicionar o controle a uma página da Web.</summary>
        <returns>Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> a ser adicionado a uma página.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você não pode chamar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> método diretamente do seu código. Esse método é chamado internamente pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle como parte do processo de adição de um novo dinâmico <xref:System.Web.UI.WebControls.WebParts.WebPart> ou controle de servidor a uma página. Um controle dinâmico é adicionado a uma página por meio de programação ou por meio da interface do usuário de Web Parts (UI), por exemplo por um usuário adicionar um controle de um catálogo de controles, em vez de um controle estático, que é declarado diretamente na marcação de uma página.  
  
> [!NOTE]
>  Se quiser que os desenvolvedores habilitar o método lidar com cenários de cópia de controle adicional, o método pode ser substituído em uma classe derivada. Para obter detalhes, consulte as seção Observações para herdeiros.  
  
 Quando um novo controle dinâmico é adicionado, se ele for um <xref:System.Web.UI.WebControls.WebParts.WebPart> controle, o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> método retorna uma nova instância do controle. Se o controle que está sendo adicionado for algum outro tipo de controle de servidor (por exemplo, um controle de usuário, um controle personalizado ou um controle ASP.NET), o controle será já foram encapsulado com um <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> objeto pelo conjunto de controles de Web Parts. Quando o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> método encontra um <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> controle, ele retorna uma nova instância do <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> controle com uma nova instância do controle filho encapsulado dentro dele.  
  
 Quando o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> método cria uma nova cópia de um controle para retornar, ele também redefine os valores de todas as propriedades para seus valores padrão. Observe que, se você quiser preservar os valores das propriedades personalizáveis e tê-los copiado para a nova instância de controle, você deve chamar o <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.CopyPersonalizationState%2A> método também. A etapa final realizada pela <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> método é chamar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID%2A> método para obter uma nova ID para o controle.  
  
> [!NOTE]
>  Porque o método obtém uma nova ID para um controle copiado, você não deve confiar em referência a um controle dinâmico que é adicionado a uma página por sua ID original. Em vez disso, você deve fazer referência a nova instância do controle retornado pelo método.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>O método é declarado como <see langword="virtual" /> para que os desenvolvedores podem herdar o <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> de classe, substitua o método e fornecer para outros cenários em que ele possa criar cópias dos controles. Por exemplo, o método pode opcionalmente receber como entrada um controle que foi serializado em um arquivo XML. O método poderia desserializar o XML (se houver) e, em seguida, chame o método base para lidar com casos existentes e retornar uma nova instância de uma <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> controle.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="CreateAvailableTransformers">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateAvailableTransformers () As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ CreateAvailableTransformers();" />
      <MemberSignature Language="F#" Value="abstract member CreateAvailableTransformers : unit -&gt; System.Web.UI.WebControls.WebParts.TransformerTypeCollection&#xA;override this.CreateAvailableTransformers : unit -&gt; System.Web.UI.WebControls.WebParts.TransformerTypeCollection" Usage="webPartManager.CreateAvailableTransformers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um conjunto de transformadores especificado no arquivo de configuração de um site e o adiciona à coleção de transformadores referenciada pela propriedade <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />.</summary>
        <returns>A coleção de transformadores especificada no arquivo de configuração de um site.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Esse método pode ser substituído para adicionar transformadores adicionais que podem ser usados pelo aplicativo. Por exemplo, o método poderia ser escrito para recuperar uma lista de transformadores disponíveis de um serviço Web.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="CreateControlCollection">
      <MemberSignature Language="C#" Value="protected override sealed System.Web.UI.ControlCollection CreateControlCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Web.UI.ControlCollection CreateControlCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateControlCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function CreateControlCollection () As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Web::UI::ControlCollection ^ CreateControlCollection();" />
      <MemberSignature Language="F#" Value="override this.CreateControlCollection : unit -&gt; System.Web.UI.ControlCollection" Usage="webPartManager.CreateControlCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna a coleção de todos os controles que são gerenciados pelo controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> em uma página da Web. Essa classe não pode ser herdada.</summary>
        <returns>Uma <see cref="T:System.Web.UI.ControlCollection" /> que consiste em todos os diversos controles de Web Parts gerenciados pelo controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Porque esse método é protegido e selado, ele fica visível para classes que herdam a <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe, mas ele não pode ser substituído.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateDisplayModes">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDisplayModes () As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ CreateDisplayModes();" />
      <MemberSignature Language="F#" Value="abstract member CreateDisplayModes : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection&#xA;override this.CreateDisplayModes : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" Usage="webPartManager.CreateDisplayModes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria o conjunto de todos os possíveis modos de exibição para um aplicativo de Web Parts.</summary>
        <returns>Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" /> que contém todos os modos de exibição que são compatíveis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método cria a lista de todos os possíveis modos de exibição, não apenas os modos de exibição com suporte em uma página específica. Para obter mais informações sobre os modos de exibição com suporte, consulte o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> propriedade.  
  
 Por padrão, o conjunto de controles de Web Parts cria o seguinte conjunto de modos de exibição a ser usado nas páginas de Web Parts:  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>  
  
 Os desenvolvedores podem criar modos de exibição personalizados, com ou sem que acompanha as zonas personalizadas que derivam de <xref:System.Web.UI.WebControls.WebParts.WebZone> ou <xref:System.Web.UI.WebControls.WebParts.ToolZone> classes. Para criar um modo de exibição personalizado, você deve herdar do <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> classe, e para adicionar o modo de exibição como um modo com suporte em uma página, você deve herdar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> de classe e substituir o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> método.  
  
 Quando você adicionar modos de exibição usando o <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection.Add%2A> método, você deve adicioná-los na ordem em que você deseja que apareçam em quaisquer controles de interface do usuário do usuário (como um <xref:System.Web.UI.WebControls.ListBox> controle) que fornecem aos usuários os possíveis modos de exibição em uma página.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> método.  
  
 O exemplo de código tem cinco partes:  
  
-   Um controle de usuário que permite que você altere os modos de exibição em uma página de Web Parts.  
  
-   Uma página da Web que hospeda outros controles.  
  
-   Um controle de usuário que reside em um <xref:System.Web.UI.WebControls.WebParts.WebPartZone> zona na página da Web e permite que você inserir e exibir o texto do rótulo.  
  
-   Um arquivo de código fonte que contém dois controles. Um é um personalizado <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle e o outro é um personalizado <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> objeto a ser adicionado para modos de exibição padrão da página.  
  
-   Um arquivo de código fonte que contém dois personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controles e uma interface personalizada.  
  
-   Uma explicação de como o exemplo funciona em um navegador.  
  
 A primeira parte do exemplo de código é o controle de usuário para alterar modos de exibição. Você pode obter o código-fonte para o controle de usuário da seção do exemplo da <xref:System.Web.UI.WebControls.WebParts.WebPartManager> visão geral da classe. Para obter mais informações sobre modos de exibição e como funciona o controle de usuário, consulte [instruções passo a passo: alterando modos de exibir em uma página de Web Parts](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 A segunda parte do exemplo é a página da Web. Ele contém duas <xref:System.Web.UI.WebControls.WebParts.WebPartZone> controles, controles de usuário e personalizado <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle. Observe que o `Register` diretivas na parte superior da página para fazer referência a controles de usuário e o namespace para os controles compilados.  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/createDisplayModeCS.aspx#1)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/createDisplayModeVB.aspx#1)]  
  
 A terceira parte do exemplo é o controle de usuário para inserir e exibir texto. Ele usa um <xref:System.Web.UI.WebControls.MultiView> controle para criar vários modos de exibição da interface do usuário. Um modo de exibição é exibida com o `Button1` botão, a outra sem. Observe que no substituído `OnPreRender` método, o código verifica para ver se a página está atualmente no modo de exibição personalizado e, em caso afirmativo, exibe a primeira exibição do controle de usuário, que inclui o botão. Se a página for não no modo de exibição personalizado, por exemplo, se a página estiver no modo de design ou procurar o botão permanece oculto.  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/TextDisplaycs.ascx#2)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/TextDisplayvb.ascx#2)]  
  
 A quarta parte do exemplo é o arquivo de origem para as duas classes personalizadas. Observe que o personalizado <xref:System.Web.UI.WebControls.WebParts.WebPartManager> substituições de classe a <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> método, e que ele primeiro chama o método base para adicionar todos os modos de exibição padrão e, em seguida, adiciona o modo de exibição personalizado. A classe de modo de exibição personalizado, `InLineEditDisplayMode`, simplesmente herde <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>, define o nome do modo de exibição no construtor e substitui um número de propriedades base para estabelecer as características de exibição personalizada.  
  
 Para o exemplo de código seja executado, você deve compilar este código-fonte. Você pode compilá-lo explicitamente e coloque o assembly resultante na pasta Bin do seu site da Web ou cache de assembly global. Como alternativa, você pode colocar o código-fonte na pasta App_Code de seu site, onde ele será compilado dinamicamente no tempo de execução. Para um passo a passo que demonstra como compilar, consulte [instruções passo a passo: desenvolvendo e usando um controle de servidor Web personalizado](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/CustomDisplayMode.cs#3)]
 [!code-vb[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/CustomDisplayMode.vb#3)]  
  
 Para executar o exemplo de código, carregue a página em um navegador. Observe que a página está atualmente em modo de procura e nenhum botão está visível. Usando o **modo de exibição** suspensa controle de lista, altere a página a ser **embutido Editar exibição** modo e observe que agora o `Button1` botão está visível no controle de usuário mais baixo. Adicione algum texto e clique no botão para atualizar o controle. Observe que a exibição de página é retornada para o modo de procura, o texto que você inseriu agora é exibido e o botão mais uma vez é oculto porque a página não está mais no modo de exibição personalizado.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
        <related type="Article" href="https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0">Passo a passo: Alterando modos de exibição em uma página de Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicConnectionID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicConnectionID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicConnectionID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicConnectionID () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicConnectionID();" />
      <MemberSignature Language="F#" Value="abstract member CreateDynamicConnectionID : unit -&gt; string&#xA;override this.CreateDynamicConnectionID : unit -&gt; string" Usage="webPartManager.CreateDynamicConnectionID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém um valor exclusivo para servir como uma ID para uma conexão dinâmica.</summary>
        <returns>Uma cadeia de caracteres que contém uma ID exclusiva para uma conexão.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID%2A> método gera um valor de GUID e o converte em uma cadeia de caracteres para servir como a ID exclusiva para uma conexão. O método é chamado sempre que uma conexão dinâmica é criada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Os desenvolvedores podem substituir este método em um derivada <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe para alterar a implementação para gerar uma ID exclusiva.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicWebPartID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicWebPartID (Type webPartType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicWebPartID(class System.Type webPartType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicWebPartID (webPartType As Type) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicWebPartID(Type ^ webPartType);" />
      <MemberSignature Language="F#" Value="abstract member CreateDynamicWebPartID : Type -&gt; string&#xA;override this.CreateDynamicWebPartID : Type -&gt; string" Usage="webPartManager.CreateDynamicWebPartID webPartType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="webPartType">O <see cref="T:System.Type" /> do controle para o qual uma ID está sendo gerada.</param>
        <summary>Gera uma ID exclusiva para um controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> dinâmico.</summary>
        <returns>Uma cadeia de caracteres que contém a ID exclusiva para um controle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Web.UI.WebControls.WebParts.WebPart> controles são adicionados a uma página da Web, eles podem ser estático (que significa que o controle é declarado na marcação da página) ou dinâmico (o que significa que eles são adicionados por meio de programação). Em qualquer cenário em que o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle está criando novos controles dinâmicos para adicionar à página, ele chama esse método para gerar uma ID exclusiva.  
  
 O método é virtual para que os desenvolvedores podem substituir se deseja fornecer uma implementação personalizada para gerar a ID.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartType" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="CreateErrorWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart (string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart(string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateErrorWebPart (originalID As String, originalTypeName As String, originalPath As String, genericWebPartID As String, errorMessage As String) As ErrorWebPart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::ErrorWebPart ^ CreateErrorWebPart(System::String ^ originalID, System::String ^ originalTypeName, System::String ^ originalPath, System::String ^ genericWebPartID, System::String ^ errorMessage);" />
      <MemberSignature Language="F#" Value="abstract member CreateErrorWebPart : string * string * string * string * string -&gt; System.Web.UI.WebControls.WebParts.ErrorWebPart&#xA;override this.CreateErrorWebPart : string * string * string * string * string -&gt; System.Web.UI.WebControls.WebParts.ErrorWebPart" Usage="webPartManager.CreateErrorWebPart (originalID, originalTypeName, originalPath, genericWebPartID, errorMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ErrorWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="originalID" Type="System.String" />
        <Parameter Name="originalTypeName" Type="System.String" />
        <Parameter Name="originalPath" Type="System.String" />
        <Parameter Name="genericWebPartID" Type="System.String" />
        <Parameter Name="errorMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="originalID">Uma cadeia de caracteres que é a ID do controle com falha. Se um <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> estiver envolvido na falha, a ID será a ID do controle de servidor filho.</param>
        <param name="originalTypeName">Uma cadeia de caracteres que é o nome do <see cref="T:System.Type" /> do controle com falha. Se um <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> estiver envolvido na falha, o nome do tipo será o tipo do controle de servidor filho.</param>
        <param name="originalPath">Uma cadeia de caracteres que contém o caminho para um controle de usuário, se um <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> que contém um controle de usuário filho estiver envolvido na falha.</param>
        <param name="genericWebPartID">Uma cadeia de caracteres que retorna a ID de um <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />, se esse tipo de controle estava envolvido na falha ao carregar ou criar um controle.</param>
        <param name="errorMessage">Uma cadeia de caracteres que contém a mensagem de erro a ser exibida na página.</param>
        <summary>Cria um controle especial que é inserido em uma página e exibido para usuários finais, quando uma tentativa de carregar ou criar um controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> dinâmico falha por alguma razão.</summary>
        <returns>Um <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" /> que é inserido em uma página no lugar de um controle que falhou ao ser carregado ou criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A> método é chamado quando o conjunto tenta carregar ou criar uma instância de um dinâmico de controle de Web Parts <xref:System.Web.UI.WebControls.WebParts.WebPart> ou controle de servidor e ele falhar por algum motivo. O método cria um <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> objeto, atribui uma mensagem de erro a ela e o retorna. O <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> controle é inserido no lugar do controle que falharam e sua mensagem de erro é exibida na página.  
  
 Você não pode chamar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A> método diretamente do seu código. No entanto, é possível herdar a <xref:System.Web.UI.WebControls.WebParts.WebPartManager> de classe e estender o método. Para obter detalhes, consulte as notas para a seção de herdeiros.  
  
 Os usuários finais podem trabalhar com um <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> de controle em uma página muito como precisaria um normal <xref:System.Web.UI.WebControls.WebParts.WebPart> controle. Para remover a mensagem de erro, eles podem fechar o controle clicando o verbo fechar, no ponto em que o controle será adicionado a um <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> objeto, como qualquer outro controle fechado. Se um usuário final exclui um <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> controle, o controle de servidor que falharam ao carregar também será excluído da página.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Se você deseja personalizar as informações retornadas na <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" /> controle, você pode substituir o <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" /> método, chame o método base, atribuir valores diferentes para os parâmetros passados para o método base e, em seguida, retornar o resultante <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />controle. Por exemplo, se você não quiser que os usuários finais vejam a <paramref name="originalPath" /> valor (que deve mostrar o caminho do diretório virtual de um controle de usuário), quando você chama o método base, você poderia passar uma cadeia de caracteres vazia ("") para esse parâmetro.  
  
Você também pode personalizar o comportamento do <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" /> controle em si, por meio de herança dele. Por exemplo, você talvez queira substituir seus <see cref="P:System.Web.UI.WebControls.WebParts.Part.Title" /> ou <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowMinimize" /> propriedade.</para>
        </block>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="CreatePersonalization">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreatePersonalization () As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ CreatePersonalization();" />
      <MemberSignature Language="F#" Value="abstract member CreatePersonalization : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartPersonalization&#xA;override this.CreatePersonalization : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartPersonalization" Usage="webPartManager.CreatePersonalization " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um objeto de personalização para conter os dados de personalização de um usuário para a página da Web atual.</summary>
        <returns>Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> para conter os dados de personalização de um usuário.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A> método retorna um objeto para conter e gerenciar as configurações de personalização do usuário para a página atual. O <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle gerencia esse objeto.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
        <related type="Article" href="https://msdn.microsoft.com/library/7dc34f74-52aa-4082-b98d-2bcf9e07e320">Visão geral de personalização de partes da Web</related>
      </Docs>
    </Member>
    <Member MemberName="CreateWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::GenericWebPart ^ CreateWebPart(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="abstract member CreateWebPart : System.Web.UI.Control -&gt; System.Web.UI.WebControls.WebParts.GenericWebPart&#xA;override this.CreateWebPart : System.Web.UI.Control -&gt; System.Web.UI.WebControls.WebParts.GenericWebPart" Usage="webPartManager.CreateWebPart control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Um controle de servidor que não seja um controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</param>
        <summary>Encapsula um controle de servidor que não seja um controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> com um objeto <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />, para que o controle possa ter a funcionalidade de Web Parts.</summary>
        <returns>Um <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> que encapsula <paramref name="control" /> e permite que ele funcione como um verdadeiro controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> método é o mecanismo principal para habilitar controles de servidor que não estão <xref:System.Web.UI.WebControls.WebParts.WebPart> controles para assumir a mesma funcionalidade que um <xref:System.Web.UI.WebControls.WebParts.WebPart> controle e, portanto, para participar totalmente de aplicativos de Web Parts. Usando esse método, os desenvolvedores muito expandir o número de controles de servidor que eles podem usar em um aplicativo de Web Parts, porque a praticamente qualquer tipo de controle de servidor – controles padrão do ASP.NET, controles de usuário e controles personalizados – podem ser usados.  
  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle também usa esse método em dois outros cenários para encapsular os controles de servidor com um <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> objeto. Quando os usuários adicionar controles de servidor a uma página usando o <xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> controle, se o controle importado não é um <xref:System.Web.UI.WebControls.WebParts.WebPart> controle, o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> método é chamado. Além disso, quando os controles de servidor são declarados no formato de persistência dentro de um <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zona em uma página da Web, o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> método é chamado para todos os controles que não são <xref:System.Web.UI.WebControls.WebParts.WebPart> controles.  
  
 Quando você adiciona um controle de servidor a uma zona por meio de programação, uma abordagem típica é usar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> método para encapsular o controle com um <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> do objeto e, em seguida, chame o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> método para adicionar o controle à coleção de todos os <xref:System.Web.UI.WebControls.WebParts.WebPart> controles da página, que é referenciado pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> propriedade.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> método. No `Button2_Click method`, o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> método é chamado para encapsular um <xref:System.Web.UI.WebControls.Calendar> controlar com um <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> objeto antes de adicioná-lo à zona.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Esse método pode ser substituído para usar um derivada <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> classe em vez disso, da classe base fornecido com as Web Parts do conjunto de controles.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteWarning">
      <MemberSignature Language="C#" Value="public virtual string DeleteWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DeleteWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DeleteWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ DeleteWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DeleteWarning : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define uma mensagem de aviso personalizada exibida aos usuários finais quando eles excluem um controle.</summary>
        <value>Uma cadeia de caracteres que contém o texto da mensagem de aviso. O valor padrão é uma mensagem de aviso localizado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um usuário exclui um <xref:System.Web.UI.WebControls.WebParts.WebPart> controlar, normalmente uma mensagem de aviso padrão é exibida. Ele avisa o usuário que, quando essa instância de um controle é excluída, a exclusão é permanente. O desenvolvedor de páginas pode fornecer aos usuários uma maneira de adicionar uma nova instância do controle para a página (como um catálogo de <xref:System.Web.UI.WebControls.WebParts.WebPart> controles, ou por meio de algum meio programático), mas a instância atual de um controle que é excluído permanentemente é removida. A caixa de diálogo que exibe o aviso inclui um botão para o usuário cancelar a exclusão, se desejado.  
  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> propriedade permite que os desenvolvedores definam a mensagem de aviso é exibida ao usuário.  
  
 Se um desenvolvedor de página atribui uma cadeia de caracteres vazia ("") o valor para essa propriedade, nenhuma caixa de diálogo de mensagem de aviso será exibido quando um usuário exclui um <xref:System.Web.UI.WebControls.WebParts.WebPart> controle.  
  
> [!NOTE]
>  O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> propriedade não é exibida no caso do estático <xref:System.Web.UI.WebControls.WebParts.WebPart> controles e controles de servidor. Controles estáticos são controles de servidor que são declarados dentro de um <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zona na marcação de uma página da Web. Como esses controles são estáticos, eles não podem ser excluídos, portanto, a mensagem de aviso de exclusão nunca é exibida nesse caso. Controles estáticos podem ser fechados por um usuário, mas um controle fechado é adicionado ao catálogo de página, do qual ele pode ser adicionado para a página por um usuário, enquanto um controle excluído nunca pode ser recuperado.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> propriedade declarativamente e programaticamente.  
  
 Há quatro partes para o exemplo de código:  
  
-   Um controle de usuário que permite que você altere os modos de exibição de página.  
  
-   Um personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controle.  
  
-   Uma página da Web.  
  
-   Uma explicação de como o exemplo funciona em um navegador.  
  
 A primeira parte do exemplo de código é o controle de usuário para alterar modos de exibição. Você pode obter o código-fonte para o controle de usuário da seção do exemplo da <xref:System.Web.UI.WebControls.WebParts.WebPartManager> visão geral da classe. Para obter mais informações sobre modos de exibição e como funciona o controle de usuário, consulte [instruções passo a passo: alterando modos de exibir em uma página de Web Parts](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 A segunda parte do exemplo de código é personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controle. Para o exemplo de código seja executado, você deve compilar este código-fonte. Você pode compilá-lo explicitamente e coloque o assembly resultante na pasta Bin do seu site da Web ou cache de assembly global. Como alternativa, você pode colocar o código-fonte na pasta App_Code de seu site, onde ele será compilado dinamicamente no tempo de execução. Este exemplo usa a abordagem de compilação dinâmica; Portanto, não há nenhuma `Assembly` de atributo no `Register` diretriz para esse controle na parte superior da página da Web. Para um passo a passo que demonstra como compilar, consulte [instruções passo a passo: desenvolvendo e usando um controle de servidor Web personalizado](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/textdisplaywebpart.vb#3)]  
  
 A terceira parte do exemplo de código é a página da Web. A página contém um <xref:System.Web.UI.WebControls.WebParts.CatalogZone> zona, com o personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controle declarado na zona, para que um usuário pode adicioná-lo para a página em tempo de execução. Observe que os controles apenas dinâmicos (controles que são adicionados a uma página por meio de programação ou de um catálogo como este) podem ser excluídos de uma página. Controles estáticos (controles que são declarados dentro de um <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zona na marcação de uma página) pode ser fechado, mas nunca é excluído. O `<asp:webpartmanager>` elemento declara um valor personalizado para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> propriedade usando o `DeleteWarning` atributo. O `Button1_Click` método atribui outro valor personalizado para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> propriedade.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/deleteWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/deleteWarningVB.aspx#1)]  
  
 Depois de carregar a página em um navegador, você precisará adicionar o <xref:System.Web.UI.WebControls.WebParts.WebPart> controle para a página. Usando o **modo de exibição** controle de lista suspensa, o modo de selecione catálogo. Quando o catálogo for exibida, marque a caixa de seleção ao lado do controle personalizado, clique em **Add** para adicioná-lo para a página e, em seguida, clique em **fechar** para retornar a página para o modo de procura. Agora que o controle estiver visível, você pode excluí-lo. Usando o **modo de exibição** controle novamente, alterne a página para o modo de design (não é possível excluir controles enquanto a página estiver no modo de procura). Clique no menu de verbos (o símbolo de seta) no cabeçalho do <xref:System.Web.UI.WebControls.WebParts.WebPart> controle e selecione **excluir**. O aviso que você definir o `DeleteWarning` atributo é exibido. Clique em **Cancelar**. Agora clique no botão rotulado **alteração excluir aviso**, que altera o valor da propriedade programaticamente. No menu de verbos do controle, selecione **excluir** novamente e observe que é de mensagem de aviso exibido neste momento.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteWebPart">
      <MemberSignature Language="C#" Value="public void DeleteWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.DeleteWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.DeleteWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">O controle de servidor a ser excluído.</param>
        <summary>Remove permanentemente uma instância dinâmica de um controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> de uma página da Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> método remove permanentemente o controle representado pelo `webPart` parâmetro de uma página. Ao contrário de um controle fechado, que é adicionado ao <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> controlar e pode ser adicionado novamente para a página, nunca pode ser adicionada a uma instância de controle excluído para a página.  
  
> [!NOTE]
>  Conforme implementado pelo controle de Web Parts definido, a capacidade dos usuários excluir um dinâmico <xref:System.Web.UI.WebControls.WebParts.WebPart> controle depende do usuário e o escopo de personalização no qual o controle foi adicionado a uma página. Se o controle é adicionado quando a página estiver no escopo compartilhado (por um usuário que tenha permissões), em seguida, o controle não pode ser excluído por usuários individuais quando a página estiver no escopo do usuário.  
  
 Somente os controles dinâmicos podem ser excluídos. Controles dinâmicos são adicionados a uma página por meio de programação ou por usuários adicionando controles a partir de um catálogo. Controles estáticos são adicionados a uma página de forma declarativa no formato de marcação ou persistência. Como as marcas declarativas são permanentemente presentes na marcação, controles estáticos nunca podem ser excluídos, mas pode ser fechados e reabertos.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> método. Na primeira vez que o **adicionar calendário** botão é clicado, o código no evento manipulador cria um <xref:System.Web.UI.WebControls.Calendar> controlar e adiciona-a uma região como um <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> objeto. Como o controle é adicionado por meio de programação, é um controle dinâmico e, portanto, ele pode ser excluído. Quando um usuário clica o **Excluir calendário** botão, o código garante que o controle existe e, em seguida, exclui-lo chamando o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> método.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsStatic" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="DesignDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DesignDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DesignDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable DesignDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa o modo de exibição usado para alterar o layout de páginas da Web que contenham controles de Web Parts. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> referências de campo personalizado <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> objeto que é criado e contido pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle. Como esse é um objeto estático, você pode consultá-lo diretamente por meio de <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe sem a necessidade de uma instância do controle.  
  
 Quando uma página que contém as Web Parts controla pela primeira vez, ela está em <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> (modo de procura) por padrão. Quando os usuários desejam alterar o layout da página, mover os controles a diferentes zonas ou em zonas atuais, eles devem primeiro alternar a página para <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> (modo de design). No modo de design, é exibida a interface do usuário (IU) para as várias zonas e os usuários podem, em seguida, arrastar controles para alterar o layout.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como trabalhar com o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> campo por meio de programação. O código preenche uma lista suspensa com os modos de exibição com suporte para a página, neste caso são procurar e design. Observe que, no `Page_PreRender` método, o código verifica se o atual <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> estiver definida como <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>. Nesse caso, `Label1` estarão visíveis e se não estiver, `Label1` ficará oculta.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/CS/wpmgrDesignDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/VB/wpmgrDesignDisplayModevb.aspx#1)]  
  
 Depois de carregar a página em um navegador, você está no modo de procura por padrão. Observe que o rótulo da página está oculto. Use o controle de lista suspensa para alternar a página para o modo de design. Observe que, por causa do código no `Page_PreRender` método, o rótulo agora está visível.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Modos de exibição de página de Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebPart">
      <MemberSignature Language="C#" Value="protected virtual void DisconnectWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DisconnectWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DisconnectWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member DisconnectWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit&#xA;override this.DisconnectWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.DisconnectWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Um controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> que deve ser desconectado.</param>
        <summary>Remove um <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou um controle de servidor que está sendo fechado ou excluído das conexões em que está participando.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> método é chamado internamente pelo controle de Web Parts definido quando um controle é fechado em uma página ou excluído de uma página. Nesse cenário, o método é chamado para remover o controle de todas as conexões em que ele está envolvido como um provedor ou consumidor. Se o controle é removido de qualquer conexão, esse método também chama o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> método para encerrar todas as conexões em que `webPart` estava envolvido.  
  
 Quando o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> método é chamado, ele gera o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> eventos. Normalmente, esse evento pode ser cancelado, mas nos dois casos não pode ser cancelada. Um caso ocorre durante as solicitações para a página, quando o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> método é chamado. Se houver um conflito entre as conexões existentes, o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> método será invocado para fechar uma das conexões conflitantes e nesta instância a <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> evento não pode ser cancelado, pois o conflito deve ser resolvido.  
  
 O outro caso ocorre quando um <xref:System.Web.UI.WebControls.WebParts.WebPart> ou controle de servidor que está conectado no momento é fechado ou excluído. Nesse caso, por causa do controle está sendo removido da página, suas necessidades de conexão a ser encerrado, também, portanto, por design, não é possível cancelar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> evento para interromper o processo de encerrar uma conexão. Para saber mais, confira o evento <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> método. Usar dois custom <xref:System.Web.UI.WebControls.WebParts.WebPart> controles, a página da Web permite que você crie uma conexão entre os controles, clicando em um botão, enquanto outro botão permite que você desconecte os controles. Se você fechar um dos controles, enquanto a página estiver no modo de procura e os controles estão conectados, uma substituição do <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> método desconecta o controle fechado, termina a conexão e exibe uma mensagem.  
  
 O exemplo de código tem quatro partes:  
  
-   Um controle de usuário para alterar modos de exibição.  
  
-   Um arquivo de origem que contém personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controles.  
  
-   Uma página da Web para hospedar os controles.  
  
-   Uma explicação de como o exemplo funciona em um navegador.  
  
 A primeira parte do exemplo de código é o controle de usuário para alterar modos de exibição. Você pode obter o código-fonte para o controle de usuário da seção do exemplo da <xref:System.Web.UI.WebControls.WebParts.WebPartManager> visão geral da classe. Para obter mais informações sobre modos de exibição e como funciona o controle de usuário, consulte [instruções passo a passo: alterando modos de exibir em uma página de Web Parts](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 A segunda parte é o arquivo que contém o código-fonte personalizado duas <xref:System.Web.UI.WebControls.WebParts.WebPart> controles que serão conectados e uma personalizada <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle. Para o exemplo de código seja executado, você deve compilar este código-fonte. Você pode compilá-lo explicitamente e coloque o assembly resultante na pasta Bin do seu site da Web ou cache de assembly global. Como alternativa, você pode colocar o código-fonte na pasta App_Code de seu site, onde ele será compilado dinamicamente no tempo de execução. Este exemplo usa a compilação dinâmica, portanto, o `Register` diretiva que faz referência a esses componentes na página da Web é declarada adequadamente na parte superior da página da Web. Para um passo a passo que demonstra as opções de compilação, consulte [instruções passo a passo: desenvolvendo e usando um controle de servidor Web personalizado](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 No código-fonte, observe o controle herdado `MyWebPartManager` que substitui o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> método. Esse método verifica cada conexão em uma página para ver se o controle que está sendo fechado participa de conexão e, em caso afirmativo, chama o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> método para encerrar a conexão. Isso é idêntico à implementação do método na base de <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle. O método substituído, em seguida, personaliza a implementação base, escrevendo uma mensagem para a página.  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 A terceira parte do exemplo de código é a página da Web. Observe que próximo à parte superior, ele contém `Register` diretivas para registrar o controle de usuário e o assembly compilado dinamicamente com o <xref:System.Web.UI.WebControls.WebParts.WebPart> controles. A página tem dois métodos principais. O `Button1_Click` método cria uma conexão entre os controles, enquanto o `Button2_Click` método desconecta os controles.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 Depois de carregar a página, clique no **Connect** botão para conectar-se os controles. Em seguida, clique no menu de verbos de um dos controles (a seta para baixo no cabeçalho do controle) e selecione **fechar** no menu de verbos. Quando você tentar fechar o controle, o método substituído é chamado, a conexão será encerrada e a mensagem é gravada para a página. Se você quiser redefinir a página para restaurar o controle fechado e fazer experiências com outras opções, clique no **redefinir estado de usuário** link para remover os dados de personalização e restaurar o estado original da página.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebParts">
      <MemberSignature Language="C#" Value="public virtual void DisconnectWebParts (System.Web.UI.WebControls.WebParts.WebPartConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DisconnectWebParts(class System.Web.UI.WebControls.WebParts.WebPartConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DisconnectWebParts (connection As WebPartConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DisconnectWebParts(System::Web::UI::WebControls::WebParts::WebPartConnection ^ connection);" />
      <MemberSignature Language="F#" Value="abstract member DisconnectWebParts : System.Web.UI.WebControls.WebParts.WebPartConnection -&gt; unit&#xA;override this.DisconnectWebParts : System.Web.UI.WebControls.WebParts.WebPartConnection -&gt; unit" Usage="webPartManager.DisconnectWebParts connection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="connection" Type="System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Parameters>
      <Docs>
        <param name="connection">Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> que representa a conexão entre controles de servidor.</param>
        <summary>Realiza o processo de desconexão de controles de servidor que estão conectados em uma página da Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> método executa o processo completo de encerrar uma conexão entre <xref:System.Web.UI.WebControls.WebParts.WebPart> ou controles de servidor, quando você passá-lo a `connection` parâmetro.  
  
 Esse método é usado para se desconectar controles quando você coloca um `<asp:connectionszone>` elemento em uma página da Web, para fornecer uma interface do usuário (IU) para gerenciar as conexões. Quando uma página está no modo de exibição de conectar (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>) e existe uma conexão atual, os usuários podem clicar em um botão que chama o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> método para encerrar a conexão.  
  
 Você também pode chamar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> método diretamente do seu código, se você quiser desconectar controles de forma programática e sem a necessidade de adicionar um `<asp:connectionszone>` elemento para uma página.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> método. Usar dois custom <xref:System.Web.UI.WebControls.WebParts.WebPart> controles, a página da Web permite que você crie uma conexão entre os controles, clicando em um botão, enquanto outro botão permite que você desconecte os controles.  
  
 O exemplo de código tem quatro partes:  
  
-   Um controle de usuário para alterar modos de exibição.  
  
-   Um arquivo de origem que contém personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controles.  
  
-   Uma página da Web para hospedar os controles.  
  
-   Uma explicação de como o exemplo funciona em um navegador.  
  
 A primeira parte do exemplo de código é o controle de usuário para alterar modos de exibição. Você pode obter o código-fonte para o controle de usuário da seção do exemplo da <xref:System.Web.UI.WebControls.WebParts.WebPartManager> visão geral da classe. Para obter mais informações sobre modos de exibição e como funciona o controle de usuário, consulte [instruções passo a passo: alterando modos de exibir em uma página de Web Parts](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 A segunda parte é um arquivo que contém o código-fonte personalizado dois <xref:System.Web.UI.WebControls.WebParts.WebPart> controles que serão conectados. Para o exemplo de código seja executado, você deve compilar este código-fonte. Você pode compilá-lo explicitamente e coloque o assembly resultante na pasta Bin do seu site da Web ou cache de assembly global. Como alternativa, você pode colocar o código-fonte na pasta App_Code de seu site, onde ele será compilado dinamicamente no tempo de execução. Este exemplo usa a compilação dinâmica, portanto, o `Register` diretiva que faz referência a esses componentes na página da Web é declarada adequadamente na parte superior da página da Web. Para um passo a passo que demonstra as opções de compilação, consulte [instruções passo a passo: desenvolvendo e usando um controle de servidor Web personalizado](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 A terceira parte do exemplo de código é a página da Web. Observe que próximo à parte superior, ele contém `Register` diretivas para registrar o controle de usuário e o assembly compilado dinamicamente com o <xref:System.Web.UI.WebControls.WebParts.WebPart> controles. A página tem dois métodos principais. O `Button1_Click` método cria uma conexão entre os controles e o `Button2_Click` método desconecta os controles.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 Depois de carregar a página, você pode clicar na **Connect** botão para conectar-se os controles. Se você digitar um texto no controle de caixa de texto e, em seguida, clique no **Enter** botão, o texto será exibido no controle conectado (ele não seria exibido se os controles foram desconectados). Se você clicar na **desconectar** botão, os controles serão desconectados. Você pode verificar o status de conexão dos controles usando o **modo de exibição** controle de lista suspensa para alternar a página em **Connect** modo. Depois de fazer isso, clique no menu de verbos (representado por uma seta) na barra de título de um dos controles e selecione o **Connect** item. A conexão da interface do usuário é exibido. ele está disponível porque não há um `<asp:connectionszone>` elemento declarado na página. Você também pode se conectar e desconectar os controles nessa interface do usuário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="connection" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="connection" /> não está contido em <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> nem <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> é somente leitura.  
  
\- ou - 
 <paramref name="connection" /> já foi desconectado de <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />.  
  
\- ou - 
 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> é somente leitura.  
  
\- ou - 
 <paramref name="connection" /> já foi desconectado de <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />.</exception>
        <block subset="none" type="overrides">
          <para>Você pode substituir a <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" /> método se você quiser alterar a implementação padrão para desconectar <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> controles. Se você substituir o método, e você simplesmente deseja adicionar uma implementação para o método existente, você pode chamar o método base antes de executar seu próprio código.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DisplayMode As WebPartDisplayMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DisplayMode { System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ get(); void set(System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o modo de exibição ativo para uma página da Web que contém controles Web Part.</summary>
        <value>Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> que determina o modo de exibição de uma página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma página que contém controles de Web Parts está sempre em um dos vários modos de exibição possíveis. Para obter detalhes sobre modos de exibição, consulte [modos de exibição de página da Web partes](https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4).  
  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe cria os modos de exibição para uma página da Web. Usando a base <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> classe, o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle cria vários objetos de modo de exibição padrão que podem ser usados nas páginas que contêm controles de Web Parts. Esses modos de exibição padrão são descritos no <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> visão geral da classe.  
  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle também gerencia os modos de exibição para páginas que usam os controles de Web Parts. Usando o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> propriedade, o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle mantém uma referência para o modo de exibição atual em uma página. Você também pode usar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> propriedade para alternar uma página em diferentes modos de exibição. Para obter um exemplo de alterar os modos de exibição em uma página que usa controles de Web Parts, consulte [instruções passo a passo: alterando modos de exibir em uma página de Web Parts](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Como parte do gerenciamento do modo de exibição, o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle também fornece eventos e manipuladores de eventos relacionados para modos de exibição, como o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A> método e o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> método. Esses métodos fornecem um mecanismo para personalizar o comportamento de uma página e para a adição de um modo de exibição personalizado.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso programático do <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> propriedade. Depois de carregar a página em um navegador, você pode usar os botões na parte inferior da página para alternar os modos de exibição. A página está no modo de procura por padrão quando ele é carregado. Se você alternar para modo de design, você pode arrastar os controles de servidor de uma zona para outra ou organizar os dois controles dentro de uma zona. Se você alternar para modo de edição, você pode clicar no cabeçalho de um dos controles de servidor, selecionados o menu de verbos **editar**e editar o controle usando a interface do usuário edição (UI) fornecido.  
  
> [!NOTE]
>  Alternar entre modos de exibição em um aplicativo de Web Parts é muito comum, e você talvez queira fornecer uma maneira consistente e reutilizável para fazer isso em todas as páginas que contêm controles de Web Parts. Para um exemplo de um controle de usuário que alterações exibem modos e que pode ser reutilizado em várias páginas, consulte [instruções passo a passo: alterando modos de exibir em uma página de Web Parts](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/CS/wpmgrDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/VB/wpmgrDisplayModevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O objeto <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> que está sendo atribuído à propriedade é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O objeto <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> que está sendo atribuído à propriedade não é um dos modos de exibição com suporte.  
  
\- ou - 
O objeto <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> que está sendo atribuído à propriedade está desabilitado.</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Modos de exibição de página de Web Parts</related>
        <related type="Article" href="https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0">Passo a passo: Alterando modos de exibição em uma página de Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanged As WebPartDisplayModeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventHandler ^ DisplayModeChanged;" />
      <MemberSignature Language="F#" Value="member this.DisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler " Usage="member this.DisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre depois que o modo de exibição atual, em uma página de Web Parts, foi alterado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Modos de exibição são parte integrante de aplicativos Web Parts. Quando os usuários alternam para um modo de exibição diferentes em uma página da Web, a página geralmente leva em uma aparência muito diferente, dependendo da finalidade do novo modo de exibição. Depois de um modo de exibição foi alterado, você pode deseja fazer determinadas alterações na interface do usuário (UI), como ocultar ou mostrar alguns controles, alterando a aparência dos elementos de interface do usuário selecionados e assim por diante.  
  
> [!NOTE]
>  Para obter mais informações sobre modos de exibição, consulte [modos de exibição de página da Web partes](https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4). Para obter mais informações sobre o consumo de eventos, consulte [como: consumir eventos em um aplicativo Web Forms](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanging As WebPartDisplayModeCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventHandler ^ DisplayModeChanging;" />
      <MemberSignature Language="F#" Value="member this.DisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler " Usage="member this.DisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre depois que um usuário clica em um verbo em uma página da Web que inicia o processo de alteração para um modo de exibição diferente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Modos de exibição são parte integrante de aplicativos Web Parts. Quando os usuários alternam para um modo de exibição diferentes em uma página da Web, a página geralmente leva em uma aparência muito diferente, dependendo da finalidade do novo modo de exibição. Depois que um usuário inicia o processo de alteração para um novo modo de exibição, clicando em um verbo, você talvez queira fazer determinadas alterações na interface do usuário (IU) usando o <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode%2A> propriedade para determinar qual será o novo modo de exibição e, em seguida, alterar vários da interface do usuário elementos de forma adequada. Uma maneira útil para fazer isso é substituir o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> método para personalizar a interface do usuário.  
  
> [!NOTE]
>  Para obter mais informações sobre modos de exibição, consulte [modos de exibição de página da Web partes](https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4). Para obter mais informações sobre o consumo de eventos, consulte [como: consumir eventos em um aplicativo Web Forms](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ DisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DisplayModes : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma coleção somente leitura de todos os modos de exibição que estão associados com um controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <value>Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" /> que contém o conjunto de <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> objetos associados com o <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> controle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> referências de propriedade todos associados a modos de exibição, em contraste com o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> propriedade, que faz referência a somente os modos de exibição que estão disponíveis (com suporte) na página atual.  
  
 Dois dos modos de exibição fornecido, procurar e design, sempre têm suporte em uma página. A outros modos de exibição de três, editar, catálogo e conexões, há suporte para somente quando uma página tem o tipo correspondente da zona necessária para um modo de exibição específico funcionar. Por exemplo, se você página não contém um <xref:System.Web.UI.WebControls.WebParts.EditorZone> zona, o modo de exibição de edição será exibido na coleção referenciada pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> propriedade, mas não seria exibido na coleção referenciada pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> propriedade.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra o uso programático do <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> propriedade. O código usa essa propriedade para preencher a lista com todos os modos de exibição disponíveis no conjunto de controles de Web Parts, mesmo aqueles que não há suporte para a página atual. Nesse caso, o catálogo e conectar-se a exibição que não há suporte para os modos, porque suas respectivas necessário zonas não estão na página.  
  
 Os outros três exibem modos – procurar, design e edição – têm suporte na página. Editar modo tem suporte porque a página contém um <xref:System.Web.UI.WebControls.WebParts.EditorZone> zona durante a procura e modos de design sempre têm suporte.  
  
 Depois de carregar a página em um navegador, você pode usar o controle de lista suspensa para alternar a página do modo de procura para modo de design e, em seguida, para o modo de edição. No modo de edição, você pode clique no menu de verbos suspenso no cabeçalho de um dos controles de servidor e selecione **editar** para editar o controle. Observe que, se você selecionar **catálogo** ou **Connect** na lista suspensa, uma página de erro é gerada.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/CS/wpmgrDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/VB/wpmgrDisplayModesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Modos de exibição de página de Web Parts</related>
        <related type="Article" href="https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0">Passo a passo: Alterando modos de exibição em uma página de Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="DynamicConnections">
      <MemberSignature Language="C#" Value="protected internal System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property DynamicConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ DynamicConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicConnections : System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a coleção de todas as conexões dinâmicas que existem atualmente em uma página da Web.</summary>
        <value>Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" /> que contém referências a todas as conexões dinâmicas em uma página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Conexões dinâmicas são as conexões que são criadas por meio de programação, em vez de estaticamente. Conexões estáticas são criadas declarando-os na marcação de uma página Web Forms. Conexões dinâmicas são formadas por meio de programação ou por um usuário criar uma conexão usando a interface de usuário de conexão (UI).  
  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A> coleção, no entanto é somente leitura e você não pode alterar seu conteúdo, fornecem acesso programático a cada objeto de conexão dinâmica.  
  
> [!NOTE]
>  Para executar operações comuns, como conectando ou desconectando <xref:System.Web.UI.WebControls.WebParts.WebPart> controles, os desenvolvedores devem usar os métodos públicos em de <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe, como <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> e <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>, em vez de tentar modificar diretamente a conexão objetos no <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A> coleção.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="EditDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EditDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ EditDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable EditDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa o modo de exibição em que os usuários finais podem editar e modificar controles de servidor. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> referências de campo personalizado <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> objeto que é criado e contido pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle. Como esse é um objeto estático, você pode consultá-lo diretamente por meio de <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe sem a necessidade de uma instância do controle.  
  
 Quando uma página que contém as Web Parts controla pela primeira vez, ela está em <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> (modo de procura) por padrão. Quando os usuários quiserem editar ou modificar um controle de servidor, é preciso primeiro alternar a página para <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> (modo de edição). Em segundo lugar, eles devem selecionar um controle de servidor específico para editar, clicando em Editar verbo no menu de verbos no cabeçalho do controle. Depois que o controle está no modo de edição, a interface do usuário (IU) edição é exibida para a edição do controle selecionado.  
  
 Para habilitar o modo de edição em uma página, a página deve conter pelo menos um <xref:System.Web.UI.WebControls.WebParts.EditorZone> controles de zona que inclui um ou mais de edição fornecido, como o <xref:System.Web.UI.WebControls.WebParts.LayoutEditorPart> controle ou controles de edição personalizados.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como trabalhar com o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> campo por meio de programação. O código preenche uma lista suspensa com os modos de exibição com suporte para a página, neste caso são procurar, design e edição. Para dar suporte à edição, um `<asp:EditorZone>` elemento está na página. Observe que, no `Page_PreRender` método, o código verifica se o atual <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> estiver definida como <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>. Nesse caso, `Label1` estarão visíveis e se não estiver, `Label1` ficará oculta.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/CS/wpmgrEditDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/VB/wpmgrEditDisplayModevb.aspx#1)]  
  
 Depois de carregar a página em um navegador, você está no modo de procura por padrão. Observe que o rótulo da página está oculta. Use o controle de lista suspensa para alternar a página de modo de edição. Observe que, por causa do código no `Page_PreRender` método, o rótulo agora está visível. Clique o **editar** verbo no menu de verbos em um dos controles, para habilitar a edição desse controle específico.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Modos de exibição de página de Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="EnableClientScript">
      <MemberSignature Language="C#" Value="public virtual bool EnableClientScript { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableClientScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableClientScript As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableClientScript { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableClientScript : bool with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que determina se o script do lado do cliente está habilitado na página da Web que contém um controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <value>Um valor booliano que indica se o script de cliente pode ser executado na página. O valor padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A> propriedade fornece uma maneira para os desenvolvedores desabilitar scripts do cliente. Você talvez queira desabilitar o script para fins de segurança do cliente, ou para garantir que todos os usuários de uma página terão uma experiência de usuário similar, mesmo que eles usam diferentes navegadores.  
  
 Você pode desabilitar o cliente de script com a adição de um `EnableClientScript` de atributo para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> elemento em uma página da Web, como a seguinte linha de código declarativo:  
  
 `<asp:webpartmanager id="manager" runat="server"`  
  
 `EnableClientScript="false" />`  
  
 Além disso, os desenvolvedores pode eliminar essa propriedade herdando a <xref:System.Web.UI.WebControls.WebParts.WebPartManager> valor de classe e definindo o padrão para `false`.  
  
 O conjunto de controles de Web Parts usa script para fornecer alguns do cliente da interface do usuário (IU) e recursos de personalização do cliente. Se você desabilitar o cliente de script, Web Parts controles ainda funcionam, mas alguns recursos são desabilitados. A capacidade de arrastar controles para diferentes regiões está desabilitada, juntamente com a capacidade de renderizar verbos em um menu suspenso de verbos na barra de título do controle (em vez disso, os verbos são exibidos como links na barra de título do controle).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="EnableTheming">
      <MemberSignature Language="C#" Value="public override bool EnableTheming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableTheming" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property EnableTheming As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableTheming { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableTheming : bool with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica que o uso de temas está habilitado em uma página da Web.</summary>
        <value>Um valor booliano que indica se os temas são habilitados. <see langword="true" /> em todos os casos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle substitui a base <xref:System.Web.UI.Control.EnableTheming%2A> propriedade para garantir que ele sempre retorna um valor de `true`. Isso é feito porque as Web Parts do conjunto de controles requer o uso de temas para renderizar as Web Parts controles que são controles filho do <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle e que formam a interface do usuário (UI) de uma página da Web. Por exemplo, temas são usados para renderizar as várias zonas, e os controles que residem nas zonas, incluindo os vários tipos de parte controles (controles que herdam a <xref:System.Web.UI.WebControls.WebParts.Part> classe), servidor personalizado, controles de servidor ASP.NET e controles de usuário controles.  
  
 Embora as substituído <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A> propriedade é implementada como uma propriedade de leitura/gravação de acordo com sua propriedade base, você não pode definir a propriedade, porque, por design, ele deve sempre retornar um valor de `true`. Se você tentar definir a propriedade, um <xref:System.NotSupportedException> exceção é lançada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Foi feita uma tentativa para definir o valor da propriedade.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="EndWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartConnecting ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartConnecting() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartConnecting ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartConnecting();" />
      <MemberSignature Language="F#" Value="abstract member EndWebPartConnecting : unit -&gt; unit&#xA;override this.EndWebPartConnecting : unit -&gt; unit" Usage="webPartManager.EndWebPartConnecting " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Conclui o processo de conexão de um controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> a outro controle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A> método termina o processo de conectar um <xref:System.Web.UI.WebControls.WebParts.WebPart> a outro controle. É o equivalente a <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A> método.  
  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A> método garante que o objeto de personalização é referenciada pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> propriedade pode ser modificada, que é necessário porque formar uma conexão é um tipo de personalização. Em seguida, o método garante que o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> o objeto não é `null`e, finalmente, chama o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O controle referenciado pela propriedade <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> é <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>Os desenvolvedores que precisam estender o <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> controle pode desejar substituir esse método em uma classe derivada. Uma abordagem seria chamar o método base e, em seguida, adicione algum tratamento personalizado adicional ou convém personalizar completamente todo o processo de conclusão de uma conexão entre controles.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="EndWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartEditing ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartEditing() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartEditing ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartEditing();" />
      <MemberSignature Language="F#" Value="abstract member EndWebPartEditing : unit -&gt; unit&#xA;override this.EndWebPartEditing : unit -&gt; unit" Usage="webPartManager.EndWebPartEditing " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Conclui o processo de edição de um controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> método termina o processo de edição um <xref:System.Web.UI.WebControls.WebParts.WebPart> controle. É o equivalente a <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> método.  
  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> método garante que o objeto de personalização é referenciada pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> propriedade pode ser modificada, que é necessário porque um controle de edição é um processo que requer alterações de personalização. Em seguida, o método garante que o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> o objeto não é `null`, de modo que selecionado no momento <xref:System.Web.UI.WebControls.WebParts.WebPart> controle pode ser alterado e, finalmente, ele chama o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O controle referenciado pela propriedade <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> é <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>Os desenvolvedores que precisam estender o <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> controle pode desejar substituir esse método em uma classe derivada. Uma abordagem seria chamar o método base e, em seguida, adicione algum tratamento personalizado adicional ou convém personalizar completamente todo o processo de concluir a edição de um controle. Por exemplo, o método de substituição, você poderia chamar o método base primeiro e, em seguida, adicione algum código que determina quais alterações de edição foram feitas e exibe a lista de alterações de volta para o usuário final como uma confirmação.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="ExportSensitiveDataWarning">
      <MemberSignature Language="C#" Value="public virtual string ExportSensitiveDataWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ExportSensitiveDataWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ExportSensitiveDataWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ExportSensitiveDataWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ExportSensitiveDataWarning : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o texto de uma mensagem de aviso que é exibida quando um usuário tenta exportar dados confidenciais de estado de um controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <value>Uma cadeia de caracteres que contém a mensagem de aviso. A mensagem padrão é um valor de cultura específica fornecido pelo .NET Framework.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um usuário tenta exportar dados confidenciais de estado de um <xref:System.Web.UI.WebControls.WebParts.WebPart> controle, se os dados que está sendo exportado vier de um membro que foi marcado como confidencial no código-fonte, uma mensagem de aviso é exibida para o usuário em uma caixa de mensagem informando que dados confidenciais que está sendo exportados e fornecendo uma oportunidade de cancelar a exportação. Os desenvolvedores podem marcar os dados de um membro específico como confidenciais, definindo o `isSensitive` parâmetro do `[Personalizable]` atributo `true` no membro. Para obter mais informações sobre esse atributo e o parâmetro, consulte o <xref:System.Web.UI.WebControls.WebParts.PersonalizableAttribute> classe.  
  
> [!IMPORTANT]
>  Quando você usa o recurso de exportação de Web Parts, dados confidenciais poderiam potencialmente ser exportados para usuários não autorizados. Para obter detalhes sobre como se proteger contra essa ameaça, consulte [Protegendo páginas de Web Parts](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2).  
  
 A mensagem padrão é exibida sempre que os usuários tentam fazer a exportação. No entanto, atribuindo um valor para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A> propriedade, você pode fornecer uma mensagem de aviso personalizado.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso declarativo do <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A> propriedade.  
  
 O código da página da Web a seguir usa um padrão <xref:System.Web.UI.WebControls.BulletedList> de controle e o coloca em uma zona. O controle será encapsulado com um <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> controle em tempo de execução, o que permite que ele atue como um verdadeiro <xref:System.Web.UI.WebControls.WebParts.WebPart> controle. Para tornar o controle exportável, uma `ExportMode` atributo é adicionado para o `<asp:bulletedlist>` elemento e o valor do atributo é definido como <xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All>, que significa que esses dados confidenciais e não confidenciais pode ser exportada. Observe também que no `<asp:webpartmanager>` elemento, o `ExportSensitiveDataWarning` atributo é atribuído um valor personalizado.  
  
 Observe que para o exemplo de código funcione, há uma configuração que você deve adicionar o arquivo Web. config para habilitar a exportação de arquivos de descrição de Web Parts. Certifique-se de que você tenha um arquivo Web. config no mesmo diretório que a página da Web para este exemplo de código. Dentro de `<system.web>` seção, verifique se há uma `<webParts>` elemento com um `enableExport` atributo definido como `true`, conforme mostrado no seguinte marcação.  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/CS/wpmgrExportSensitiveWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/VB/wpmgrExportSensitiveWarningVB.aspx#1)]  
  
 Depois de carregar a página em um navegador, clique no menu de verbos (representado por uma seta para baixo) na barra de título do controle que contém os links. No menu de verbos, selecione **exportar**e observe que uma caixa de mensagem é exibida com o aviso personalizado. Se você quiser continuar com a exportação, clique em **Okey**, que permitirá que você salve uma cópia local de um arquivo de descrição de XML com os dados sobre o controle.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="ExportWebPart">
      <MemberSignature Language="C#" Value="public virtual void ExportWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExportWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ExportWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member ExportWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Xml.XmlWriter -&gt; unit&#xA;override this.ExportWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Xml.XmlWriter -&gt; unit" Usage="webPartManager.ExportWebPart (webPart, writer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="webPart">O controle do qual os dados serão exportados.</param>
        <param name="writer">Um <see cref="T:System.Xml.XmlWriter" /> que grava os dados exportados de <c>webPart</c> em um arquivo de descrição de XML.</param>
        <summary>Cria um arquivo de descrição de XML que contém dados de estado e de propriedade de um controle de servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> método reúne vários dados de estado e de propriedade de `webPart` em um arquivo XML. Os dados incluem informações sobre o controle em si, incluindo seu assembly, dados de estado e dados de propriedade. O usuário que inicia a exportação pode salvar o arquivo XML para o disco no computador local ou na rede. Outros usuários podem, em seguida, importe o arquivo de descrição para uma página diferente ou um site da Web e aplicar os dados de estado e de propriedade para uma instância diferente do `webPart`. Isso fornece um mecanismo rápido e conveniente para os usuários compartilhar e reutilizar suas configurações em controles de servidor, e ele também fornece aos desenvolvedores um meio para controlar a aparência e comportamento de controles importados e exportados.  
  
 Propriedades em `webPart` não são exportados por padrão. Para habilitar a exportação de uma propriedade, você deve marcá-la com o `[Personalizable]` atributo no código-fonte. Você também pode marcar uma propriedade exportável como contendo dados confidenciais, definindo o `isSensitive` parâmetro do `[Personalizable]` atributo `true`. Por padrão, `isSensitive` é `false`. Os desenvolvedores podem definir o parâmetro `true` para indicar que os dados são confidenciais.  
  
 Para habilitar `webPart` para ser exportada, um desenvolvedor define sua <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A> valor da propriedade para um <xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All> (que inclui todas as propriedades personalizáveis e confidenciais), ou para <xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.NonSensitiveData>, que exporta tudo, exceto as propriedades confidenciais .  
  
> [!IMPORTANT]
>  Permitir que os usuários para exportar dados de controles e para importar dados para outros controles, envolve alguns riscos de segurança. Os desenvolvedores devem usar a abordagem discutida acima para proteger dados confidenciais e se deseja evitar o risco de exposição de dados completamente, eles não devem habilitar exportação em `webPart` em todos os. Para obter detalhes sobre problemas de segurança de Web Parts, consulte [Protegendo páginas de Web Parts](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> é <see langword="null" />.  
  
\- ou - 
 <paramref name="writer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> não está contido na coleção de controles referenciada em <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />.  
  
\- ou - 
A propriedade <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" /> de <paramref name="webPart" /> está definida como um valor de <see cref="F:System.Web.UI.WebControls.WebParts.WebPartExportMode.None" />, o que significa que a exportação está desabilitada para <paramref name="webPart" />.</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2">Protegendo Web Parts páginas</related>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public override void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Focus();" />
      <MemberSignature Language="F#" Value="override this.Focus : unit -&gt; unit" Usage="webPartManager.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Substituído para impedir que o foco seja definido no controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />, porque ele não tem IU (interface do usuário).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Focus%2A> substituições de método base <xref:System.Web.UI.Control.Focus%2A?displayProperty=nameWithType> método e gera uma exceção se um chamador chama o método. Porque o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle não tem nenhuma interface do usuário e nunca fica visível aos usuários, nunca pode permitir que o foco para ser definida em si mesmo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Um chamador tenta chamar o método <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" />, que não é compatível em um controle que não tem interface do usuário.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConsumerConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ConsumerConnectionPointCollection ^ GetConsumerConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member GetConsumerConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection&#xA;override this.GetConsumerConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection" Usage="webPartManager.GetConsumerConnectionPoints webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Um controle de servidor que atua como um consumidor em uma conexão.</param>
        <summary>Recupera a coleção de objetos <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" /> que podem atuar como pontos de conexão de um controle de servidor que atua como um consumidor em uma conexão de Web Parts.</summary>
        <returns>Um <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection" /> que contém todos os pontos de conexão no consumidor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma conexão de Web Parts sempre envolve exatamente dois controles, um que atua como o provedor de dados, atuando como o consumidor de dados. Cada controle deve ter um ou mais métodos que são definidos como pontos de conexão. No caso de um controle do consumidor, seus pontos de conexão são <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint> objetos. Recuperar os pontos de conexão do consumidor é uma etapa necessária na formação de uma conexão de Web Parts.  
  
 Um consumidor deve sempre ter o ponto de conexão pelo menos um para ser capaz de estabelecer uma conexão. O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> método verifica se um controle do consumidor e recupera uma coleção de todos os seus pontos de conexão. Se um <xref:System.Web.UI.WebControls.WebParts.WebPart> controle não tem nenhum ponto de conexão, o método retorna uma coleção vazia.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> método.  
  
 O exemplo de código tem quatro partes:  
  
-   Um controle de usuário que permite que você altere os modos de exibição em uma página de Web Parts.  
  
-   Uma página da Web que contém dois personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controles que podem ser conectados, e um `<asp:webpartmanager>` elemento.  
  
-   Um arquivo de código fonte que contém dois personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controles e uma interface personalizada.  
  
-   Uma explicação de como o exemplo funciona em um navegador.  
  
 A primeira parte do exemplo de código é o controle de usuário para alterar modos de exibição. Você pode obter o código-fonte para o controle de usuário da seção do exemplo da <xref:System.Web.UI.WebControls.WebParts.WebPartManager> visão geral da classe. Para obter mais informações sobre modos de exibição e como funciona o controle de usuário, consulte o tópico [instruções passo a passo: alterando modos de exibir em uma página de Web Parts](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Contém a marcação declarativa para a página da Web `Register` diretivas para o controle de usuário e os controles personalizados. Há um `<asp:webpartmanager>` elemento, um `<asp:webpartzone>` elemento para conter os controles personalizados e um `<asp:connectionszone>` elemento. Observe que, no `Page_Load` método, o código verifica se uma conexão já existe e, se não estiver, define um provedor, um consumidor e seus pontos de conexão do respectivo e, em seguida, adiciona uma nova conexão para o conjunto de conexões estáticas referenciado pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> propriedade. Observe que o <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection> objeto que é recuperado usando o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> método é então passado para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> método para determinar se uma conexão entre os dois controles pode ser criado.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 A terceira parte do exemplo é o código-fonte para os controles. Você pode obter esse código e instruções para compilá-lo, na seção exemplo o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> visão geral da classe.  
  
 Depois que você carregar a página da Web em um navegador, clique o **modo de exibição** controle de lista suspensa e selecione **Connect** para alternar a página para o modo de conexão. Conectar-se o modo usa a `<asp:connectionszone>` elemento para que você possa criar conexões entre controles. No modo de conexão, clique na seta para baixo na barra de título do **CEP** para ativar o menu de verbos de controle e, em seguida, clique em **Connect**. Depois que a interface do usuário de conexão (IU) for exibida, observe que uma conexão já foi criado pelo código contido no `Page_Load` método. Se você retornar a esta página em uma sessão de navegador posterior, essa conexão estático já estará estabelecida e não precisará ser recriado cada vez que a página for carregada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentWebPartManager">
      <MemberSignature Language="C#" Value="public static System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager(System.Web.UI.Page)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::UI::WebControls::WebParts::WebPartManager ^ GetCurrentWebPartManager(System::Web::UI::Page ^ page);" />
      <MemberSignature Language="F#" Value="static member GetCurrentWebPartManager : System.Web.UI.Page -&gt; System.Web.UI.WebControls.WebParts.WebPartManager" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager page" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
      </Parameters>
      <Docs>
        <param name="page">A página da Web que contém uma instância do <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</param>
        <summary>Recupera uma referência para a instância atual do controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> na página.</summary>
        <returns>Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> que faz referência à instância atual do controle em uma página.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> método é útil em contextos em que você deseja recuperar uma referência ao atual <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle. Um cenário comum onde isso ocorrerá é se você estiver escrevendo um controle personalizado que não é possível saber durante o desenvolvimento do que a ID do <xref:System.Web.UI.WebControls.WebParts.WebPartManager> será controle em sua página.  
  
> [!NOTE]
>  O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> método for estático, portanto, você pode chamá-lo diretamente sem a necessidade de uma instância de um <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle.  
  
 Alguns controles nas Web Parts controlam conjunto, como <xref:System.Web.UI.WebControls.WebParts.WebPart> controles, têm um <xref:System.Web.UI.WebControls.WebParts.WebPart.WebPartManager%2A> propriedade que pode recuperar uma referência ao atual <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle. Portanto, ao trabalhar com esses controles, você deve usar essa propriedade para recuperar uma referência.  
  
 Se você estiver codificando em um contexto em que você souber a ID do <xref:System.Web.UI.WebControls.WebParts.WebPartManager> de controle, como gravar código embutido dentro de uma página da Web, é mais simples e mais eficiente para referir-se diretamente para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle usando sua ID.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> método. O exemplo tem duas partes: um controle de servidor personalizado e uma página da Web que hospeda o controle.  
  
 Personalizado <xref:System.Web.UI.WebControls.Label> controle usa o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> método para recuperar a ID do <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle na página atual e, em seguida, exibe a ID.  
  
 [!code-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/MyManagerIDLabel.cs#2)]
 [!code-vb[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/MyManagerIDLabel.vb#2)]  
  
 O exemplo de código a seguir fornece a página da Web que hospeda o controle em um <xref:System.Web.UI.WebControls.WebParts.WebPartZone> zona.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/getCurrentWPManagerCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/getcurrentWPManagervb.aspx#1)]  
  
 Depois de carregar a página em um navegador, observe que a ID do atual <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle é exibido dentro do personalizado <xref:System.Web.UI.WebControls.Label> controle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="page" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="GetDisplayTitle">
      <MemberSignature Language="C#" Value="protected internal virtual string GetDisplayTitle (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance string GetDisplayTitle(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetDisplayTitle(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::String ^ GetDisplayTitle(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member GetDisplayTitle : System.Web.UI.WebControls.WebParts.WebPart -&gt; string&#xA;override this.GetDisplayTitle : System.Web.UI.WebControls.WebParts.WebPart -&gt; string" Usage="webPartManager.GetDisplayTitle webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">O controle para o qual o método retorna o valor de <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" />.</param>
        <summary>Obtém uma cadeia de caracteres que contém o valor para a propriedade <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> de um controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <returns>Uma cadeia de caracteres que contém o valor calculado de <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> para <paramref name="webPart" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obtém o valor calculado do <xref:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle%2A> propriedade para `webPart`. Quando os desenvolvedores não atribuem um valor para o <xref:System.Web.UI.WebControls.WebParts.Part.Title%2A> propriedade de um <xref:System.Web.UI.WebControls.WebParts.WebPart> controle, esse método produz o valor a ser exibido como o título. O valor calculado para controles sem título consiste em um número acrescentado a uma cadeia de caracteres, com o número que indica a sequência de um controle dentro da zona atual.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> não está na coleção <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />.</exception>
        <block subset="none" type="overrides">
          <para>Esse método pode ser substituído para alterar como o título da exibição padrão é calculado.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" />
      </Docs>
    </Member>
    <Member MemberName="GetExportUrl">
      <MemberSignature Language="C#" Value="public string GetExportUrl (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetExportUrl(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetExportUrl(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.GetExportUrl : System.Web.UI.WebControls.WebParts.WebPart -&gt; string" Usage="webPartManager.GetExportUrl webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">O <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> que está sendo exportado.</param>
        <summary>Obtém o caminho virtual relativo e a cadeia de caracteres de consulta que fazem parte da solicitação quando um usuário tenta exportar um controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <returns>Uma cadeia de caracteres que contém o caminho virtual relativo e a cadeia de caracteres de consulta que, juntos, formam a solicitação para exportar um controle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A> método é um caminho virtual relativo ao local do servidor da página que contém o controle, mais o valor de cadeia de caracteres de consulta acrescentada que faz a solicitação de exportação enviada ao servidor. O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A> método codifica a cadeia de caracteres antes de permitir que a solicitação ser enviada, para proteger contra ataques de script mal-intencionado.  
  
> [!NOTE]
>  Para obter mais informações sobre como proteger aplicativos Web Parts, consulte [Protegendo páginas de Web Parts](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::GenericWebPart ^ GetGenericWebPart(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.GetGenericWebPart : System.Web.UI.Control -&gt; System.Web.UI.WebControls.WebParts.GenericWebPart" Usage="webPartManager.GetGenericWebPart control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Um controle de servidor que existe em um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> e é encapsulado como um controle filho de um <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> em tempo de execução.</param>
        <summary>Obtém uma referência à instância do controle <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> que contém um controle de servidor.</summary>
        <returns>Um <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> que encapsula <paramref name="control" /> como um controle filho. O método retorna <see langword="null" /> se <paramref name="control" /> não está contido em um <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em geral, há duas categorias de controles que os desenvolvedores de colocam na <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zonas para participar de aplicativos de Web Parts: <xref:System.Web.UI.WebControls.WebParts.WebPart> controles que herdam a <xref:System.Web.UI.WebControls.WebParts.WebPart> classe base e outros controles de servidor, que podem ser padrão Controles ASP.NET, controles personalizados ou controles de usuário. Quando qualquer um desses controles é colocado em uma <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zona, ele usa a funcionalidade de um <xref:System.Web.UI.WebControls.WebParts.WebPart> controle. Um <xref:System.Web.UI.WebControls.WebParts.WebPart> controle essa funcionalidade por natureza, mas não os outros tipos de controles de servidor. Para habilitar os outros controles de servidor atuar como <xref:System.Web.UI.WebControls.WebParts.WebPart> controla quando eles são colocados em um <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zona, o ASP.NET envolve-as com um <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> controle. Porque o <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> controle herda diretamente o <xref:System.Web.UI.WebControls.WebParts.WebPart> classe, ele fornece seus controles filho com recursos de Web Parts true.  
  
 Muitas vezes em tempo de execução, os desenvolvedores de páginas talvez queira obter uma referência para o <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> controle que contém um dos controles de servidor em uma zona. O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> método permite recuperar uma referência para o <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> controle.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> método. O exemplo de código contém uma <xref:System.Web.UI.WebControls.Calendar> controle declarados dentro de um <xref:System.Web.UI.WebControls.WebParts.WebPartZone> zona. O `Button1_Click` método primeiro imprime a ID do <xref:System.Web.UI.WebControls.Calendar> controle em um rótulo e, em seguida, usa o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> método para recuperar uma referência para o <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> controle que encapsula o calendário. A ID do <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> controle e a ID do seu controle filho (que é o <xref:System.Web.UI.WebControls.Calendar> controle), são impressas em um segundo rótulo.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/CS/getGenericWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/VB/getGenericWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="GetProviderConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ProviderConnectionPointCollection ^ GetProviderConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member GetProviderConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection&#xA;override this.GetProviderConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection" Usage="webPartManager.GetProviderConnectionPoints webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Um controle de servidor que atua como um provedor em uma conexão.</param>
        <summary>Recupera a coleção de objetos <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" /> que podem atuar como pontos de conexão de um controle de servidor que atua como um provedor em uma conexão de Web Parts.</summary>
        <returns>Um <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection" /> que contém todos os pontos de conexão no provedor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma conexão de Web Parts sempre envolve exatamente dois controles, um que atua como o provedor de dados, atuando como o consumidor de dados. Cada controle deve ter um ou mais métodos que são definidos como pontos de conexão. No caso de um controle do provedor, seus pontos de conexão são <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint> objetos.  
  
 Um provedor deve sempre ter o ponto de conexão pelo menos um para ser capaz de estabelecer uma conexão. O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> método verifica se um controle do provedor e recupera uma coleção de todos os seus pontos de conexão. Recuperar os pontos de conexão do provedor é uma etapa necessária na formação de uma conexão de Web Parts.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> método.  
  
 O exemplo tem quatro partes:  
  
-   Um controle de usuário que permite que você altere os modos de exibição em uma página de Web Parts.  
  
-   Uma página da Web que contém dois personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controles que podem ser conectados, e um `<asp:webpartmanager>` elemento.  
  
-   Um arquivo de código fonte que contém dois personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controles e uma interface personalizada.  
  
-   Uma explicação de como o exemplo funciona em um navegador.  
  
 A primeira parte do exemplo de código é o controle de usuário para alterar modos de exibição. Você pode obter o código-fonte para o controle de usuário da seção do exemplo da <xref:System.Web.UI.WebControls.WebParts.WebPartManager> visão geral da classe. Para obter mais informações sobre modos de exibição e como funciona o controle de usuário, consulte [instruções passo a passo: alterando modos de exibir em uma página de Web Parts](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Contém a marcação declarativa para a página da Web `Register` diretivas para o controle de usuário e os controles personalizados. Há um `<asp:webpartmanager>` elemento, um `<asp:webpartzone>` elemento para conter os controles personalizados e um `<asp:connectionszone>` elemento. Observe que, no `Page_Load` método, o código verifica se uma conexão já existe e, se não estiver, define um provedor, um consumidor e seus pontos de conexão do respectivo e, em seguida, adiciona uma nova conexão para o conjunto de conexões estáticas referenciado pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> propriedade. Observe que o <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection> objeto que é recuperado usando o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> método é então passado para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> método para determinar se uma conexão entre os dois controles pode ser criado.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 A terceira parte do exemplo é o código-fonte para os controles. Você pode obter esse código e instruções para compilá-lo, na seção exemplo o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> visão geral da classe.  
  
 Depois que você carregar a página da Web em um navegador, clique o **modo de exibição** controle de lista suspensa e selecione **Connect** para alternar a página para o modo de conexão. Conectar-se o modo usa a `<asp:connectionszone>` elemento para que você possa criar conexões entre controles. No modo de conexão, clique na seta para baixo na barra de título do **CEP** para ativar o menu de verbos de controle e, em seguida, clique em **Connect**. Depois que a interface do usuário de conexão (IU) for exibida, observe que uma conexão já foi criado pelo código contido no `Page_Load` método. Se você retornar a esta página em uma sessão de navegador posterior, essa conexão estático já estará estabelecida e não precisará ser recriado cada vez que a página for carregada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="ImportWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPart ImportWebPart (System.Xml.XmlReader reader, out string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart ImportWebPart(class System.Xml.XmlReader reader, [out] string&amp; errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ImportWebPart (reader As XmlReader, ByRef errorMessage As String) As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ ImportWebPart(System::Xml::XmlReader ^ reader, [Runtime::InteropServices::Out] System::String ^ % errorMessage);" />
      <MemberSignature Language="F#" Value="abstract member ImportWebPart : System.Xml.XmlReader *  -&gt; System.Web.UI.WebControls.WebParts.WebPart&#xA;override this.ImportWebPart : System.Xml.XmlReader *  -&gt; System.Web.UI.WebControls.WebParts.WebPart" Usage="webPartManager.ImportWebPart (reader, errorMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="errorMessage" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="reader">Um <see cref="T:System.Xml.XmlReader" /> que lê os dados de estado e de propriedade do arquivo de descrição XML que está sendo importado.</param>
        <param name="errorMessage">Um <see cref="T:System.String" /> que é exibido para o usuário se for encontrado um erro durante a importação.</param>
        <summary>Importa um arquivo de descrição XML que contém dados de estado e de propriedade para um controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> e aplica os dados ao controle.</summary>
        <returns>Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (ou um controle de servidor encapsulado por um <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />, portanto, tratado como um <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />) que é referenciado no arquivo de descrição de XML importado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> método importa um arquivo de descrição XML que foi criado pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> método para um controle de servidor. Não é o controle de servidor real que é importado, mas apenas o arquivo de descrição que contém dados de estado e de propriedade sobre o controle. O controle e o assembly referenciado no arquivo de descrição já devem estar disponíveis no servidor em que um usuário tenta importar o arquivo de descrição.  
  
 Para habilitar a importação de um controle, um desenvolvedor precisa para adicionar um <xref:System.Web.UI.WebControls.WebParts.CatalogZone> controle na página onde importação será habilitada. Dentro da zona, um <xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> controle deve ser adicionado. Esse controle fornece uma caixa de diálogo que permite aos usuários procurar e localize o arquivo de descrição para importar.  
  
 Depois que um usuário encontra um arquivo de descrição e começa a importação, o arquivo de descrição é lido pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> método. Se não existem erros e se o assembly e o controle for encontrados, o controle de servidor é adicionado ao catálogo de dentro do <xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> controle e os vários dados de propriedade e o estado especificados no arquivo de descrição são aplicados ao controle. O usuário pode, em seguida, selecione o controle e adicioná-lo para a página.  
  
> [!IMPORTANT]
>  Como o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> método, o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> método tem algumas possíveis riscos de segurança. Porque envolve a importação de dados em um site da Web, um usuário mal-intencionado pode tentar inserir dados incorretos ou código de script, mesmo no arquivo de descrição que é importado. Em seguida, os dados ruins podem aparecer em uma página ou em um banco de dados ou o script inserido foi executado. Para obter uma visão geral dos possíveis riscos associados com a importação de arquivos de descrição e maneiras de evitar esses riscos, consulte [Protegendo páginas de Web Parts](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.EndOfStreamException">
          <paramref name="reader" /> não pode ler o arquivo.  
  
\- ou - 
 <paramref name="reader" /> necessário para exibir uma mensagem de erro de importação, mas não foi possível localizar um no arquivo.  
  
\- ou - 
 <paramref name="reader" /> atingiu o fim do arquivo sem encontrar o elemento XML que contém os dados exportados.</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ImportCatalogPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2">Protegendo Web Parts páginas</related>
      </Docs>
    </Member>
    <Member MemberName="Internals">
      <MemberSignature Language="C#" Value="protected System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Internals" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Internals As WebPartManagerInternals" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ Internals { System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Internals : System.Web.UI.WebControls.WebParts.WebPartManagerInternals" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Internals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManagerInternals</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma referência à classe <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />, que é usada para combinar e separar um conjunto de métodos que estão, na verdade, implementados na classe <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />, mas geralmente são úteis para os desenvolvedores de controle.</summary>
        <value>Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />, por meio do qual uma <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> pode fazer referência a vários métodos que foram separados no <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> propriedade expõe as APIs chamar em um conjunto de <xref:System.Web.UI.WebControls.WebParts.WebPartManager> métodos que são usados principalmente em casos de extensibilidade.  
  
 A maneira projetada para usar esses métodos internos é para acessá-los por meio de <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> propriedade. Porque a propriedade estiver protegida, você só pode acessá-lo e chamar os métodos em uma instância das <xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> classe herdando os <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe.  
  
> [!NOTE]
>  Essa propriedade é oculta do IntelliSense em [!INCLUDE[vsprvsext](~/includes/vsprvsext-md.md)]. No entanto, em um derivada <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe, você ainda pode acessar a propriedade e seus vários membros.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAuthorized">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se um <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou outro controle de servidor pode ser adicionado a uma página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parte da flexibilidade do recurso de Web Parts é a capacidade de adicionar controles de servidor às páginas da Web em tempo de execução. Há uma série de cenários comuns em que um controle de servidor (que pode ser personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controle, um controle de servidor personalizado, um controle de usuário ou um controle ASP.NET) pode ser adicionado.  
  
 Os seguintes cenários comuns, as Web Parts controla o conjunto de tentativas de adicionar controles de servidor a uma página e o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> método é chamado para autorizá-los:  
  
-   Quando um controle de servidor é adicionado ao declará-la na marcação de uma página da Web dentro de um <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zona.  
  
-   Quando um controle de servidor é adicionado por meio de programação para uma zona.  
  
-   Quando um usuário importa um controle de servidor em um catálogo de Web Parts de controles.  
  
-   Quando um existente, controle de servidor é carregado do armazenamento de dados de personalização.  
  
-   Quando um controle de servidor é adicionado a um <xref:System.Web.UI.WebControls.WebParts.DeclarativeCatalogPart> controle para disponibilizá-lo em um catálogo de controles de servidor.  
  
 Em cada cenário em que os controles são adicionados, o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> método é chamado para garantir que todos os critérios de autorização foram atendidos para permitir que um controle a ser adicionado. Quando um controle está autorizado, ele é adicionado normalmente como seria se não havia nenhum cenário de filtragem. Quando um controle não está autorizado, o conjunto de controles de Web Parts pode responder de várias maneiras, dependendo do contexto. O conjunto de controles pode falhar em modo silencioso adicionar uma parte não autorizada (se não é necessário para informar ao usuário), ele pode exibir uma mensagem de erro ou ele pode adicionar uma instância da <xref:System.Web.UI.WebControls.WebParts.UnauthorizedWebPart> classe como um espaço reservado. Esse objeto de espaço reservado não estiver visível na página, mas é visível no código de origem da página para indicar que um controle não autorizado foi excluído.  
  
 O determinante de se um controle está autorizado é o filtro de autorização. Um filtro de autorização é um recurso do conjunto de controles de Web Parts que permite aos desenvolvedores excluir de uma página de todos os controles que não atendem aos critérios especificados.  
  
 Para criar um cenário de filtragem, os desenvolvedores devem fazer duas coisas. Primeiro, ele devem atribuir um valor de cadeia de caracteres (o valor pode ser arbitrário) para o <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriedade de cada <xref:System.Web.UI.WebControls.WebParts.WebPart> eles planejam usar o cenário de controle. Eles também podem atribuir um valor para essa propriedade para outros tipos de controles de servidor que não são <xref:System.Web.UI.WebControls.WebParts.WebPart> controles, porque se elas forem colocadas <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zonas, tais controles são encapsulados com um <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> controle em tempo de execução e esse controle herda o <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriedade.  
  
 A segunda etapa necessária para a criação de um cenário de filtragem é como substituição de <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> método, ou para criar um manipulador de eventos para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> eventos. Esses métodos, um desenvolvedor pode verificar a <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriedade, e se o valor indica que o controle não deve ser autorizado, o desenvolvedor garante que o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> método retorna um valor de `false`.  
  
> [!NOTE]
>  Para exemplos de código e uma descrição de como configurar um cenário de filtragem personalizada usando o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> método, consulte os tópicos para as sobrecargas do método.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public bool IsAuthorized (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAuthorized(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAuthorized(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.IsAuthorized : System.Web.UI.WebControls.WebParts.WebPart -&gt; bool" Usage="webPartManager.IsAuthorized webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou outro controle de servidor que está sendo verificado quanto à autorização.</param>
        <summary>Realiza as etapas iniciais para determinar se um controle está autorizado a ser adicionado a uma página.</summary>
        <returns>Um valor booliano que indica se <paramref name="webPart" /> pode ser adicionado a uma página.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> é o método inicial chamado pelo controle de Web Parts definido para verificar a autorização para um <xref:System.Web.UI.WebControls.WebParts.WebPart> controle. Ele aceita `webPart` como um parâmetro e inicia um processo que determina se o controle será adicionado a uma página. Chame esse método do seu código diretamente quando você precisa determinar se um determinado controle está autorizado.  
  
 Esse método executa as tarefas iniciais de determinar se o controle herda do <xref:System.Web.UI.WebControls.WebParts.WebPart> classe ou é um <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> controlar e, nesse caso, o tipo de filho de controle contém. Para concluir a tarefa de autorização, ele chama o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> sobrecarregar o método.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como chamar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29> método do seu código para determinar se um controle está autorizado a ser adicionado a uma página.  
  
 O exemplo de código tem três partes:  
  
-   Um personalizado <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle que substitui o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> método.  
  
-   Uma página da Web que cria um filtro para um <xref:System.Web.UI.WebControls.WebParts.WebPart> controle.  
  
-   Uma explicação de como executar o exemplo de código.  
  
 Este exemplo de código usa um personalizado <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle que substitui o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> sobrecarregar o método para fornecer manipulação personalizada do <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriedade. Esse controle verifica um valor da propriedade `admin` e, se o valor estiver presente, autoriza o controle. Se um controle tiver um valor diferente, ele não está autorizado; controles sem o valor da propriedade são autorizados, conforme eles são presumidos como não deve ser parte do cenário de filtragem.  
  
 Para este exemplo de código ser executado, você deve compilar este código-fonte. Você pode compilá-lo explicitamente e coloque o assembly resultante na pasta Bin do seu site da Web ou cache de assembly global. Como alternativa, você pode colocar o código-fonte na pasta App_Code de seu site, onde ele será compilado dinamicamente no tempo de execução. Este exemplo de código usa o método de compilação dinâmica. Para um passo a passo que demonstra como compilar, consulte [instruções passo a passo: desenvolvendo e usando um controle de servidor Web personalizado](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 A segunda parte do exemplo de código cria um filtro que potencialmente pode excluir um controle. A seguinte página da Web contém três controles de servidor ASP.NET em um `<asp:webpartzone>` elemento. Observe que os controles primeiros e segundo têm seus <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriedades definidas como valores diferentes, e o terceiro não atribui a propriedade. Esse valor de autorização pode ser verificada em tempo de execução e o controle pode ser adicionado à página, se o filtro corresponde a critérios definidos pelo desenvolvedor. Observe também que de `Page_Load` método, o código chama o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29> método para determinar se cada um dos controles está autorizada e, se assim, ele define cada controle <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A> propriedade.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 Observe que, para o exemplo de código funcione, você deve adicionar uma configuração no arquivo Web. config para habilitar a exportação de arquivos de descrição de Web Parts. Certifique-se de que você tenha um arquivo Web. config no mesmo diretório que a página da Web para este exemplo de código. Dentro de `<system.web>` seção, verifique se há uma `<webParts>` elemento com um `enableExport` atributo definido como `true`, conforme mostrado no seguinte marcação.  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 Depois de carregar a página em um navegador, observe que o primeiro controle é exibido, porque ele corresponde aos critérios no método substituído. O segundo controle não é adicionado à página, porque ele é excluído pelo filtro. O terceiro controle também é adicionado, porque ele não tem seu <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> conjunto de propriedades. Observe que se você clicar no ícone do menu de verbos na barra de título de qualquer um dos controles, eles podem ambos ser exportado porque suas respectivas <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A> foram atribuídos a valores de propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> é <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Este método é chamado diretamente do seu código. Se você quiser obter maior controle programático sobre o processo de autorização, você pode substituir o <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" /> sobrecarregar o método.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public virtual bool IsAuthorized (Type type, string path, string authorizationFilter, bool isShared);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAuthorized(class System.Type type, string path, string authorizationFilter, bool isShared) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAuthorized(Type ^ type, System::String ^ path, System::String ^ authorizationFilter, bool isShared);" />
      <MemberSignature Language="F#" Value="abstract member IsAuthorized : Type * string * string * bool -&gt; bool&#xA;override this.IsAuthorized : Type * string * string * bool -&gt; bool" Usage="webPartManager.IsAuthorized (type, path, authorizationFilter, isShared)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="authorizationFilter" Type="System.String" />
        <Parameter Name="isShared" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">O <see cref="T:System.Type" /> do controle que está sendo verificado quanto à autorização.</param>
        <param name="path">O caminho relativo de aplicativo para o arquivo de origem do controle que está sendo autorizado, se o controle é um controle de usuário.</param>
        <param name="authorizationFilter">Um valor arbitrário de cadeia de caracteres atribuído à propriedade <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" /> de um controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />, usado para autorizar se um controle pode ser adicionado a uma página.</param>
        <param name="isShared">Indica se o controle que está sendo verificado quanto à autorização é um controle compartilhado, o que significa que ele é visível para muitos ou todos os usuários do aplicativo e o valor da propriedade <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsShared" /> é definido como <see langword="true" />.</param>
        <summary>Realiza as etapas finais para determinar se um controle está autorizado a ser adicionado a uma página.</summary>
        <returns>Um valor booliano que indica se um controle está autorizado a ser adicionado a uma página.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> sobrecarga do método executa as etapas finais para determinar se um controle está autorizado a ser adicionado a uma página. O método garante que `type` é um tipo válido e que `path` tem um valor somente se o controle que está sendo verificado é um controle de usuário. Em seguida, ele chama a crítica <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> método, que gera o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> eventos.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como substituir o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> método para determinar se um controle está autorizado a ser adicionado a uma página.  
  
 A primeira etapa é criar um filtro que potencialmente pode excluir um controle. A seguinte página da Web contém três controles de servidor ASP.NET em um `<asp:webpartzone>` elemento. Observe que os controles primeiros e segundo têm seus <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriedades definidas como valores diferentes, e o terceiro não atribui a propriedade. Esse valor de autorização pode ser verificada em tempo de execução e o controle pode ser adicionado à página, se o filtro corresponde a critérios definidos pelo desenvolvedor.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 A segunda etapa é substituir o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> método e criar personalizadas de tratamento para filtros de autorização. Observe que o código primeiro verifica se a propriedade tem um valor, para que qualquer controle que não atribui o <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriedade será adicionada automaticamente. Se um controle tiver um filtro, o código retorna `true` somente se o valor do filtro for igual a `admin`. Isso demonstra um mecanismo simples, que você pode usar para a exibição de determinados controles para determinados usuários, dependendo da sua função. Embora um exemplo completo usando funções está além do escopo deste tópico, você poderia usar a mesma lógica de como o método substituído neste exemplo de código, exceto que você pode verificar se o usuário atual está em uma função que corresponda ao valor de filtro de autorização e, em seguida, adicione o controle somente para esse usuário. Isso permite que você crie páginas em que alguns usuários veria todos os controles e outros usuários veria apenas os controles selecionados. Isso é a aparência a lógica que verifica o filtro se você tiver usado as funções:  
  
```vb  
If Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter) Then  
  return True  
Else  
  return False  
End If  
```  
  
```csharp  
if(Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter))  
    return true;  
else  
    return false;  
```  
  
 Para o exemplo de código seja executado, você deve compilar este código-fonte. Você pode compilá-lo explicitamente e coloque o assembly resultante na pasta Bin do seu site da Web ou cache de assembly global. Como alternativa, você pode colocar o código-fonte na pasta App_Code de seu site, onde ele será compilado dinamicamente no tempo de execução. Este exemplo de código usa o método de compilação dinâmica. Para um passo a passo que demonstra como compilar, consulte [instruções passo a passo: desenvolvendo e usando um controle de servidor Web personalizado](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 Depois de carregar a página em um navegador, observe que o primeiro controle é exibido, porque ele corresponde aos critérios no método substituído. O segundo controle não é adicionado à página, porque o valor do filtro é excluído. O terceiro controle é adicionado, porque ele não tem seu <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> conjunto de propriedades. Se você alterar o valor da propriedade no segundo controle corresponde do primeiro controle e, em seguida, execute novamente a página, o segundo controle é adicionado também.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> é um controle de usuário e <paramref name="path" /> é <see langword="null" /> ou uma cadeia de caracteres vazia ("").  
  
\- ou - 
 <paramref name="type" /> não é um controle de usuário e <paramref name="path" /> tem um valor atribuído a ele.</exception>
        <block subset="none" type="overrides">
          <para>Esse método pode ser substituído pelo herdando a <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> de classe, se você quiser fornecer tratamento adicional durante a verificação de autorização. Você talvez queira substituir o método para verificar para determinados valores no <paramref name="authorizationFilter" /> parâmetro e com base no valor, retornam um valor booliano que determina se o controle será adicionado a uma página.  
  
Para desenvolvedores de páginas que também queiram verificar se há filtros de autorização e fornecer manipulação personalizada, há uma opção para fazer essa embutida em uma página. aspx ou em um arquivo code-behind, sem a necessidade de herdar de qualquer classe. Você pode declarar um manipulador de eventos alternativo na página para o <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" /> método da <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> controle. Para obter mais detalhes e um exemplo, consulte o <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" /> método.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="IsCustomPersonalizationStateDirty">
      <MemberSignature Language="C#" Value="protected virtual bool IsCustomPersonalizationStateDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property IsCustomPersonalizationStateDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsCustomPersonalizationStateDirty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCustomPersonalizationStateDirty : bool" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se foram feitas alterações de personalização que afetam os detalhes de personalização de nível de página controlados pelo controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <value>Um valor booliano que indica se foram feitas alterações de personalização. O valor padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle usa o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A> propriedade internamente para controlar se os dados de personalização de nível de página que ele gerencia foi alterada. Os dados de personalização são alterados quando os usuários executar diversas ações de personalização no nível da página, como adicionar ou remover <xref:System.Web.UI.WebControls.WebParts.WebPart> controles, conexão ou desconexão de controles, alterando o layout da página, movendo os controles e outras ações.  
  
> [!NOTE]
>  Os usuários também podem realizar a personalização no nível de controle, o que significa que eles façam alterações de personalização um controle específico, e as alterações afetam somente esse controle. Um exemplo seria o controle de edição e alterar o texto de título ou sua cor de plano de fundo. Personalização de nível de controle não afeta os dados de personalização de nível de página controlados pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle e então o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A> o valor da propriedade não é alterado para `true` quando ocorre a personalização de nível de controle.  
  
 Embora o método é protegido e não pode ser acessado diretamente por um chamador, o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> propriedade pode ser acessado diretamente por chamadores e retorna o valor dessa propriedade.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.PersonalizationState.IsDirty" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.PersonalizationState.SetDirty" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="LoadControlState">
      <MemberSignature Language="C#" Value="protected internal override void LoadControlState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void LoadControlState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub LoadControlState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void LoadControlState(System::Object ^ savedState);" />
      <MemberSignature Language="F#" Value="override this.LoadControlState : obj -&gt; unit" Usage="webPartManager.LoadControlState savedState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">Contém os dados de estado persistente a serem carregados.</param>
        <summary>Carrega dados de estado do controle que foram salvos de uma solicitação de página anterior e precisam ser restaurados em uma solicitação subsequente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A> método é útil para restaurar os dados de propriedade que devem ser persistentes entre postbacks de uma página, mesmo quando o <xref:System.Web.UI.Control.EnableViewState%2A> estiver definida como `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="savedState" /> não é um <see cref="P:System.Web.UI.PageStatePersister.ControlState" /> válido.</exception>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void LoadCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub LoadCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void LoadCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit&#xA;override this.LoadCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit" Usage="webPartManager.LoadCustomPersonalizationState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">Um <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> que contém os dados de estado a serem carregados.</param>
        <summary>Armazena os dados de personalização customizados que foram passados para o controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> pelos objetos de personalização para serem usados durante o processo de inicialização.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A> método fornece dados de estado salvo na forma de um <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> objeto. Esses dados, eventualmente, são usados para carregar os dados de personalização em controles de Web Parts e executar outras tarefas de inicialização.  
  
> [!NOTE]
>  Esse método é chamado por uma sequência de métodos que começa quando o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState%2A> método solicita associado inicialmente <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> objeto para fornecer dados de personalização para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle.  
  
 Você não pode chamar este método diretamente do seu código. Você pode, no entanto, diretamente chamar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A> chamadas de método, que por si só o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A> método e retorna os dados de personalização.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Os desenvolvedores podem substituir os <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" /> método em um derivada <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="MediumPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MediumPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MediumPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MediumPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MediumPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MediumPermissionSet : System.Security.PermissionSet" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um objeto <see cref="T:System.Security.PermissionSet" /> que concede apenas permissão <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> e permissão <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" />.</summary>
        <value>Um <see cref="T:System.Security.PermissionSet" /> objeto que permite somente <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> permissão e <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" /> permissão.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Security.PermissionSet> objeto que é retornado por essa propriedade é usado durante a importação para desserialização de tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimalPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MinimalPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MinimalPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MinimalPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MinimalPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MinimalPermissionSet : System.Security.PermissionSet" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um objeto <see cref="T:System.Security.PermissionSet" /> que concede apenas permissão <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> e permissão <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" />.</summary>
        <value>Obtém um objeto <see cref="T:System.Security.PermissionSet" /> que concede apenas permissão <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> e permissão <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Security.PermissionSet> objeto retornado por essa propriedade é usado durante a importação para tudo, exceto o tipo da desserialização.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveWebPart">
      <MemberSignature Language="C#" Value="public virtual void MoveWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MoveWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberSignature Language="F#" Value="abstract member MoveWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.WebPartZoneBase * int -&gt; unit&#xA;override this.MoveWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.WebPartZoneBase * int -&gt; unit" Usage="webPartManager.MoveWebPart (webPart, zone, zoneIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">A <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou outro controle de servidor que está sendo movido.</param>
        <param name="zone">A <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> de destino para a qual a <c>webPart</c> está sendo movida.</param>
        <param name="zoneIndex">Um inteiro que indica o índice de <c>webPart</c> em relação a outros controles na <c>zona</c>.</param>
        <summary>Move um <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou um controle de servidor de uma zona <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> para outra ou para uma nova posição dentro da mesma zona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle usa o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> método para mover `webPart` para um novo local na mesma região ou em uma região diferente. Você pode chamar esse método diretamente do código e também é chamado quando um usuário move um controle para uma nova posição usando várias opções na interface do usuário de Web Parts (UI).  
  
 Um número de condições que deve ser atendido antes de `webPart` pode ser movido, e a maioria deles é indicada por itens listados na seção ' exceções ' deste tópico. Se `webPart` não estava contido em um <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zona para começar, ele não pode ser movido para uma zona.  
  
 Depois que as condições forem atendidas, ocorre a seguinte sequência de ações para mover `webPart`:  
  
1.  O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> método aciona o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> eventos.  
  
2.  `webPart` é removido de sua zona atual (se necessário) e adicionado à sua nova zona ou a nova posição dentro da zona atual.  
  
3.  O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> método aciona o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> eventos.  
  
4.  O `zoneIndex` de cada <xref:System.Web.UI.WebControls.WebParts.WebPart> controle em regiões de origem e de destino será redefinido para refletir o controle movido.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como chamar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> método diretamente do código para mover um <xref:System.Web.UI.WebControls.WebParts.WebPart> controle de uma zona para outra.  
  
 O exemplo de código tem três partes:  
  
-   Um controle de usuário para alterar modos de exibição.  
  
-   Uma página da Web para hospedar os controles.  
  
-   Uma explicação de como executar o exemplo de código.  
  
 A primeira parte do exemplo de código é o controle de usuário para alterar modos de exibição. Você pode obter o código-fonte para o controle de usuário da seção do exemplo da <xref:System.Web.UI.WebControls.WebParts.WebPartManager> visão geral da classe. Para obter mais informações sobre modos de exibição e como funciona o controle de usuário, consulte [instruções passo a passo: alterando modos de exibir em uma página de Web Parts](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 A segunda parte do exemplo é uma página de Web que contém duas zonas, cada uma delas contém dois controles de servidor. Quando um usuário clica o **mover WebPart** botão na página, o código a `Button1_Click` método move um controle de primeira zona para uma nova posição na segunda zona. Observe que o código primeiro deve chamar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> método para recuperar o <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> objeto que encapsula o `list1` controle. Isso é necessário porque o primeiro parâmetro do <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> método exige um <xref:System.Web.UI.WebControls.WebParts.WebPart> controlam, enquanto `list1` é um controle de servidor ASP.NET.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/CS/MoveWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/VB/MoveWebPartVB.aspx#1)]  
  
 Depois que a página for carregada, clique no **WebPart mover** botão e observe que o controle que contém os links se move para a posição intermediária na segunda zona. Esse movimento do controle é realizado por meio de programação, chamando o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> método. Você também pode usar o **modo de exibição** controle de lista suspensa para alternar a página para o modo de design e no modo de design, você pode arrastar os controles para diferentes regiões ou em posições diferentes dentro de suas zonas. O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> método também é chamado pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager> move o controle para lidar com tais iniciada pelo usuário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> não está contido na coleção <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> do controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.  
  
\- ou - 
 <paramref name="zone" /> não está contido na coleção <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" /> do controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.  
  
\- ou - 
A zona referenciada pela propriedade <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.Zone" /> do controle <paramref name="webPart" /> é <see langword="null" />, o que significa que <paramref name="webPart" /> não está atualmente contido em uma zona.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> ou <paramref name="zone" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="zoneIndex" /> é menor que zero.</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="OnAuthorizeWebPart">
      <MemberSignature Language="C#" Value="protected virtual void OnAuthorizeWebPart (System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAuthorizeWebPart(class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAuthorizeWebPart (e As WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAuthorizeWebPart(System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs -&gt; unit&#xA;override this.OnAuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs -&gt; unit" Usage="webPartManager.OnAuthorizeWebPart e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" /> que contém dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" /> e invoca um manipulador para o evento, se houver.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> método é chamado pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> método, quando um <xref:System.Web.UI.WebControls.WebParts.WebPart> controle está sendo verificado quanto à autorização a ser adicionado a uma página. Quando o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> método é chamado, ele gera o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> evento, e se houver um método de manipulador para o evento, ele invoca o manipulador.  
  
 O processo de autorização <xref:System.Web.UI.WebControls.WebParts.WebPart> controles é um importante recurso de Web Parts. Cada <xref:System.Web.UI.WebControls.WebParts.WebPart> ou controle de servidor que é adicionado a uma zona pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle passa por um processo de autorização para determinar se o controle pode ser adicionado. Por padrão, o conjunto de controles de Web Parts não fornece nenhum critério de filtragem para impedir que os controles que está sendo adicionado a uma zona. Mas o conjunto de controles fornecem os mecanismos necessários para que os desenvolvedores criem seus próprios critérios de filtragem. Usando esses mecanismos, você pode criar cenários de filtragem personalizados. Por exemplo, você poderia criar um filtro de modo que, se um usuário estiver em uma função de administrador, certos controles seriam adicionados a uma região quando a página é renderizada, e se o usuário estiver em uma função de usuário, esses controles não seriam adicionados.  
  
 Os mecanismos para controles de filtragem durante o processo de autorização são as <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriedade no <xref:System.Web.UI.WebControls.WebParts.WebPart> controles, o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> e <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> métodos e o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> evento no <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle.  
  
 Para criar um cenário de filtragem, existem basicamente duas tarefas. Primeiro, você pode atribuir cadeias de caracteres para o <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriedade de cada <xref:System.Web.UI.WebControls.WebParts.WebPart> controle você deseja filtrar. Esses valores de cadeia de caracteres poderão ser arbitrários, mas eles devem conter os critérios que você deseja filtrar. Por exemplo, se você quisesse um determinado controle a ser adicionado a uma região somente se um administrador o usuário está exibindo a página, em seguida, você pode atribuir um valor de cadeia de caracteres de `admin` à propriedade. Em seguida, você poderia usar o recurso de funções do ASP.NET e adicionar todos os usuários do seu site para várias funções, como administrador, o Gerenciador e o usuário. Quando uma página está carregando, seu código de filtragem seria verificar qual função de um usuário está em, compará-lo com o valor do filtro de autorização em um controle que está sendo verificado e se (por exemplo) o usuário está em uma função de administrador e você tiver definido o controle <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> valor para `admin`, o controle pode ser adicionado.  
  
 A segunda etapa na criação de um cenário de filtragem é escrever código para verificar a <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> valores de propriedade em <xref:System.Web.UI.WebControls.WebParts.WebPart> controla e determinar se cada controle está autorizado antes de ser adicionado para sua zona. Há duas opções sobre onde colocar esse código de filtragem. A primeira opção é a opção preferencial para os desenvolvedores de páginas. Você pode criar um método para manipular o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> diretamente no código do script de servidor de página da Web ou em um arquivo de separação de código de evento. Associar o seu método com o evento, adicionando a `OnAuthorizeWebPart` de atributo na marca o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle na página, conforme mostrado no código de marcação de exemplo a seguir.  
  
```  
<asp:webpartmanager id="manager1" runat="server"   
   OnAuthorizeWebPart="manager1_AuthorizeWebPart" />  
```  
  
 Tudo o que seu método personalizado precisa fazer é verificar cada <xref:System.Web.UI.WebControls.WebParts.WebPart> controlar para os critérios de filtragem e em seguida, com base nos resultados, atribua um valor booliano para a <xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs.IsAuthorized%2A> propriedade da <xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs> objeto para indicar se o <xref:System.Web.UI.WebControls.WebParts.WebPart> controle pode ser adicionado. O código na seção exemplo demonstra como fazer isso.  
  
 A segunda opção sobre onde colocar seu código de filtragem é herdar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> de classe e substituir um método para verificar os critérios de filtro. Os dois métodos que você pode substituir para fazer isso são as <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> método ou o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> método. Embora qualquer um dos métodos funcionaria, na maioria dos casos é preferível para substituir a <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> método, porque ele oferece maior controle programático sobre o processo de autorização inteiro, enquanto o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> método faz apenas uma tarefa específica , que é gerar o evento e a seleção para um manipulador. Para obter um exemplo de código de um personalizado <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe que substitui o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> método, consulte o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> sobrecarga do método.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir um manipulador de evento personalizado para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> evento, para que o manipulador pode fornecer o código personalizado de filtragem para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> método. Esse exemplo seria uma maneira comum de um desenvolvedor de página fornecer um cenário de filtragem e a autorização de <xref:System.Web.UI.WebControls.WebParts.WebPart> controles a serem adicionados a uma página.  
  
 Na página da Web, observe que o `<asp:webpartmanager>` elemento tem o `OnAuthorizeWebPart` atributo com o nome do manipulador de eventos atribuído a ele. O método verifica se os controles na página têm seus respectivos <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> valores de propriedade é definida como `admin` e, nesse caso, retorna `true`, que significa que eles serão autorizados e adicionados à página.  
  
> [!NOTE]
>  Observe que os controles que não tem qualquer valor atribuído para o <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> propriedade são adicionados, bem, porque são considerados não deve para ser parte de um cenário de filtragem. Isso seria uma abordagem comum em um cenário de filtragem: alguns controles serão filtradas, e outras pessoas não seria, porque eles são presumidos como disponível para todos os usuários.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 Porque a configuração de usuários em funções está além do escopo deste tópico, este exemplo de código não verifica as funções de usuário a filtragem. No entanto, o cenário de filtragem de controles de acordo com as funções de usuário é provavelmente um dos usos mais comuns desse recurso de filtragem. Se você tiver funções em seu site, e você deseja verificar as funções de usuário neste método para controles de filtro, o método é semelhante a seguinte bloco de código (em comparação com a abordagem mais simples no exemplo de código anterior, que não usa as funções).  
  
```vb  
Protected Sub WebPartManager1_AuthorizeWebPart(ByVal sender _  
  As Object, ByVal e As WebPartAuthorizationEventArgs)  
  
  If String.IsNullOrEmpty(e.AuthorizationFilter) Then  
    If Roles.IsUserInRole(Page.User.Identity.Name, _  
      e.AuthorizationFilter) Then  
  
      e.IsAuthorized = True  
    Else  
      e.IsAuthorized = False  
    End If  
  End If  
  
End Sub  
```  
  
```csharp  
protected void mgr1_AuthorizeWebPart(object sender,   
  WebPartAuthorizationEventArgs e)  
{  
  if (!String.IsNullOrEmpty(e.AuthorizationFilter))  
  {  
    if(Roles.IsUserInRole(Page.User.Identity.Name, e.authorizationFilter))  
      e.IsAuthorized = true;  
    else  
      e.IsAuthorized = false;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnConnectionsActivated : EventArgs -&gt; unit&#xA;override this.OnConnectionsActivated : EventArgs -&gt; unit" Usage="webPartManager.OnConnectionsActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" /> para indicar que uma página e seus controles estão carregados e que as conexões da página foram ativadas para iniciar o compartilhamento de dados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A> método aciona o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated> evento depois que uma página tiver concluído o processo de carregamento. O método fornece uma maneira de adicionar um manipulador para o evento.  
  
 Os desenvolvedores de páginas podem adicionar um manipulador personalizado para o evento adicionando um `OnConnectionsActivated` de atributo para o `<asp:webpartmanager>` elemento em uma página e, em seguida, atribuir um nome de método personalizado para o atributo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Os desenvolvedores podem substituir os <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" /> método em um derivada <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivating">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivating (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivating(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivating (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivating(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnConnectionsActivating : EventArgs -&gt; unit&#xA;override this.OnConnectionsActivating : EventArgs -&gt; unit" Usage="webPartManager.OnConnectionsActivating e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" /> para indicar que uma página e seus controles foram carregados e o processo de ativação de conexões pode começar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> método aciona o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> evento, que fornece aos desenvolvedores um mecanismo para personalizar programaticamente o processo de ativação de conexões.  
  
 Os desenvolvedores de páginas podem adicionar um manipulador personalizado para o evento adicionando um `OnConnectionsActivating` de atributo para o `<asp:webpartmanager>` elemento em uma página e, em seguida, atribuir um nome de método personalizado para o atributo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Os desenvolvedores podem substituir os <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" /> método em um derivada <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanged (System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanged(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanged (e As WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanged(System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs -&gt; unit&#xA;override this.OnDisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs -&gt; unit" Usage="webPartManager.OnDisplayModeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" /> que contém dados de evento associados com um modo de exibição alterado.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" /> para indicar que o controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> concluiu o processo de alternar de um modo de exibição para outro em uma página da Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A> formulário de método em sua base simplesmente gera o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged> eventos.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Você pode substituir o <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" /> método. Por exemplo, após uma alteração de modo de exibição, convém alterar algo na aparência da interface do usuário (UI), dependendo de qual vídeo modo está contido no <see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs.OldDisplayMode" /> propriedade. Ou você talvez queira ocultar determinados conteúdos, ou exibir um determinado controle.  
  
Quando você substitui o método, você deve normalmente chamar o método base como a última etapa do método substituído, para que seu código personalizado é executado primeiro e o evento é gerado por último, indicando que a alteração do modo é concluída.</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanging (System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanging(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanging (e As WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanging(System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs -&gt; unit&#xA;override this.OnDisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs -&gt; unit" Usage="webPartManager.OnDisplayModeChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém dados de evento associados com um modo de exibição em alteração.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" /> para indicar que o controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> está no processo de alternar de um modo de exibição para outro em uma página da Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> formulário de método em sua base simplesmente gera o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging> eventos.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Você pode substituir o <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" /> método. Por exemplo, como um modo de exibição está sendo alterado, você talvez queira verificar qual será o novo modo de exibição (usando o <see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode" /> propriedade) e alterar algo na interface do usuário (UI) com base no qual será o novo modo de exibição. Se você tivesse um modo de exibição personalizado, você talvez queira tornar alguns controles visível se o modo personalizado vai ser o novo modo de exibição.  
  
Quando você substitui esse método, você normalmente deve chamar o método base como a primeira etapa do método substituído, para que o evento é gerado para indicar que um modo de exibição está começando a mudar. Em seguida, seu código personalizado pode fazer alterações na interface do usuário (IU) antes que o novo modo de exibição, na verdade, é exibido.</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnInit : EventArgs -&gt; unit" Usage="webPartManager.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.Control.Init" />, que é o primeiro evento no ciclo de vida do controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit%2A> método chama o método base, o que gera a <xref:System.Web.UI.Control.Init> eventos para o controle e, em seguida, executa várias etapas preparatórias, como ao garantir que há apenas uma instância da <xref:System.Web.UI.WebControls.WebParts.WebPartManager> em uma página e carregar dados de personalização.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Há outro controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> na página</exception>
        <altmember cref="E:System.Web.UI.Control.Init" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal override void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPreRender : EventArgs -&gt; unit" Usage="webPartManager.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.Control.PreRender" />, que ocorre imediatamente antes de um controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> ser renderizado em uma página da Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender%2A> método chama o método base, o que gera o <xref:System.Web.UI.Control.PreRender> controla o evento para o controle e, em seguida, registra vários scripts de cliente que são necessários nas páginas que contêm as Web Parts.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanged (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanged(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanged (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanged(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnSelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnSelectedWebPartChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />, que ocorre depois que um controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> é recém-selecionado ou que sua seleção é desmarcada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> método aciona o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged> evento, que normalmente é um ponto no tempo em que um desenvolvedor talvez queira alterar a aparência da interface do usuário (IU). Por exemplo, quando um novo <xref:System.Web.UI.WebControls.WebParts.WebPart> controle for selecionado, o controle de Web Parts definido alterações a renderização do controle recém-selecionado. Após a seleção de um controle estiver desmarcada, a renderização é retornada ao normal.  
  
 Depois que um usuário seleciona um determinado <xref:System.Web.UI.WebControls.WebParts.WebPart> controle de edição, o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> método é chamado. Quando o usuário termina o controle de edição e fecha-lo, com o resultado que a seleção do controle está desmarcada, o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> método é chamado novamente.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Há várias opções relacionadas ao <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" /> evento, para permitir que os desenvolvedores personalizem o processamento que ocorre depois que o controle selecionado foi alterado. No código declarativo, dentro a <see langword="&lt;asp:webpartmanager&gt;" /> elemento que você pode definir o <see langword="OnSelectedWebPartChanged" /> de atributo e atribua a ele o nome de um método personalizado. No método personalizado, você poderia modificar a renderização dos controles selecionados quando o evento ocorre. Outra opção é herdar o <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> de classe e substituir o método. Uma terceira opção é para personalizar a renderização no nível de zona; Por exemplo, é possível herdar a <see cref="T:System.Web.UI.WebControls.WebParts.EditorZoneBase" /> de classe e substituir seu <see cref="M:System.Web.UI.WebControls.WebParts.EditorZoneBase.OnSelectedWebPartChanged(System.Object,System.Web.UI.WebControls.WebParts.WebPartEventArgs)" /> método para personalizar a renderização de controles marcadas e desmarcadas durante o processo de edição.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanging (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanging(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanging (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanging(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit&#xA;override this.OnSelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit" Usage="webPartManager.OnSelectedWebPartChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />, que ocorre durante o processo de alteração de qual controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> está selecionado no momento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> método gera a <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> evento que ocorre durante o processo de alteração de qual <xref:System.Web.UI.WebControls.WebParts.WebPart> controle está selecionado no momento.  
  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle usa esse método e o evento associado, para fornecer uma oportunidade de cancelar um processo no qual o controle selecionado está sendo alterado. Por exemplo, o método é chamado dentro de <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> método e também dentro o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> método, para fornecer uma maneira de cancelar o processo. Se um usuário clica o verbo de cancelamento em um controle que está sendo editado, o controle não será mais selecionado e alterações de edição não são salvas porque o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> método torna possível cancelar as alterações de edição.  
  
> [!NOTE]
>  Da mesma forma, o método é chamado durante os métodos que começam e terminam o processo de conectar um <xref:System.Web.UI.WebControls.WebParts.WebPart> a outro controle, para permitir o cancelamento desse processo.  
  
 Os desenvolvedores de páginas podem criar um manipulador personalizado para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> eventos, adicionando o `OnSelectedWebPartChanging` atributo para o `<asp:webpartmanager>` elemento na marcação declarativa de página e atribuir ao atributo de nome de um método personalizado.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal override void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnUnload : EventArgs -&gt; unit" Usage="webPartManager.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dados de evento associados com a remoção do controle.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.Control.Unload" /> base e remove a instância <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> de uma página da Web.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdded">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdded (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdded(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdded (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdded(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartAdded e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />, que ocorre depois que um controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> é adicionado a uma página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A> método é chamado durante o processo de adição de um <xref:System.Web.UI.WebControls.WebParts.WebPart> controle (ou outro controle de servidor que é adicionado a um <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zona) a uma página.  
  
 Os desenvolvedores de páginas podem criar um manipulador personalizado para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> eventos, adicionando o `OnWebPartAdded` atributo para o <`asp:webpartmanager>` elemento e atribuir um nome de método personalizado para o atributo.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdding">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdding (System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdding(class System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdding (e As WebPartAddingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdding(System::Web::UI::WebControls::WebParts::WebPartAddingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs -&gt; unit&#xA;override this.OnWebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs -&gt; unit" Usage="webPartManager.OnWebPartAdding e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />, que ocorre durante o processo de adição de um controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (ou um controle de servidor ou de usuário) a uma zona <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A> método aciona o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding> evento para indicar que um controle está no processo que está sendo adicionado. O método também fornece a opção de cancelar o processo de adição. Se o controle é adicionado com êxito, o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> evento segue.  
  
 Os desenvolvedores de páginas podem fornecer um manipulador personalizado para o evento associado com a adição de `OnWebPartAdding` de atributo para o `<asp:webpartmanager>` elemento em uma página da Web e, em seguida, atribuir um nome de método personalizado para o atributo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Os desenvolvedores que criam derivados <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classes podem substituir o <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" /> método para personalizar a manipulação do evento.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosed (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosed(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosed (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosed(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartClosed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" /> para sinalizar que um controle foi removido de uma página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A> método gera a <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> evento para indicar que um <xref:System.Web.UI.WebControls.WebParts.WebPart> controle (ou outro controle de servidor ou usuário) foi fechado com êxito em uma página.  
  
 Para fechar um <xref:System.Web.UI.WebControls.WebParts.WebPart> controle significa para removê-lo a partir de uma página para que ele não será renderizado e também para colocá-lo em um especial que contém o objeto chamado de catálogo de página. Um catálogo de página, que corresponde do <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> de controle, que mantém referências para fechado <xref:System.Web.UI.WebControls.WebParts.WebPart> controles para cada página. Se um <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> controle é declarado em uma página dentro de um <xref:System.Web.UI.WebControls.WebParts.CatalogZone> zona, os usuários podem alternar a página em modo de exibição de catálogo e adicionar novamente para a página de todos os controles que foram fechados anteriormente.  
  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A> método fornece uma oportunidade para os desenvolvedores a criar um manipulador personalizado para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> eventos. Os desenvolvedores de páginas podem adicionar um manipulador personalizado para o evento adicionando um `OnWebPartClosed` de atributo para o `<asp:webpartmanager>` elemento em uma página e, em seguida, atribuir um nome de método personalizado para o atributo. É uma tarefa útil que um desenvolvedor pode realizar nesse método exibir um espaço reservado no lugar do controle fechado, completo com uma dica de ferramenta que poderia informar aos usuários como adicionar o controle de volta para a página.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosing (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosing(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosing (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosing(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit&#xA;override this.OnWebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />, que ocorre durante o processo de remoção de um controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou controle de servidor de uma página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A> método aciona o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> evento para indicar que um controle está no processo que está sendo fechado ou removido de uma página. O método também fornece a opção de cancelar o processo de fechamento. Se o controle for removido com êxito na página, o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> evento segue.  
  
 Os desenvolvedores de páginas podem fornecer um manipulador personalizado para o evento associado com a adição de `OnWebPartClosinging` de atributo para o `<asp:webpartmanager>` elemento em uma página da Web e, em seguida, atribuir um nome de método personalizado para o atributo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Os desenvolvedores que criam derivados <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classes podem substituir o <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" /> método para personalizar a manipulação do evento.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleted (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleted(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleted (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleted(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />, que ocorre depois que um controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> é permanentemente excluído de uma página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A> método é chamado durante o processo de exclusão de um <xref:System.Web.UI.WebControls.WebParts.WebPart> controle (ou outro controle de servidor que é adicionado a um <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zona) de uma página.  
  
 Os desenvolvedores de páginas podem criar um manipulador personalizado para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> eventos, adicionando o `OnWebPartDeleted` atributo para o <`asp:webpartmanager>` elemento e atribuir um nome de método personalizado para o atributo.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleting (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleting(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleting (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleting(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit&#xA;override this.OnWebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartDeleting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />, que indica que um controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> dinâmico (ou controle de usuário ou de servidor que está contido em uma zona <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />) está no processo de ser excluído.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Apenas dinâmico <xref:System.Web.UI.WebControls.WebParts.WebPart> controles podem ser excluídos, e quando um controle é excluído, a instância de controle é removida permanentemente de uma página e não pode ser restaurada. Dinâmico <xref:System.Web.UI.WebControls.WebParts.WebPart> controles são aqueles que são adicionados por meio de programação ou de um catálogo de Web Parts, em vez de controles estáticos que são declarados na marcação de uma página da Web.  
  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A> método aciona o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting> evento para indicar que um controle está sendo excluído permanentemente de sua zona. O método também fornece a oportunidade de cancelar o processo de exclusão. Se o controle é excluído com êxito na página, o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> evento segue.  
  
 Os desenvolvedores de páginas podem fornecer um manipulador personalizado para o evento associado com a adição de `OnWebPartDeleting` de atributo para o `<asp:webpartmanager>` elemento em uma página da Web e, em seguida, atribuir um nome de método personalizado para o atributo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Os desenvolvedores que criam derivados <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classes podem substituir o <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" /> método para personalizar a manipulação do evento.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoved">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoved (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoved(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoved (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoved(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartMoved e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />, que ocorre depois que um controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> é movido para um local diferente em uma página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> método gera a <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> evento no final do <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> método, o que garante que o processo de mover um controle seja concluído antes que qualquer código no evento manipulador é executado.  
  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> evento é gerado quando um controle é movido dentro da zona atual ou a outra zona, e não importa se o movimento é feito por meio de programação ou por um usuário arrastar o controle.  
  
 Os desenvolvedores de páginas podem criar um manipulador personalizado para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> eventos, adicionando o `OnWebPartMoved` atributo para o <`asp:webpartmanager>` elemento e atribuir um nome de método personalizado para o atributo.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoving">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoving (System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoving(class System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoving (e As WebPartMovingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoving(System::Web::UI::WebControls::WebParts::WebPartMovingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs -&gt; unit&#xA;override this.OnWebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs -&gt; unit" Usage="webPartManager.OnWebPartMoving e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />, que indica que um <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou controle de usuário ou de servidor, em uma zona <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />, está no processo de ser movido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> método gera a <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> evento, que ocorre quando um <xref:System.Web.UI.WebControls.WebParts.WebPart> ou outro controle de servidor está sendo movido dentro da zona ou para outra zona. O método também fornece a oportunidade de cancelar o processo de movimentação. Se a movimentação for concluída com êxito, o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> evento segue.  
  
 Os desenvolvedores de páginas podem fornecer um manipulador personalizado para o evento associado com a adição de `OnWebPartMoving` de atributo para o `<asp:webpartmanager>` elemento em uma página da Web e, em seguida, atribuir um nome de método personalizado para o atributo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Os desenvolvedores que criam derivados <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classes podem substituir o <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" /> método para personalizar a manipulação do evento.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit&#xA;override this.OnWebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsConnected e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" /> que ocorre depois que uma conexão é estabelecida entre controles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A> método dispara o evento correspondente no final do <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> método, que garante que as etapas necessárias para conectar dois controles forem concluídas antes de executar qualquer código no manipulador de eventos.  
  
 O método fornece controle programático sobre o processo de criação de conexões e o evento associado é um ponto conveniente no qual atualizar a interface do usuário (UI) ou notificar o usuário que uma conexão foi estabelecida.  
  
 Os desenvolvedores de páginas podem criar um manipulador personalizado para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> eventos, adicionando o `OnWebPartsConnected` atributo para o <`asp:webpartmanager>` elemento e atribuir um nome de método personalizado para o atributo.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit&#xA;override this.OnWebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsConnecting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />, que ocorre durante o processo de estabelecimento de uma conexão entre dois <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou controles de servidor ou de usuário, contidos em um zona <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A> método aciona o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> evento que ocorre quando dois controles tentam estabelecer uma conexão. O método fornece a oportunidade de cancelar a tentativa de conexão. Se a conexão for bem-sucedida, o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> evento segue.  
  
 Os desenvolvedores de páginas podem fornecer um manipulador personalizado para o evento associado com a adição de `OnWebPartsConnecting` de atributo para o `<asp:webpartmanager>` elemento em uma página da Web e, em seguida, atribuir um nome de método personalizado para o atributo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Os desenvolvedores que criam derivados <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classes podem substituir o <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" /> método para personalizar a manipulação do evento.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit&#xA;override this.OnWebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsDisconnected e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />, que ocorre depois que uma conexão entre controles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> é finalizada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A> método dispara o evento correspondente no final do <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> método, que executa o processo de encerramento de uma conexão entre dois controles.  
  
 O método fornece controle programático sobre o processo de encerramento de uma conexão, para que os desenvolvedores podem informar ao usuário, faça alterações à interface do usuário (UI) ou fazer outras alterações no aplicativo.  
  
 Os desenvolvedores de páginas podem criar um manipulador personalizado para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> eventos, adicionando o `OnWebPartsDisconnected` atributo para o <`asp:webpartmanager>` elemento e atribuir um nome de método personalizado para o atributo.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit&#xA;override this.OnWebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsDisconnecting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />, que indica que dois <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou controles de usuário ou de servidor, em uma zona <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />, estão no processo de finalizar uma conexão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A> método aciona o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> evento que ocorre quando dois controles estão terminando uma conexão. O método fornece a oportunidade de cancelar o processo de desconexão. Se a conexão for removido com êxito, o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> evento segue.  
  
 Os desenvolvedores de páginas podem fornecer um manipulador personalizado para o evento associado com a adição de `OnWebPartsDisconnecting` de atributo para o `<asp:webpartmanager>` elemento em uma página da Web e, em seguida, atribuir um nome de método personalizado para o atributo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Os desenvolvedores que criam derivados <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classes podem substituir o <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" /> método para personalizar a manipulação do evento.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="Personalization">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Personalization As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ Personalization { System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Personalization : System.Web.UI.WebControls.WebParts.WebPartPersonalization" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Personalization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma referência a um objeto que contém os dados de personalização de uma página da Web.</summary>
        <value>Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> que contém os dados de personalização.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> propriedade fornece uma maneira de acessar o <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> objeto que está associado uma página por meio de <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle. Usando essa propriedade, você pode acessar os vários membros do objeto de personalização. Por exemplo, você pode usar o <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A> método para alternar o escopo de personalização da página de compartilhado para escopo de usuário, ou vice-versa. Você também pode descobrir o escopo de personalização da página, se a personalização ainda está habilitada na página, qual provedor está sendo usado para os dados de personalização e muito mais.  
  
 Observe que os dados referenciados pela <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> propriedade é somente os dados de personalização de nível de página que são controlados pela <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle. Os dados de personalização de controle específicos, como os valores das propriedades personalizáveis no <xref:System.Web.UI.WebControls.WebParts.WebPart> controles, é não fazem parte do <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> propriedade.  
  
> [!NOTE]
>  Para obter mais informações sobre a personalização de Web Parts, consulte [visão geral de personalização do Web Parts](https://msdn.microsoft.com/library/7dc34f74-52aa-4082-b98d-2bcf9e07e320).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> propriedade programaticamente.  
  
 A seguinte página da Web permite que um usuário entrar no modo de edição para editar certos aspectos do <xref:System.Web.UI.WebControls.Calendar> controle. O **ativar/desativar escopo** botão alterna a página para o usuário ou o escopo de personalização compartilhado. O **modo de edição** e **modo de procurar** botões cada alternar a página para o modo de exibição apropriado. Observe que, nos `<script>` marca a seção do arquivo, dois dos métodos que manipulam eventos usam o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> propriedade para acessar membros útil do objeto subjacente. Especificamente, esses métodos usam o <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A> método e o <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Scope%2A> propriedade no objeto acessado por meio de <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> propriedade.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Personalization#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/CS/wpmgrPersonalizationCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Personalization#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/VB/wpmgrPersonalizationVB.aspx#1)]  
  
 Para o exemplo de código seja executado, você também deve habilitar um usuário ou usuários personalizar páginas no escopo compartilhado. Adicionar uma entrada ao arquivo Web. config, dentro de `<system.web>` seção, que se parece com a marcação a seguir.  
  
```  
<webParts>  
  <personalization>  
    <authorization>  
      <allow  
        users="[Replace the text and brackets with a user name or   
           group.]"  
        roles="admin"   
        verbs="enterSharedScope"  />  
    </authorization>  
  </personalization>  
</webParts>   
```  
  
 Depois de carregar a página em um navegador, clique o **ativar/desativar escopo** botão e observe que a página agora apresenta o escopo é compartilhado. Clique em **modo de edição** para alterar o modo de exibição, clique no menu de verbos do controle visível e selecione **editar** no menu. Observe que a interface do usuário (IU) para ambos os controles de edição aparece. Agora, clique em **modo de procurar** para retornar à navegação normal. Se a página informar que está no escopo compartilhado, clique em **ativar/desativar escopo** novamente para garantir que a página estiver no escopo do usuário. Em seguida, siga as mesmas etapas para editar o controle novamente, mas observe que agora a interface do usuário de edição, o <xref:System.Web.UI.WebControls.WebParts.BehaviorEditorPart> controle não será exibido. Isso ocorre porque esse controle só funciona quando a página estiver no escopo de personalização compartilhadas.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
        <related type="Article" href="https://msdn.microsoft.com/library/7dc34f74-52aa-4082-b98d-2bcf9e07e320">Visão geral de personalização de partes da Web</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScript">
      <MemberSignature Language="C#" Value="protected virtual void RegisterClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RegisterClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.RegisterClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RegisterClientScript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RegisterClientScript();" />
      <MemberSignature Language="F#" Value="abstract member RegisterClientScript : unit -&gt; unit&#xA;override this.RegisterClientScript : unit -&gt; unit" Usage="webPartManager.RegisterClientScript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Habilita o controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> a emitir script do lado do cliente, que é usado para vários recursos de personalização, como arrastar controles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> em uma página da Web.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="webPartManager.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Um <see cref="T:System.Web.UI.HtmlTextWriter" /> que recebe o conteúdo do controle a ser gravado na página.</param>
        <summary>Substituído para impedir que o controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> renderize qualquer conteúdo.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveControlState">
      <MemberSignature Language="C#" Value="protected internal override object SaveControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance object SaveControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function SaveControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Object ^ SaveControlState();" />
      <MemberSignature Language="F#" Value="override this.SaveControlState : unit -&gt; obj" Usage="webPartManager.SaveControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Salva dados de estado do controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> para que os dados possam ser restaurados nas solicitações futuras à página da Web que contém o controle.</summary>
        <returns>Um <see cref="T:System.Object" /> para conter os dados de estado salvos do controle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A> método salva dados de estado para propriedades que devem ser persistentes entre postbacks de página, mesmo quando o <xref:System.Web.UI.Control.EnableViewState%2A> estiver definida como `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void SaveCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SaveCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SaveCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SaveCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberSignature Language="F#" Value="abstract member SaveCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit&#xA;override this.SaveCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit" Usage="webPartManager.SaveCustomPersonalizationState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">Um <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> que contém os dados de estado a serem carregados.</param>
        <summary>Salva dados de estado de personalização customizados mantidos pelo controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />, para que esses dados possam ser recarregados sempre que a página for recarregada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A> método é essencial no processo de personalização, pois ele permite que as configurações personalizadas do usuário a ser armazenado para sessões futuras do navegador e visita a uma página. O método salva os dados de estado de personalização customizados, que incluem itens como o seguinte: dinâmico <xref:System.Web.UI.WebControls.WebParts.WebPart> ou controles de servidor que foram adicionados a uma página ou excluídos de uma página; controles que foram movidos em uma página; e conexões dinâmicas que têm foi criada ou excluída.  
  
 Você não pode chamar este método diretamente do seu código. Você pode, no entanto, chamar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A> método, que por si só chama esse método para salvar os dados de personalização.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Os desenvolvedores podem substituir este método em um derivada <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe para personalizar o processo de salvar os dados de personalização.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectedWebPart As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPart ^ SelectedWebPart { System::Web::UI::WebControls::WebParts::WebPart ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectedWebPart : System.Web.UI.WebControls.WebParts.WebPart" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma referência a um <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou outro controle de servidor que esteja atualmente selecionado para edição ou para criação de uma conexão com outro controle.</summary>
        <value>Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> controle que está selecionado no momento para edição ou formando uma conexão.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> propriedade retorna uma referência a um <xref:System.Web.UI.WebControls.WebParts.WebPart> ou outro controle de servidor que está selecionado no momento para edição ou para a criação de uma conexão com outro controle.  
  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle fornece vários métodos úteis e eventos para manipular o processo de selecionar um controle. O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> evento ocorre depois que um controle for selecionado, mas antes que quaisquer alterações sejam feitas. Para executar algumas ações no controle depois que ele for selecionado, substituir o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> método. Por exemplo, você talvez queira alterar a aparência de um controle que está selecionado, mas não mudou ainda, para enfatizar visualmente qual controle está selecionado.  
  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged> evento ocorre depois que o controle selecionado foi alterado. Para executar algumas ações no controle após ele ter sido alterado, substituir o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanged As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ SelectedWebPartChanged;" />
      <MemberSignature Language="F#" Value="member this.SelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.SelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre depois que a seleção de um controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> foi alterada e movida para outro controle em uma página da Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento pode ser usado em conjunto com o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> método para alterar a interface do usuário (UI) de um controle selecionado. Por exemplo, se o usuário alterna a página para o modo de design (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>) e, em seguida, seleciona um <xref:System.Web.UI.WebControls.WebParts.WebPart> controle com a intenção de arrastando-o para uma nova posição, é comum para alterar a renderização do controle selecionado, por exemplo, alterando a cor do seu borda ou em segundo plano enquanto ele estiver selecionado.  
  
> [!NOTE]
>  Para obter mais informações sobre o consumo de eventos, consulte [como: consumir eventos em um aplicativo Web Forms](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanging As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ SelectedWebPartChanging;" />
      <MemberSignature Language="F#" Value="member this.SelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " Usage="member this.SelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre durante o processo de alteração de qual <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou qual controle de servidor está atualmente selecionado em uma página da Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento pode ser usado em conjunto com o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> método. Os desenvolvedores de páginas podem criar um manipulador de eventos em seu código adicionando a `OnSelectedWebPartChanging` de atributo para o `<asp:webpartmanager>` elemento em uma página e definindo o valor do atributo como o nome de um método personalizado que manipulará o evento.  
  
 Esse evento é gerado durante o processo de inicial ou final de uma conexão entre controles e quando começando e terminando em uma edição de um controle. Para obter detalhes, consulte o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> método.  
  
 Normalmente, quando o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> evento é gerado como resultado direto de uma ação do usuário que o controle selecionado é alterado, o evento pode ser cancelado. No entanto, há um cenário no qual o evento não pode ser cancelado. Se um <xref:System.Web.UI.WebControls.WebParts.WebPartZone> controle é excluído, o <xref:System.Web.UI.WebControls.WebParts.WebPart> controles que ele contém devem todos ser fechados, caso contrário, seriam órfão. Nesse caso, o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controlar fecha o <xref:System.Web.UI.WebControls.WebParts.WebPart> controles, não o usuário e ele devem determinar qual controle está selecionado no momento e quando alterar a seleção sem qualquer chance de interrupção, para que ele possa concluir o processo de limpeza todos os controles. Portanto, por design o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> método não pode ser cancelado neste cenário. Para um evento relacionado que pode ser cancelado, consulte o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> eventos.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="SetPersonalizationDirty">
      <MemberSignature Language="C#" Value="protected void SetPersonalizationDirty ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetPersonalizationDirty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetPersonalizationDirty ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetPersonalizationDirty();" />
      <MemberSignature Language="F#" Value="member this.SetPersonalizationDirty : unit -&gt; unit" Usage="webPartManager.SetPersonalizationDirty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Define um sinalizador que indica que os dados de personalização customizados para o controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> foram alterados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A> método define um sinalizador que, por fim, faz com que os componentes de personalização no controle de Web Parts definido para salvar os dados de personalização atualizado. Para obter mais informações sobre os cenários que podem causar alterações nos dados de personalização rastreados pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager> de controle, consulte o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> propriedade.  
  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A> método não pode ser chamado diretamente do seu código e não pode ser substituído, pois ele é usado internamente pelo controle de Web Parts definido como parte do recurso de personalização de Web Parts.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>O método pode ser chamado por um derivada <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> classe. Isso seria útil se você quiser personalizar a personalização de componentes de controle de Web Parts definido e, portanto, precisam controlar o processo de configuração de sinalizadores para os dados de personalização.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="SetSelectedWebPart">
      <MemberSignature Language="C#" Value="protected void SetSelectedWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetSelectedWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetSelectedWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.SetSelectedWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.SetSelectedWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou controle de servidor que foi selecionado.</param>
        <summary>Define o valor da propriedade <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> igual ao <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> selecionado no momento ou ao controle de servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A> método é chamado durante os processos que começam ou terminam a edição do controle especificado o `webPart` parâmetro e aqueles que começar ou terminar uma conexão que inclui `webPart`.  
  
 No início dos processos de edição e a conexão, `webPart` é o controle que foi selecionado para ser editado ou para inserir uma conexão.  
  
 No final dos processos de conexão e de edição `null` é passado para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A> método, o que resulta em um controle selecionado no momento não mais que está sendo selecionado.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="SkinID">
      <MemberSignature Language="C#" Value="public override string SkinID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SkinID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SkinID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SkinID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SkinID : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.SkinID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define uma cadeia de caracteres vazia ("") para que nenhuma capa possa ser aplicada ao controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <value>Uma cadeia de caracteres vazia que impede o <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> controle da necessidade de uma capa atribuída a ele.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A> propriedade substitui a herdadas <xref:System.Web.UI.Control.SkinID%2A?displayProperty=nameWithType> propriedade para impedir que o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle, que é um controle invisível, do uso de capas. A implementação da propriedade impede que uma capa de que está sendo atribuído ao sempre retornar uma cadeia de caracteres vazia do `get` acessador e sempre gerar uma exceção se não houver uma tentativa de definir um valor no `set` acessador.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Foi feita uma tentativa para definir o valor da propriedade.</exception>
        <altmember cref="P:System.Web.UI.Control.SkinID" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="StaticConnections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StaticConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ StaticConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StaticConnections : System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma referência para a coleção de todos os objetos <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> em uma página da Web que são definidos como conexões estáticas.</summary>
        <value>Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" /> que contém todas as conexões estáticas na página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> propriedade é usada pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle para controlar e gerenciar todas as conexões estáticas em uma página. Uma conexão estática, em contraste com uma conexão dinâmica, não precisa ser adicionado a uma página sempre que a página é renderizada.  
  
 A coleção referenciada por esta propriedade contém todas as conexões estáticas que existem na página, se eles são criados programaticamente ou especificados com um `<asp:webpartconnection>` elemento na marcação da página.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso programático do <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> propriedade.  
  
 O exemplo de código tem quatro partes:  
  
-   Um controle de usuário que permite que você altere os modos de exibição em uma página de Web Parts.  
  
-   Um arquivo de código fonte que contém dois personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controles e uma interface personalizada.  
  
-   Uma página da Web que contém dois personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controles que podem ser conectados, e um `<asp:webpartmanager>` elemento.  
  
-   Uma explicação de como o exemplo funciona em um navegador.  
  
 O código a seguir contém somente a parte da página da Web do exemplo. Você também precisará obter as primeiras duas partes do exemplo – o controle de usuário personalizada e o código-fonte para os controles personalizados e a interface – da seção do exemplo da <xref:System.Web.UI.WebControls.WebParts.WebPartManager> visão geral da classe. Esse tópico também explica as opções para compilar o <xref:System.Web.UI.WebControls.WebParts.WebPart> controles.  
  
 A terceira parte do exemplo de código é a página da Web. Contém a marcação declarativa para a página `Register` diretivas para o controle de usuário e os controles personalizados. Há um `<asp:webpartmanager>` elemento, um `<asp:webpartzone>` elemento para conter os controles personalizados e um `<asp:connectionszone>` elemento. Observe que, no `Page_Load` método, o código verifica se uma conexão já existe e, se não estiver, define um provedor, um consumidor e seus pontos de conexão do respectivo e, em seguida, adiciona uma nova conexão para o conjunto de conexões estáticas referenciado pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> propriedade.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 Depois que você carregar a página da Web em um navegador, clique o **modo de exibição** controle de lista suspensa e selecione **Connect** para alternar a página para o modo de conexão. Conectar-se o modo usa a `<asp:connectionszone>` elemento para que você possa criar conexões entre controles. No modo de conexão, clique na seta para baixo na barra de título do **CEP** para ativar o menu de verbos de controle e, em seguida, clique em **Connect**. Depois que a interface do usuário de conexão (IU) for exibida, observe que uma conexão já foi criado pelo código contido no `Page_Load` método. Se você retornar a esta página em uma sessão de navegador posterior, essa conexão estático já estará estabelecida e não precisará ser recriado cada vez que a página for carregada.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="SupportedDisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportedDisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ SupportedDisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportedDisplayModes : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma coleção somente leitura de todos os modos de exibição que estão disponíveis em uma página da Web específica.</summary>
        <value>Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" /> que contém o conjunto de <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> objetos disponíveis em uma página da Web específica.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> propriedade contém somente os modos de exibição que estão disponíveis, na verdade, em uma página, considerando os tipos de controles de zona presentes na página.  
  
> [!NOTE]
>  Modos de exibição podem ser desabilitados, e quando um modo de exibição estiver desabilitado, ele não é adicionado para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> coleção, mesmo quando o tipo de zona que suporte esse modo de exibição correspondente está presente na página.  
  
 Sempre há suporte para o modo de procura e o modo de design. Os modos de exibição que podem variar são a edição do catálogo e conecte-se os modos. Cada um desses modos de exibição está associado um tipo específico de <xref:System.Web.UI.WebControls.WebParts.ToolZone> controle. É a presença dessa zona especialmente tipada em uma página da Web que faz com que um modo de exibição específico a ser adicionado à coleção referenciada pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> propriedade. Por exemplo, se uma página da Web contém uma <xref:System.Web.UI.WebControls.WebParts.EditorZone> zona, mas não um <xref:System.Web.UI.WebControls.WebParts.CatalogZone> de zona, em seguida, o modo de exibição de edição é um dos modos com suporte nessa página, mas não há suporte para o modo de exibição de catálogo.  
  
> [!NOTE]
>  O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> difere de propriedade de <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> propriedade, que faz referência a uma coleção que contém todos os modos de exibição que estão disponíveis para a atual <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controlar, mesmo aqueles que não têm suporte em uma página específica.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra o uso programático do <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> propriedade. O código usa essa propriedade para preencher a lista com apenas os modos de exibição disponíveis na página da Web atual.  
  
 Há três suporte para modos de exibição nesta página: Procurar, design e editar. As duas primeiras estão sempre disponíveis, e o modo de edição está disponível neste exemplo de código porque a página contém um <xref:System.Web.UI.WebControls.WebParts.EditorZone> controle. O catálogo e conecte-se a exibição modos não são mostrados, porque suas zonas correspondentes não estão nesta página.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/CS/wpmgrSuppDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/VB/wpmgrSuppDisplayModesvb.aspx#1)]  
  
 Depois de carregar a página em um navegador, você pode usar o controle de lista suspensa para alternar a página do modo de procura para modo de design e, em seguida, para o modo de edição. No modo de edição, você pode clique no menu de verbos suspenso no cabeçalho de um dos controles de servidor e selecione **editar** para editar o controle.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Modos de exibição de página de Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty">
      <MemberSignature Language="C#" Value="bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsDirty As Boolean Implements IPersonalizable.IsDirty" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Web::UI::WebControls::WebParts::IPersonalizable::IsDirty { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se os dados de estado de personalização customizados, gerenciados pelo controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />, foram alterados em uma página da Web.</summary>
        <value>Um valor booliano que indica se os dados de estado de personalização foi alterado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> propriedade fornece uma maneira para os chamadores determinar se os dados que são gerenciados do estado personalização o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle foi alterado. Quando os usuários personalizar detalhes de nível de página, por exemplo alterando o layout da página, criando ou excluindo conexões e adicionando ou excluindo controles, os dados de personalização é gerenciado pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controlar alterações. Esse é um método de passagem que retorna a chamadores o valor do protegido <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A> propriedade, que não pode ser acessada diretamente por chamadores.  
  
> [!NOTE]
>  O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> propriedade não indica se os valores de propriedade personalizável ou propriedades individuais que afetam a aparência do indivíduo <xref:System.Web.UI.WebControls.WebParts.WebPart> controles, foram alterados. Personalização de nível de controle é controlada individualmente para cada controle. O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> propriedade indica somente se os dados de personalização que está no nível da página e é gerenciado pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle foi alterado.  
  
 A lista a seguir descreve alguns casos comuns de personalização que faria com que o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> propriedade para retornar um valor de `true`, indicando que o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle tem alguns dados de personalização alterados:  
  
-   Fechando um estático <xref:System.Web.UI.WebControls.WebParts.WebPart> controle (ou controle de servidor ou usuário) em uma página.  
  
-   Restaurando um estático fechado <xref:System.Web.UI.WebControls.WebParts.WebPart> controle de um catálogo de página de volta para uma página.  
  
-   Mover qualquer controle dentro da zona ou para outra zona.  
  
-   Adicionando um controle de um catálogo de <xref:System.Web.UI.WebControls.WebParts.WebPart> ou controles de servidor ou adicionar um controle programaticamente.  
  
-   Criar uma conexão entre dois <xref:System.Web.UI.WebControls.WebParts.WebPart> controla, seja programaticamente ou usando a interface do usuário de conexão (UI).  
  
-   Excluindo uma conexão entre dois <xref:System.Web.UI.WebControls.WebParts.WebPart> controla, seja programaticamente ou usando a conexão da interface do usuário.  
  
 Para acessar o valor dessa propriedade, você deve converter o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> instância de controle para o <xref:System.Web.UI.WebControls.WebParts.IPersonalizable> interface; você pode, em seguida, leia o <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A> valor da propriedade.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra um uso simples dos <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> instâncias de propriedade para indicar alguns personalização de página comuns que fazem com que um <xref:System.Web.UI.WebControls.WebParts.WebPartManager> para alterar os dados de personalização do controle.  
  
 O exemplo de código tem quatro partes:  
  
-   Um controle de usuário que permite que você altere os modos de exibição em uma página que contém controles de Web Parts.  
  
-   Um arquivo de origem que contém o código para personalizar duas <xref:System.Web.UI.WebControls.WebParts.WebPart> controles que podem ser conectados e uma interface.  
  
-   Uma página da Web que hospeda todos os controles.  
  
-   Uma explicação de como funciona o exemplo de código.  
  
 A primeira parte do exemplo de código é o controle de usuário para alterar modos de exibição. Você pode obter o código-fonte para o controle de usuário da seção do exemplo da <xref:System.Web.UI.WebControls.WebParts.WebPartManager> visão geral da classe. Para obter informações sobre modos de exibição e como funciona o controle de usuário, consulte [instruções passo a passo: alterando modos de exibir em uma página de Web Parts](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 A segunda parte do exemplo é o arquivo de origem com os controles personalizados e a interface. Observe que o `IZipCode` interface expõe um método, e que esse método como implementado no personalizado `ZipCodeWebPart` controle funciona como um método de retorno de chamada para habilitar `ZipCodeWebPart` para atuar como um provedor em um cenário de conexão. O outro controle `WeatherWebPart`, atua como o consumidor de controle em uma conexão; ele pode consumir a interface específica fornecida pelo `ZipCodeWebPart`. Em um aplicativo real, `WeatherWebPart` poderia consumir um valor de CEP personalizado do provedor e, em seguida, fornecer informações meteorológicas gráfica para usuários.  
  
 Para o exemplo de código seja executado, você deve compilar este código-fonte. Você pode compilá-lo explicitamente e coloque o assembly resultante na pasta Bin do seu site da Web ou cache de assembly global. Como alternativa, você pode colocar o código-fonte na pasta App_Code de seu site, onde ele será compilado dinamicamente no tempo de execução. Este exemplo de código usa a compilação dinâmica; Portanto, observe que o `Register` diretiva para este componente na parte superior da página da Web contém apenas `TagPrefix` e `Namespace` atributos, sem um `Assembly` atributo. Para um passo a passo que demonstra como compilar, consulte [instruções passo a passo: desenvolvendo e usando um controle de servidor Web personalizado](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/ZipCodeComponent.vb#2)]  
  
 A terceira parte do exemplo de código é a página da Web. Observe que ela contém duas <xref:System.Web.UI.WebControls.WebParts.WebPartZone> zonas, com a primeira que contém dois personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controles. Há também uma <xref:System.Web.UI.WebControls.WebParts.CatalogZone> zona, que contém um padrão <xref:System.Web.UI.WebControls.Calendar> controle que os usuários podem adicionar à página. O `<asp:connectionszone>` elemento fornece uma interface do usuário para que os usuários criem conexões entre os controles de conexão. No `Page_PreRender` método, observe que ele verifica se os dados de personalização foram alterados e, em caso afirmativo, atualiza o texto de `Label1`.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/wpmgrIsDirtyCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/wpmgrIsDirtyVB.aspx#1)]  
  
 Depois de carregar a página em um navegador, tente criar alguns dos cenários listados na seção Comentários deste tópico que irá alterar os dados de personalização. Conforme você faz várias alterações, quando uma alteração envolve um dos cenários de personalização rastreados pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controlar, o texto do `Label1` controle é exibido para indicar que os dados de personalização foi alterada. Por exemplo, você pode:  
  
-   Criar uma conexão entre controles clicando o **conectar-se controles de Web Part** botão.  
  
-   Use o **modo de exibição** controle de lista suspensa para alternar a página para o modo de catálogo e adicionar o **meu calendário** controle para o segundo <xref:System.Web.UI.WebControls.WebParts.WebPartZone> zona.  
  
-   Alterar a página de volta para procurar o modo, clique no menu de verbos (mostrado com um símbolo de seta na barra de título) para o **meu calendário** controle e selecione **fechar** fechá-lo e adicioná-lo no catálogo de página.  
  
-   Retornar a página para o modo de catálogo e adicione a **meu calendário** controle de volta para a página.  
  
-   Use o **modo de exibição** controlar para alternar a página para o modo de design e reorganizar o layout dos controles arrastando um ou mais deles para outra zona ou para uma posição diferente na mesma região.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.IPersonalizable" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do .NET web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Load">
      <MemberSignature Language="C#" Value="void IPersonalizable.Load (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Load (state As PersonalizationDictionary) Implements IPersonalizable.Load" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Load;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">Um <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> que contém os dados de estado a serem carregados.</param>
        <summary>Retorna dados de estado de personalização customizados salvos anteriormente e que precisam ser carregados no controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é uma implementação do <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Load%2A?displayProperty=nameWithType> método, que fornece uma maneira para o controle de Web Parts do conjunto de acessar diretamente o protegido <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A?displayProperty=nameWithType> método. Quando este método é chamado, ele armazena os dados de personalizadas personalizados que são gerenciados pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle e que foi salvo anteriormente no armazenamento permanente de dados para uso posterior no processo de inicialização.  
  
> [!NOTE]
>  Na maioria dos casos, código de página e controle do desenvolvedor não precisa chamar esse método, porque ele é usado principalmente por controle de Web Parts definido como seu mecanismo para recuperar dados de personalização.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Um cenário em que os desenvolvedores usariam esse método é se eles estão desenvolvendo uma estrutura de personalização customizados para usar no lugar de um fornecido pelo conjunto de controles de Web Parts. Nesses casos, os desenvolvedores podem herdar a <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> de classe e substituir o <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" /> método para retornar uma implementação personalizada de um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> objeto. Personalizado <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> objeto seria chamar a implementação do <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" /> método no momento adequado para carregar dados de personalização personalizadas.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Save">
      <MemberSignature Language="C#" Value="void IPersonalizable.Save (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Save (state As PersonalizationDictionary) Implements IPersonalizable.Save" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Save;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">Um <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> que contém os dados de estado a serem salvos.</param>
        <summary>Salva os dados de estado de personalização customizados que são gerenciados pelo controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A> método é uma implementação do <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A?displayProperty=nameWithType> método, que fornece uma maneira para o controle de Web Parts do conjunto de acessar diretamente o protegido <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A?displayProperty=nameWithType> método. Quando este método é chamado, ele salva dados de todos os personalizados que são gerenciados pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle para o armazenamento permanente de dados configurado para um aplicativo de Web Parts.  
  
> [!NOTE]
>  Na maioria dos casos, código de página e controle do desenvolvedor não precisa chamar esse método, porque ele é usado principalmente por controle de Web Parts definido como seu mecanismo para salvar os dados de personalização.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Um cenário em que os desenvolvedores funcionaria com esse método é se eles estão desenvolvendo uma estrutura de personalização customizados para usar no lugar de um fornecido pelo conjunto de controles de Web Parts. Nesses casos, os desenvolvedores podem herdar a <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> de classe e substituir o <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" /> método para retornar uma implementação personalizada de um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> objeto. Personalizado <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> objeto seria chamar a implementação do <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" /> método no momento adequado para salvar os dados de personalização.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="TrackViewState">
      <MemberSignature Language="C#" Value="protected override void TrackViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void TrackViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub TrackViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void TrackViewState();" />
      <MemberSignature Language="F#" Value="override this.TrackViewState : unit -&gt; unit" Usage="webPartManager.TrackViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aplica dados de estado de personalização ao controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> e chama o método base para habilitar o controle de alterações nos dados de estado de exibição para o controle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As alterações aos dados de estado de exibição são armazenadas em uma <xref:System.Web.UI.StateBag> do objeto e pode ser acessado por meio do controle <xref:System.Web.UI.Control.ViewState%2A> propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que permite que os controles filho fiquem visíveis.</summary>
        <value>Um valor booliano que indica se um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> controle e seus controles filho são visíveis. <see langword="true" /> em todos os casos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle substitui a base <xref:System.Web.UI.Control.Visible%2A?displayProperty=nameWithType> propriedade sempre retorna um valor de `true` para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> propriedade. Mesmo que o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle em si não estiver visível, o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> propriedade precisa ser definida como `true` para que todos os seus controles filho fiquem visíveis por padrão.  
  
 Se você tentar definir o valor da <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> propriedade, sempre gera um erro porque o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle tiver substituído o comportamento de propriedade base e impede que atribuir qualquer valor à propriedade.  
  
 Essa propriedade não é associável em designers visuais, mas é associável em tempo de execução. Para obter mais informações, consulte <xref:System.ComponentModel.BindableAttribute>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Foi feita uma tentativa para atribuir um valor à propriedade.</exception>
      </Docs>
    </Member>
    <Member MemberName="WebPartAdded">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdded As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartAdded;" />
      <MemberSignature Language="F#" Value="member this.WebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre depois que um <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> dinâmico ou outro controle de servidor foi adicionado a uma zona <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />, para indicar que o controle foi adicionado com êxito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> evento é útil para indicar que um controle dinâmico (um controle adicionado por meio de programação, ao contrário do que está sendo declarado na marcação da página) foi adicionado com êxito a uma zona. Em conjunto com o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A> método, o evento fornece aos desenvolvedores uma maneira de atualizar a interface do usuário (UI) ou caso contrário, notifique os usuários que um controle foi adicionado com êxito.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartAdding">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdding As WebPartAddingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAddingEventHandler ^ WebPartAdding;" />
      <MemberSignature Language="F#" Value="member this.WebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler " Usage="member this.WebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre durante o processo de adição de um <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> dinâmico ou outro controle de servidor a uma zona <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding> é gerado pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A> método após o início do processo de adição de um controle a uma zona. Esse evento fornece uma oportunidade de cancelar o processo antes de ser concluída. Se o processo de adição for bem-sucedida, esse evento é seguido de <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> eventos.  
  
 Os desenvolvedores de páginas podem fornecer manipuladores personalizados para o evento adicionando o `OnWebPartAdding` de atributo para o `<asp:webpartmanager>` elemento em uma página e atribuir um nome de método personalizado para o atributo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartClosed">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosed As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartClosed;" />
      <MemberSignature Language="F#" Value="member this.WebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando um controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (ou controle de servidor ou de usuário) é removido de uma página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> evento indica que um controle tem sido fechado com êxito, por um usuário ou programaticamente. Para fechar um <xref:System.Web.UI.WebControls.WebParts.WebPart> controle significa para removê-lo a partir de uma página para que ele não será renderizado e também para colocá-lo em um especial que contém o objeto chamado de catálogo de página. Um catálogo de página, que corresponde do <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> de controle, que mantém referências para fechado <xref:System.Web.UI.WebControls.WebParts.WebPart> controles para cada página. Se um <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> controle é declarado em uma página dentro de um <xref:System.Web.UI.WebControls.WebParts.CatalogZone> zona, os usuários podem alternar uma página em modo de exibição de catálogo e adicionar novamente a uma página de todos os controles que foram fechados anteriormente.  
  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> evento está associado a <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A> método, que gera o evento e fornece um manipulador para ele.  
  
 Os desenvolvedores de páginas podem adicionar um manipulador personalizado para o evento adicionando um `OnWebPartClosed` de atributo para o `<asp:webpartmanager>` elemento em uma página e, em seguida, atribuir um nome de método personalizado para o atributo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartClosing">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosing As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartClosing;" />
      <MemberSignature Language="F#" Value="member this.WebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " Usage="member this.WebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre durante o processo de remoção de um controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (ou controle de servidor ou de usuário) de uma página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> é gerado pela <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A> método quando o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle está no processo de um controle de fechamento. Se a remoção do controle for bem-sucedida, esse evento é seguido de <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> eventos.  
  
 Os desenvolvedores de páginas podem fornecer um manipulador personalizado para o evento adicionando o `OnWebPartClosed` de atributo para o <`asp:webpartmanager>` elemento em uma página e atribuir um nome de método personalizado para o atributo.  
  
 Normalmente, quando o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> evento é gerado como resultado direto de fechamento de um usuário um <xref:System.Web.UI.WebControls.WebParts.WebPart> controle, o evento pode ser cancelado. No entanto, há um cenário no qual o evento não pode ser cancelado. Se um <xref:System.Web.UI.WebControls.WebParts.WebPartZone> controle é excluído, o <xref:System.Web.UI.WebControls.WebParts.WebPart> controles que ele contém devem todos ser fechados, caso contrário, seriam órfão. Nesse caso, o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controlar fecha o <xref:System.Web.UI.WebControls.WebParts.WebPart> controla, não pelo usuário. E quando o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle está no processo de chamada a <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> método para fechar cada controle e o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> evento é gerado, o evento não pode ser cancelado (por design) porque o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> precisa para concluir a tarefa de limpeza todos os controles da zona.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleted">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleted As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartDeleted;" />
      <MemberSignature Language="F#" Value="member this.WebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre depois que um <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou outro controle de servidor foi excluído de uma zona <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> evento é útil para indicar que um controle dinâmico (um controle adicionado por meio de programação, ao contrário do que está sendo declarado na marcação da página) foi excluído com êxito de uma zona. Em conjunto com o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A> método, o evento fornece aos desenvolvedores uma maneira de atualizar a interface do usuário (UI) ou caso contrário, notifique os usuários que um controle foi excluído com êxito.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleting As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartDeleting;" />
      <MemberSignature Language="F#" Value="member this.WebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " Usage="member this.WebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre durante o processo de exclusão permanente de uma instância de um <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> dinâmico ou outro controle de servidor de uma zona <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting> é gerado pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A> método durante o processo de exclusão de um controle dinâmico (uma que tenha sido adicionado por meio de programação ou por um usuário por meio da interface do usuário de Web Parts). O evento fornece uma oportunidade de cancelar o processo antes de ser concluído. Se o processo de exclusão for concluído com êxito, esse evento é seguido de <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> eventos.  
  
 Os desenvolvedores de páginas podem fornecer manipuladores personalizados para o evento adicionando o `OnWebPartDeleting` de atributo para o `<asp:webpartmanager>` elemento em uma página e atribuir um nome de método personalizado para o atributo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartMoved">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoved As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartMoved;" />
      <MemberSignature Language="F#" Value="member this.WebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre depois que um <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou controle de servidor é movido para um local diferente em uma página da Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento se aplica a estático (declarado na marcação de uma página da Web) e controles dinâmicos. Ele está associado com o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> método. Porque o evento é gerado depois que um movimento for concluído, os desenvolvedores podem incluir um manipulador de eventos para fornecer algumas notificação para os usuários, alguma validação ou outras ações. Para adicionar um manipulador de eventos, você pode adicionar um `OnWebPartMoved` de atributo para o `<asp:webpartmanager>` elemento em uma página e atribua o nome de um método personalizado para o atributo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartMoving">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoving As WebPartMovingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartMovingEventHandler ^ WebPartMoving;" />
      <MemberSignature Language="F#" Value="member this.WebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler " Usage="member this.WebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre durante o processo de movimentação de um <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou outro controle de servidor que está contido em uma zona <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> é gerado quando um <xref:System.Web.UI.WebControls.WebParts.WebPart> ou outro controle de servidor está sendo movido dentro de sua própria zona, ou a outra zona. Isso pode ocorrer quando um usuário arrasta um controle, e quando há uma mudança programática.  
  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> é gerado pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> método e fornece uma oportunidade de cancelar o processo de movimentação antes de ser concluída. Se a migração for concluída e o controle seja posicionado em uma nova posição, esse evento é seguido de <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> eventos.  
  
 Os desenvolvedores de páginas podem criar um manipulador personalizado para o evento adicionando o `OnWebPartMoving` de atributo para o `<asp:webpartmanager>` elemento e atribuir um nome de método personalizado para o atributo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="WebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartCollection WebParts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartCollection WebParts" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebParts As WebPartCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartCollection ^ WebParts { System::Web::UI::WebControls::WebParts::WebPartCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebParts : System.Web.UI.WebControls.WebParts.WebPartCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma referência a todos os controles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> rastreados pelo controle <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> em uma página da Web.</summary>
        <value>Uma <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCollection" /> que contém referências a um conjunto de controles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> propriedade é usada pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle rastrear todas <xref:System.Web.UI.WebControls.WebParts.WebPart> controles que estão contidos dentro do <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zonas na página. Embora a coleção é somente leitura, você pode acessar individuais <xref:System.Web.UI.WebControls.WebParts.WebPart> controla por meio das alterações da coleção e faça a eles por meio de programação.  
  
> [!NOTE]
>  É possível ter uma <xref:System.Web.UI.WebControls.WebParts.WebPart> controle colocado em uma página fora de um <xref:System.Web.UI.WebControls.WebParts.WebPartZone> zona, o que resulta em um controle não está sendo controlado pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controlar ou referenciados em seu <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> coleção. No entanto, há poucos motivos para usar um <xref:System.Web.UI.WebControls.WebParts.WebPart> controlar fora de uma zona, pois, em seguida, ele perde sua funcionalidade de Web Parts e atua como um controle de servidor normal.  
  
 Qualquer tipo de controle que pode ser colocado em uma região, se um personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controle, um controle ASP.NET padrão, um controle de usuário ou um controle de servidor personalizado, pode ser tratado como um <xref:System.Web.UI.WebControls.WebParts.WebPart> controle em tempo de execução. Quando um controle que não é um <xref:System.Web.UI.WebControls.WebParts.WebPart> controle é colocado em um <xref:System.Web.UI.WebControls.WebParts.WebPartZone> zona, em tempo de execução ASP.NET encapsula o controle com um <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> objeto, de modo que o controle pode se comportar como um verdadeiro <xref:System.Web.UI.WebControls.WebParts.WebPart> controle. Portanto, ao usar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> propriedade, o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle pode acompanhar qualquer tipo de controle de servidor, independentemente se ele deriva o <xref:System.Web.UI.WebControls.WebParts.WebPart> classe.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> propriedade por meio de programação para acesso individual <xref:System.Web.UI.WebControls.WebParts.WebPart> controles. Observe que na marcação declarativa para a página da Web, dentro de `<asp:webpartzone>` elemento há são dois controles de servidor ASP.NET padrão. Embora eles não herdam a <xref:System.Web.UI.WebControls.WebParts.WebPart> classe, porque eles estão em uma zona serão encapsulados com um <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> do objeto em tempo de execução e, portanto, serão incluídos na coleção referenciada pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> propriedade. Você também pode adicionar personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controles, controles de usuário ou personalizados do servidor controla nessa zona, e eles pode ser tratados da mesma maneira.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_WebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/CS/wpmgrWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_WebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/VB/wpmgrWebPartsVB.aspx#1)]  
  
 Observe que, para o exemplo de código funcione, você deve adicionar uma configuração no arquivo Web. config para habilitar a exportação de arquivos de descrição de Web Parts. Certifique-se de que você tenha um arquivo Web. config no mesmo diretório que a página da Web para este exemplo de código. Dentro de `<system.web>` seção, verifique se há uma `<webParts>` elemento com um `enableExport` atributo definido como `true`, conforme mostrado no seguinte marcação.  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 Depois que você carregar a página em um navegador, se você clicar na **contagem de Web Part** botão, o código usa o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> propriedade para retornar a contagem dos controles na coleção. Se você clicar na **título do calendário ocultar** botão, o código altera o calendário para que ele renderize com apenas uma borda e não um título.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsConnected;" />
      <MemberSignature Language="F#" Value="member this.WebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " Usage="member this.WebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre depois que uma conexão específica é estabelecida entre controles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (ou controles de servidor ou de usuário).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> evento está associado a <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A> método. O evento é útil porque depois que você sabe que uma conexão for concluída, você talvez queira informar ao usuário o fato de, ou até mesmo alterar a interface do usuário (IU) da página. Por exemplo, você talvez queira exibir alguns imagem gráfica que sugere uma conexão bem-sucedida entre dois controles, ou exibir uma mensagem breve e altere o modo de exibição de página de volta para o modo de procura.  
  
 Os desenvolvedores de páginas podem associar um manipulador de eventos personalizado com esse evento adicionando o `OnWebPartsConnected` de atributo para o `<asp:webpartmanager>` os elementos na página e atribuir um nome de método personalizado para o atributo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsConnecting;" />
      <MemberSignature Language="F#" Value="member this.WebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " Usage="member this.WebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre durante o processo de criação de uma conexão entre controles <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (ou controles de servidor ou de usuário, colocados em uma zona <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> é gerado pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A> método, e ele sinaliza que o processo de conexão foi iniciado (por exemplo, um usuário tiver selecionado um controle e clicou em um verbo de conexão), mas ainda não foi concluída. O evento fornece uma oportunidade de cancelar uma conexão antes de ser concluída. Se a conexão for concluída com êxito, esse evento é seguido de <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> eventos.  
  
 Os desenvolvedores de páginas podem adicionar um manipulador personalizado para o evento adicionando o `OnWebPartsConnecting` de atributo para o `<asp:webpartmanager>` elemento e atribuir um nome de método personalizado para o atributo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsDisconnected;" />
      <MemberSignature Language="F#" Value="member this.WebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " Usage="member this.WebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre depois que uma conexão entre dois <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou controles de servidor foi encerrada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> evento está associado a <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A> método. O evento é útil porque depois que você sabe que uma conexão é encerrada, você talvez queira informar ao usuário, executar algumas ações de limpeza no código ou fazer outras alterações na interface do usuário (IU).  
  
 Os desenvolvedores de páginas podem associar um manipulador de eventos personalizado com esse evento adicionando o `OnWebPartsDisConnected` de atributo para o `<asp:webpartmanager>` os elementos na página e atribuir um nome de método personalizado para o atributo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsDisconnecting;" />
      <MemberSignature Language="F#" Value="member this.WebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " Usage="member this.WebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre durante o processo de encerramento da conexão entre <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ou controles de servidor anteriormente conectados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> é gerado pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A> método e ele sinaliza o fato de que um usuário tenha clicado em um verbo de desconexão, ou o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> método caso contrário, foi chamado. O evento fornece uma oportunidade de cancelar o processo de encerramento de uma conexão antes de ser concluída. Se a conexão é encerrada com êxito, esse evento é seguido de <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> eventos.  
  
 Os desenvolvedores de páginas podem adicionar um manipulador personalizado para o evento adicionando o `OnWebPartsDisconnecting` de atributo para o `<asp:webpartmanager>` elemento e atribuir um nome de método personalizado para o atributo.  
  
 Normalmente, quando o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> evento é gerado como resultado direto de uma ação do usuário que encerra uma conexão, o evento pode ser cancelado. No entanto, há vários cenários em que o evento não pode ser cancelado. O primeiro cenário é, se um <xref:System.Web.UI.WebControls.WebParts.WebPartZone> controle é excluído, o <xref:System.Web.UI.WebControls.WebParts.WebPart> controles que ele contém devem todos ser fechados, caso contrário, seriam órfão. Nesse caso, o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controlar fecha o <xref:System.Web.UI.WebControls.WebParts.WebPart> controles, não o usuário e ele também devem ser capazes encerrar as conexões de todos os controles conectados sem qualquer chance de interrupção, para que ele possa concluir o processo de limpeza e de fechamento todos os controles. Portanto, por design o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> método não pode ser cancelado neste cenário. Para um evento relacionado que pode ser cancelado, consulte o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> eventos.  
  
 O segundo cenário no qual o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> evento não pode ser cancelado quando o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> método é chamado (isso chamados durante cada solicitação para uma página, por exemplo), e algum tipo de conflito das conexões existentes em uma página. Por exemplo, talvez um usuário se conecta a controle x a y de controle, mas um usuário compartilhado se conecta a controle x para controlar z e ainda controle x não é permitido para formar várias conexões. Nesse caso, as configurações de um usuário individual para a conexão tenha precedência e o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle resolve o conflito chamando o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> método e encerrando a conexão entre x e z para o usuário específico. Como a desconexão é essencial para resolver o conflito, por design o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> evento não pode ser cancelado nesse cenário.  
  
 O terceiro cenário no qual o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> método não pode ser cancelado quando um <xref:System.Web.UI.WebControls.WebParts.WebPart> ou controle de servidor que está conectado no momento é excluído ou fechado. Como o controle será definitivamente a ser removido da página, é uma necessidade de lógica para remover sua conexão. Portanto, quando o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> invocada pelo controle a <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> método, que por sua vez dispara o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> evento, por design lá está sem a possibilidade de cancelar o evento.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
        <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">Páginas do ASP.NET Web Parts</related>
      </Docs>
    </Member>
    <Member MemberName="Zones">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Zones As WebPartZoneCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ Zones { System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Zones : System.Web.UI.WebControls.WebParts.WebPartZoneCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Zones" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartZoneCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma referência a uma coleção de todas as zonas <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> em uma página da Web.</summary>
        <value>Um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneCollection" /> que referencia um conjunto de zonas <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> propriedade é usada pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle para acompanhar o <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> zonas em uma página da Web. Observe que a propriedade não faz referência a todos os tipos de zonas; faz referência a apenas as zonas que derivam de <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> classe, incluindo <xref:System.Web.UI.WebControls.WebParts.WebPartZone> zonas.  
  
 Embora a coleção referenciada pela propriedade é somente leitura, você pode usá-lo para acessar os objetos individuais na coleção e trabalhar com eles de forma programática.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> propriedade por meio de programação para acesso individual <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> controles de zona. Observe que a marcação declarativa para a página da Web, há dois `<asp:webpartzone>` elementos, cada um contendo um controle de servidor. No `<script>` seção da página, o código usa o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> propriedade para acessar as zonas individuais, listando todos os IDs de zona e, em seguida, alterar a cor de plano de fundo na segunda região.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Zones#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/CS/wpmgrzonescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Zones#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/VB/wpmgrzonesvb.aspx#1)]  
  
 Observe que, para o exemplo de código funcione, você deve adicionar uma configuração no arquivo Web. config para habilitar a exportação de arquivos de descrição de Web Parts. Certifique-se de que você tenha um arquivo Web. config no mesmo diretório que a página da Web para este exemplo de código. Dentro de `<system.web>` seção, verifique se há uma `<webParts>` elemento com um `enableExport` atributo definido como `true`, conforme mostrado no seguinte marcação.  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 Depois que você carregar a página em um navegador, se você clicar na **lista de IDs de zona** botão, o código usa o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> propriedade para listar as IDs de todas as zonas na coleção. Se você clicar na **alteração de zona BackColor** botão, o código altera a cor de plano de fundo da segunda zona.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>