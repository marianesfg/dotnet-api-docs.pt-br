<Type Name="Graphics" FullName="System.Drawing.Graphics">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0c805f19271c474b48818dbb6343a613d1b9b420" /><Meta Name="ms.sourcegitcommit" Value="9e3550fb2088d4faf2043f0acb29da4555519937" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="12/12/2018" /><Meta Name="ms.locfileid" Value="53301149" /></Metadata><TypeSignature Language="C#" Value="public sealed class Graphics : MarshalByRefObject, IDisposable, System.Drawing.IDeviceContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Graphics extends System.MarshalByRefObject implements class System.Drawing.IDeviceContext, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Drawing.Graphics" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Graphics&#xA;Inherits MarshalByRefObject&#xA;Implements IDeviceContext, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Graphics sealed : MarshalByRefObject, IDisposable, System::Drawing::IDeviceContext" />
  <TypeSignature Language="F#" Value="type Graphics = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable&#xA;    interface IDeviceContext" />
  <AssemblyInfo>
    <AssemblyName>System.Drawing</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Drawing.Common</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.1</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Drawing.IDeviceContext</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Encapsula uma superfície de desenho GDI+. Essa classe não pode ser herdada.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Drawing.Graphics> classe fornece métodos para desenhar objetos para o dispositivo de vídeo. Um <xref:System.Drawing.Graphics> está associado um contexto de dispositivo específico.  
  
 Você pode obter um <xref:System.Drawing.Graphics> objeto chamando o <xref:System.Windows.Forms.Control.CreateGraphics%2A?displayProperty=nameWithType> método em um objeto que herda de <xref:System.Windows.Forms.Control?displayProperty=nameWithType>, ou ao manipular um controle <xref:System.Windows.Forms.Control.Paint?displayProperty=nameWithType> eventos e acessar os <xref:System.Windows.Forms.PaintEventArgs.Graphics%2A> propriedade do <xref:System.Windows.Forms.PaintEventArgs?displayProperty=nameWithType> classe. Você também pode criar uma <xref:System.Drawing.Graphics> objeto de uma imagem usando o <xref:System.Drawing.Graphics.FromImage%2A> método. Para obter mais informações sobre como criar uma <xref:System.Drawing.Graphics> do objeto, consulte [como: Criar objetos gráficos para desenho](~/docs/framework/winforms/advanced/how-to-create-graphics-objects-for-drawing.md).  
  
 Você pode desenhar várias formas diferentes e linhas usando um <xref:System.Drawing.Graphics> objeto. Para obter mais informações sobre como desenhar linhas e formas, consulte o específico `Draw` *GraphicalElement* método para a linha ou forma que você deseja desenhar. Esses métodos incluem <xref:System.Drawing.Graphics.DrawLine%2A>, <xref:System.Drawing.Graphics.DrawArc%2A>, <xref:System.Drawing.Graphics.DrawClosedCurve%2A>, <xref:System.Drawing.Graphics.DrawPolygon%2A>, e <xref:System.Drawing.Graphics.DrawRectangle%2A>. Para obter mais informações sobre como desenhar linhas e formas, consulte [usando uma caneta para desenhar linhas e formas](~/docs/framework/winforms/advanced/using-a-pen-to-draw-lines-and-shapes.md) e [usando um pincel para preencher formas](~/docs/framework/winforms/advanced/using-a-brush-to-fill-shapes.md).  
  
 Você também pode desenhar imagens e ícones usando o <xref:System.Drawing.Graphics.DrawImage%2A> e <xref:System.Drawing.Graphics.DrawIcon%2A> métodos, respectivamente. Para executar uma transferência de bloco de bits de dados de cor na tela para o superfície de desenho a <xref:System.Drawing.Graphics> do objeto, consulte <xref:System.Drawing.Graphics.CopyFromScreen%2A>. Para obter mais informações sobre como desenhar imagens com um <xref:System.Drawing.Graphics> do objeto, consulte [trabalhando com imagens, Bitmaps, ícones e metarquivos](~/docs/framework/winforms/advanced/working-with-images-bitmaps-icons-and-metafiles.md).  
  
 Além disso, você pode manipular o sistema de coordenadas usado pelo <xref:System.Drawing.Graphics> objeto. Para obter mais informações sobre o sistema de coordenadas e como manipulá-lo, consulte [sistemas de coordenadas e transformações](~/docs/framework/winforms/advanced/coordinate-systems-and-transformations.md).  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer um <xref:System.Windows.Forms.PaintEventArgs> objeto. O <xref:System.Windows.Forms.PaintEventArgs> objeto é nomeado `e` e é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma imagem de um arquivo JPEG. O arquivo é denominado SampImag.jpg e está localizado na pasta do exemplo.  
  
-   Cria um ponto no qual desenhar o canto superior esquerdo da imagem.  
  
-   Desenha a imagem sem escala para a tela usando um <xref:System.Drawing.Graphics> objeto.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#40](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#40)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#40](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#40)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#40](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#40)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/162861f9-f050-445e-8abb-b2c43a918b8b">Como criar objetos gráficos para desenho</related>
    <related type="Article" href="https://msdn.microsoft.com/library/eb0f6d6f-9e52-4167-9592-ff4b82fb5869">Introdução à programação de elementos gráficos</related>
    <related type="Article" href="https://msdn.microsoft.com/library/6207cad1-7a34-4bd6-bfc1-db823ca7a73e">Gerenciando o estado de um objeto gráfico</related>
  </Docs>
  <Members>
    <Member MemberName="AddMetafileComment">
      <MemberSignature Language="C#" Value="public void AddMetafileComment (byte[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddMetafileComment(unsigned int8[] data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.AddMetafileComment(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddMetafileComment (data As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddMetafileComment(cli::array &lt;System::Byte&gt; ^ data);" />
      <MemberSignature Language="F#" Value="member this.AddMetafileComment : byte[] -&gt; unit" Usage="graphics.AddMetafileComment data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="data">Matriz de bytes que contém o comentário.</param>
        <summary>Adiciona um comentário ao <see cref="T:System.Drawing.Imaging.Metafile" /> atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é válido somente se esse <xref:System.Drawing.Graphics> está associado com um <xref:System.Drawing.Imaging.Metafile>.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro da <xref:System.Windows.Forms.Control.Paint> manipulador de eventos, bem como `thisForm`, o <xref:System.Windows.Forms.Form> para o exemplo. O código executa as seguintes ações:  
  
-   Cria um temporário <xref:System.Drawing.Graphics> para criar o metarquivo e obtém um `hdc`, um identificador para o seu contexto de dispositivo.  
  
-   Cria uma nova meta-arquivo usando o `hdc`.  
  
-   Cria uma <xref:System.Drawing.Graphics> para exibição do metarquivo do <xref:System.Drawing.Imaging.Metafile>.  
  
-   Desenha um retângulo para o metarquivo.  
  
-   Adiciona um comentário para o metarquivo.  
  
-   Descarta o <xref:System.Drawing.Graphics> para metarquivo, que fecha o metarquivo.  
  
-   Descarta o metarquivo.  
  
-   Libera temporárias `hdc`.  
  
-   Descarta temporárias <xref:System.Drawing.Graphics>.  
  
-   Cria um segunda meta-arquivo do arquivo criado anteriormente.  
  
-   Desenha o metarquivo na tela.  
  
-   Descarta o metarquivo.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#1)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#1)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginContainer">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Salva um contêiner de elementos gráficos com o estado atual deste <see cref="T:System.Drawing.Graphics" /> e abre e usa um novo contêiner de elementos gráficos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginContainer">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.GraphicsContainer BeginContainer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Drawing2D.GraphicsContainer BeginContainer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.BeginContainer" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginContainer () As GraphicsContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Drawing2D::GraphicsContainer ^ BeginContainer();" />
      <MemberSignature Language="F#" Value="member this.BeginContainer : unit -&gt; System.Drawing.Drawing2D.GraphicsContainer" Usage="graphics.BeginContainer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.GraphicsContainer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Salva um contêiner de elementos gráficos com o estado atual deste <see cref="T:System.Drawing.Graphics" /> e abre e usa um novo contêiner de elementos gráficos.</summary>
        <returns>Esse método retorna um <see cref="T:System.Drawing.Drawing2D.GraphicsContainer" /> que representa o estado deste <see cref="T:System.Drawing.Graphics" /> no momento da chamada de método.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método com o <xref:System.Drawing.Graphics.EndContainer%2A> método para criar contêineres de elementos gráficos aninhados. Contêineres de elementos gráficos reter estado de elementos gráficos, como a transformação, recorte e propriedades de processamento.  
  
 Quando você chama o <xref:System.Drawing.Graphics.BeginContainer%2A> método de um <xref:System.Drawing.Graphics>, um bloco de informações que mantém o estado do <xref:System.Drawing.Graphics> é colocado em uma pilha. O <xref:System.Drawing.Graphics.BeginContainer%2A> método retorna um <xref:System.Drawing.Drawing2D.GraphicsContainer> que identifica esse bloco de informações. Quando você passa o objeto de identificação para o <xref:System.Drawing.Graphics.EndContainer%2A> método, o bloco de informações é removido da pilha e é usado para restaurar o <xref:System.Drawing.Graphics> para o estado em que estava no momento do <xref:System.Drawing.Graphics.BeginContainer%2A> chamada de método.  
  
 Contêineres podem ser aninhados. ou seja, você pode chamar o <xref:System.Drawing.Graphics.BeginContainer%2A> método várias vezes antes de chamar o <xref:System.Drawing.Graphics.EndContainer%2A> método. Sempre que você chama o <xref:System.Drawing.Graphics.BeginContainer%2A> método, um bloco de informações é colocado na pilha, e você recebe um <xref:System.Drawing.Drawing2D.GraphicsContainer> para o bloco de informações. Quando você passa um desses objetos para o <xref:System.Drawing.Graphics.EndContainer%2A> método, o <xref:System.Drawing.Graphics> é retornado para o estado em que estava no momento das <xref:System.Drawing.Graphics.BeginContainer%2A> chamada de método que retornou que determinado <xref:System.Drawing.Drawing2D.GraphicsContainer>. O bloco de informações é colocado na pilha de por que <xref:System.Drawing.Graphics.BeginContainer%2A> chamada de método é removida da pilha, e todos os blocos de informações é colocado na pilha depois que <xref:System.Drawing.Graphics.BeginContainer%2A> chamada de método também serão removidos.  
  
 Chamadas para o <xref:System.Drawing.Graphics.Save%2A> blocos de informações de local do método na mesma pilha de chamadas para o <xref:System.Drawing.Graphics.BeginContainer%2A> método. Assim como uma <xref:System.Drawing.Graphics.EndContainer%2A> chamada de método é emparelhada com um <xref:System.Drawing.Graphics.BeginContainer%2A> chamada de método, um <xref:System.Drawing.Graphics.Restore%2A> chamada de método é emparelhada com um <xref:System.Drawing.Graphics.Save%2A> chamada de método.  
  
 Quando você chama o <xref:System.Drawing.Graphics.EndContainer%2A> todos os blocos de informações de método, colocado na pilha de (pelo <xref:System.Drawing.Graphics.Save%2A> método ou o <xref:System.Drawing.Graphics.BeginContainer%2A> método) após a chamada correspondente para o <xref:System.Drawing.Graphics.BeginContainer%2A> método são removidos da pilha. Da mesma forma, quando você chama o <xref:System.Drawing.Graphics.Restore%2A> todos os blocos de informações de método, colocado na pilha de (pelo <xref:System.Drawing.Graphics.Save%2A> método ou o <xref:System.Drawing.Graphics.BeginContainer%2A> método) após a chamada correspondente para o <xref:System.Drawing.Graphics.Save%2A> método são removidos da pilha.  
  
 O estado dos gráficos estabelecido pelo <xref:System.Drawing.Graphics.BeginContainer%2A> método inclui as qualidades de renderização do estado padrão de elementos gráficos, as alterações de estado de qualidade de renderização existente quando o método é chamado são redefinidas para os valores padrão.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Abre um novo contêiner de elementos gráficos e salva o contêiner antigo.  
  
-   Converte as coordenadas de mundo no contêiner.  
  
-   Preenche um retângulo vermelho a (convertido de coordenadas da) novo contêiner.  
  
-   Fecha o novo contêiner e restaura o contêiner salvo.  
  
-   Preenche um retângulo verde (para as coordenadas não convertidos) do contêiner salvo.  
  
 O resultado é um retângulo verde que overlies um retângulo vermelho do mesmo tamanho.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#2)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#2)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginContainer">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.GraphicsContainer BeginContainer (System.Drawing.Rectangle dstrect, System.Drawing.Rectangle srcrect, System.Drawing.GraphicsUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Drawing2D.GraphicsContainer BeginContainer(valuetype System.Drawing.Rectangle dstrect, valuetype System.Drawing.Rectangle srcrect, valuetype System.Drawing.GraphicsUnit unit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.BeginContainer(System.Drawing.Rectangle,System.Drawing.Rectangle,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginContainer (dstrect As Rectangle, srcrect As Rectangle, unit As GraphicsUnit) As GraphicsContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Drawing2D::GraphicsContainer ^ BeginContainer(System::Drawing::Rectangle dstrect, System::Drawing::Rectangle srcrect, System::Drawing::GraphicsUnit unit);" />
      <MemberSignature Language="F#" Value="member this.BeginContainer : System.Drawing.Rectangle * System.Drawing.Rectangle * System.Drawing.GraphicsUnit -&gt; System.Drawing.Drawing2D.GraphicsContainer" Usage="graphics.BeginContainer (dstrect, srcrect, unit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.GraphicsContainer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dstrect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcrect" Type="System.Drawing.Rectangle" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="dstrect">A estrutura <see cref="T:System.Drawing.Rectangle" /> que, juntamente com o parâmetro <paramref name="srcrect" />, especifica uma transformação de escala para o contêiner.</param>
        <param name="srcrect">A estrutura <see cref="T:System.Drawing.Rectangle" /> que, juntamente com o parâmetro <paramref name="dstrect" />, especifica uma transformação de escala para o contêiner.</param>
        <param name="unit">Membro da enumeração <see cref="T:System.Drawing.GraphicsUnit" /> que especifica a unidade de medida para o contêiner.</param>
        <summary>Salva um contêiner gráfico com o estado atual deste <see cref="T:System.Drawing.Graphics" /> e abre e usa um novo contêiner gráfico com a transformação de escala especificada.</summary>
        <returns>Esse método retorna um <see cref="T:System.Drawing.Drawing2D.GraphicsContainer" /> que representa o estado deste <see cref="T:System.Drawing.Graphics" /> no momento da chamada de método.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método com o <xref:System.Drawing.Graphics.EndContainer%2A> método para criar contêineres de elementos gráficos aninhados. Contêineres de elementos gráficos reter estado de elementos gráficos, como a transformação, recorte e propriedades de processamento.  
  
 Quando você chama o <xref:System.Drawing.Graphics.BeginContainer%2A> método de um <xref:System.Drawing.Graphics>, um bloco de informações que mantém o estado do <xref:System.Drawing.Graphics> é colocado em uma pilha. O <xref:System.Drawing.Graphics.BeginContainer%2A> método retorna um <xref:System.Drawing.Drawing2D.GraphicsContainer> que identifica esse bloco de informações. Quando você passa o objeto de identificação para o <xref:System.Drawing.Graphics.EndContainer%2A> método, o bloco de informações é removido da pilha e é usado para restaurar o <xref:System.Drawing.Graphics> para o estado em que estava no momento do <xref:System.Drawing.Graphics.BeginContainer%2A> chamada de método.  
  
 Contêineres podem ser aninhados. ou seja, você pode chamar o <xref:System.Drawing.Graphics.BeginContainer%2A> método várias vezes antes de chamar o <xref:System.Drawing.Graphics.EndContainer%2A> método. Sempre que você chama o <xref:System.Drawing.Graphics.BeginContainer%2A> método, um bloco de informações é colocado na pilha, e você recebe um <xref:System.Drawing.Drawing2D.GraphicsContainer> para o bloco de informações. Quando você passa um desses objetos para o <xref:System.Drawing.Graphics.EndContainer%2A> método, o <xref:System.Drawing.Graphics> é retornado para o estado em que estava no momento das <xref:System.Drawing.Graphics.BeginContainer%2A> chamada de método que retornou que determinado <xref:System.Drawing.Drawing2D.GraphicsContainer>. O bloco de informações é colocado na pilha de por que <xref:System.Drawing.Graphics.BeginContainer%2A> chamada de método é removida da pilha, e todos os blocos de informações é colocado na pilha depois que <xref:System.Drawing.Graphics.BeginContainer%2A> chamada de método também serão removidos.  
  
 Chamadas para o <xref:System.Drawing.Graphics.Save%2A> blocos de informações de local do método na mesma pilha de chamadas para o <xref:System.Drawing.Graphics.BeginContainer%2A> método. Assim como uma <xref:System.Drawing.Graphics.EndContainer%2A> chamada de método é emparelhada com um <xref:System.Drawing.Graphics.BeginContainer%2A> chamada de método, um <xref:System.Drawing.Graphics.Restore%2A> chamada de método é emparelhada com um <xref:System.Drawing.Graphics.Save%2A> chamada de método.  
  
 Quando você chama o <xref:System.Drawing.Graphics.EndContainer%2A> todos os blocos de informações de método, colocado na pilha de (pelo <xref:System.Drawing.Graphics.Save%2A> método ou o <xref:System.Drawing.Graphics.BeginContainer%2A> método) após a chamada correspondente para o <xref:System.Drawing.Graphics.BeginContainer%2A> método são removidos da pilha. Da mesma forma, quando você chama o <xref:System.Drawing.Graphics.Restore%2A> todos os blocos de informações de método, colocado na pilha de (pelo <xref:System.Drawing.Graphics.Save%2A> método ou o <xref:System.Drawing.Graphics.BeginContainer%2A> método) após a chamada correspondente para o <xref:System.Drawing.Graphics.Save%2A> método são removidos da pilha.  
  
 Esse método Especifica uma transformação de escala para o novo contêiner de elementos gráficos com o `dstrect` e `srcrect` parâmetros. A escala é igual para a transformação que, quando aplicado a `srcrect`, resulta em `dstrect`.  
  
 O estado dos gráficos estabelecido pelo <xref:System.Drawing.Graphics.BeginContainer%2A> método inclui as qualidades de renderização do estado padrão de elementos gráficos, as alterações de estado de qualidade de renderização existente quando o método é chamado são redefinidas para os valores padrão.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria dois retângulos para especificar uma transformação de escala para o novo contêiner.  
  
-   Abre o novo contêiner de elementos gráficos e salva o contêiner antigo.  
  
-   Preenche um retângulo vermelho a (dimensionado coordenadas da) novo contêiner.  
  
-   Fecha o novo contêiner e restaura o contêiner salvo.  
  
-   Preenche um retângulo verde (para as coordenadas fora de escala) do contêiner salvo.  
  
 O resultado é um retângulo verde que overlies um retângulo vermelho menor.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#3)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#3)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginContainer">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.GraphicsContainer BeginContainer (System.Drawing.RectangleF dstrect, System.Drawing.RectangleF srcrect, System.Drawing.GraphicsUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Drawing2D.GraphicsContainer BeginContainer(valuetype System.Drawing.RectangleF dstrect, valuetype System.Drawing.RectangleF srcrect, valuetype System.Drawing.GraphicsUnit unit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.BeginContainer(System.Drawing.RectangleF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginContainer (dstrect As RectangleF, srcrect As RectangleF, unit As GraphicsUnit) As GraphicsContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Drawing2D::GraphicsContainer ^ BeginContainer(System::Drawing::RectangleF dstrect, System::Drawing::RectangleF srcrect, System::Drawing::GraphicsUnit unit);" />
      <MemberSignature Language="F#" Value="member this.BeginContainer : System.Drawing.RectangleF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit -&gt; System.Drawing.Drawing2D.GraphicsContainer" Usage="graphics.BeginContainer (dstrect, srcrect, unit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.GraphicsContainer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dstrect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcrect" Type="System.Drawing.RectangleF" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="dstrect">A estrutura <see cref="T:System.Drawing.RectangleF" /> que, juntamente com o parâmetro <paramref name="srcrect" />, especifica uma transformação de escala para o novo contêiner de elementos gráficos.</param>
        <param name="srcrect">A estrutura <see cref="T:System.Drawing.RectangleF" /> que, juntamente com o parâmetro <paramref name="dstrect" />, especifica uma transformação de escala para o novo contêiner de elementos gráficos.</param>
        <param name="unit">Membro da enumeração <see cref="T:System.Drawing.GraphicsUnit" /> que especifica a unidade de medida para o contêiner.</param>
        <summary>Salva um contêiner gráfico com o estado atual deste <see cref="T:System.Drawing.Graphics" /> e abre e usa um novo contêiner gráfico com a transformação de escala especificada.</summary>
        <returns>Esse método retorna um <see cref="T:System.Drawing.Drawing2D.GraphicsContainer" /> que representa o estado deste <see cref="T:System.Drawing.Graphics" /> no momento da chamada de método.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método com o <xref:System.Drawing.Graphics.EndContainer%2A> método para criar contêineres de elementos gráficos aninhados. Contêineres de elementos gráficos reter estado de elementos gráficos, como a transformação, recorte e propriedades de processamento.  
  
 Quando você chama o <xref:System.Drawing.Graphics.BeginContainer%2A> método de um <xref:System.Drawing.Graphics>, um bloco de informações que mantém o estado do <xref:System.Drawing.Graphics> é colocado em uma pilha. O <xref:System.Drawing.Graphics.BeginContainer%2A> método retorna um <xref:System.Drawing.Drawing2D.GraphicsContainer> que identifica esse bloco de informações. Quando você passa o objeto de identificação para o <xref:System.Drawing.Graphics.EndContainer%2A> método, o bloco de informações é removido da pilha e é usado para restaurar o <xref:System.Drawing.Graphics> para o estado em que estava no momento do <xref:System.Drawing.Graphics.BeginContainer%2A> chamada de método.  
  
 Contêineres podem ser aninhados. ou seja, você pode chamar o <xref:System.Drawing.Graphics.BeginContainer%2A> método várias vezes antes de chamar o <xref:System.Drawing.Graphics.EndContainer%2A> método. Sempre que você chama o <xref:System.Drawing.Graphics.BeginContainer%2A> método, um bloco de informações é colocado na pilha, e você recebe um <xref:System.Drawing.Drawing2D.GraphicsContainer> para o bloco de informações. Quando você passa um desses objetos para o <xref:System.Drawing.Graphics.EndContainer%2A> método, o <xref:System.Drawing.Graphics> é retornado para o estado em que estava no momento das <xref:System.Drawing.Graphics.BeginContainer%2A> chamada de método que retornou que determinado <xref:System.Drawing.Drawing2D.GraphicsContainer>. O bloco de informações é colocado na pilha de por que <xref:System.Drawing.Graphics.BeginContainer%2A> chamada de método é removida da pilha, e todos os blocos de informações é colocado na pilha depois que <xref:System.Drawing.Graphics.BeginContainer%2A> chamada de método também serão removidos.  
  
 Chamadas para o <xref:System.Drawing.Graphics.Save%2A> blocos de informações de local do método na mesma pilha de chamadas para o <xref:System.Drawing.Graphics.BeginContainer%2A> método. Assim como uma <xref:System.Drawing.Graphics.EndContainer%2A> chamada de método é emparelhada com um <xref:System.Drawing.Graphics.BeginContainer%2A> chamada de método, um <xref:System.Drawing.Graphics.Restore%2A> chamada de método é emparelhada com um <xref:System.Drawing.Graphics.Save%2A> chamada de método.  
  
 Quando você chama o <xref:System.Drawing.Graphics.EndContainer%2A> todos os blocos de informações de método, colocado na pilha de (pelo `Save` método ou o <xref:System.Drawing.Graphics.BeginContainer%2A> método) após a chamada correspondente para o <xref:System.Drawing.Graphics.BeginContainer%2A> método são removidos da pilha. Da mesma forma, quando você chama o <xref:System.Drawing.Graphics.Restore%2A> todos os blocos de informações de método, colocado na pilha de (pelo <xref:System.Drawing.Graphics.Save%2A> método ou o <xref:System.Drawing.Graphics.BeginContainer%2A> método) após a chamada correspondente para o <xref:System.Drawing.Graphics.Save%2A> método são removidos da pilha.  
  
 Esse método Especifica uma transformação de escala para o novo contêiner de elementos gráficos com o `dstrect` e `srcrect` parâmetros. A escala é igual para a transformação que, quando aplicado a `srcrect`, resulta em `dstrect`.  
  
 O estado dos gráficos estabelecido pelo <xref:System.Drawing.Graphics.BeginContainer%2A> método inclui as qualidades de renderização do estado padrão de elementos gráficos, as alterações de estado de qualidade de renderização existente quando o método é chamado são redefinidas para os valores padrão.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria dois retângulos para especificar uma transformação de escala para o novo contêiner.  
  
-   Abre o novo contêiner de elementos gráficos e salva o contêiner antigo.  
  
-   Preenche um retângulo vermelho a (dimensionado coordenadas da) novo contêiner.  
  
-   Fecha o novo contêiner e restaura o contêiner salvo.  
  
-   Preenche um retângulo verde (para as coordenadas fora de escala) do contêiner salvo.  
  
 O resultado é um retângulo verde que overlies um retângulo vermelho menor.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#4)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#4)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear (System.Drawing.Color color);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear(valuetype System.Drawing.Color color) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Clear(System.Drawing.Color)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear(System::Drawing::Color color);" />
      <MemberSignature Language="F#" Value="member this.Clear : System.Drawing.Color -&gt; unit" Usage="graphics.Clear color" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="color" Type="System.Drawing.Color" />
      </Parameters>
      <Docs>
        <param name="color">Estrutura de <see cref="T:System.Drawing.Color" /> que representa a cor da tela de fundo da superfície de desenho.</param>
        <summary>Limpa toda a superfície de desenho e a preenche com a cor da tela de fundo especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Drawing.Graphics.Clear%2A> método limpa o estado do objeto graphics e não deve ser chamado quando o objeto de gráfico não pode ser atualizado. Por exemplo, se o <xref:System.Drawing.Graphics.Clear%2A> método é chamado em uma área de trabalho protegida em uma sessão do terminal server, um <xref:System.Runtime.InteropServices.ExternalException> pode ocorrer, deixando o <xref:System.Drawing.Graphics> objeto em um estado inconsistente.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código limpa o superfície de desenho a <xref:System.Drawing.Graphics> e define a cor do plano de fundo para a cor definida pelo sistema azul-petróleo.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#5)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#5)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clip">
      <MemberSignature Language="C#" Value="public System.Drawing.Region Clip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Region Clip" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.Clip" />
      <MemberSignature Language="VB.NET" Value="Public Property Clip As Region" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Region ^ Clip { System::Drawing::Region ^ get(); void set(System::Drawing::Region ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Clip : System.Drawing.Region with get, set" Usage="System.Drawing.Graphics.Clip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Region</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um <see cref="T:System.Drawing.Region" /> que limita a região desenho desse <see cref="T:System.Drawing.Graphics" />.</summary>
        <value>A <see cref="T:System.Drawing.Region" /> que limita a parte desse <see cref="T:System.Drawing.Graphics" /> que está atualmente disponível para o desenho.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Modificando o <xref:System.Drawing.Region> objeto retornado pela <xref:System.Drawing.Graphics.Clip%2A> propriedade não afeta os desenhos subsequentes com o <xref:System.Drawing.Graphics> objeto. Para alterar a região de recorte, substitua os <xref:System.Drawing.Graphics.Clip%2A> com um novo valor da propriedade <xref:System.Drawing.Region> objeto. Para determinar se a região de recorte é infinita, recuperar o <xref:System.Drawing.Graphics.Clip%2A> propriedade e chame seu <xref:System.Drawing.Region.IsInfinite%2A> método.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Drawing.Graphics.Clip%2A> propriedade. Este exemplo é projetado para ser usado com o Windows Forms. Cole o código em um formulário e chame o `SetAndFillClip` método ao lidar com o formulário <xref:System.Windows.Forms.Control.Paint> evento, passando `e` como <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-cpp[System.Drawing.GraphicsProperties#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CPP/form1.cpp#4)]
 [!code-csharp[System.Drawing.GraphicsProperties#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CS/form1.cs#4)]
 [!code-vb[System.Drawing.GraphicsProperties#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClipBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF ClipBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.RectangleF ClipBounds" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.ClipBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClipBounds As RectangleF" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::RectangleF ClipBounds { System::Drawing::RectangleF get(); };" />
      <MemberSignature Language="F#" Value="member this.ClipBounds : System.Drawing.RectangleF" Usage="System.Drawing.Graphics.ClipBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma estrutura <see cref="T:System.Drawing.RectangleF" /> que delimita a área de recorte desse <see cref="T:System.Drawing.Graphics" />.</summary>
        <value>Uma estrutura <see cref="T:System.Drawing.RectangleF" /> que representa um retângulo delimitador para a área de recorte desse <see cref="T:System.Drawing.Graphics" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A unidade para o retângulo resultante é designada pelo <xref:System.Drawing.Graphics.PageUnit%2A> propriedade. A unidade padrão é pixels. Um <xref:System.Drawing.Graphics> é tipicamente associado um controle e serão a origem do retângulo em relação à área de cliente desse controle.  
  
 Se a região de recorte é infinita, o <xref:System.Drawing.Graphics.ClipBounds%2A> propriedade retorna um retângulo grande sem sentido. Para determinar se a região de recorte é infinita, recuperar o <xref:System.Drawing.Graphics.Clip%2A> propriedade e chame seu <xref:System.Drawing.Region.IsInfinite%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompositingMode">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.CompositingMode CompositingMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.CompositingMode CompositingMode" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.CompositingMode" />
      <MemberSignature Language="VB.NET" Value="Public Property CompositingMode As CompositingMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::CompositingMode CompositingMode { System::Drawing::Drawing2D::CompositingMode get(); void set(System::Drawing::Drawing2D::CompositingMode value); };" />
      <MemberSignature Language="F#" Value="member this.CompositingMode : System.Drawing.Drawing2D.CompositingMode with get, set" Usage="System.Drawing.Graphics.CompositingMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.CompositingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que especifica como imagens compostas são desenhadas para este <see cref="T:System.Drawing.Graphics" />.</summary>
        <value>Esta propriedade especifica um membro da enumeração <see cref="T:System.Drawing.Drawing2D.CompositingMode" />. O padrão é <see cref="F:System.Drawing.Drawing2D.CompositingMode.SourceOver" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O modo de composição determina se os pixels a partir de uma imagem de origem substituam ou são combinadas com pixels da tela de fundo.  
  
> [!NOTE]
>  Você não deve usar um <xref:System.Drawing.Graphics.CompositingMode%2A> valor da propriedade de <xref:System.Drawing.Drawing2D.CompositingMode.SourceCopy> quando o <xref:System.Drawing.Graphics.TextRenderingHint%2A> estiver definida como <xref:System.Drawing.Text.TextRenderingHint.ClearTypeGridFit>. Uma exceção pode ocorrer ou a imagem pode não renderizar corretamente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompositingQuality">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.CompositingQuality CompositingQuality { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.CompositingQuality CompositingQuality" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.CompositingQuality" />
      <MemberSignature Language="VB.NET" Value="Public Property CompositingQuality As CompositingQuality" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::CompositingQuality CompositingQuality { System::Drawing::Drawing2D::CompositingQuality get(); void set(System::Drawing::Drawing2D::CompositingQuality value); };" />
      <MemberSignature Language="F#" Value="member this.CompositingQuality : System.Drawing.Drawing2D.CompositingQuality with get, set" Usage="System.Drawing.Graphics.CompositingQuality" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.CompositingQuality</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a qualidade de renderização de imagens compostas desenhadas para este <see cref="T:System.Drawing.Graphics" />.</summary>
        <value>Esta propriedade especifica um membro da enumeração <see cref="T:System.Drawing.Drawing2D.CompositingQuality" />. O padrão é <see cref="F:System.Drawing.Drawing2D.CompositingQuality.Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A qualidade de composição determina o nível de qualidade de renderização de imagens compostas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyFromScreen">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Executa uma transferência de bloco de bits dos dados de cores da tela até a superfície de desenho do <see cref="T:System.Drawing.Graphics" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyFromScreen">
      <MemberSignature Language="C#" Value="public void CopyFromScreen (System.Drawing.Point upperLeftSource, System.Drawing.Point upperLeftDestination, System.Drawing.Size blockRegionSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyFromScreen(valuetype System.Drawing.Point upperLeftSource, valuetype System.Drawing.Point upperLeftDestination, valuetype System.Drawing.Size blockRegionSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.CopyFromScreen(System.Drawing.Point,System.Drawing.Point,System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFromScreen (upperLeftSource As Point, upperLeftDestination As Point, blockRegionSize As Size)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFromScreen(System::Drawing::Point upperLeftSource, System::Drawing::Point upperLeftDestination, System::Drawing::Size blockRegionSize);" />
      <MemberSignature Language="F#" Value="member this.CopyFromScreen : System.Drawing.Point * System.Drawing.Point * System.Drawing.Size -&gt; unit" Usage="graphics.CopyFromScreen (upperLeftSource, upperLeftDestination, blockRegionSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="upperLeftSource" Type="System.Drawing.Point" />
        <Parameter Name="upperLeftDestination" Type="System.Drawing.Point" />
        <Parameter Name="blockRegionSize" Type="System.Drawing.Size" />
      </Parameters>
      <Docs>
        <param name="upperLeftSource">O ponto no canto superior esquerdo do retângulo de origem.</param>
        <param name="upperLeftDestination">O ponto no canto superior esquerdo do retângulo de destino.</param>
        <param name="blockRegionSize">O tamanho da área a ser transferida.</param>
        <summary>Executa uma transferência de bloco de bits dos dados de cores, correspondendo a um retângulo de pixels, da tela até a superfície de desenho do <see cref="T:System.Drawing.Graphics" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Drawing.Graphics.CopyFromScreen%2A> métodos são úteis para uma imagem de disposição em camadas sobre o outro. Para especificar como as cores de origem e destino são mescladas, use um dos <xref:System.Drawing.Graphics.CopyFromScreen%2A> métodos que leva um <xref:System.Drawing.CopyPixelOperation> parâmetro.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Drawing.Graphics.CopyFromScreen%2A> método. Para executar este exemplo, cole-o em um formulário do Windows. Lidar com o formulário <xref:System.Windows.Forms.Control.Paint> eventos e chamadas a `CopyPixels1` método a partir de <xref:System.Windows.Forms.Control.Paint> método de manipulação de eventos, passando `e` como <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-csharp[System.Drawing.MiscWhidbeySnippets#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/CS/Form1.cs#4)]
 [!code-vb[System.Drawing.MiscWhidbeySnippets#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">A operação falhou.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para acesso a todas as janelas. Relacionado a enumeração: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/c8dff5f8-f56a-4c07-ae31-64643b31f8fc">Como imprimir um formulário do Windows Forms</related>
        <related type="Article" href="https://msdn.microsoft.com/library/33b76910-13a3-4521-be98-5c097341ae3b">Como: Copiar Pixels para reduzir a cintilação nos Windows Forms</related>
      </Docs>
    </Member>
    <Member MemberName="CopyFromScreen">
      <MemberSignature Language="C#" Value="public void CopyFromScreen (System.Drawing.Point upperLeftSource, System.Drawing.Point upperLeftDestination, System.Drawing.Size blockRegionSize, System.Drawing.CopyPixelOperation copyPixelOperation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyFromScreen(valuetype System.Drawing.Point upperLeftSource, valuetype System.Drawing.Point upperLeftDestination, valuetype System.Drawing.Size blockRegionSize, valuetype System.Drawing.CopyPixelOperation copyPixelOperation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.CopyFromScreen(System.Drawing.Point,System.Drawing.Point,System.Drawing.Size,System.Drawing.CopyPixelOperation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFromScreen(System::Drawing::Point upperLeftSource, System::Drawing::Point upperLeftDestination, System::Drawing::Size blockRegionSize, System::Drawing::CopyPixelOperation copyPixelOperation);" />
      <MemberSignature Language="F#" Value="member this.CopyFromScreen : System.Drawing.Point * System.Drawing.Point * System.Drawing.Size * System.Drawing.CopyPixelOperation -&gt; unit" Usage="graphics.CopyFromScreen (upperLeftSource, upperLeftDestination, blockRegionSize, copyPixelOperation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="upperLeftSource" Type="System.Drawing.Point" />
        <Parameter Name="upperLeftDestination" Type="System.Drawing.Point" />
        <Parameter Name="blockRegionSize" Type="System.Drawing.Size" />
        <Parameter Name="copyPixelOperation" Type="System.Drawing.CopyPixelOperation" />
      </Parameters>
      <Docs>
        <param name="upperLeftSource">O ponto no canto superior esquerdo do retângulo de origem.</param>
        <param name="upperLeftDestination">O ponto no canto superior esquerdo do retângulo de destino.</param>
        <param name="blockRegionSize">O tamanho da área a ser transferida.</param>
        <param name="copyPixelOperation">Um dos valores de <see cref="T:System.Drawing.CopyPixelOperation" />.</param>
        <summary>Executa uma transferência de bloco de bits dos dados de cores, correspondendo a um retângulo de pixels, da tela até a superfície de desenho do <see cref="T:System.Drawing.Graphics" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Drawing.Graphics.CopyFromScreen%2A> métodos são úteis para uma imagem de disposição em camadas sobre o outro. O `copyPixelOperation` parâmetro permite que você especifique se e como as cores de origem devem ser combinadas com as cores na área de destino.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Drawing.Graphics.CopyFromScreen%2A> método. Para executar este exemplo, cole-o em um formulário do Windows. Lidar com o formulário <xref:System.Windows.Forms.Control.Paint> eventos e chamadas a `CopyPixels2` método a partir de <xref:System.Windows.Forms.Control.Paint> método de manipulação de eventos, passando `e` como <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-csharp[System.Drawing.MiscWhidbeySnippets#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/CS/Form1.cs#5)]
 [!code-vb[System.Drawing.MiscWhidbeySnippets#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="copyPixelOperation" /> não é membro de <see cref="T:System.Drawing.CopyPixelOperation" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">A operação falhou.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para acesso a todas as janelas. Relacionado a enumeração: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/c8dff5f8-f56a-4c07-ae31-64643b31f8fc">Como imprimir um formulário do Windows Forms</related>
        <related type="Article" href="https://msdn.microsoft.com/library/33b76910-13a3-4521-be98-5c097341ae3b">Como: Copiar Pixels para reduzir a cintilação nos Windows Forms</related>
      </Docs>
    </Member>
    <Member MemberName="CopyFromScreen">
      <MemberSignature Language="C#" Value="public void CopyFromScreen (int sourceX, int sourceY, int destinationX, int destinationY, System.Drawing.Size blockRegionSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyFromScreen(int32 sourceX, int32 sourceY, int32 destinationX, int32 destinationY, valuetype System.Drawing.Size blockRegionSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.CopyFromScreen(System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFromScreen (sourceX As Integer, sourceY As Integer, destinationX As Integer, destinationY As Integer, blockRegionSize As Size)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFromScreen(int sourceX, int sourceY, int destinationX, int destinationY, System::Drawing::Size blockRegionSize);" />
      <MemberSignature Language="F#" Value="member this.CopyFromScreen : int * int * int * int * System.Drawing.Size -&gt; unit" Usage="graphics.CopyFromScreen (sourceX, sourceY, destinationX, destinationY, blockRegionSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceX" Type="System.Int32" />
        <Parameter Name="sourceY" Type="System.Int32" />
        <Parameter Name="destinationX" Type="System.Int32" />
        <Parameter Name="destinationY" Type="System.Int32" />
        <Parameter Name="blockRegionSize" Type="System.Drawing.Size" />
      </Parameters>
      <Docs>
        <param name="sourceX">A coordenada X do ponto no canto superior esquerdo do retângulo de origem.</param>
        <param name="sourceY">A coordenada y do ponto no canto superior esquerdo do retângulo de origem.</param>
        <param name="destinationX">A coordenada X do ponto no canto superior esquerdo do retângulo de destino.</param>
        <param name="destinationY">A coordenada y do ponto no canto superior esquerdo do retângulo de destino.</param>
        <param name="blockRegionSize">O tamanho da área a ser transferida.</param>
        <summary>Executa uma transferência de bloco de bits dos dados de cores, correspondente a um retângulo de pixels, da tela à superfície de desenho do <see cref="T:System.Drawing.Graphics" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Drawing.Graphics.CopyFromScreen%2A> métodos são úteis para uma imagem de disposição em camadas sobre o outro. Para especificar como as cores de origem e destino são mescladas, use um dos <xref:System.Drawing.Graphics.CopyFromScreen%2A> métodos que leva um <xref:System.Drawing.CopyPixelOperation> parâmetro.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Drawing.Graphics.CopyFromScreen%2A> para imprimir uma cópia do formulário atual.  
  
 [!code-csharp[System.Drawing.Graphics.CopyFromScreen#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Graphics.CopyFromScreen/CS/Form1.cs#1)]
 [!code-vb[System.Drawing.Graphics.CopyFromScreen#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Graphics.CopyFromScreen/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">A operação falhou.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para acesso a todas as janelas. Relacionado a enumeração: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/c8dff5f8-f56a-4c07-ae31-64643b31f8fc">Como imprimir um formulário do Windows Forms</related>
        <related type="Article" href="https://msdn.microsoft.com/library/33b76910-13a3-4521-be98-5c097341ae3b">Como: Copiar Pixels para reduzir a cintilação nos Windows Forms</related>
      </Docs>
    </Member>
    <Member MemberName="CopyFromScreen">
      <MemberSignature Language="C#" Value="public void CopyFromScreen (int sourceX, int sourceY, int destinationX, int destinationY, System.Drawing.Size blockRegionSize, System.Drawing.CopyPixelOperation copyPixelOperation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyFromScreen(int32 sourceX, int32 sourceY, int32 destinationX, int32 destinationY, valuetype System.Drawing.Size blockRegionSize, valuetype System.Drawing.CopyPixelOperation copyPixelOperation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.CopyFromScreen(System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.Size,System.Drawing.CopyPixelOperation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFromScreen(int sourceX, int sourceY, int destinationX, int destinationY, System::Drawing::Size blockRegionSize, System::Drawing::CopyPixelOperation copyPixelOperation);" />
      <MemberSignature Language="F#" Value="member this.CopyFromScreen : int * int * int * int * System.Drawing.Size * System.Drawing.CopyPixelOperation -&gt; unit" Usage="graphics.CopyFromScreen (sourceX, sourceY, destinationX, destinationY, blockRegionSize, copyPixelOperation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceX" Type="System.Int32" />
        <Parameter Name="sourceY" Type="System.Int32" />
        <Parameter Name="destinationX" Type="System.Int32" />
        <Parameter Name="destinationY" Type="System.Int32" />
        <Parameter Name="blockRegionSize" Type="System.Drawing.Size" />
        <Parameter Name="copyPixelOperation" Type="System.Drawing.CopyPixelOperation" />
      </Parameters>
      <Docs>
        <param name="sourceX">A coordenada X do ponto no canto superior esquerdo do retângulo de origem.</param>
        <param name="sourceY">A coordenada y do ponto no canto superior esquerdo do retângulo de origem</param>
        <param name="destinationX">A coordenada X do ponto no canto superior esquerdo do retângulo de destino.</param>
        <param name="destinationY">A coordenada y do ponto no canto superior esquerdo do retângulo de destino.</param>
        <param name="blockRegionSize">O tamanho da área a ser transferida.</param>
        <param name="copyPixelOperation">Um dos valores de <see cref="T:System.Drawing.CopyPixelOperation" />.</param>
        <summary>Executa uma transferência de bloco de bits dos dados de cores, correspondente a um retângulo de pixels, da tela à superfície de desenho do <see cref="T:System.Drawing.Graphics" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Drawing.Graphics.CopyFromScreen%2A> métodos são úteis para uma imagem de disposição em camadas sobre o outro. O `copyPixelOperation` parâmetro permite que você especifique se e como as cores de origem devem ser combinadas com as cores na área de destino.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Drawing.Graphics.CopyFromScreen%2A> método. Para executar este exemplo, cole-o em um formulário do Windows. Lidar com o formulário <xref:System.Windows.Forms.Control.Paint> eventos e chamadas a `CopyPixels4` método a partir de <xref:System.Windows.Forms.Control.Paint> método de manipulação de eventos, passando `e` como <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-csharp[System.Drawing.MiscWhidbeySnippets#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/CS/Form1.cs#7)]
 [!code-vb[System.Drawing.MiscWhidbeySnippets#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="copyPixelOperation" /> não é membro de <see cref="T:System.Drawing.CopyPixelOperation" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">A operação falhou.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para acesso a todas as janelas. Relacionado a enumeração: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/c8dff5f8-f56a-4c07-ae31-64643b31f8fc">Como imprimir um formulário do Windows Forms</related>
        <related type="Article" href="https://msdn.microsoft.com/library/33b76910-13a3-4521-be98-5c097341ae3b">Como: Copiar Pixels para reduzir a cintilação nos Windows Forms</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="graphics.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos usados por este <see cref="T:System.Drawing.Graphics" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando <xref:System.Drawing.Graphics.Dispose%2A> permite que os recursos usados por este <xref:System.Drawing.Graphics> sejam realocados para outras finalidades.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um <xref:System.Drawing.Image> de uma gráfico de arquivos SampImag.jpg no diretório de exemplo.  
  
-   Cria uma <xref:System.Drawing.Graphics> do <xref:System.Drawing.Image>.  
  
-   Altera a imagem ao preencher um retângulo dentro dele.  
  
-   Desenha o <xref:System.Drawing.Image> na tela.  
  
-   Libera o criado <xref:System.Drawing.Graphics>.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#6)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#6)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiX">
      <MemberSignature Language="C#" Value="public float DpiX { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 DpiX" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.DpiX" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DpiX As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float DpiX { float get(); };" />
      <MemberSignature Language="F#" Value="member this.DpiX : single" Usage="System.Drawing.Graphics.DpiX" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a resolução horizontal deste <see cref="T:System.Drawing.Graphics" />.</summary>
        <value>O valor, em pontos por polegada, para a resolução horizontal com suporte por este <see cref="T:System.Drawing.Graphics" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre como criar aplicativos de alta resolução, consulte  
  
 [Alto DPI](https://go.microsoft.com/fwlink/?LinkId=159804).  
  
   
  
## Examples  
 O método a seguir mostra o uso do <xref:System.Drawing.Graphics.DpiX%2A> e <xref:System.Drawing.Graphics.DpiY%2A> propriedades. Este exemplo é projetado para uso com um formulário do Windows. Para executar este exemplo, cole-o em um formulário que contenha um <xref:System.Windows.Forms.ListBox> denominado listBox1 e chame esse método de construtor do formulário.  
  
 [!code-cpp[System.Drawing.MiscExamples#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.MiscExamples/CPP/form1.cpp#4)]
 [!code-csharp[System.Drawing.MiscExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscExamples/CS/form1.cs#4)]
 [!code-vb[System.Drawing.MiscExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscExamples/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=159804">Alto DPI</related>
      </Docs>
    </Member>
    <Member MemberName="DpiY">
      <MemberSignature Language="C#" Value="public float DpiY { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 DpiY" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.DpiY" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DpiY As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float DpiY { float get(); };" />
      <MemberSignature Language="F#" Value="member this.DpiY : single" Usage="System.Drawing.Graphics.DpiY" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a resolução vertical deste <see cref="T:System.Drawing.Graphics" />.</summary>
        <value>O valor, em pontos por polegada, da resolução vertical com suporte por este <see cref="T:System.Drawing.Graphics" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre como criar aplicativos de alta resolução, consulte  
  
 [Alto DPI](https://go.microsoft.com/fwlink/?LinkId=159804).  
  
   
  
## Examples  
 O método a seguir mostra o uso do <xref:System.Drawing.Graphics.DpiX%2A> e <xref:System.Drawing.Graphics.DpiY%2A> propriedades. Este exemplo é projetado para uso com um formulário do Windows. Para executar este exemplo, cole-o em um formulário que contenha um <xref:System.Windows.Forms.ListBox> denominado listBox1 e chame esse método de construtor do formulário.  
  
 [!code-cpp[System.Drawing.MiscExamples#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.MiscExamples/CPP/form1.cpp#4)]
 [!code-csharp[System.Drawing.MiscExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscExamples/CS/form1.cs#4)]
 [!code-vb[System.Drawing.MiscExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscExamples/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=159804">Alto DPI</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawArc">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Desenha um arco que representa uma parte de uma elipse especificada por um par de coordenadas, uma largura ou uma altura.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawArc">
      <MemberSignature Language="C#" Value="public void DrawArc (System.Drawing.Pen pen, System.Drawing.Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawArc(class System.Drawing.Pen pen, valuetype System.Drawing.Rectangle rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawArc(System.Drawing.Pen,System.Drawing.Rectangle,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawArc(System::Drawing::Pen ^ pen, System::Drawing::Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawArc : System.Drawing.Pen * System.Drawing.Rectangle * single * single -&gt; unit" Usage="graphics.DrawArc (pen, rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo do arco.</param>
        <param name="rect">Estrutura <see cref="T:System.Drawing.RectangleF" /> que define os limites da elipse.</param>
        <param name="startAngle">Ângulo em graus medido no sentido horário do eixo x ao ponto de partida do arco.</param>
        <param name="sweepAngle">Ângulo em graus medido no sentido horário do parâmetro <paramref name="startAngle" /> ao ponto de término do arco.</param>
        <summary>Desenha um arco que representa uma parte de uma elipse especificada por uma estrutura <see cref="T:System.Drawing.Rectangle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método desenha um arco que é uma parte do perímetro de uma elipse. A elipse é definida pelos limites de um retângulo. O arco é a parte do perímetro da elipse entre o `startAngle` parâmetro e o `startAngle`  +  `sweepAngle` parâmetros.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma caneta preta.  
  
-   Cria um retângulo de limite de uma elipse.  
  
-   Define o início (45 graus) e os ângulos de varredura (270 graus).  
  
-   Desenha um arco elíptico à tela.  
  
 O resultado é uma elipse parcial ausente um segmento entre + e - 45 graus do eixo x.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#7)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#7)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawArc">
      <MemberSignature Language="C#" Value="public void DrawArc (System.Drawing.Pen pen, System.Drawing.RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawArc(class System.Drawing.Pen pen, valuetype System.Drawing.RectangleF rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawArc(System.Drawing.Pen,System.Drawing.RectangleF,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawArc(System::Drawing::Pen ^ pen, System::Drawing::RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawArc : System.Drawing.Pen * System.Drawing.RectangleF * single * single -&gt; unit" Usage="graphics.DrawArc (pen, rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo do arco.</param>
        <param name="rect">Estrutura <see cref="T:System.Drawing.RectangleF" /> que define os limites da elipse.</param>
        <param name="startAngle">Ângulo em graus medido no sentido horário do eixo x ao ponto de partida do arco.</param>
        <param name="sweepAngle">Ângulo em graus medido no sentido horário do parâmetro <paramref name="startAngle" /> ao ponto de término do arco.</param>
        <summary>Desenha um arco que representa uma parte de uma elipse especificada por uma estrutura <see cref="T:System.Drawing.RectangleF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método desenha um arco que é uma parte do perímetro de uma elipse. A elipse é definida pelos limites de um retângulo. O arco é a parte do perímetro da elipse entre o `startAngle` parâmetro e o `startAngle`  +  `sweepAngle` parâmetros.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma caneta preta.  
  
-   Cria um retângulo de limite de uma elipse.  
  
-   Define o início (45 graus) e os ângulos de varredura (270 graus).  
  
-   Desenha um arco elíptico à tela.  
  
 O resultado é uma elipse parcial ausente um segmento entre + e - 45 graus do eixo x.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#8)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#8)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="DrawArc">
      <MemberSignature Language="C#" Value="public void DrawArc (System.Drawing.Pen pen, int x, int y, int width, int height, int startAngle, int sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawArc(class System.Drawing.Pen pen, int32 x, int32 y, int32 width, int32 height, int32 startAngle, int32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawArc(System.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawArc(System::Drawing::Pen ^ pen, int x, int y, int width, int height, int startAngle, int sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawArc : System.Drawing.Pen * int * int * int * int * int * int -&gt; unit" Usage="graphics.DrawArc (pen, x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="startAngle" Type="System.Int32" />
        <Parameter Name="sweepAngle" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo do arco.</param>
        <param name="x">A coordenada X do canto superior esquerdo do retângulo que define a elipse.</param>
        <param name="y">A coordenada y do canto superior esquerdo do retângulo que define a elipse.</param>
        <param name="width">Largura do retângulo que define a elipse.</param>
        <param name="height">Altura do retângulo que define a elipse.</param>
        <param name="startAngle">Ângulo em graus medido no sentido horário do eixo x ao ponto de partida do arco.</param>
        <param name="sweepAngle">Ângulo em graus medido no sentido horário do parâmetro <paramref name="startAngle" /> ao ponto de término do arco.</param>
        <summary>Desenha um arco que representa uma parte de uma elipse especificada por um par de coordenadas, uma largura ou uma altura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método desenha um arco que é uma parte do perímetro de uma elipse. A elipse é definida pelos limites de um retângulo. O arco é a parte do perímetro da elipse entre o `startAngle` parâmetro e o `startAngle`  +  `sweepAngle` parâmetros.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma caneta preta.  
  
-   Cria a posição e tamanho de um retângulo a ser associado a uma elipse.  
  
-   Define o início (45 graus) e os ângulos de varredura (270 graus).  
  
-   Desenha um arco elíptico à tela.  
  
 O resultado é uma elipse parcial ausente um segmento entre + e - 45 graus do eixo x.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#9](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#9)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#9)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawArc">
      <MemberSignature Language="C#" Value="public void DrawArc (System.Drawing.Pen pen, float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawArc(class System.Drawing.Pen pen, float32 x, float32 y, float32 width, float32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawArc(System.Drawing.Pen,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawArc(System::Drawing::Pen ^ pen, float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawArc : System.Drawing.Pen * single * single * single * single * single * single -&gt; unit" Usage="graphics.DrawArc (pen, x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo do arco.</param>
        <param name="x">A coordenada X do canto superior esquerdo do retângulo que define a elipse.</param>
        <param name="y">A coordenada y do canto superior esquerdo do retângulo que define a elipse.</param>
        <param name="width">Largura do retângulo que define a elipse.</param>
        <param name="height">Altura do retângulo que define a elipse.</param>
        <param name="startAngle">Ângulo em graus medido no sentido horário do eixo x ao ponto de partida do arco.</param>
        <param name="sweepAngle">Ângulo em graus medido no sentido horário do parâmetro <paramref name="startAngle" /> ao ponto de término do arco.</param>
        <summary>Desenha um arco que representa uma parte de uma elipse especificada por um par de coordenadas, uma largura ou uma altura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método desenha um arco que é uma parte do perímetro de uma elipse. A elipse é definida pelos limites de um retângulo. O arco é a parte do perímetro da elipse entre o `startAngle` parâmetro e o `startAngle`  +  `sweepAngle` parâmetros.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma caneta preta.  
  
-   Cria a posição e tamanho de um retângulo a ser associado a uma elipse.  
  
-   Define o início (45 graus) e os ângulos de varredura (270 graus).  
  
-   Desenha um arco elíptico à tela.  
  
 O resultado é uma elipse parcial ausente um segmento entre + e - 45 graus do eixo x.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#10)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#10)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawBezier">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Desenha uma spline de Bézier definida por quatro estruturas <see cref="T:System.Drawing.Point" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawBezier">
      <MemberSignature Language="C#" Value="public void DrawBezier (System.Drawing.Pen pen, System.Drawing.Point pt1, System.Drawing.Point pt2, System.Drawing.Point pt3, System.Drawing.Point pt4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawBezier(class System.Drawing.Pen pen, valuetype System.Drawing.Point pt1, valuetype System.Drawing.Point pt2, valuetype System.Drawing.Point pt3, valuetype System.Drawing.Point pt4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawBezier(System.Drawing.Pen,System.Drawing.Point,System.Drawing.Point,System.Drawing.Point,System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawBezier(System::Drawing::Pen ^ pen, System::Drawing::Point pt1, System::Drawing::Point pt2, System::Drawing::Point pt3, System::Drawing::Point pt4);" />
      <MemberSignature Language="F#" Value="member this.DrawBezier : System.Drawing.Pen * System.Drawing.Point * System.Drawing.Point * System.Drawing.Point * System.Drawing.Point -&gt; unit" Usage="graphics.DrawBezier (pen, pt1, pt2, pt3, pt4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="pt1" Type="System.Drawing.Point" />
        <Parameter Name="pt2" Type="System.Drawing.Point" />
        <Parameter Name="pt3" Type="System.Drawing.Point" />
        <Parameter Name="pt4" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pen">Estrutura <see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo da curva.</param>
        <param name="pt1">Estrutura <see cref="T:System.Drawing.Point" /> que representa o ponto inicial da curva.</param>
        <param name="pt2">Estrutura <see cref="T:System.Drawing.Point" /> que representa o primeiro ponto de controle da curva.</param>
        <param name="pt3">Estrutura <see cref="T:System.Drawing.Point" /> que representa o segundo ponto de controle da curva.</param>
        <param name="pt4">Estrutura <see cref="T:System.Drawing.Point" /> que representa o ponto final da curva.</param>
        <summary>Desenha uma spline de Bézier definida por quatro estruturas <see cref="T:System.Drawing.Point" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A curva de Bézier é desenhada no primeiro ponto até o quarto ponto. Os pontos do segundo e terceiro são pontos de controle que determina a forma da curva.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma caneta preta.  
  
-   Cria o início, fim e dois pontos de controle da curva.  
  
-   Desenha a curva de Bézier na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#11](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#11)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#11)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawBezier">
      <MemberSignature Language="C#" Value="public void DrawBezier (System.Drawing.Pen pen, System.Drawing.PointF pt1, System.Drawing.PointF pt2, System.Drawing.PointF pt3, System.Drawing.PointF pt4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawBezier(class System.Drawing.Pen pen, valuetype System.Drawing.PointF pt1, valuetype System.Drawing.PointF pt2, valuetype System.Drawing.PointF pt3, valuetype System.Drawing.PointF pt4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawBezier(System.Drawing.Pen,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawBezier(System::Drawing::Pen ^ pen, System::Drawing::PointF pt1, System::Drawing::PointF pt2, System::Drawing::PointF pt3, System::Drawing::PointF pt4);" />
      <MemberSignature Language="F#" Value="member this.DrawBezier : System.Drawing.Pen * System.Drawing.PointF * System.Drawing.PointF * System.Drawing.PointF * System.Drawing.PointF -&gt; unit" Usage="graphics.DrawBezier (pen, pt1, pt2, pt3, pt4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="pt1" Type="System.Drawing.PointF" />
        <Parameter Name="pt2" Type="System.Drawing.PointF" />
        <Parameter Name="pt3" Type="System.Drawing.PointF" />
        <Parameter Name="pt4" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo da curva.</param>
        <param name="pt1">Estrutura <see cref="T:System.Drawing.PointF" /> que representa o ponto inicial da curva.</param>
        <param name="pt2">Estrutura <see cref="T:System.Drawing.PointF" /> que representa o primeiro ponto de controle da curva.</param>
        <param name="pt3">Estrutura <see cref="T:System.Drawing.PointF" /> que representa o segundo ponto de controle da curva.</param>
        <param name="pt4">Estrutura <see cref="T:System.Drawing.PointF" /> que representa o ponto final da curva.</param>
        <summary>Desenha uma spline de Bézier definida por quatro estruturas <see cref="T:System.Drawing.PointF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O spline de Bézier é desenhado no primeiro ponto até o quarto ponto. Os pontos do segundo e terceiro são pontos de controle que determina a forma da curva.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma caneta preta.  
  
-   Cria o início, fim e dois pontos de controle da curva.  
  
-   Desenha a curva de Bézier na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#12](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#12)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#12)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawBezier">
      <MemberSignature Language="C#" Value="public void DrawBezier (System.Drawing.Pen pen, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawBezier(class System.Drawing.Pen pen, float32 x1, float32 y1, float32 x2, float32 y2, float32 x3, float32 y3, float32 x4, float32 y4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawBezier(System.Drawing.Pen,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawBezier(System::Drawing::Pen ^ pen, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);" />
      <MemberSignature Language="F#" Value="member this.DrawBezier : System.Drawing.Pen * single * single * single * single * single * single * single * single -&gt; unit" Usage="graphics.DrawBezier (pen, x1, y1, x2, y2, x3, y3, x4, y4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x1" Type="System.Single" />
        <Parameter Name="y1" Type="System.Single" />
        <Parameter Name="x2" Type="System.Single" />
        <Parameter Name="y2" Type="System.Single" />
        <Parameter Name="x3" Type="System.Single" />
        <Parameter Name="y3" Type="System.Single" />
        <Parameter Name="x4" Type="System.Single" />
        <Parameter Name="y4" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo da curva.</param>
        <param name="x1">A coordenada X do ponto de partida da curva.</param>
        <param name="y1">A coordenada Y do ponto de partida da curva.</param>
        <param name="x2">A coordenada X do primeiro ponto de controle da curva.</param>
        <param name="y2">A coordenada Y do primeiro ponto de controle da curva.</param>
        <param name="x3">A coordenada X do segundo ponto de controle da curva.</param>
        <param name="y3">A coordenada Y do segundo ponto de controle da curva.</param>
        <param name="x4">A coordenada X do ponto de término da curva.</param>
        <param name="y4">A coordenada Y do ponto de término da curva.</param>
        <summary>Desenha um spline de Bézier definida por quatro pares de coordenadas ordenados que representam pontos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O spline de Bézier é desenhado no primeiro ponto até o quarto ponto. Os pontos do segundo e terceiro são pontos de controle que determina a forma da curva.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma caneta preta.  
  
-   Cria as coordenadas de início, fim e dois pontos de controle da curva.  
  
-   Desenha a curva de Bézier na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#13](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#13)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#13)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawBeziers">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Desenha uma série de splines de Bézier de uma matriz de estruturas de <see cref="T:System.Drawing.Point" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawBeziers">
      <MemberSignature Language="C#" Value="public void DrawBeziers (System.Drawing.Pen pen, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawBeziers(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawBeziers(System.Drawing.Pen,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawBeziers(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawBeziers : System.Drawing.Pen * System.Drawing.Point[] -&gt; unit" Usage="graphics.DrawBeziers (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo da linha.</param>
        <param name="points">Matriz de estruturas <see cref="T:System.Drawing.Point" /> que representa os pontos que determinam a curva. O número de pontos da matriz deve ser um múltiplo de 3 mais 1, como 4, 7 ou 10.</param>
        <summary>Desenha uma série de splines de Bézier de uma matriz de estruturas de <see cref="T:System.Drawing.Point" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O número de pontos da matriz deve ser um múltiplo de 3 mais 1 porque o spline primeiro requer 4 pontos e quaisquer outros splines requerem 3 pontos. O spline de Bézier primeiro é desenhado no primeiro ponto para o quarto ponto na matriz de ponto. Os pontos do segundo e terceiro são pontos de controle que determina a forma da curva. Cada curva subsequente precisa exatamente três pontos mais: dois mais controlam pontos e um ponto final. O ponto final da curva anterior é usado como o ponto de partida para cada curva adicional.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma caneta preta.  
  
-   Cria o início, fim e dois pontos de controle para uma curva primeiro e o ponto de extremidade e dois pontos de controle para a segunda curva.  
  
-   Desenha as curvas de Bézier sucessivas na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#14](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#14)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#14](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#14)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="points" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawBeziers">
      <MemberSignature Language="C#" Value="public void DrawBeziers (System.Drawing.Pen pen, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawBeziers(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawBeziers(System.Drawing.Pen,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawBeziers(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawBeziers : System.Drawing.Pen * System.Drawing.PointF[] -&gt; unit" Usage="graphics.DrawBeziers (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo da curva.</param>
        <param name="points">Matriz de estruturas <see cref="T:System.Drawing.PointF" /> que representa os pontos que determinam a curva. O número de pontos da matriz deve ser um múltiplo de 3 mais 1, como 4, 7 ou 10.</param>
        <summary>Desenha uma série de splines de Bézier de uma matriz de estruturas de <see cref="T:System.Drawing.PointF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O número de pontos da matriz deve ser um múltiplo de 3 mais 1 porque o spline primeiro requer 4 pontos e quaisquer outros splines requerem 3 pontos. A curva de Bézier a primeira é desenhada no primeiro ponto para o quarto ponto na matriz de ponto. Os pontos do segundo e terceiro são pontos de controle que determina a forma da curva. Cada curva subsequente precisa exatamente três pontos mais: dois mais controlam pontos e um ponto final. O ponto final da curva anterior é usado como o ponto de partida para cada curva adicional.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma caneta preta.  
  
-   Cria o início, fim e dois pontos de controle para uma curva primeiro e o ponto de extremidade e dois pontos de controle para a segunda curva.  
  
-   Desenha as curvas de Bézier sucessivas na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#15](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#15)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#15)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#15](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="points" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawClosedCurve">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Desenha um spline cardinal fechado definido por uma matriz de estruturas <see cref="T:System.Drawing.Point" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawClosedCurve">
      <MemberSignature Language="C#" Value="public void DrawClosedCurve (System.Drawing.Pen pen, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawClosedCurve(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawClosedCurve(System.Drawing.Pen,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawClosedCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawClosedCurve : System.Drawing.Pen * System.Drawing.Point[] -&gt; unit" Usage="graphics.DrawClosedCurve (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, largura e altura da curva.</param>
        <param name="points">Matriz de estruturas <see cref="T:System.Drawing.Point" /> que definem o spline.</param>
        <summary>Desenha um spline cardinal fechado definido por uma matriz de estruturas <see cref="T:System.Drawing.Point" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método desenha um spline cardinal fechado que passa por cada ponto na matriz. Se o último ponto não coincide com o primeiro ponto, um segmento de curva adicionais é adicionado a partir do último ponto até o primeiro ponto para fechar a figura.  
  
 A matriz de pontos deve conter pelo menos quatro <xref:System.Drawing.Point> estruturas.  
  
 Esse método usa uma tensão de padrão de 0,5.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria canetas vermelhas e verdes.  
  
-   Cria a sete pontos para definir uma curva.  
  
-   Desenha a sete linhas retas vermelhas entre os sete pontos para formar um polígono fechado.  
  
-   Desenha uma curva fechada verde por meio de sete pontos.  
  
 O método usa uma tensão de padrão de 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#16](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#16)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#16](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#16)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#16](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="points" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawClosedCurve">
      <MemberSignature Language="C#" Value="public void DrawClosedCurve (System.Drawing.Pen pen, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawClosedCurve(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawClosedCurve(System.Drawing.Pen,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawClosedCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawClosedCurve : System.Drawing.Pen * System.Drawing.PointF[] -&gt; unit" Usage="graphics.DrawClosedCurve (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, largura e altura da curva.</param>
        <param name="points">Matriz de estruturas <see cref="T:System.Drawing.PointF" /> que definem o spline.</param>
        <summary>Desenha um spline cardinal fechado definido por uma matriz de estruturas <see cref="T:System.Drawing.PointF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método desenha um spline cardinal fechado que passa por cada ponto na matriz. Se o último ponto não coincide com o primeiro ponto, um segmento de curva adicionais é adicionado a partir do último ponto até o primeiro ponto para fechá-la.  
  
 A matriz de pontos deve conter pelo menos quatro <xref:System.Drawing.PointF> estruturas.  
  
 Esse método usa uma tensão de padrão de 0,5.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria canetas vermelhas e verdes.  
  
-   Cria a sete pontos para definir uma curva.  
  
-   Desenha a sete linhas retas vermelhas entre os sete pontos para formar um polígono fechado.  
  
-   Desenha uma curva fechada verde por meio de sete pontos.  
  
 O método usa uma tensão de padrão de 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#18](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#18)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#18](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#18)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="points" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawClosedCurve">
      <MemberSignature Language="C#" Value="public void DrawClosedCurve (System.Drawing.Pen pen, System.Drawing.Point[] points, float tension, System.Drawing.Drawing2D.FillMode fillmode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawClosedCurve(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points, float32 tension, valuetype System.Drawing.Drawing2D.FillMode fillmode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawClosedCurve(System.Drawing.Pen,System.Drawing.Point[],System.Single,System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawClosedCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points, float tension, System::Drawing::Drawing2D::FillMode fillmode);" />
      <MemberSignature Language="F#" Value="member this.DrawClosedCurve : System.Drawing.Pen * System.Drawing.Point[] * single * System.Drawing.Drawing2D.FillMode -&gt; unit" Usage="graphics.DrawClosedCurve (pen, points, tension, fillmode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="tension" Type="System.Single" />
        <Parameter Name="fillmode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, largura e altura da curva.</param>
        <param name="points">Matriz de estruturas <see cref="T:System.Drawing.Point" /> que definem o spline.</param>
        <param name="tension">Valor maior ou igual a 0.0F que especifica a tensão da curva.</param>
        <param name="fillmode">Membro da enumeração <see cref="T:System.Drawing.Drawing2D.FillMode" /> que determina como a curva é preenchida. Este parâmetro é necessário, mas é ignorado.</param>
        <summary>Desenha um spline cardinal fechado definido por uma matriz de estruturas <see cref="T:System.Drawing.Point" /> usando uma tensão especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método desenha um spline cardinal fechado que passa por cada ponto na matriz. Se o último ponto não coincide com o primeiro ponto, um segmento de curva adicionais é adicionado a partir do último ponto até o primeiro ponto para fechá-la.  
  
 A matriz de pontos deve conter pelo menos quatro <xref:System.Drawing.Point> estruturas.  
  
 O `tension` parâmetro determina a forma de spline. Se o valor da `tension` parâmetro é 0.0F, esse método desenha segmentos de linha reta para conectar os pontos. Normalmente, o `tension` parâmetro é menor ou igual a 1.0F. Valores ao longo do 1.0F produzem resultados incomuns.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria canetas vermelhas e verdes.  
  
-   Cria a sete pontos para definir a curva.  
  
-   Desenha a sete linhas retas vermelhas entre os sete pontos para formar um polígono.  
  
-   Cria as configurações do modo de tensão e preenchimento.  
  
-   Desenha uma curva fechada verde por meio de sete pontos.  
  
 O método usa uma tensão de 1,0 e define o modo de preenchimento como `FillMode.Alternate`.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#17](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#17)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#17](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#17)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#17](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="points" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawClosedCurve">
      <MemberSignature Language="C#" Value="public void DrawClosedCurve (System.Drawing.Pen pen, System.Drawing.PointF[] points, float tension, System.Drawing.Drawing2D.FillMode fillmode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawClosedCurve(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points, float32 tension, valuetype System.Drawing.Drawing2D.FillMode fillmode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawClosedCurve(System.Drawing.Pen,System.Drawing.PointF[],System.Single,System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawClosedCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points, float tension, System::Drawing::Drawing2D::FillMode fillmode);" />
      <MemberSignature Language="F#" Value="member this.DrawClosedCurve : System.Drawing.Pen * System.Drawing.PointF[] * single * System.Drawing.Drawing2D.FillMode -&gt; unit" Usage="graphics.DrawClosedCurve (pen, points, tension, fillmode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="tension" Type="System.Single" />
        <Parameter Name="fillmode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, largura e altura da curva.</param>
        <param name="points">Matriz de estruturas <see cref="T:System.Drawing.PointF" /> que definem o spline.</param>
        <param name="tension">Valor maior ou igual a 0.0F que especifica a tensão da curva.</param>
        <param name="fillmode">Membro da enumeração <see cref="T:System.Drawing.Drawing2D.FillMode" /> que determina como a curva é preenchida. Este parâmetro é necessário, mas é ignorado.</param>
        <summary>Desenha um spline cardinal fechado definido por uma matriz de estruturas <see cref="T:System.Drawing.PointF" /> usando uma tensão especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método desenha um spline cardinal fechado que passa por cada ponto na matriz. Se o último ponto não coincide com o primeiro ponto, um segmento de curva adicionais é adicionado a partir do último ponto até o primeiro ponto para fechá-la.  
  
 A matriz de pontos deve conter pelo menos quatro <xref:System.Drawing.PointF> estruturas.  
  
 O `tension` parâmetro determina a forma de spline. Se o valor da `tension` parâmetro é 0.0F, esse método desenha segmentos de linha reta para conectar os pontos. Normalmente, o `tension` parâmetro é menor ou igual a 1.0F. Valores ao longo do 1.0F produzem resultados incomuns.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria canetas vermelhas e verdes.  
  
-   Cria a sete pontos para definir a curva.  
  
-   Desenha a sete linhas retas vermelhas entre os sete pontos para formar um polígono.  
  
-   Cria as configurações do modo de tensão e preenchimento.  
  
-   Desenha uma curva fechada verde por meio de sete pontos.  
  
 O método usa uma tensão de 1,0 e define o modo de preenchimento como `FillMode.Alternate`.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#19](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#19)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#19](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#19)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#19](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="points" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawCurve">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Desenha um spline cardinal por meio de uma matriz especificada de estruturas <see cref="T:System.Drawing.Point" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.Point[] -&gt; unit" Usage="graphics.DrawCurve (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, largura e altura da curva.</param>
        <param name="points">Matriz de estruturas <see cref="T:System.Drawing.Point" /> que definem o spline.</param>
        <summary>Desenha um spline cardinal por meio de uma matriz especificada de estruturas <see cref="T:System.Drawing.Point" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método desenha um spline cardinal que passa por cada ponto na matriz.  
  
 A matriz de pontos deve conter pelo menos três <xref:System.Drawing.Point> estruturas para uma curva a ser desenhado.  
  
 Esse método usa uma tensão de padrão de 0,5.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria canetas vermelhas e verdes.  
  
-   Cria a sete pontos para definir uma curva.  
  
-   Desenha seis linhas retas vermelhas entre os sete pontos para formar um polígono incompleto.  
  
-   Desenha uma curva verde aberta por meio de sete pontos.  
  
 O método usa uma tensão de padrão de 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#20](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#20)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#20](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#20)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#20](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="points" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.PointF[] -&gt; unit" Usage="graphics.DrawCurve (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo da curva.</param>
        <param name="points">Matriz de estruturas <see cref="T:System.Drawing.PointF" /> que definem o spline.</param>
        <summary>Desenha um spline cardinal por meio de uma matriz especificada de estruturas <see cref="T:System.Drawing.PointF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método desenha um spline cardinal que passa por cada ponto na matriz.  
  
 A matriz de pontos deve conter pelo menos três <xref:System.Drawing.PointF> estruturas para uma curva a ser desenhado.  
  
 Esse método usa uma tensão de padrão de 0,5.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria canetas vermelhas e verdes.  
  
-   Cria a sete pontos para definir uma curva.  
  
-   Desenha seis linhas retas vermelhas entre os sete pontos para formar um polígono incompleto.  
  
-   Desenha uma curva verde aberta por meio de sete pontos.  
  
 O método usa uma tensão de padrão de 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#23](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#23)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#23](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#23)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#23](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="points" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.Point[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.Point[],System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points, float tension);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.Point[] * single -&gt; unit" Usage="graphics.DrawCurve (pen, points, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo da curva.</param>
        <param name="points">Matriz de estruturas <see cref="T:System.Drawing.Point" /> que definem a spline.</param>
        <param name="tension">Valor maior ou igual a 0.0F que especifica a tensão da curva.</param>
        <summary>Desenha uma spline cardinal por meio de uma matriz especificada de estruturas <see cref="T:System.Drawing.Point" /> usando uma tensão especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método desenha um spline cardinal que passa por cada ponto na matriz.  
  
 A matriz de pontos deve conter pelo menos três <xref:System.Drawing.Point> estruturas para uma curva a ser desenhado.  
  
 O `tension` parâmetro determina a forma de spline. Se o valor da `tension` parâmetro é 0.0F, esse método desenha segmentos de linha reta para conectar os pontos. Normalmente, o `tension` parâmetro é menor ou igual a 1.0F. Valores ao longo do 1.0F produzem resultados incomuns.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria canetas vermelhas e verdes.  
  
-   Cria a sete pontos para definir a curva.  
  
-   Desenha seis linhas retas vermelhas entre os sete pontos para formar um polígono incompleto.  
  
-   Cria uma configuração de tensão.  
  
-   Desenha uma curva fechada em verde aberta por meio de sete pontos.  
  
 O método usa uma tensão de 1.0.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#22](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#22)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#22](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#22)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#22](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="points" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.PointF[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.PointF[],System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points, float tension);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.PointF[] * single -&gt; unit" Usage="graphics.DrawCurve (pen, points, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo da curva.</param>
        <param name="points">Matriz de estruturas <see cref="T:System.Drawing.PointF" /> que representam os pontos que definem a curva.</param>
        <param name="tension">Valor maior ou igual a 0.0F que especifica a tensão da curva.</param>
        <summary>Desenha uma spline cardinal por meio de uma matriz especificada de estruturas <see cref="T:System.Drawing.PointF" /> usando uma tensão especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método desenha um spline cardinal que passa por cada ponto na matriz.  
  
 A matriz de pontos deve conter pelo menos três <xref:System.Drawing.PointF> estruturas para uma curva a ser desenhado.  
  
 O `tension` parâmetro determina a forma de spline. Se o valor da `tension` parâmetro é 0.0F, esse método desenha segmentos de linha reta para conectar os pontos. Normalmente, o `tension` parâmetro é menor ou igual a 1.0F. Valores ao longo do 1.0F produzem resultados incomuns.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria canetas vermelhas e verdes.  
  
-   Cria a sete pontos para definir a curva.  
  
-   Desenha seis linhas retas vermelhas entre os sete pontos para formar um polígono incompleto.  
  
-   Cria uma configuração de tensão.  
  
-   Desenha uma curva fechada em verde aberta por meio de sete pontos.  
  
 O método usa uma tensão de 1.0.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#26](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#26)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#26](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#26)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#26](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="points" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.PointF[] points, int offset, int numberOfSegments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points, int32 offset, int32 numberOfSegments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.PointF[],System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points, int offset, int numberOfSegments);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.PointF[] * int * int -&gt; unit" Usage="graphics.DrawCurve (pen, points, offset, numberOfSegments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numberOfSegments" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo da curva.</param>
        <param name="points">Matriz de estruturas <see cref="T:System.Drawing.PointF" /> que definem o spline.</param>
        <param name="offset">Deslocado do primeiro elemento na matriz do parâmetro <paramref name="points" /> para o ponto inicial na curva.</param>
        <param name="numberOfSegments">Número de segmentos após o ponto inicial a serem incluídos na curva.</param>
        <summary>Desenha um spline cardinal por meio de uma matriz especificada de estruturas <see cref="T:System.Drawing.PointF" />. O desenho começa deslocado em relação ao início da matriz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método desenha um spline cardinal que passa por cada ponto na matriz.  
  
 A matriz de pontos deve conter pelo menos três <xref:System.Drawing.PointF> estruturas para uma curva a ser desenhado.  
  
 O valor da `offset` parâmetro especifica o número de elementos a serem ignorados na matriz. O primeiro elemento após os elementos ignorados representa o ponto de partida da curva.  
  
 O valor da `numberOfSegments` parâmetro especifica o número de segmentos, após o ponto de partida, para desenhar na curva. O valor da `numberOfSegments` parâmetro deve ser pelo menos 1. O valor da `offset` parâmetro mais o valor da `numberOfSegments` parâmetro deve ser menor que o número de elementos na matriz do `points` parâmetro.  
  
 Esse método usa uma tensão de padrão de 0,5.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria canetas vermelhas e verdes.  
  
-   Cria a sete pontos para definir uma curva.  
  
-   Desenha seis linhas retas vermelhas entre os sete pontos para formar um polígono incompleto.  
  
-   Define o deslocamento do ponto de partida e o número de segmentos.  
  
-   Desenha uma aberto verde curva (começando no terceiro ponto) pelos últimos cinco pontos.  
  
 O método usa uma tensão de padrão de 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#24](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#24)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#24](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#24)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#24](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="points" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.Point[] points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points, int32 offset, int32 numberOfSegments, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.Point[],System.Int32,System.Int32,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.Point[] * int * int * single -&gt; unit" Usage="graphics.DrawCurve (pen, points, offset, numberOfSegments, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numberOfSegments" Type="System.Int32" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo da curva.</param>
        <param name="points">Matriz de estruturas <see cref="T:System.Drawing.Point" /> que definem o spline.</param>
        <param name="offset">Deslocado do primeiro elemento na matriz do parâmetro <paramref name="points" /> para o ponto inicial na curva.</param>
        <param name="numberOfSegments">Número de segmentos após o ponto inicial a serem incluídos na curva.</param>
        <param name="tension">Valor maior ou igual a 0.0F que especifica a tensão da curva.</param>
        <summary>Desenha uma spline cardinal por meio de uma matriz especificada de estruturas <see cref="T:System.Drawing.Point" /> usando uma tensão especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método desenha um spline cardinal que passa por cada ponto na matriz.  
  
 A matriz de pontos deve conter pelo menos três <xref:System.Drawing.Point> estruturas para uma curva a ser desenhado.  
  
 O valor da `offset` parâmetro especifica o número de elementos a serem ignorados na matriz. O primeiro elemento após os elementos ignorados representa o ponto de partida da curva.  
  
 O valor da `numberOfSegments` parâmetro especifica o número de segmentos, após o ponto de partida, para desenhar na curva. O valor da `numberOfSegments` parâmetro deve ser pelo menos 1. O valor da `offset` parâmetro mais o valor da `numberOfSegments` parâmetro deve ser menor que o número de elementos na matriz do `points` parâmetro.  
  
 O `tension` parâmetro determina a forma de spline. Se o valor da `tension` parâmetro é 0.0F, esse método desenha segmentos de linha reta para conectar os pontos. Normalmente, o `tension` parâmetro é menor ou igual a 1.0F. Valores ao longo do 1.0F produzem resultados incomuns.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria canetas vermelhas e verdes.  
  
-   Cria a sete pontos para definir uma curva.  
  
-   Desenha seis linhas retas vermelhas entre os sete pontos para formar um polígono incompleto.  
  
-   Define o deslocamento do ponto de partida e o número de segmentos.  
  
-   Define a tensão.  
  
-   Desenha uma aberto verde curva (começando no terceiro ponto) pelos últimos cinco pontos.  
  
 O método define a tensão 1.0.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#21](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#21)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#21](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#21)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#21](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="points" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.PointF[] points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points, int32 offset, int32 numberOfSegments, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.PointF[],System.Int32,System.Int32,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.PointF[] * int * int * single -&gt; unit" Usage="graphics.DrawCurve (pen, points, offset, numberOfSegments, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numberOfSegments" Type="System.Int32" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo da curva.</param>
        <param name="points">Matriz de estruturas <see cref="T:System.Drawing.PointF" /> que definem o spline.</param>
        <param name="offset">Deslocado do primeiro elemento na matriz do parâmetro <paramref name="points" /> para o ponto inicial na curva.</param>
        <param name="numberOfSegments">Número de segmentos após o ponto inicial a serem incluídos na curva.</param>
        <param name="tension">Valor maior ou igual a 0.0F que especifica a tensão da curva.</param>
        <summary>Desenha uma spline cardinal por meio de uma matriz especificada de estruturas <see cref="T:System.Drawing.PointF" /> usando uma tensão especificada. O desenho começa deslocado em relação ao início da matriz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método desenha um spline cardinal que passa por cada ponto na matriz.  
  
 A matriz de pontos deve conter pelo menos três <xref:System.Drawing.PointF> estruturas para a curva a ser desenhado.  
  
 O valor da `offset` parâmetro especifica o número de elementos a serem ignorados na matriz. O primeiro elemento após os elementos ignorados representa o ponto de partida da curva.  
  
 O valor da `numberOfSegments` parâmetro especifica o número de segmentos, após o ponto de partida, para desenhar na curva. O valor da `numberOfSegments` parâmetro deve ser pelo menos 1. O valor da `offset` parâmetro mais o valor da `numberOfSegments` parâmetro deve ser menor que o número de elementos na matriz do `points` parâmetro.  
  
 O `tension` parâmetro determina a forma de spline. Se o valor da `tension` parâmetro é 0.0F, esse método desenha segmentos de linha reta para conectar os pontos. Normalmente, o `tension` parâmetro é menor ou igual a 1.0F. Valores ao longo do 1.0F produzem resultados incomuns.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria canetas vermelhas e verdes.  
  
-   Cria a sete pontos para definir uma curva.  
  
-   Desenha seis linhas retas vermelhas entre os sete pontos para formar um polígono incompleto.  
  
-   Define o deslocamento do ponto de partida e o número de segmentos.  
  
-   Define a tensão.  
  
-   Desenha uma aberto verde curva (começando no terceiro ponto) pelos últimos cinco pontos.  
  
 O método define a tensão 1.0.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#25](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#25)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#25](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#25)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#25](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="points" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawEllipse">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Desenha uma elipse definida por um retângulo delimitador especificado por um par de coordenadas, uma altura e uma largura.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public void DrawEllipse (System.Drawing.Pen pen, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawEllipse(class System.Drawing.Pen pen, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawEllipse(System.Drawing.Pen,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawEllipse(System::Drawing::Pen ^ pen, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.DrawEllipse : System.Drawing.Pen * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawEllipse (pen, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo da elipse.</param>
        <param name="rect">Estrutura <see cref="T:System.Drawing.Rectangle" /> que define os limites da elipse.</param>
        <summary>Desenha uma elipse especificada por uma estrutura <see cref="T:System.Drawing.Rectangle" /> delimitadora.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método desenha uma elipse definida pelo retângulo delimitador especificado pelo `rect` parâmetro.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma caneta preta.  
  
-   Cria um retângulo de limite de uma elipse.  
  
-   Desenha a elipse na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#27](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#27)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#27](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#27)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#27](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public void DrawEllipse (System.Drawing.Pen pen, System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawEllipse(class System.Drawing.Pen pen, valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawEllipse(System.Drawing.Pen,System.Drawing.RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawEllipse(System::Drawing::Pen ^ pen, System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.DrawEllipse : System.Drawing.Pen * System.Drawing.RectangleF -&gt; unit" Usage="graphics.DrawEllipse (pen, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo da elipse.</param>
        <param name="rect">Estrutura <see cref="T:System.Drawing.RectangleF" /> que define os limites da elipse.</param>
        <summary>Desenha uma elipse definida por um <see cref="T:System.Drawing.RectangleF" /> delimitador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método desenha uma elipse definida pelo retângulo delimitador especificado pelo `rect` parâmetro.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma caneta preta.  
  
-   Cria um retângulo de limite de uma elipse.  
  
-   Desenha a elipse na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#28](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#28)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#28](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#28)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#28](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public void DrawEllipse (System.Drawing.Pen pen, int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawEllipse(class System.Drawing.Pen pen, int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawEllipse(System.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawEllipse(System::Drawing::Pen ^ pen, int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.DrawEllipse : System.Drawing.Pen * int * int * int * int -&gt; unit" Usage="graphics.DrawEllipse (pen, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo da elipse.</param>
        <param name="x">A coordenada X do canto superior esquerdo do retângulo delimitador que define a elipse.</param>
        <param name="y">A coordenada y do canto superior esquerdo do retângulo delimitador que define a elipse.</param>
        <param name="width">Largura do retângulo delimitador que define a elipse.</param>
        <param name="height">Altura do retângulo delimitador que define a elipse.</param>
        <summary>Desenha uma elipse definida por um retângulo delimitador especificado pelas coordenadas do canto superior esquerdo do retângulo, uma altura e uma largura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método desenha uma elipse que é definida pelo retângulo delimitador descrito pelo `x`, `y`, `width`, e `height` parâmetros.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma caneta preta.  
  
-   Cria a posição e tamanho de um retângulo a ser associado a uma elipse.  
  
-   Desenha a elipse na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#29](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#29)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#29](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#29)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#29](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public void DrawEllipse (System.Drawing.Pen pen, float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawEllipse(class System.Drawing.Pen pen, float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawEllipse(System.Drawing.Pen,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawEllipse(System::Drawing::Pen ^ pen, float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.DrawEllipse : System.Drawing.Pen * single * single * single * single -&gt; unit" Usage="graphics.DrawEllipse (pen, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo da elipse.</param>
        <param name="x">A coordenada X do canto superior esquerdo do retângulo delimitador que define a elipse.</param>
        <param name="y">A coordenada y do canto superior esquerdo do retângulo delimitador que define a elipse.</param>
        <param name="width">Largura do retângulo delimitador que define a elipse.</param>
        <param name="height">Altura do retângulo delimitador que define a elipse.</param>
        <summary>Desenha uma elipse definida por um retângulo delimitador especificado por um par de coordenadas, uma altura e uma largura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método desenha uma elipse que é definida pelo retângulo delimitador descrito pelo `x`, `y`, `width`, e `height` parâmetros.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma caneta preta.  
  
-   Cria a posição e tamanho de um retângulo a ser associado a uma elipse.  
  
-   Desenha a elipse na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#30](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#30)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#30](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#30)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#30](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawIcon">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Desenha a imagem representada pelo <see cref="T:System.Drawing.Icon" /> especificado nas coordenadas especificadas.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawIcon">
      <MemberSignature Language="C#" Value="public void DrawIcon (System.Drawing.Icon icon, System.Drawing.Rectangle targetRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawIcon(class System.Drawing.Icon icon, valuetype System.Drawing.Rectangle targetRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawIcon(System.Drawing.Icon,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawIcon(System::Drawing::Icon ^ icon, System::Drawing::Rectangle targetRect);" />
      <MemberSignature Language="F#" Value="member this.DrawIcon : System.Drawing.Icon * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawIcon (icon, targetRect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="icon" Type="System.Drawing.Icon" />
        <Parameter Name="targetRect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="icon"><see cref="T:System.Drawing.Icon" /> a ser desenhado.</param>
        <param name="targetRect">Estrutura de <see cref="T:System.Drawing.Rectangle" /> que especifica o local e o tamanho da imagem resultante na superfície de exibição. A imagem contida no parâmetro <paramref name="icon" /> é dimensionada para as dimensões desta área retangular.</param>
        <summary>Desenha a imagem representada pelo <see cref="T:System.Drawing.Icon" /> especificado, dentro da área especificada por uma estrutura de <see cref="T:System.Drawing.Rectangle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um ícone de um arquivo de ícone padrão do Windows SampIcon.ico na pasta example.  
  
-   Cria um retângulo no qual desenhar o ícone.  
  
-   Desenha o ícone para a tela.  
  
 A posição do retângulo localiza o ícone na tela, e o tamanho do retângulo determina o dimensionamento do ícone desenhado.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#31](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#31)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#31](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#31)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#31](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="icon" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawIcon">
      <MemberSignature Language="C#" Value="public void DrawIcon (System.Drawing.Icon icon, int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawIcon(class System.Drawing.Icon icon, int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawIcon(System.Drawing.Icon,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawIcon(System::Drawing::Icon ^ icon, int x, int y);" />
      <MemberSignature Language="F#" Value="member this.DrawIcon : System.Drawing.Icon * int * int -&gt; unit" Usage="graphics.DrawIcon (icon, x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="icon" Type="System.Drawing.Icon" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="icon"><see cref="T:System.Drawing.Icon" /> a ser desenhado.</param>
        <param name="x">A coordenada X do canto superior esquerdo da imagem desenhada.</param>
        <param name="y">A coordenada y do canto superior esquerdo da imagem desenhada.</param>
        <summary>Desenha a imagem representada pelo <see cref="T:System.Drawing.Icon" /> especificado nas coordenadas especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um ícone de um arquivo de ícone padrão do Windows SampIcon.ico na pasta example.  
  
-   Cria as coordenadas do canto superior esquerdo, na qual desenhar o ícone.  
  
-   Desenha o ícone para a tela.  
  
 O ícone desenhado está fora de escala.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#32](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#32)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#32](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#32)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#32](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="icon" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawIconUnstretched">
      <MemberSignature Language="C#" Value="public void DrawIconUnstretched (System.Drawing.Icon icon, System.Drawing.Rectangle targetRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawIconUnstretched(class System.Drawing.Icon icon, valuetype System.Drawing.Rectangle targetRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawIconUnstretched(System.Drawing.Icon,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawIconUnstretched(System::Drawing::Icon ^ icon, System::Drawing::Rectangle targetRect);" />
      <MemberSignature Language="F#" Value="member this.DrawIconUnstretched : System.Drawing.Icon * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawIconUnstretched (icon, targetRect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="icon" Type="System.Drawing.Icon" />
        <Parameter Name="targetRect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="icon"><see cref="T:System.Drawing.Icon" /> a ser desenhado.</param>
        <param name="targetRect">A estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica o local e o tamanho da imagem resultante. A imagem não é dimensionada para se ajustar a esse retângulo, mas mantém seu tamanho original. Se a imagem for maior do que o retângulo, ela será recortada para caber dentro dele.</param>
        <summary>Desenha a imagem representada pelo <see cref="T:System.Drawing.Icon" /> sem dimensionar a imagem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um ícone de um arquivo de ícone padrão do Windows SampIcon.ico na pasta example.  
  
-   Cria um retângulo no qual desenhar o ícone.  
  
-   Desenha o ícone para a tela.  
  
 A posição do retângulo localiza o ícone na tela, e o ícone desenhado está fora de escala e específico sem corte.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#33](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#33)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#33](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#33)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#33](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="icon" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawImage">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Desenha o <see cref="T:System.Drawing.Image" /> especificado no local especificado e com o tamanho original.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Point point);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Point -&gt; unit" Usage="graphics.DrawImage (image, point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="point"><see cref="T:System.Drawing.Point" /> estrutura que representa o local do canto superior esquerdo da imagem desenhada.</param>
        <summary>Desenha o <see cref="T:System.Drawing.Image" /> especificado, usando seu tamanho físico original, no local especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Drawing.Image> armazena um valor para a largura em pixels e um valor para a resolução horizontal (pontos por polegada). A largura física, em polegadas, de uma imagem é a largura de pixel dividida pela resolução horizontal. Por exemplo, uma imagem com uma largura de 216 pixels e uma resolução horizontal de 72 pontos por polegada tem uma largura física de 3 polegadas. Comentários semelhantes se aplicam à altura em pixels e altura física.  
  
 Esse método desenha uma imagem usando seu tamanho físico, portanto, a imagem terá seu tamanho correto em polegadas, independentemente da resolução (pontos por polegada) do dispositivo de vídeo. Por exemplo, suponha que uma imagem tem uma largura de 216 pixels e uma resolução horizontal de 72 pontos por polegada. Se você chamar esse método para desenhar a imagem em um dispositivo que tem uma resolução de 96 pontos por polegada, a largura de pixel da imagem renderizada será (216/72) * 96 = 288.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma imagem de um arquivo JPEG SampImag.jpg na pasta do exemplo.  
  
-   Cria um ponto no qual desenhar o canto superior esquerdo da imagem.  
  
-   Desenha a imagem sem escala para a tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#34](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#34)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#34](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#34)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#34](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Point[] destPoints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Point[] destPoints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::Point&gt; ^ destPoints);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Point[] -&gt; unit" Usage="graphics.DrawImage (image, destPoints)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="destPoints">Matriz de três estruturas <see cref="T:System.Drawing.Point" /> que definem um paralelogramo.</param>
        <summary>Desenha o <see cref="T:System.Drawing.Image" /> especificado no local especificado e com o tamanho e forma especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `destPoints` parâmetro especifica três pontos de um paralelogramo. Os três <xref:System.Drawing.Point> estruturas representarem os cantos superior esquerdo, superior direito e inferior esquerdo do paralelogramo. O quarto ponto é inferido das três primeiras para formar um paralelogramo.  
  
 A imagem representada pelo `image` parâmetro é dimensionado e distorcido para ajustar a forma do paralelogramo especificado pelo `destPoints` parâmetros.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma imagem de um arquivo JPEG SampImag.jpg na pasta do exemplo.  
  
-   Cria pontos que definem um paralelogramo no qual desenhar a imagem.  
  
-   Desenha a imagem na tela.  
  
 A posição do paralelogramo localiza a imagem na tela, e o tamanho da imagem original e o tamanho e a forma do paralelogramo determinam o dimensionamento e distorção da imagem desenhada.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#35](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#35)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#35](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#35)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#35](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.PointF point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.PointF point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::PointF point);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.PointF -&gt; unit" Usage="graphics.DrawImage (image, point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="point" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="point">Uma estrutura <see cref="T:System.Drawing.PointF" /> que representa o canto superior esquerdo da imagem desenhada.</param>
        <summary>Desenha o <see cref="T:System.Drawing.Image" /> especificado, usando seu tamanho físico original, no local especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Drawing.Image> armazena um valor para a largura em pixels e um valor para a resolução horizontal (pontos por polegada). A largura física, em polegadas, de uma imagem é a largura de pixel dividida pela resolução horizontal. Por exemplo, uma imagem com uma largura de 216 pixels e uma resolução horizontal de 72 pontos por polegada tem uma largura física de 3 polegadas. Comentários semelhantes se aplicam à altura em pixels e altura física.  
  
 Esse método desenha uma imagem usando seu tamanho físico, portanto, a imagem terá seu tamanho correto em polegadas, independentemente da resolução (pontos por polegada) do dispositivo de vídeo. Por exemplo, suponha que uma imagem tem uma largura de 216 pixels e uma resolução horizontal de 72 pontos por polegada. Se você chamar esse método para desenhar a imagem em um dispositivo que tem uma resolução de 96 pontos por polegada, a largura de pixel da imagem renderizada será (216/72) * 96 = 288.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma imagem de um arquivo JPEG SampImag.jpg na pasta do exemplo.  
  
-   Cria um ponto no qual desenhar o canto superior esquerdo da imagem.  
  
-   Desenha a imagem sem escala para a tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#40](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#40)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#40](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#40)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#40](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.PointF[] destPoints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.PointF[] destPoints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.PointF[] -&gt; unit" Usage="graphics.DrawImage (image, destPoints)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="destPoints">Matriz de três estruturas <see cref="T:System.Drawing.PointF" /> que definem um paralelogramo.</param>
        <summary>Desenha o <see cref="T:System.Drawing.Image" /> especificado no local especificado e com o tamanho e forma especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `destPoints` parâmetro especifica três pontos de um paralelogramo. Os três <xref:System.Drawing.PointF> estruturas representarem os cantos superior esquerdo, superior direito e inferior esquerdo do paralelogramo. O quarto ponto é inferido das três primeiras para formar um paralelogramo.  
  
 A imagem representada pelo `image` objeto é dimensionado e distorcido para ajustar a forma do paralelogramo especificado pelo `destPoints` parâmetro.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma imagem de um arquivo JPEG SampImag.jpg na pasta do exemplo.  
  
-   Cria pontos que definem um paralelogramo no qual desenhar a imagem.  
  
-   Desenha a imagem na tela.  
  
 A posição do paralelogramo localiza a imagem na tela, e o tamanho da imagem original e o tamanho e a forma do paralelogramo determinam o dimensionamento e distorção da imagem desenhada.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#41](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#41)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#41](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#41)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#41](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawImage (image, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="rect">A estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica o local e o tamanho da imagem desenhada.</param>
        <summary>Desenha o <see cref="T:System.Drawing.Image" /> especificado no local especificado e com o tamanho especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A imagem representada pelo `image` objeto é dimensionado para as dimensões de `rect` retângulo.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma imagem de um arquivo JPEG SampImag.jpg na pasta do exemplo.  
  
-   Cria um retângulo no qual desenhar a imagem.  
  
-   Desenha a imagem na tela.  
  
 A posição do retângulo localiza a imagem na tela e o tamanho da imagem original e o tamanho do retângulo determinam a escala da imagem desenhada.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#46](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#46)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#46](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#46)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#46](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#46)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.RectangleF -&gt; unit" Usage="graphics.DrawImage (image, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="rect">A estrutura <see cref="T:System.Drawing.RectangleF" /> que especifica o local e o tamanho da imagem desenhada.</param>
        <summary>Desenha o <see cref="T:System.Drawing.Image" /> especificado no local especificado e com o tamanho especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A imagem representada pelo `image` objeto é dimensionado para as dimensões de `rect` retângulo.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma imagem de um arquivo JPEG SampImag.jpg na pasta do exemplo.  
  
-   Cria um retângulo no qual desenhar a imagem.  
  
-   Desenha a imagem na tela.  
  
 A posição do retângulo localiza a imagem na tela e o tamanho original da imagem e o tamanho do retângulo determinam a escala da imagem desenhada.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#56](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#56)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#56](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#56)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#56](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#56)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, int x, int y);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * int * int -&gt; unit" Usage="graphics.DrawImage (image, x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="x">A coordenada X do canto superior esquerdo da imagem desenhada.</param>
        <param name="y">A coordenada y do canto superior esquerdo da imagem desenhada.</param>
        <summary>Desenha a imagem especificada usando seu tamanho físico original na localização especificada por um par de coordenadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Drawing.Image> armazena um valor para a largura em pixels e um valor para a resolução horizontal (pontos por polegada). A largura física, em polegadas, de uma imagem é a largura de pixel dividida pela resolução horizontal. Por exemplo, uma imagem com uma largura de 216 pixels e uma resolução horizontal de 72 pontos por polegada tem uma largura física de 3 polegadas. Comentários semelhantes se aplicam à altura em pixels e altura física.  
  
 O <xref:System.Drawing.Graphics.DrawImage%2A> método desenha uma imagem usando seu tamanho físico, portanto, a imagem terá seu tamanho correto em polegadas, independentemente da resolução (pontos por polegada) do dispositivo de vídeo. Por exemplo, suponha que uma imagem tem uma largura de 216 pixels e uma resolução horizontal de 72 pontos por polegada. Se você chamar <xref:System.Drawing.Graphics.DrawImage%2A> para desenhar a imagem em um dispositivo que tem uma resolução de 96 pontos por polegada, a largura de pixel da imagem renderizada será (216/72) * 96 = 288.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma imagem de um arquivo JPEG SampImag.jpg na pasta do exemplo SampImag.jpg na pasta do exemplo.  
  
-   Cria as coordenadas de um ponto no qual desenhar o canto superior esquerdo da imagem.  
  
-   Desenha a imagem sem escala.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#58](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#58)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#58](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#58)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#58](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, float x, float y);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * single * single -&gt; unit" Usage="graphics.DrawImage (image, x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="x">A coordenada X do canto superior esquerdo da imagem desenhada.</param>
        <param name="y">A coordenada y do canto superior esquerdo da imagem desenhada.</param>
        <summary>Desenha o <see cref="T:System.Drawing.Image" /> especificado, usando seu tamanho físico original, no local especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Drawing.Image> armazena um valor para a largura em pixels e um valor para a resolução horizontal (pontos por polegada). A largura física, em polegadas, de uma imagem é a largura de pixel dividida pela resolução horizontal. Por exemplo, uma imagem com uma largura de 216 pixels e uma resolução horizontal de 72 pontos por polegada tem uma largura física de 3 polegadas. Comentários semelhantes se aplicam à altura em pixels e altura física.  
  
 Esse método desenha uma imagem usando seu tamanho físico, portanto, a imagem terá seu tamanho correto em polegadas, independentemente da resolução (pontos por polegada) do dispositivo de vídeo. Por exemplo, suponha que uma imagem tem uma largura de 216 pixels e uma resolução horizontal de 72 pontos por polegada. Se você chamar esse método para desenhar a imagem em um dispositivo que tem uma resolução de 96 pontos por polegada, a largura de pixel da imagem renderizada será (216/72) * 96 = 288.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma imagem de um arquivo JPEG SampImag.jpg na pasta do exemplo.  
  
-   Cria as coordenadas de um ponto no qual desenhar o canto superior esquerdo da imagem.  
  
-   Desenha a imagem sem escala para a tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#61](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#61)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#61](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#61)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#61](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#61)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="destPoints">Matriz de três estruturas <see cref="T:System.Drawing.Point" /> que definem um paralelogramo.</param>
        <param name="srcRect">A estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica a parte do objeto <paramref name="image" /> a ser desenhada.</param>
        <param name="srcUnit">Membro da enumeração de <see cref="T:System.Drawing.GraphicsUnit" /> que especifica as unidades de medida usadas pelo parâmetro <paramref name="srcRect" />.</param>
        <summary>Desenha a parte especificada do <see cref="T:System.Drawing.Image" /> especificado no local especificado e com o tamanho especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `destPoints` parâmetro especifica três pontos de um paralelogramo. Os três <xref:System.Drawing.Point> estruturas representarem os cantos superior esquerdo, superior direito e inferior esquerdo do paralelogramo. O quarto ponto é inferido das três primeiras para formar um paralelogramo.  
  
 O `srcRect` parâmetro especifica uma parte retangular do `image` objeto a ser desenhado. Esta parte é dimensionada e distorcida para ajustá-la no paralelogramo especificado pelo `destPoints` parâmetro.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma imagem de um arquivo JPEG SampImag.jpg na pasta do exemplo.  
  
-   Cria pontos que definem um paralelogramo no qual desenhar a imagem.  
  
-   Cria um retângulo para selecionar a parte da imagem a ser desenhado.  
  
-   Define os unidade de desenho ao pixel de gráficos.  
  
-   Desenha a imagem na tela.  
  
 A posição do paralelogramo localiza a imagem na tela, e o tamanho do retângulo e o tamanho e a forma do paralelogramo determinam o dimensionamento e distorção da imagem desenhada.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#36](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#36)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#36](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#36)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#36](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#36)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="destPoints">Matriz de três estruturas <see cref="T:System.Drawing.PointF" /> que definem um paralelogramo.</param>
        <param name="srcRect">A estrutura <see cref="T:System.Drawing.RectangleF" /> que especifica a parte do objeto <paramref name="image" /> a ser desenhada.</param>
        <param name="srcUnit">Membro da enumeração de <see cref="T:System.Drawing.GraphicsUnit" /> que especifica as unidades de medida usadas pelo parâmetro <paramref name="srcRect" />.</param>
        <summary>Desenha a parte especificada do <see cref="T:System.Drawing.Image" /> especificado no local especificado e com o tamanho especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `destPoints` parâmetro especifica três pontos de um paralelogramo. Os três <xref:System.Drawing.PointF> estruturas representarem os cantos superior esquerdo, superior direito e inferior esquerdo do paralelogramo. O quarto ponto é inferido das três primeiras para formar um paralelogramo.  
  
 O `srcRect` parâmetro especifica uma parte retangular do `image` objeto a ser desenhado. Esta parte é dimensionada e distorcida para ajustá-la no paralelogramo especificado pelo `destPoints` parâmetro.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma imagem de um arquivo JPEG SampImag.jpg na pasta do exemplo.  
  
-   Cria pontos que definem um paralelogramo de destino no qual desenhar a imagem.  
  
-   Cria um retângulo de origem do qual extrair uma parte da imagem.  
  
-   Define a unidade de medida do retângulo de origem como pixels.  
  
-   Desenha a imagem na tela.  
  
 A posição do paralelogramo destino localiza a imagem na tela, o tamanho do retângulo de origem e o tamanho e forma do paralelogramo destino determinam o dimensionamento e distorção da imagem desenhada e determina o tamanho do retângulo qual parte da imagem original é desenhada na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#42](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#42)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#42](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#42)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#42](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Drawing.Rectangle,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * System.Drawing.Rectangle * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcRect, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="destRect">A estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica o local e o tamanho da imagem desenhada. A imagem é dimensionada para se ajustar ao retângulo.</param>
        <param name="srcRect">A estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica a parte do objeto <paramref name="image" /> a ser desenhada.</param>
        <param name="srcUnit">Membro da enumeração de <see cref="T:System.Drawing.GraphicsUnit" /> que especifica as unidades de medida usadas pelo parâmetro <paramref name="srcRect" />.</param>
        <summary>Desenha a parte especificada do <see cref="T:System.Drawing.Image" /> especificado no local especificado e com o tamanho especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `srcRect` parâmetro especifica uma parte retangular do `image` objeto a ser desenhado. Esta parte é dimensionada para se ajustar dentro do retângulo especificado pelo `destRect` parâmetro.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma imagem de um arquivo JPEG SampImag.jpg na pasta do exemplo.  
  
-   Cria um retângulo de destino no qual desenhar a imagem.  
  
-   Cria um retângulo de origem do qual extrair uma parte da imagem.  
  
-   Define a unidade de medida do retângulo de origem como pixels.  
  
-   Desenha a imagem na tela.  
  
 A posição do retângulo de destino localiza a imagem na tela, os tamanhos dos retângulos de origem e destino determinam o dimensionamento da imagem desenhada e o tamanho do retângulo de origem determina qual parte da imagem original é desenhada para o tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#47](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#47)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#47](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#47)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#47](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#47)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.RectangleF destRect, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.RectangleF destRect, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.RectangleF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::RectangleF destRect, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.RectangleF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcRect, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="destRect">A estrutura <see cref="T:System.Drawing.RectangleF" /> que especifica o local e o tamanho da imagem desenhada. A imagem é dimensionada para se ajustar ao retângulo.</param>
        <param name="srcRect">A estrutura <see cref="T:System.Drawing.RectangleF" /> que especifica a parte do objeto <paramref name="image" /> a ser desenhada.</param>
        <param name="srcUnit">Membro da enumeração de <see cref="T:System.Drawing.GraphicsUnit" /> que especifica as unidades de medida usadas pelo parâmetro <paramref name="srcRect" />.</param>
        <summary>Desenha a parte especificada do <see cref="T:System.Drawing.Image" /> especificado no local especificado e com o tamanho especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `srcRect` parâmetro especifica uma parte retangular do `image` objeto a ser desenhado. Esta parte é dimensionada para se ajustar dentro do retângulo especificado pelo `destRect` parâmetro.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma imagem de um arquivo JPEG SampImag.jpg na pasta do exemplo.  
  
-   Cria um retângulo de destino no qual desenhar a imagem.  
  
-   Cria um retângulo de origem do qual extrair uma parte da imagem.  
  
-   Define a unidade de medida do retângulo de origem como pixels.  
  
-   Desenha a imagem na tela.  
  
 A posição do retângulo de destino localiza a imagem na tela, os tamanhos dos retângulos de origem e destino determinam o dimensionamento da imagem desenhada e o tamanho do retângulo de origem determina qual parte da imagem original é desenhada para o tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#57](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#57)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#57](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#57)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#57](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#57)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="destPoints">Matriz de três estruturas <see cref="T:System.Drawing.Point" /> que definem um paralelogramo.</param>
        <param name="srcRect">A estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica a parte do objeto <paramref name="image" /> a ser desenhada.</param>
        <param name="srcUnit">Membro da enumeração de <see cref="T:System.Drawing.GraphicsUnit" /> que especifica as unidades de medida usadas pelo parâmetro <paramref name="srcRect" />.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica informações de gama e nova coloração para o objeto <paramref name="image" />.</param>
        <summary>Desenha a parte especificada do <see cref="T:System.Drawing.Image" /> especificado no local especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `destPoints` parâmetro especifica três pontos de um paralelogramo. Os três <xref:System.Drawing.Point> estruturas representarem os cantos superior esquerdo, superior direito e inferior esquerdo do paralelogramo. O quarto ponto é inferido das três primeiras para formar um paralelogramo.  
  
 O `srcRect` parâmetro especifica uma parte retangular do`image` objeto a ser desenhado. Esta parte é dimensionada e distorcida para ajustá-la no paralelogramo especificado pelo `destPoints` parâmetro.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma imagem de um arquivo JPEG SampImag.jpg na pasta do exemplo.  
  
-   Cria pontos que definem um paralelogramo no qual desenhar a imagem.  
  
-   Cria um retângulo para selecionar a parte da imagem a ser desenhado.  
  
-   Define os unidade de desenho ao pixel de gráficos.  
  
-   Desenha a imagem original à tela.  
  
-   Cria um paralelogramo adicional nos quais desenhar uma imagem ajustada.  
  
-   Cria e define os atributos da imagem ajustada para ter um valor maior que o usual de gama.  
  
-   Desenha a imagem ajustada à tela.  
  
 Para o paralelogramo original, não ajustado, a posição localiza a imagem na tela e o tamanho do retângulo e o tamanho e a forma do paralelogramo determinam o dimensionamento e distorção da imagem desenhada.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#37](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#37)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#37](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#37)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#37](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#37)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="destPoints">Matriz de três estruturas <see cref="T:System.Drawing.PointF" /> que definem um paralelogramo.</param>
        <param name="srcRect">A estrutura <see cref="T:System.Drawing.RectangleF" /> que especifica a parte do objeto <paramref name="image" /> a ser desenhada.</param>
        <param name="srcUnit">Membro da enumeração de <see cref="T:System.Drawing.GraphicsUnit" /> que especifica as unidades de medida usadas pelo parâmetro <paramref name="srcRect" />.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica informações de gama e nova coloração para o objeto <paramref name="image" />.</param>
        <summary>Desenha a parte especificada do <see cref="T:System.Drawing.Image" /> especificado no local especificado e com o tamanho especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `destPoints` parâmetro especifica três pontos de um paralelogramo. Os três <xref:System.Drawing.PointF> estruturas representarem os cantos superior esquerdo, superior direito e inferior esquerdo do paralelogramo. O quarto ponto é inferido das três primeiras para formar um paralelogramo.  
  
 O `srcRect` parâmetro especifica uma parte retangular do `image` objeto a ser desenhado. Esta parte é dimensionada e distorcida para ajustá-la no paralelogramo especificado pelo `destPoints` parâmetro.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma imagem de um arquivo JPEG SampImag.jpg na pasta do exemplo.  
  
-   Cria pontos que definem um paralelogramo de destino no qual desenhar a imagem.  
  
-   Cria um retângulo de origem do qual extrair uma parte da imagem.  
  
-   Define a unidade de medida do retângulo de origem como pixels.  
  
-   Desenha a imagem original à tela.  
  
-   Cria um paralelogramo adicional nos quais desenhar uma imagem ajustada.  
  
-   Cria e define os atributos da imagem ajustada para ter um valor maior que o usual de gama.  
  
-   Desenha a imagem ajustada à tela.  
  
 Para o paralelogramo de destino original, não ajustado, a posição localiza a imagem em tela, o tamanho do retângulo de origem e o tamanho e forma do paralelogramo destino determina o dimensionamento e distorção da imagem desenhada e o tamanho das retângulo determina qual parte da imagem original é desenhada na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#43](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#43)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#43](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#43)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#43](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#43)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, int x, int y, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, int32 x, int32 y, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Int32,System.Int32,System.Drawing.Rectangle,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, int x, int y, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * int * int * System.Drawing.Rectangle * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, x, y, srcRect, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="x">A coordenada X do canto superior esquerdo da imagem desenhada.</param>
        <param name="y">A coordenada y do canto superior esquerdo da imagem desenhada.</param>
        <param name="srcRect">A estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica a parte do objeto <paramref name="image" /> a ser desenhada.</param>
        <param name="srcUnit">Membro da enumeração de <see cref="T:System.Drawing.GraphicsUnit" /> que especifica as unidades de medida usadas pelo parâmetro <paramref name="srcRect" />.</param>
        <summary>Desenha uma parte de uma imagem em um local especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Drawing.Image> armazena um valor para a largura em pixels e um valor para a resolução horizontal (pontos por polegada). A largura física, em polegadas, de uma imagem é a largura de pixel dividida pela resolução horizontal. Por exemplo, uma imagem com uma largura de pixel de 360 e uma resolução horizontal de 72 pontos por polegada tem uma largura física de 5 polegadas. Comentários semelhantes se aplicam à altura em pixels e altura física.  
  
 Esse método desenha uma parte de uma imagem usando seu tamanho físico, portanto, a parte da imagem terá seu tamanho correto em polegadas, independentemente da resolução (pontos por polegada) do dispositivo de vídeo. Por exemplo, suponha que uma parte da imagem tem uma largura de 216 pixels e uma resolução horizontal de 72 pontos por polegada. Se você chamar este método para desenhar a imagem parte em um dispositivo que tem uma resolução de 96 pontos por polegada, a largura em pixels da parte da imagem renderizada será (216/72) * 96 = 288.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma imagem de um arquivo JPEG SampImag.jpg na pasta do exemplo.  
  
-   Cria as coordenadas na qual desenhar o canto superior esquerdo da imagem.  
  
-   Cria um retângulo de origem do qual extrair uma parte da imagem.  
  
-   Define a unidade de medida do retângulo de origem como pixels.  
  
-   Desenha a imagem na tela.  
  
 O tamanho do retângulo de origem determina qual parte da imagem original fora de escala é desenhada na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#59](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#59)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#59](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#59)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#59](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * int * int * int * int -&gt; unit" Usage="graphics.DrawImage (image, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="x">A coordenada X do canto superior esquerdo da imagem desenhada.</param>
        <param name="y">A coordenada y do canto superior esquerdo da imagem desenhada.</param>
        <param name="width">Largura da imagem desenhada.</param>
        <param name="height">Altura da imagem desenhada.</param>
        <summary>Desenha o <see cref="T:System.Drawing.Image" /> especificado no local especificado e com o tamanho especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O retângulo definido pela `x`, `y`, `width`, e `height` parâmetros determina a posição e tamanho da imagem desenhada.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma imagem de um arquivo JPEG SampImag.jpg na pasta do exemplo.  
  
-   Cria a posição e tamanho de um retângulo no qual desenhar a imagem.  
  
-   Desenha a imagem na tela.  
  
 A posição do retângulo localiza a imagem na tela e o tamanho da imagem original e o tamanho do retângulo determinam a escala da imagem desenhada.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#60](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#60)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#60](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#60)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#60](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, float x, float y, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, float32 x, float32 y, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Single,System.Single,System.Drawing.RectangleF,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, float x, float y, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * single * single * System.Drawing.RectangleF * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, x, y, srcRect, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="x">A coordenada X do canto superior esquerdo da imagem desenhada.</param>
        <param name="y">A coordenada y do canto superior esquerdo da imagem desenhada.</param>
        <param name="srcRect">Uma estrutura <see cref="T:System.Drawing.RectangleF" /> que especifica a parte do <see cref="T:System.Drawing.Image" /> a ser desenhada.</param>
        <param name="srcUnit">Membro da enumeração de <see cref="T:System.Drawing.GraphicsUnit" /> que especifica as unidades de medida usadas pelo parâmetro <paramref name="srcRect" />.</param>
        <summary>Desenha uma parte de uma imagem em um local especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Drawing.Image> armazena um valor para a largura em pixels e um valor para a resolução horizontal (pontos por polegada). A largura física, em polegadas, de uma imagem é a largura de pixel dividida pela resolução horizontal. Por exemplo, uma imagem com uma largura de pixel de 360 e uma resolução horizontal de 72 pontos por polegada tem uma largura física de 5 polegadas. Comentários semelhantes se aplicam à altura em pixels e altura física.  
  
 Esse método desenha uma parte de uma imagem usando seu tamanho físico, portanto, a parte da imagem terá seu tamanho correto em polegadas, independentemente da resolução (pontos por polegada) do dispositivo de vídeo. Por exemplo, suponha que uma parte da imagem tem uma largura de 216 pixels e uma resolução horizontal de 72 pontos por polegada. Se você chamar este método para desenhar a imagem parte em um dispositivo que tem uma resolução de 96 pontos por polegada, a largura em pixels da parte da imagem renderizada será (216/72) * 96 = 288.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma imagem de um arquivo JPEG SampImag.jpg na pasta do exemplo.  
  
-   Cria as coordenadas na qual desenhar o canto superior esquerdo da imagem.  
  
-   Cria um retângulo de origem do qual extrair uma parte da imagem.  
  
-   Define a unidade de medida do retângulo de origem como pixels.  
  
-   Desenha a imagem na tela.  
  
 O tamanho do retângulo de origem determina qual parte da imagem original fora de escala é desenhada na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#62](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#62)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#62](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#62)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#62](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * single * single * single * single -&gt; unit" Usage="graphics.DrawImage (image, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="x">A coordenada X do canto superior esquerdo da imagem desenhada.</param>
        <param name="y">A coordenada y do canto superior esquerdo da imagem desenhada.</param>
        <param name="width">Largura da imagem desenhada.</param>
        <param name="height">Altura da imagem desenhada.</param>
        <summary>Desenha o <see cref="T:System.Drawing.Image" /> especificado no local especificado e com o tamanho especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O retângulo definido pela `x`, `y`, `width`, e `height` parâmetros determina a posição e tamanho da imagem desenhada.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma imagem de um arquivo JPEG SampImag.jpg na pasta do exemplo.  
  
-   Cria a posição e tamanho de um retângulo no qual desenhar a imagem.  
  
-   Desenha a imagem na tela.  
  
 A posição do retângulo localiza a imagem na tela e o tamanho da imagem original e o tamanho do retângulo determinam a escala da imagem desenhada.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#63](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#63)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#63](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#63)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#63](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr, System.Drawing.Graphics.DrawImageAbort callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr, class System.Drawing.Graphics/DrawImageAbort callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr, System::Drawing::Graphics::DrawImageAbort ^ callback);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit, imageAttr, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="destPoints">Matriz de três estruturas <see cref="T:System.Drawing.PointF" /> que definem um paralelogramo.</param>
        <param name="srcRect">A estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica a parte do objeto <paramref name="image" /> a ser desenhada.</param>
        <param name="srcUnit">Membro da enumeração de <see cref="T:System.Drawing.GraphicsUnit" /> que especifica as unidades de medida usadas pelo parâmetro <paramref name="srcRect" />.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica informações de gama e nova coloração para o objeto <paramref name="image" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> que especifica um método a ser chamado durante o desenho da imagem. Esse método é invocado com frequência para verificar se a execução do método <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" /> deve ser interrompida de acordo com os critérios determinados pelo aplicativo.</param>
        <summary>Desenha a parte especificada do <see cref="T:System.Drawing.Image" /> especificado no local especificado e com o tamanho especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `destPoints` parâmetro especifica três pontos de um paralelogramo. Os três <xref:System.Drawing.PointF> estruturas representarem os cantos superior esquerdo, superior direito e inferior esquerdo do paralelogramo. O quarto ponto é inferido das três primeiras para formar um paralelogramo.  
  
 O `srcRect` parâmetro especifica uma parte retangular do `image` objeto a ser desenhado. Esta parte é dimensionada e distorcida para ajustá-la no paralelogramo especificado pelo `destPoints` parâmetro.  
  
 Essa sobrecarga com o `callback` parâmetro fornece os meios para interromper o desenho de uma imagem depois que ele inicia de acordo com os critérios determinados pelo aplicativo. Por exemplo, um aplicativo pode começar a desenhar uma imagem grande e o usuário pode rolar a imagem da tela, em que, caso o aplicativo foi possível interromper o desenho.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código primeiro define um método de retorno de chamada para o <xref:System.Drawing.Graphics.DrawImageAbort> delegar; a definição é simplista e simplesmente testa para ver se o <xref:System.Drawing.Graphics.DrawImage%2A> chamadas de método-lo com um valor nulo `callBackData` parâmetro. O corpo principal do exemplo executa as seguintes ações:  
  
-   Cria uma instância do <xref:System.Drawing.Graphics.DrawImageAbort> método de retorno de chamada:  
  
-   Cria uma imagem de um arquivo JPEG SampImag.jpg na pasta do exemplo.  
  
-   Cria pontos que definem um paralelogramo no qual desenhar a imagem.  
  
-   Cria um retângulo para selecionar a parte da imagem a ser desenhado.  
  
-   Define os unidade de desenho ao pixel de gráficos.  
  
-   Desenha a imagem original à tela.  
  
-   Cria um paralelogramo adicional nos quais desenhar uma imagem ajustada.  
  
-   Cria e define os atributos da imagem ajustada para ter um valor maior que o usual de gama.  
  
-   Desenha a imagem ajustada à tela.  
  
 Para o paralelogramo original, não ajustado, a posição localiza a imagem na tela e o tamanho do retângulo e o tamanho e a forma do paralelogramo determinam o dimensionamento e distorção da imagem desenhada.  
  
 Como este exemplo usa uma sobrecarga que não passa um `callBackData` parâmetro, o <xref:System.Drawing.Graphics.DrawImageAbort> retorno de chamada retorna `true`, que faz com que o <xref:System.Drawing.Graphics.DrawImage%2A> método end e o código de manipulação de exceção incluídos no exemplo imprime o texto da exceção em vez de desenhar a imagem.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#38](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#38)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#38](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#38)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#38](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr, System.Drawing.Graphics.DrawImageAbort callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr, class System.Drawing.Graphics/DrawImageAbort callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr, System::Drawing::Graphics::DrawImageAbort ^ callback);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit, imageAttr, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="destPoints">Matriz de três estruturas <see cref="T:System.Drawing.PointF" /> que definem um paralelogramo.</param>
        <param name="srcRect">A estrutura <see cref="T:System.Drawing.RectangleF" /> que especifica a parte do objeto <paramref name="image" /> a ser desenhada.</param>
        <param name="srcUnit">Membro da enumeração de <see cref="T:System.Drawing.GraphicsUnit" /> que especifica as unidades de medida usadas pelo parâmetro <paramref name="srcRect" />.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica informações de gama e nova coloração para o objeto <paramref name="image" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> que especifica um método a ser chamado durante o desenho da imagem. Esse método é invocado com frequência para verificar se a execução do método <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" /> deve ser interrompida de acordo com os critérios determinados pelo aplicativo.</param>
        <summary>Desenha a parte especificada do <see cref="T:System.Drawing.Image" /> especificado no local especificado e com o tamanho especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `destPoints` parâmetro especifica três pontos de um paralelogramo. Os três <xref:System.Drawing.PointF> estruturas representarem os cantos superior esquerdo, superior direito e inferior esquerdo do paralelogramo. O quarto ponto é inferido das três primeiras para formar um paralelogramo.  
  
 O `srcRect` parâmetro especifica uma parte retangular do `image` objeto a ser desenhado. Esta parte é dimensionada e distorcida para ajustá-la no paralelogramo especificado pelo `destPoints` parâmetro.  
  
 Essa sobrecarga com o `callback` parâmetro fornece os meios para interromper o desenho de uma imagem depois que ele inicia de acordo com os critérios determinados pelo aplicativo. Por exemplo, um aplicativo pode começar a desenhar uma imagem grande e o usuário pode rolar a imagem da tela, em que, caso o aplicativo foi possível interromper o desenho.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código primeiro define um método de retorno de chamada para o <xref:System.Drawing.Graphics.DrawImageAbort> delegar; a definição é simplista e simplesmente testa para ver se o <xref:System.Drawing.Graphics.DrawImage%2A> chamadas de método-lo com um valor nulo `callBackData` parâmetro. O corpo principal do exemplo executa as seguintes ações:  
  
-   Cria uma instância do <xref:System.Drawing.Graphics.DrawImageAbort> método de retorno de chamada.  
  
-   Cria uma imagem de um arquivo JPEG SampImag.jpg na pasta do exemplo.  
  
-   Cria pontos que definem um paralelogramo no qual desenhar a imagem.  
  
-   Cria um retângulo para selecionar a parte da imagem a ser desenhado.  
  
-   Define os unidade de desenho ao pixel de gráficos.  
  
-   Desenha a imagem original à tela.  
  
-   Cria um paralelogramo adicional nos quais desenhar uma imagem ajustada.  
  
-   Cria e define os atributos da imagem ajustada para ter um valor maior que o usual de gama.  
  
-   Desenha a imagem ajustada à tela.  
  
 Para o paralelogramo original, não ajustado, a posição localiza a imagem na tela e o tamanho do retângulo e o tamanho e a forma do paralelogramo determinam o dimensionamento e distorção da imagem desenhada.  
  
 Como este exemplo usa uma sobrecarga que não passa um `callBackData` parâmetro, o <xref:System.Drawing.Graphics.DrawImageAbort> retorno de chamada retorna `true`, que faz com que o <xref:System.Drawing.Graphics.DrawImage%2A> método end e o código de manipulação de exceção incluídos no exemplo imprime o texto da exceção em vez de desenhar a imagem.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#44](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#44)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#44](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#44)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#44](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#44)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr, System.Drawing.Graphics.DrawImageAbort callback, int callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr, class System.Drawing.Graphics/DrawImageAbort callback, int32 callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr, System::Drawing::Graphics::DrawImageAbort ^ callback, int callbackData);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort * int -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit, imageAttr, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
        <Parameter Name="callbackData" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="destPoints">Matriz de três estruturas <see cref="T:System.Drawing.PointF" /> que definem um paralelogramo.</param>
        <param name="srcRect">A estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica a parte do objeto <paramref name="image" /> a ser desenhada.</param>
        <param name="srcUnit">Membro da enumeração de <see cref="T:System.Drawing.GraphicsUnit" /> que especifica as unidades de medida usadas pelo parâmetro <paramref name="srcRect" />.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica informações de gama e nova coloração para o objeto <paramref name="image" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> que especifica um método a ser chamado durante o desenho da imagem. Esse método é invocado com frequência para verificar se a execução do método <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" /> deve ser interrompida de acordo com os critérios determinados pelo aplicativo.</param>
        <param name="callbackData">Valor que especifica os dados adicionais que o delegado <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> usará para verificar se a execução do método <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" /> será interrompida.</param>
        <summary>Desenha a parte especificada do <see cref="T:System.Drawing.Image" /> especificado no local especificado e com o tamanho especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `destPoints` parâmetro especifica três pontos de um paralelogramo. Os três <xref:System.Drawing.PointF> estruturas representarem os cantos superior esquerdo, superior direito e inferior esquerdo do paralelogramo. O quarto ponto é inferido das três primeiras para formar um paralelogramo.  
  
 O `srcRect` parâmetro especifica uma parte retangular do `image` objeto a ser desenhado. Esta parte é dimensionada e distorcida para ajustá-la no paralelogramo especificado pelo `destPoints` parâmetro.  
  
 Essa sobrecarga com o `callback` e `callbackData` parâmetros fornece os meios para interromper o desenho de uma imagem depois que ele inicia de acordo com critérios e dados determinados pelo aplicativo. Por exemplo, um aplicativo pode começar a desenhar uma imagem grande e o usuário pode rolar a imagem da tela, em que, caso o aplicativo foi possível interromper o desenho.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código primeiro define um método de retorno de chamada para o <xref:System.Drawing.Graphics.DrawImageAbort> delegar; a definição é simplista e simplesmente testa para ver se o <xref:System.Drawing.Graphics.DrawImage%2A> chamadas de método-lo com um valor nulo `callBackData` parâmetro. O corpo principal do exemplo executa as seguintes ações:  
  
-   Cria uma instância do <xref:System.Drawing.Graphics.DrawImageAbort> método de retorno de chamada.  
  
-   Cria uma imagem de um arquivo JPEG SampImag.jpg na pasta do exemplo.  
  
-   Cria pontos que definem um paralelogramo no qual desenhar a imagem.  
  
-   Cria um retângulo para selecionar a parte da imagem a ser desenhado.  
  
-   Define os unidade de desenho ao pixel de gráficos.  
  
-   Desenha a imagem original à tela.  
  
-   Cria um paralelogramo adicional nos quais desenhar uma imagem ajustada.  
  
-   Cria e define os atributos da imagem ajustada para ter um valor maior que o usual de gama.  
  
-   Desenha a imagem ajustada à tela.  
  
 Para o paralelogramo original, não ajustado, a posição localiza a imagem na tela e o tamanho do retângulo e o tamanho e a forma do paralelogramo determinam o dimensionamento e distorção da imagem desenhada.  
  
 Como este exemplo usa uma sobrecarga que passa um `callBackData` parâmetro, o <xref:System.Drawing.Graphics.DrawImageAbort> retorno de chamada retorna `false`, que faz com que o <xref:System.Drawing.Graphics.DrawImage%2A> método para continuar e o exemplo desenha a imagem ajustada à tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#39](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#39)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#39](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#39)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#39](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#39)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr, System.Drawing.Graphics.DrawImageAbort callback, int callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr, class System.Drawing.Graphics/DrawImageAbort callback, int32 callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr, System::Drawing::Graphics::DrawImageAbort ^ callback, int callbackData);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort * int -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit, imageAttr, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
        <Parameter Name="callbackData" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="destPoints">Matriz de três estruturas <see cref="T:System.Drawing.PointF" /> que definem um paralelogramo.</param>
        <param name="srcRect">A estrutura <see cref="T:System.Drawing.RectangleF" /> que especifica a parte do objeto <paramref name="image" /> a ser desenhada.</param>
        <param name="srcUnit">Membro da enumeração de <see cref="T:System.Drawing.GraphicsUnit" /> que especifica as unidades de medida usadas pelo parâmetro <paramref name="srcRect" />.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica informações de gama e nova coloração para o objeto <paramref name="image" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> que especifica um método a ser chamado durante o desenho da imagem. Esse método é invocado com frequência para verificar se a execução do método <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" /> deve ser interrompida de acordo com os critérios determinados pelo aplicativo.</param>
        <param name="callbackData">Valor que especifica os dados adicionais que o delegado <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> usará para verificar se a execução do método <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" /> será interrompida.</param>
        <summary>Desenha a parte especificada do <see cref="T:System.Drawing.Image" /> especificado no local especificado e com o tamanho especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `destPoints` parâmetro especifica três pontos de um paralelogramo. Os três <xref:System.Drawing.PointF> estruturas representarem os cantos superior esquerdo, superior direito e inferior esquerdo do paralelogramo. O quarto ponto é inferido das três primeiras para formar um paralelogramo.  
  
 O `srcRect` parâmetro especifica uma parte retangular do `image` objeto a ser desenhado. Esta parte é dimensionada e distorcida para ajustá-la no paralelogramo especificado pelo `destPoints` parâmetro.  
  
 Essa sobrecarga com o `callback` e `callbackData` parâmetros fornece os meios para interromper o desenho de uma imagem depois que ele inicia de acordo com critérios e dados determinados pelo aplicativo. Por exemplo, um aplicativo pode começar a desenhar uma imagem grande e o usuário pode rolar a imagem da tela, em que, caso o aplicativo foi possível interromper o desenho.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro da `Pa` <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código primeiro define um método de retorno de chamada para o <xref:System.Drawing.Graphics.DrawImageAbort> delegar; a definição é simplista e simplesmente testa para ver se o <xref:System.Drawing.Graphics.DrawImage%2A> chamadas de método-lo com um valor nulo `callBackData` parâmetro. O corpo principal do exemplo executa as seguintes ações:  
  
-   Cria uma instância do <xref:System.Drawing.Graphics.DrawImageAbort> método de retorno de chamada.  
  
-   Cria uma imagem de um arquivo JPEG SampImag.jpg na pasta do exemplo.  
  
-   Cria pontos que definem um paralelogramo no qual desenhar a imagem.  
  
-   Cria um retângulo para selecionar a parte da imagem a ser desenhado.  
  
-   Define os unidade de desenho ao pixel de gráficos.  
  
-   Desenha a imagem original à tela.  
  
-   Cria um paralelogramo adicional nos quais desenhar uma imagem ajustada.  
  
-   Cria e define os atributos da imagem ajustada para ter um valor maior que o usual de gama.  
  
-   Desenha a imagem ajustada à tela.  
  
 Para o paralelogramo original, não ajustado, a posição localiza a imagem na tela e o tamanho do retângulo e o tamanho e a forma do paralelogramo determinam o dimensionamento e distorção da imagem desenhada.  
  
 Como este exemplo usa uma sobrecarga que passa um `callBackData` parâmetro, o <xref:System.Drawing.Graphics.DrawImageAbort> retorno de chamada retorna `false`, que faz com que o <xref:System.Drawing.Graphics.DrawImage%2A> método para continuar e o exemplo desenha a imagem ajustada à tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#45](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#45)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#45](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#45)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#45](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#45)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, int32 srcX, int32 srcY, int32 srcWidth, int32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * int * int * int * int * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Int32" />
        <Parameter Name="srcY" Type="System.Int32" />
        <Parameter Name="srcWidth" Type="System.Int32" />
        <Parameter Name="srcHeight" Type="System.Int32" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="destRect">A estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica o local e o tamanho da imagem desenhada. A imagem é dimensionada para se ajustar ao retângulo.</param>
        <param name="srcX">A coordenada X do canto superior esquerdo da parte da imagem de origem a ser desenhada.</param>
        <param name="srcY">A coordenada y do canto superior esquerdo da parte da imagem de origem a ser desenhada.</param>
        <param name="srcWidth">Largura da parte da imagem de origem a ser desenhada.</param>
        <param name="srcHeight">Altura da parte da imagem de origem a ser desenhada.</param>
        <param name="srcUnit">O membro da enumeração de <see cref="T:System.Drawing.GraphicsUnit" /> que especifica as unidades de medida usadas para determinar o retângulo de origem.</param>
        <summary>Desenha a parte especificada do <see cref="T:System.Drawing.Image" /> especificado no local especificado e com o tamanho especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `srcX`, `srcY`, `srcWidth`, e `srcHeight` os parâmetros especificam uma parte retangular, da `image` objeto a ser desenhado. O retângulo é relativa ao canto superior esquerdo da imagem de origem. Esta parte é dimensionada para se ajustar dentro do retângulo especificado pelo `destRect` parâmetro.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma imagem de um arquivo JPEG SampImag.jpg na pasta do exemplo.  
  
-   Cria um retângulo de destino no qual desenhar a imagem.  
  
-   Cria as coordenadas de um retângulo de origem do qual extrair uma parte da imagem.  
  
-   Define a unidade de medida do retângulo de origem como pixels.  
  
-   Desenha a imagem na tela.  
  
 A posição do retângulo de destino localiza a imagem na tela e os tamanhos dos retângulos de origem e destino determinam o dimensionamento da imagem desenhada e o tamanho do retângulo de origem determina qual parte da imagem original é desenhada para o tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#48](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#48)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#48](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#48)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#48](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#48)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, float32 srcX, float32 srcY, float32 srcWidth, float32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * single * single * single * single * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Single" />
        <Parameter Name="srcY" Type="System.Single" />
        <Parameter Name="srcWidth" Type="System.Single" />
        <Parameter Name="srcHeight" Type="System.Single" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="destRect">A estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica o local e o tamanho da imagem desenhada. A imagem é dimensionada para se ajustar ao retângulo.</param>
        <param name="srcX">A coordenada X do canto superior esquerdo da parte da imagem de origem a ser desenhada.</param>
        <param name="srcY">A coordenada y do canto superior esquerdo da parte da imagem de origem a ser desenhada.</param>
        <param name="srcWidth">Largura da parte da imagem de origem a ser desenhada.</param>
        <param name="srcHeight">Altura da parte da imagem de origem a ser desenhada.</param>
        <param name="srcUnit">O membro da enumeração de <see cref="T:System.Drawing.GraphicsUnit" /> que especifica as unidades de medida usadas para determinar o retângulo de origem.</param>
        <summary>Desenha a parte especificada do <see cref="T:System.Drawing.Image" /> especificado no local especificado e com o tamanho especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `srcX`, `srcY`, `srcWidth`, e `srcHeight` os parâmetros especificam uma parte retangular, da `image` objeto a ser desenhado. O retângulo é relativa ao canto superior esquerdo da imagem de origem. Esta parte é dimensionada para se ajustar dentro do retângulo especificado pelo `destRect` parâmetro.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma imagem de um arquivo JPEG SampImag.jpg na pasta do exemplo.  
  
-   Cria as coordenadas de um retângulo de destino no qual desenhar a imagem.  
  
-   Cria um retângulo de origem do qual extrair uma parte da imagem.  
  
-   Define a unidade de medida do retângulo de origem como pixels.  
  
-   Desenha a imagem na tela.  
  
 A posição do retângulo de destino localiza a imagem na tela, os tamanhos dos retângulos de origem e destino determinam o dimensionamento da imagem desenhada e o tamanho do retângulo de origem determina qual parte da imagem original é desenhada para o tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#52](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#52)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#52](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#52)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#52](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, int32 srcX, int32 srcY, int32 srcWidth, int32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * int * int * int * int * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Int32" />
        <Parameter Name="srcY" Type="System.Int32" />
        <Parameter Name="srcWidth" Type="System.Int32" />
        <Parameter Name="srcHeight" Type="System.Int32" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="destRect">A estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica o local e o tamanho da imagem desenhada. A imagem é dimensionada para se ajustar ao retângulo.</param>
        <param name="srcX">A coordenada X do canto superior esquerdo da parte da imagem de origem a ser desenhada.</param>
        <param name="srcY">A coordenada y do canto superior esquerdo da parte da imagem de origem a ser desenhada.</param>
        <param name="srcWidth">Largura da parte da imagem de origem a ser desenhada.</param>
        <param name="srcHeight">Altura da parte da imagem de origem a ser desenhada.</param>
        <param name="srcUnit">O membro da enumeração de <see cref="T:System.Drawing.GraphicsUnit" /> que especifica as unidades de medida usadas para determinar o retângulo de origem.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica informações de gama e nova coloração para o objeto <paramref name="image" />.</param>
        <summary>Desenha a parte especificada do <see cref="T:System.Drawing.Image" /> especificado no local especificado e com o tamanho especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `srcX`, `srcY`, `srcWidth`, e `srcHeight` os parâmetros especificam uma parte retangular, da `image` objeto a ser desenhado. O retângulo é relativa ao canto superior esquerdo da imagem de origem. Esta parte é dimensionada para se ajustar dentro do retângulo especificado pelo `destRect` parâmetro.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma imagem de um arquivo JPEG SampImag.jpg na pasta do exemplo.  
  
-   Cria um retângulo de destino no qual desenhar a imagem.  
  
-   Cria as coordenadas de um retângulo de origem do qual extrair uma parte da imagem.  
  
-   Define a unidade de medida do retângulo de origem como pixels.  
  
-   Desenha a imagem original à tela.  
  
-   Cria um retângulo adicional nos quais desenhar uma imagem ajustada.  
  
-   Cria e define os atributos da imagem ajustada para ter um valor maior que o usual de gama.  
  
-   Desenha a imagem ajustada à tela.  
  
 Para o retângulo de destino original, não ajustado, a posição localiza a imagem na tela e os tamanhos dos retângulos de origem e destino determinam o dimensionamento da imagem desenhada e o tamanho do retângulo de origem determina qual parte das imagem original é desenhada na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#49](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#49)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#49](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#49)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#49](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#49)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttrs);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, float32 srcX, float32 srcY, float32 srcWidth, float32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttrs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttrs);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * single * single * single * single * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttrs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Single" />
        <Parameter Name="srcY" Type="System.Single" />
        <Parameter Name="srcWidth" Type="System.Single" />
        <Parameter Name="srcHeight" Type="System.Single" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttrs" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="destRect">A estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica o local e o tamanho da imagem desenhada. A imagem é dimensionada para se ajustar ao retângulo.</param>
        <param name="srcX">A coordenada X do canto superior esquerdo da parte da imagem de origem a ser desenhada.</param>
        <param name="srcY">A coordenada y do canto superior esquerdo da parte da imagem de origem a ser desenhada.</param>
        <param name="srcWidth">Largura da parte da imagem de origem a ser desenhada.</param>
        <param name="srcHeight">Altura da parte da imagem de origem a ser desenhada.</param>
        <param name="srcUnit">O membro da enumeração de <see cref="T:System.Drawing.GraphicsUnit" /> que especifica as unidades de medida usadas para determinar o retângulo de origem.</param>
        <param name="imageAttrs"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica informações de gama e nova coloração para o objeto <paramref name="image" />.</param>
        <summary>Desenha a parte especificada do <see cref="T:System.Drawing.Image" /> especificado no local especificado e com o tamanho especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `srcX`, `srcY`, `srcWidth`, e `srcHeight` os parâmetros especificam uma parte retangular, da `image` objeto a ser desenhado. O retângulo é relativa ao canto superior esquerdo da imagem de origem. Esta parte é dimensionada para se ajustar dentro do retângulo especificado pelo `destRect` parâmetro.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma imagem de um arquivo JPEG SampImag.jpg na pasta do exemplo.  
  
-   Cria um retângulo de destino no qual desenhar a imagem.  
  
-   Cria as coordenadas de um retângulo de origem do qual extrair uma parte da imagem.  
  
-   Define a unidade de medida do retângulo de origem como pixels.  
  
-   Desenha a imagem original à tela.  
  
-   Cria um retângulo adicional nos quais desenhar uma imagem ajustada.  
  
-   Cria e define os atributos da imagem ajustada para ter um valor maior que o usual de gama.  
  
-   Desenha a imagem ajustada à tela.  
  
 Para o retângulo de destino original, não ajustado, a posição localiza a imagem na tela e os tamanhos dos retângulos de origem e destino determinam o dimensionamento da imagem desenhada e o tamanho do retângulo de origem determina qual parte das imagem original é desenhada na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#53](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#53)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#53](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#53)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#53](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#53)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr, System.Drawing.Graphics.DrawImageAbort callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, int32 srcX, int32 srcY, int32 srcWidth, int32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr, class System.Drawing.Graphics/DrawImageAbort callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr, System::Drawing::Graphics::DrawImageAbort ^ callback);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * int * int * int * int * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttr, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Int32" />
        <Parameter Name="srcY" Type="System.Int32" />
        <Parameter Name="srcWidth" Type="System.Int32" />
        <Parameter Name="srcHeight" Type="System.Int32" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="destRect">A estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica o local e o tamanho da imagem desenhada. A imagem é dimensionada para se ajustar ao retângulo.</param>
        <param name="srcX">A coordenada X do canto superior esquerdo da parte da imagem de origem a ser desenhada.</param>
        <param name="srcY">A coordenada y do canto superior esquerdo da parte da imagem de origem a ser desenhada.</param>
        <param name="srcWidth">Largura da parte da imagem de origem a ser desenhada.</param>
        <param name="srcHeight">Altura da parte da imagem de origem a ser desenhada.</param>
        <param name="srcUnit">O membro da enumeração de <see cref="T:System.Drawing.GraphicsUnit" /> que especifica as unidades de medida usadas para determinar o retângulo de origem.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica informações de gama e nova coloração para <paramref name="image" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> que especifica um método a ser chamado durante o desenho da imagem. Esse método é invocado com frequência para verificar se a execução do método <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" /> deve ser interrompida de acordo com os critérios determinados pelo aplicativo.</param>
        <summary>Desenha a parte especificada do <see cref="T:System.Drawing.Image" /> especificado no local especificado e com o tamanho especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `srcX`, `srcY`, `srcWidth`, e `srcHeight` os parâmetros especificam uma parte retangular, da `image` objeto a ser desenhado. O retângulo é relativa ao canto superior esquerdo da imagem de origem. Esta parte é dimensionada para se ajustar dentro do retângulo especificado pelo `destRect` objeto.  
  
 Essa sobrecarga com o `callback` parâmetro fornece os meios para interromper o desenho de uma imagem depois que ele inicia de acordo com os critérios determinados pelo aplicativo. Por exemplo, um aplicativo pode começar a desenhar uma imagem grande e o usuário pode rolar a imagem da tela, em que, caso o aplicativo foi possível interromper o desenho.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código primeiro define um método de retorno de chamada para o <xref:System.Drawing.Graphics.DrawImageAbort> delegar; a definição é simplista e simplesmente testa para ver se o <xref:System.Drawing.Graphics.DrawImage%2A> chamadas de método-lo com um valor nulo `callBackData` parâmetro. O corpo principal do exemplo executa as seguintes ações:  
  
-   Cria uma instância do <xref:System.Drawing.Graphics.DrawImageAbort> método de retorno de chamada.  
  
-   Cria uma imagem de um arquivo JPEG SampImag.jpg na pasta do exemplo.  
  
-   Cria pontos que definem um retângulo de destino no qual desenhar a imagem.  
  
-   Cria um retângulo de origem para selecionar a parte da imagem a ser desenhado.  
  
-   Define os unidade de desenho ao pixel de gráficos.  
  
-   Desenha a imagem original à tela.  
  
-   Cria um retângulo de destino adicionais nos quais desenhar uma imagem ajustada.  
  
-   Cria e define os atributos da imagem ajustada para ter um valor maior que o usual de gama.  
  
-   Desenha a imagem ajustada à tela.  
  
 Para o retângulo de destino original, não ajustado, a posição localiza a imagem na tela e o tamanho do retângulo de origem e o tamanho e a forma do retângulo de destino determinam a escala da imagem desenhada.  
  
 Como este exemplo usa uma sobrecarga que não passa um `callBackData` parâmetro, o <xref:System.Drawing.Graphics.DrawImageAbort> retorno de chamada retorna `true`, que faz com que o <xref:System.Drawing.Graphics.DrawImage%2A> método end e o código de manipulação de exceção incluídos no exemplo imprime o texto da exceção em vez de desenhar a imagem.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#50](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#50)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#50](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#50)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#50](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttrs, System.Drawing.Graphics.DrawImageAbort callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, float32 srcX, float32 srcY, float32 srcWidth, float32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttrs, class System.Drawing.Graphics/DrawImageAbort callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttrs, System::Drawing::Graphics::DrawImageAbort ^ callback);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * single * single * single * single * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttrs, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Single" />
        <Parameter Name="srcY" Type="System.Single" />
        <Parameter Name="srcWidth" Type="System.Single" />
        <Parameter Name="srcHeight" Type="System.Single" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttrs" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="destRect">A estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica o local e o tamanho da imagem desenhada. A imagem é dimensionada para se ajustar ao retângulo.</param>
        <param name="srcX">A coordenada X do canto superior esquerdo da parte da imagem de origem a ser desenhada.</param>
        <param name="srcY">A coordenada y do canto superior esquerdo da parte da imagem de origem a ser desenhada.</param>
        <param name="srcWidth">Largura da parte da imagem de origem a ser desenhada.</param>
        <param name="srcHeight">Altura da parte da imagem de origem a ser desenhada.</param>
        <param name="srcUnit">O membro da enumeração de <see cref="T:System.Drawing.GraphicsUnit" /> que especifica as unidades de medida usadas para determinar o retângulo de origem.</param>
        <param name="imageAttrs"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica informações de gama e nova coloração para o objeto <paramref name="image" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> que especifica um método a ser chamado durante o desenho da imagem. Esse método é invocado com frequência para verificar se a execução do método <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" /> deve ser interrompida de acordo com os critérios determinados pelo aplicativo.</param>
        <summary>Desenha a parte especificada do <see cref="T:System.Drawing.Image" /> especificado no local especificado e com o tamanho especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `srcX`, `srcY`, `srcWidth`, e `srcHeight` os parâmetros especificam uma parte retangular, da `image` objeto a ser desenhado. O retângulo é relativa ao canto superior esquerdo da imagem de origem. Esta parte é dimensionada para se ajustar dentro do retângulo especificado pelo `destRect` parâmetro.  
  
 Essa sobrecarga com o `callback` parâmetro fornece os meios para interromper o desenho de uma imagem depois que ele inicia de acordo com os critérios determinados pelo aplicativo. Por exemplo, um aplicativo pode começar a desenhar uma imagem grande e o usuário pode rolar a imagem da tela, em que, caso o aplicativo foi possível interromper o desenho.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código primeiro define um método de retorno de chamada para o <xref:System.Drawing.Graphics.DrawImageAbort> delegar; a definição é simplista e simplesmente testa para ver se o <xref:System.Drawing.Graphics.DrawImage%2A> chamadas de método-lo com um valor nulo `callBackData` parâmetro. O corpo principal do exemplo executa as seguintes ações:  
  
-   Cria uma instância do <xref:System.Drawing.Graphics.DrawImageAbort> método de retorno de chamada.  
  
-   Cria uma imagem de um arquivo JPEG SampImag.jpg na pasta do exemplo.  
  
-   Cria pontos que definem um retângulo de destino no qual desenhar a imagem.  
  
-   Cria um retângulo de origem para selecionar a parte da imagem a ser desenhado.  
  
-   Define os unidade de desenho ao pixel de gráficos.  
  
-   Desenha a imagem original à tela.  
  
-   Cria um retângulo de destino adicionais nos quais desenhar uma imagem ajustada.  
  
-   Cria e define os atributos da imagem ajustada para ter um valor maior que o usual de gama.  
  
-   Desenha a imagem ajustada à tela.  
  
 Para o retângulo de destino original, não ajustado, a posição localiza a imagem na tela e o tamanho do retângulo de origem e o tamanho e a forma do retângulo de destino determinam a escala da imagem desenhada.  
  
 Como este exemplo usa uma sobrecarga que não passa um `callBackData` parâmetro, o <xref:System.Drawing.Graphics.DrawImageAbort> retorno de chamada retorna `true`, que faz com que o <xref:System.Drawing.Graphics.DrawImage%2A> método end e o código de manipulação de exceção incluídos no exemplo imprime o texto da exceção em vez de desenhar a imagem.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#54](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#54)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#54](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#54)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#54](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttrs, System.Drawing.Graphics.DrawImageAbort callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, int32 srcX, int32 srcY, int32 srcWidth, int32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttrs, class System.Drawing.Graphics/DrawImageAbort callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttrs, System::Drawing::Graphics::DrawImageAbort ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * int * int * int * int * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort * nativeint -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttrs, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Int32" />
        <Parameter Name="srcY" Type="System.Int32" />
        <Parameter Name="srcWidth" Type="System.Int32" />
        <Parameter Name="srcHeight" Type="System.Int32" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttrs" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="destRect">A estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica o local e o tamanho da imagem desenhada. A imagem é dimensionada para se ajustar ao retângulo.</param>
        <param name="srcX">A coordenada X do canto superior esquerdo da parte da imagem de origem a ser desenhada.</param>
        <param name="srcY">A coordenada y do canto superior esquerdo da parte da imagem de origem a ser desenhada.</param>
        <param name="srcWidth">Largura da parte da imagem de origem a ser desenhada.</param>
        <param name="srcHeight">Altura da parte da imagem de origem a ser desenhada.</param>
        <param name="srcUnit">O membro da enumeração de <see cref="T:System.Drawing.GraphicsUnit" /> que especifica as unidades de medida usadas para determinar o retângulo de origem.</param>
        <param name="imageAttrs"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica informações de gama e nova coloração para o objeto <paramref name="image" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> que especifica um método a ser chamado durante o desenho da imagem. Esse método é invocado com frequência para verificar se a execução do método <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.IntPtr)" /> deve ser interrompida de acordo com os critérios determinados pelo aplicativo.</param>
        <param name="callbackData">Valor que especifica os dados adicionais que o delegado <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> usará para verificar se a execução do método <see langword="DrawImage" /> será interrompida.</param>
        <summary>Desenha a parte especificada do <see cref="T:System.Drawing.Image" /> especificado no local especificado e com o tamanho especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `srcX`, `srcY`, `srcWidth`, e `srcHeight` os parâmetros especificam uma parte retangular, da `image` objeto a ser desenhado. O retângulo é relativa ao canto superior esquerdo da imagem de origem. Esta parte é dimensionada para se ajustar dentro do retângulo especificado pelo `destRect` parâmetro.  
  
 Essa sobrecarga com o `callback` e `callbackData` parâmetros fornece os meios para interromper o desenho de uma imagem depois que ele inicia de acordo com critérios e dados determinados pelo aplicativo. Por exemplo, um aplicativo pode começar a desenhar uma imagem grande e o usuário pode rolar a imagem da tela, em que, caso o aplicativo foi possível interromper o desenho.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código primeiro define um método de retorno de chamada para o <xref:System.Drawing.Graphics.DrawImageAbort> delegar; a definição é simplista e simplesmente testa para ver se o <xref:System.Drawing.Graphics.DrawImage%2A> chamadas de método-lo com um valor nulo `callBackData` parâmetro. O corpo principal do exemplo executa as seguintes ações:  
  
-   Cria uma instância do <xref:System.Drawing.Graphics.DrawImageAbort> método de retorno de chamada.  
  
-   Cria uma imagem de um arquivo JPEG SampImag.jpg na pasta do exemplo.  
  
-   Cria pontos que definem um retângulo de destino no qual desenhar a imagem.  
  
-   Cria um retângulo de origem para selecionar a parte da imagem a ser desenhado.  
  
-   Define os unidade de desenho ao pixel de gráficos.  
  
-   Desenha a imagem original à tela.  
  
-   Cria um retângulo de destino adicionais nos quais desenhar uma imagem ajustada.  
  
-   Cria e define os atributos da imagem ajustada para ter um valor maior que o usual de gama.  
  
-   Desenha a imagem ajustada à tela.  
  
 Para o retângulo de destino original, não ajustado, a posição localiza a imagem na tela e o tamanho do retângulo de origem e o tamanho e a forma do retângulo de destino determinam a escala da imagem desenhada.  
  
 Como este exemplo usa uma sobrecarga que passa um `callBackData` parâmetro, o <xref:System.Drawing.Graphics.DrawImageAbort> retorno de chamada retorna `false`, que faz com que o <xref:System.Drawing.Graphics.DrawImage%2A> método para continuar e o exemplo desenha a imagem ajustada à tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#51](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#51)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#51](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#51)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#51](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#51)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttrs, System.Drawing.Graphics.DrawImageAbort callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, float32 srcX, float32 srcY, float32 srcWidth, float32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttrs, class System.Drawing.Graphics/DrawImageAbort callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttrs, System::Drawing::Graphics::DrawImageAbort ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * single * single * single * single * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort * nativeint -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttrs, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Single" />
        <Parameter Name="srcY" Type="System.Single" />
        <Parameter Name="srcWidth" Type="System.Single" />
        <Parameter Name="srcHeight" Type="System.Single" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttrs" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="destRect">A estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica o local e o tamanho da imagem desenhada. A imagem é dimensionada para se ajustar ao retângulo.</param>
        <param name="srcX">A coordenada X do canto superior esquerdo da parte da imagem de origem a ser desenhada.</param>
        <param name="srcY">A coordenada y do canto superior esquerdo da parte da imagem de origem a ser desenhada.</param>
        <param name="srcWidth">Largura da parte da imagem de origem a ser desenhada.</param>
        <param name="srcHeight">Altura da parte da imagem de origem a ser desenhada.</param>
        <param name="srcUnit">O membro da enumeração de <see cref="T:System.Drawing.GraphicsUnit" /> que especifica as unidades de medida usadas para determinar o retângulo de origem.</param>
        <param name="imageAttrs"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica informações de gama e nova coloração para o objeto <paramref name="image" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> que especifica um método a ser chamado durante o desenho da imagem. Esse método é invocado com frequência para verificar se a execução do método <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.IntPtr)" /> deve ser interrompida de acordo com os critérios determinados pelo aplicativo.</param>
        <param name="callbackData">Valor que especifica os dados adicionais que o delegado <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> usará para verificar se a execução do método <see langword="DrawImage" /> será interrompida.</param>
        <summary>Desenha a parte especificada do <see cref="T:System.Drawing.Image" /> especificado no local especificado e com o tamanho especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `srcX`, `srcY`, `srcWidth`, e `srcHeight` os parâmetros especificam uma parte retangular, da `image` objeto a ser desenhado. O retângulo é relativa ao canto superior esquerdo da imagem de origem. Esta parte é dimensionada para se ajustar dentro do retângulo especificado pelo `destRect` parâmetro.  
  
 Essa sobrecarga com o `callback` e `callbackData` parâmetros fornece os meios para interromper o desenho de uma imagem depois que ele inicia de acordo com critérios e dados determinados pelo aplicativo. Por exemplo, um aplicativo pode começar a desenhar uma imagem grande e o usuário pode rolar a imagem da tela, em que, caso o aplicativo foi possível interromper o desenho.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código primeiro define um método de retorno de chamada para o <xref:System.Drawing.Graphics.DrawImageAbort> delegar; a definição é simplista e simplesmente testa para ver se o <xref:System.Drawing.Graphics.DrawImage%2A> chamadas de método-lo com um valor nulo `callBackData` parâmetro. O corpo principal do exemplo executa as seguintes ações:  
  
-   Cria uma instância do <xref:System.Drawing.Graphics.DrawImageAbort> método de retorno de chamada.  
  
-   Cria uma imagem de um arquivo JPEG SampImag.jpg na pasta do exemplo.  
  
-   Cria pontos que definem um retângulo de destino no qual desenhar a imagem.  
  
-   Cria um retângulo de origem para selecionar a parte da imagem a ser desenhado.  
  
-   Define os unidade de desenho ao pixel de gráficos.  
  
-   Desenha a imagem original à tela.  
  
-   Cria um retângulo de destino adicionais nos quais desenhar uma imagem ajustada.  
  
-   Cria e define os atributos da imagem ajustada para ter um valor maior que o usual de gama.  
  
-   Desenha a imagem ajustada à tela.  
  
 Para o retângulo de destino original, não ajustado, a posição localiza a imagem na tela e o tamanho do retângulo de origem e o tamanho e a forma do retângulo de destino determinam a escala da imagem desenhada.  
  
 Como este exemplo usa uma sobrecarga que passa um `callBackData` parâmetro, o <xref:System.Drawing.Graphics.DrawImageAbort> retorno de chamada retorna `false`, que faz com que o <xref:System.Drawing.Graphics.DrawImage%2A> método para continuar e o exemplo desenha a imagem ajustada à tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#55](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#55)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#55](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#55)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#55](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawImageUnscaled">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Desenha a imagem especificada usando seu tamanho físico original no local especificado por um par de coordenadas.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawImageUnscaled">
      <MemberSignature Language="C#" Value="public void DrawImageUnscaled (System.Drawing.Image image, System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImageUnscaled(class System.Drawing.Image image, valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImageUnscaled(System.Drawing.Image,System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImageUnscaled(System::Drawing::Image ^ image, System::Drawing::Point point);" />
      <MemberSignature Language="F#" Value="member this.DrawImageUnscaled : System.Drawing.Image * System.Drawing.Point -&gt; unit" Usage="graphics.DrawImageUnscaled (image, point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="point">Estrutura <see cref="T:System.Drawing.Point" /> que especifica o canto superior esquerdo da imagem desenhada.</param>
        <summary>Desenha uma imagem especificada usando seu tamanho físico original em um local especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Drawing.Image> armazena um valor para a largura em pixels e um valor para a resolução horizontal (pontos por polegada). A largura física, em polegadas, de uma imagem é a largura de pixel dividida pela resolução horizontal. Por exemplo, uma imagem com uma largura de 216 pixels e uma resolução horizontal de 72 pontos por polegada tem uma largura física de 3 polegadas. Comentários semelhantes se aplicam à altura em pixels e altura física.  
  
 O <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> método desenha uma imagem usando seu tamanho físico, portanto, a imagem terá seu tamanho correto em polegadas, independentemente da resolução (pontos por polegada) do dispositivo de vídeo. Por exemplo, suponha que uma imagem tem uma largura de 216 pixels e uma resolução horizontal de 72 pontos por polegada. Se você chamar <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> para desenhar a imagem em um dispositivo que tem uma resolução de 96 pontos por polegada, a largura de pixel da imagem renderizada será (216/72) * 96 = 288.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma imagem de um arquivo JPEG SampImag.jpg na pasta do exemplo.  
  
-   Cria um ponto no qual desenhar o canto superior esquerdo da imagem.  
  
-   Desenha a imagem inteira usando seu tamanho físico.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#64](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#64)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#64](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#64)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#64](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawImageUnscaled">
      <MemberSignature Language="C#" Value="public void DrawImageUnscaled (System.Drawing.Image image, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImageUnscaled(class System.Drawing.Image image, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImageUnscaled(System.Drawing.Image,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImageUnscaled(System::Drawing::Image ^ image, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.DrawImageUnscaled : System.Drawing.Image * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawImageUnscaled (image, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="rect"><see cref="T:System.Drawing.Rectangle" /> que especifica o canto superior esquerdo da imagem desenhada. As propriedades X e Y do retângulo especificam o canto superior esquerdo. As propriedades de Largura e Altura são ignoradas.</param>
        <summary>Desenha uma imagem especificada usando seu tamanho físico original em um local especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Drawing.Image> armazena um valor para a largura em pixels e um valor para a resolução horizontal (pontos por polegada). A largura física, em polegadas, de uma imagem é a largura de pixel dividida pela resolução horizontal. Por exemplo, uma imagem com uma largura de 216 pixels e uma resolução horizontal de 72 pontos por polegada tem uma largura física de 3 polegadas. Comentários semelhantes se aplicam à altura em pixels e altura física.  
  
 O <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> método desenha uma imagem usando seu tamanho físico, portanto, a imagem terá seu tamanho correto em polegadas, independentemente da resolução (pontos por polegada) do dispositivo de vídeo. Por exemplo, suponha que uma imagem tem uma largura de 216 pixels e uma resolução horizontal de 72 pontos por polegada. Se você chamar <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> para desenhar a imagem em um dispositivo que tem uma resolução de 96 pontos por polegada, a largura de pixel da imagem renderizada será (216/72) * 96 = 288.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawImageUnscaled">
      <MemberSignature Language="C#" Value="public void DrawImageUnscaled (System.Drawing.Image image, int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImageUnscaled(class System.Drawing.Image image, int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImageUnscaled(System.Drawing.Image,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImageUnscaled(System::Drawing::Image ^ image, int x, int y);" />
      <MemberSignature Language="F#" Value="member this.DrawImageUnscaled : System.Drawing.Image * int * int -&gt; unit" Usage="graphics.DrawImageUnscaled (image, x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="x">A coordenada X do canto superior esquerdo da imagem desenhada.</param>
        <param name="y">A coordenada y do canto superior esquerdo da imagem desenhada.</param>
        <summary>Desenha a imagem especificada usando seu tamanho físico original no local especificado por um par de coordenadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Drawing.Image> armazena um valor para a largura em pixels e um valor para a resolução horizontal (pontos por polegada). A largura física, em polegadas, de uma imagem é a largura de pixel dividida pela resolução horizontal. Por exemplo, uma imagem com uma largura de 216 pixels e uma resolução horizontal de 72 pontos por polegada tem uma largura física de 3 polegadas. Comentários semelhantes se aplicam à altura em pixels e altura física.  
  
 O <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> método desenha uma imagem usando seu tamanho físico, portanto, a imagem terá seu tamanho correto em polegadas, independentemente da resolução (pontos por polegada) do dispositivo de vídeo. Por exemplo, suponha que uma imagem tem uma largura de 216 pixels e uma resolução horizontal de 72 pontos por polegada. Se você chamar <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> para desenhar a imagem em um dispositivo que tem uma resolução de 96 pontos por polegada, a largura de pixel da imagem renderizada será (216/72) * 96 = 288.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma imagem de um arquivo JPEG, SampImag.jpg, na pasta do exemplo.  
  
-   Cria um ponto no qual desenhar o canto superior esquerdo da imagem.  
  
-   Desenha a imagem inteira usando seu tamanho físico.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#65](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#65)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#65](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#65)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#65](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#65)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawImageUnscaled">
      <MemberSignature Language="C#" Value="public void DrawImageUnscaled (System.Drawing.Image image, int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImageUnscaled(class System.Drawing.Image image, int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImageUnscaled(System.Drawing.Image,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImageUnscaled(System::Drawing::Image ^ image, int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.DrawImageUnscaled : System.Drawing.Image * int * int * int * int -&gt; unit" Usage="graphics.DrawImageUnscaled (image, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="x">A coordenada X do canto superior esquerdo da imagem desenhada.</param>
        <param name="y">A coordenada y do canto superior esquerdo da imagem desenhada.</param>
        <param name="width">Não usado.</param>
        <param name="height">Não usado.</param>
        <summary>Desenha uma imagem especificada usando seu tamanho físico original em um local especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Drawing.Image> armazena um valor para a largura em pixels e um valor para a resolução horizontal (pontos por polegada). A largura física, em polegadas, de uma imagem é a largura de pixel dividida pela resolução horizontal. Por exemplo, uma imagem com uma largura de 216 pixels e uma resolução horizontal de 72 pontos por polegada tem uma largura física de 3 polegadas. Comentários semelhantes se aplicam à altura em pixels e altura física.  
  
 O <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> método desenha uma imagem usando seu tamanho físico, portanto, a imagem terá seu tamanho correto em polegadas, independentemente da resolução (pontos por polegada) do dispositivo de vídeo. Por exemplo, suponha que uma imagem tem uma largura de 216 pixels e uma resolução horizontal de 72 pontos por polegada. Se você chamar <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> para desenhar a imagem em um dispositivo que tem uma resolução de 96 pontos por polegada, a largura de pixel da imagem renderizada será (216/72) * 96 = 288.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawImageUnscaledAndClipped">
      <MemberSignature Language="C#" Value="public void DrawImageUnscaledAndClipped (System.Drawing.Image image, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImageUnscaledAndClipped(class System.Drawing.Image image, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImageUnscaledAndClipped(System.Drawing.Image,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImageUnscaledAndClipped(System::Drawing::Image ^ image, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.DrawImageUnscaledAndClipped : System.Drawing.Image * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawImageUnscaledAndClipped (image, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="image">O <see cref="T:System.Drawing.Image" /> a ser desenhado.</param>
        <param name="rect">O <see cref="T:System.Drawing.Rectangle" /> no qual desenhar a imagem.</param>
        <summary>Desenha a imagem especificada sem dimensionamento e recortes, caso necessários, para se ajustar no retângulo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Drawing.Graphics.DrawImageUnscaledAndClipped%2A> método. Para executar este exemplo, cole-o em um formulário do Windows. Lidar com o formulário <xref:System.Windows.Forms.Control.Paint> eventos e chamadas a `DrawImageUnscaled` método a partir de <xref:System.Windows.Forms.Control.Paint> método de manipulação de eventos, passando `e` como <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-csharp[System.Drawing.MiscWhidbeySnippets#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/CS/Form1.cs#8)]
 [!code-vb[System.Drawing.MiscWhidbeySnippets#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawLine">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Desenha uma linha que conecta os dois pontos especificados por pares de coordenadas.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public void DrawLine (System.Drawing.Pen pen, System.Drawing.Point pt1, System.Drawing.Point pt2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawLine(class System.Drawing.Pen pen, valuetype System.Drawing.Point pt1, valuetype System.Drawing.Point pt2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawLine(System.Drawing.Pen,System.Drawing.Point,System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawLine(System::Drawing::Pen ^ pen, System::Drawing::Point pt1, System::Drawing::Point pt2);" />
      <MemberSignature Language="F#" Value="member this.DrawLine : System.Drawing.Pen * System.Drawing.Point * System.Drawing.Point -&gt; unit" Usage="graphics.DrawLine (pen, pt1, pt2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="pt1" Type="System.Drawing.Point" />
        <Parameter Name="pt2" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo da linha.</param>
        <param name="pt1">Estrutura <see cref="T:System.Drawing.Point" /> que representa o primeiro ponto de conexão.</param>
        <param name="pt2">Estrutura <see cref="T:System.Drawing.Point" /> que representa o segundo ponto de conexão.</param>
        <summary>Desenha uma linha conectando duas estruturas <see cref="T:System.Drawing.Point" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma caneta preta.  
  
-   Cria pontos para os pontos de extremidade da linha.  
  
-   Desenha a linha para a tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#66](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#66)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#66](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#66)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#66](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#66)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/winforms/advanced/using-a-pen-to-draw-lines-and-shapes.md">Usando uma caneta para desenhar linhas e formas</related>
      </Docs>
    </Member>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public void DrawLine (System.Drawing.Pen pen, System.Drawing.PointF pt1, System.Drawing.PointF pt2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawLine(class System.Drawing.Pen pen, valuetype System.Drawing.PointF pt1, valuetype System.Drawing.PointF pt2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawLine(System.Drawing.Pen,System.Drawing.PointF,System.Drawing.PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawLine(System::Drawing::Pen ^ pen, System::Drawing::PointF pt1, System::Drawing::PointF pt2);" />
      <MemberSignature Language="F#" Value="member this.DrawLine : System.Drawing.Pen * System.Drawing.PointF * System.Drawing.PointF -&gt; unit" Usage="graphics.DrawLine (pen, pt1, pt2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="pt1" Type="System.Drawing.PointF" />
        <Parameter Name="pt2" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo da linha.</param>
        <param name="pt1">Estrutura <see cref="T:System.Drawing.PointF" /> que representa o primeiro ponto de conexão.</param>
        <param name="pt2">Estrutura <see cref="T:System.Drawing.PointF" /> que representa o segundo ponto de conexão.</param>
        <summary>Desenha uma linha conectando duas estruturas <see cref="T:System.Drawing.PointF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método desenha uma linha que conecta os dois pontos especificados pela `pt1` e p`2` parâmetros.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma caneta preta.  
  
-   Cria pontos para os pontos de extremidade da linha.  
  
-   Desenha a linha para a tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#67](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#67)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#67](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#67)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#67](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#67)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/winforms/advanced/using-a-pen-to-draw-lines-and-shapes.md">Usando uma caneta para desenhar linhas e formas</related>
      </Docs>
    </Member>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public void DrawLine (System.Drawing.Pen pen, int x1, int y1, int x2, int y2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawLine(class System.Drawing.Pen pen, int32 x1, int32 y1, int32 x2, int32 y2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawLine(System.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawLine(System::Drawing::Pen ^ pen, int x1, int y1, int x2, int y2);" />
      <MemberSignature Language="F#" Value="member this.DrawLine : System.Drawing.Pen * int * int * int * int -&gt; unit" Usage="graphics.DrawLine (pen, x1, y1, x2, y2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x1" Type="System.Int32" />
        <Parameter Name="y1" Type="System.Int32" />
        <Parameter Name="x2" Type="System.Int32" />
        <Parameter Name="y2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo da linha.</param>
        <param name="x1">A coordenada X do primeiro ponto.</param>
        <param name="y1">A coordenada y do primeiro ponto.</param>
        <param name="x2">A coordenada X do segundo ponto.</param>
        <param name="y2">A coordenada y do segundo ponto.</param>
        <summary>Desenha uma linha que conecta os dois pontos especificados por pares de coordenadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método desenha uma linha que conecta os dois pontos especificados pela `x1`, `y1`, `x2`, e `y2` parâmetros.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma caneta preta.  
  
-   Cria as coordenadas dos pontos de extremidade da linha.  
  
-   Desenha a linha para a tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#68](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#68)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#68](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#68)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#68](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/winforms/advanced/using-a-pen-to-draw-lines-and-shapes.md">Usando uma caneta para desenhar linhas e formas</related>
      </Docs>
    </Member>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public void DrawLine (System.Drawing.Pen pen, float x1, float y1, float x2, float y2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawLine(class System.Drawing.Pen pen, float32 x1, float32 y1, float32 x2, float32 y2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawLine(System.Drawing.Pen,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawLine(System::Drawing::Pen ^ pen, float x1, float y1, float x2, float y2);" />
      <MemberSignature Language="F#" Value="member this.DrawLine : System.Drawing.Pen * single * single * single * single -&gt; unit" Usage="graphics.DrawLine (pen, x1, y1, x2, y2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x1" Type="System.Single" />
        <Parameter Name="y1" Type="System.Single" />
        <Parameter Name="x2" Type="System.Single" />
        <Parameter Name="y2" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo da linha.</param>
        <param name="x1">A coordenada X do primeiro ponto.</param>
        <param name="y1">A coordenada y do primeiro ponto.</param>
        <param name="x2">A coordenada X do segundo ponto.</param>
        <param name="y2">A coordenada y do segundo ponto.</param>
        <summary>Desenha uma linha que conecta os dois pontos especificados por pares de coordenadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método desenha uma linha que conecta os dois pontos especificados pela `x1`, `y1`, `x2`, e `y2` parâmetros.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma caneta preta.  
  
-   Cria as coordenadas dos pontos de extremidade da linha.  
  
-   Desenha a linha para a tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#69](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#69)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#69](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#69)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#69](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/winforms/advanced/using-a-pen-to-draw-lines-and-shapes.md">Usando uma caneta para desenhar linhas e formas</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawLines">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Desenha uma série de segmentos de linha que se conectam a uma matriz de estruturas <see cref="T:System.Drawing.Point" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawLines">
      <MemberSignature Language="C#" Value="public void DrawLines (System.Drawing.Pen pen, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawLines(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawLines(System.Drawing.Pen,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawLines(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawLines : System.Drawing.Pen * System.Drawing.Point[] -&gt; unit" Usage="graphics.DrawLines (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo dos segmentos de linha.</param>
        <param name="points">Matriz de estruturas <see cref="T:System.Drawing.Point" /> que representam os pontos de conexão.</param>
        <summary>Desenha uma série de segmentos de linha que se conectam a uma matriz de estruturas <see cref="T:System.Drawing.Point" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método desenha uma série de linhas que conectam a uma matriz de pontos finais. Os primeiros dois pontos na matriz de especificam a primeira linha. Cada ponto adicional que especifica o final de um segmento de linha cujo ponto de partida é o ponto final do segmento de linha anterior.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma caneta preta.  
  
-   Cria uma matriz de pontos de segmentos de linha.  
  
-   Desenha os segmentos de linha conectados na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#70](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#70)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#70](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#70)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#70](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#70)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="points" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawLines">
      <MemberSignature Language="C#" Value="public void DrawLines (System.Drawing.Pen pen, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawLines(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawLines(System.Drawing.Pen,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawLines(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawLines : System.Drawing.Pen * System.Drawing.PointF[] -&gt; unit" Usage="graphics.DrawLines (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo dos segmentos de linha.</param>
        <param name="points">Matriz de estruturas <see cref="T:System.Drawing.PointF" /> que representam os pontos de conexão.</param>
        <summary>Desenha uma série de segmentos de linha que se conectam a uma matriz de estruturas <see cref="T:System.Drawing.PointF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método desenha uma série de linhas que conectam a uma matriz de pontos finais. Os primeiros dois pontos na matriz de especificam a primeira linha. Cada ponto adicional que especifica o final de um segmento de linha cujo ponto de partida é o ponto final do segmento de linha anterior.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Código cria uma caneta preta.  
  
-   Cria uma matriz de pontos de segmentos de linha.  
  
-   Desenha os segmentos de linha conectados na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#71](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#71)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#71](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#71)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#71](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#71)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="points" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawPath">
      <MemberSignature Language="C#" Value="public void DrawPath (System.Drawing.Pen pen, System.Drawing.Drawing2D.GraphicsPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPath(class System.Drawing.Pen pen, class System.Drawing.Drawing2D.GraphicsPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPath(System.Drawing.Pen,System.Drawing.Drawing2D.GraphicsPath)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPath(System::Drawing::Pen ^ pen, System::Drawing::Drawing2D::GraphicsPath ^ path);" />
      <MemberSignature Language="F#" Value="member this.DrawPath : System.Drawing.Pen * System.Drawing.Drawing2D.GraphicsPath -&gt; unit" Usage="graphics.DrawPath (pen, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="path" Type="System.Drawing.Drawing2D.GraphicsPath" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo do caminho.</param>
        <param name="path"><see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> a ser desenhado.</param>
        <summary>Desenha um <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A transformação atual no contexto do gráfico é aplicada para o <xref:System.Drawing.Drawing2D.GraphicsPath> antes de ela é desenhada.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um objeto de caminho de gráficos e adiciona uma elipse a ele.  
  
-   Cria uma caneta preta.  
  
-   Desenha o caminho de gráficos na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#72](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#72)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#72](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#72)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#72](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#72)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="path" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawPie">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Desenha uma forma de pizza definida por uma elipse especificada por um par de coordenadas, uma largura, uma altura e duas linhas radiais.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawPie">
      <MemberSignature Language="C#" Value="public void DrawPie (System.Drawing.Pen pen, System.Drawing.Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPie(class System.Drawing.Pen pen, valuetype System.Drawing.Rectangle rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPie(System.Drawing.Pen,System.Drawing.Rectangle,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPie(System::Drawing::Pen ^ pen, System::Drawing::Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawPie : System.Drawing.Pen * System.Drawing.Rectangle * single * single -&gt; unit" Usage="graphics.DrawPie (pen, rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo da forma de pizza.</param>
        <param name="rect">Estrutura <see cref="T:System.Drawing.Rectangle" /> que representa o retângulo delimitador que define a elipse da qual a fatia da pizza foi obtida.</param>
        <param name="startAngle">Ângulo medido em graus no sentido horário do eixo x até o primeiro lado da forma de pizza.</param>
        <param name="sweepAngle">Ângulo medido em graus no sentido horário do parâmetro <paramref name="startAngle" /> para o segundo lado da forma de pizza.</param>
        <summary>Desenha uma forma de pizza definida por uma reticência especificada por uma estrutura <see cref="T:System.Drawing.Rectangle" /> e duas linhas radiais.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método desenha uma forma de pizza definida por um arco de uma elipse e as duas linhas radiais que fazem interseção com os pontos de extremidade do arco. A elipse é definida pelo retângulo delimitador. A forma de pizza consiste em duas linhas radiais definidas pelos `startAngle` e `sweepAngle` parâmetros e o arco entre as interseções dessas linhas radial com a elipse.  
  
 Se o `sweepAngle` parâmetro é maior que 360 graus ou menor que-360 graus, ele será tratado como se fosse 360 graus ou -360 graus, respectivamente.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma caneta preta.  
  
-   Cria um retângulo que delimita uma elipse completa.  
  
-   Define os ângulos no qual iniciar desenho (em relação ao eixo x) e por meio do qual desenhar (tanto no sentido horário).  
  
-   Desenha o segmento de pizza na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#73](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#73)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#73](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#73)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#73](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#73)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawPie">
      <MemberSignature Language="C#" Value="public void DrawPie (System.Drawing.Pen pen, System.Drawing.RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPie(class System.Drawing.Pen pen, valuetype System.Drawing.RectangleF rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPie(System.Drawing.Pen,System.Drawing.RectangleF,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPie(System::Drawing::Pen ^ pen, System::Drawing::RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawPie : System.Drawing.Pen * System.Drawing.RectangleF * single * single -&gt; unit" Usage="graphics.DrawPie (pen, rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo da forma de pizza.</param>
        <param name="rect">Estrutura <see cref="T:System.Drawing.RectangleF" /> que representa o retângulo delimitador que define a elipse da qual a fatia da pizza foi obtida.</param>
        <param name="startAngle">Ângulo medido em graus no sentido horário do eixo x até o primeiro lado da forma de pizza.</param>
        <param name="sweepAngle">Ângulo medido em graus no sentido horário do parâmetro <paramref name="startAngle" /> para o segundo lado da forma de pizza.</param>
        <summary>Desenha uma forma de pizza definida por uma reticência especificada por uma estrutura <see cref="T:System.Drawing.RectangleF" /> e duas linhas radiais.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método desenha uma forma de pizza definida por um arco de uma elipse e as duas linhas radiais que fazem interseção com os pontos de extremidade do arco. A elipse é definida pelo retângulo delimitador. A forma de pizza consiste em duas linhas radiais definidas pelos `startAngle` e `sweepAngle` parâmetros e o arco entre as interseções dessas linhas radial com a elipse.  
  
 Se o `sweepAngle` parâmetro é maior que 360 graus ou menor que-360 graus, ele será tratado como se fosse 360 graus ou -360 graus, respectivamente.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma caneta preta.  
  
-   Cria um retângulo que delimita uma elipse completa.  
  
-   Define os ângulos no qual iniciar desenho (em relação ao eixo x) e por meio do qual desenhar (tanto no sentido horário).  
  
-   Desenha o segmento de pizza na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#74](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#74)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#74](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#74)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#74](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#74)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawPie">
      <MemberSignature Language="C#" Value="public void DrawPie (System.Drawing.Pen pen, int x, int y, int width, int height, int startAngle, int sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPie(class System.Drawing.Pen pen, int32 x, int32 y, int32 width, int32 height, int32 startAngle, int32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPie(System.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPie(System::Drawing::Pen ^ pen, int x, int y, int width, int height, int startAngle, int sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawPie : System.Drawing.Pen * int * int * int * int * int * int -&gt; unit" Usage="graphics.DrawPie (pen, x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="startAngle" Type="System.Int32" />
        <Parameter Name="sweepAngle" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo da forma de pizza.</param>
        <param name="x">A coordenada X do canto superior esquerdo do retângulo delimitador que define a elipse de onde vem a forma de pizza.</param>
        <param name="y">A coordenada Y do canto superior esquerdo do retângulo delimitador que define a elipse de onde vem a forma de pizza.</param>
        <param name="width">A largura do retângulo delimitador que define a elipse da qual vem a forma de pizza.</param>
        <param name="height">A altura do retângulo delimitador que define a elipse da qual vem a forma de pizza.</param>
        <param name="startAngle">Ângulo medido em graus no sentido horário do eixo x até o primeiro lado da forma de pizza.</param>
        <param name="sweepAngle">Ângulo medido em graus no sentido horário do parâmetro <paramref name="startAngle" /> para o segundo lado da forma de pizza.</param>
        <summary>Desenha uma forma de pizza definida por uma elipse especificada por um par de coordenadas, uma largura, uma altura e duas linhas radiais.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método desenha uma forma de pizza definida por um arco de uma elipse e as duas linhas radiais que fazem interseção com os pontos de extremidade do arco. A elipse é definida por descrito pelo retângulo delimitador do `x`, `y`, `width`, e `height` parâmetros. A forma de pizza consiste em duas linhas radiais definidas pelos `startAngle` e `sweepAngle` parâmetros e o arco entre as interseções dessas linhas radial com a elipse.  
  
 Se o `sweepAngle` parâmetro é maior que 360 graus ou menor que-360 graus, ele será tratado como se fosse 360 graus ou -360 graus, respectivamente.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma caneta preta.  
  
-   Cria a posição e tamanho de um retângulo que delimita uma elipse completa.  
  
-   Define os ângulos no qual iniciar desenho (em relação ao eixo x) e por meio do qual desenhar (tanto no sentido horário).  
  
-   Desenha a forma de pizza na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#75](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#75)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#75](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#75)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#75](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#75)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawPie">
      <MemberSignature Language="C#" Value="public void DrawPie (System.Drawing.Pen pen, float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPie(class System.Drawing.Pen pen, float32 x, float32 y, float32 width, float32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPie(System.Drawing.Pen,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPie(System::Drawing::Pen ^ pen, float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawPie : System.Drawing.Pen * single * single * single * single * single * single -&gt; unit" Usage="graphics.DrawPie (pen, x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo da forma de pizza.</param>
        <param name="x">A coordenada X do canto superior esquerdo do retângulo delimitador que define a elipse de onde vem a forma de pizza.</param>
        <param name="y">A coordenada Y do canto superior esquerdo do retângulo delimitador que define a elipse de onde vem a forma de pizza.</param>
        <param name="width">A largura do retângulo delimitador que define a elipse da qual vem a forma de pizza.</param>
        <param name="height">A altura do retângulo delimitador que define a elipse da qual vem a forma de pizza.</param>
        <param name="startAngle">Ângulo medido em graus no sentido horário do eixo x até o primeiro lado da forma de pizza.</param>
        <param name="sweepAngle">Ângulo medido em graus no sentido horário do parâmetro <paramref name="startAngle" /> para o segundo lado da forma de pizza.</param>
        <summary>Desenha uma forma de pizza definida por uma elipse especificada por um par de coordenadas, uma largura, uma altura e duas linhas radiais.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método desenha uma forma de pizza definida por um arco de uma elipse e as duas linhas radiais que fazem interseção com os pontos de extremidade do arco. A elipse é definida por descrito pelo retângulo delimitador do `x`, `y`, `width`, e `height` parâmetros. A forma de pizza consiste em duas linhas radiais definidas pelos `startAngle` e `sweepAngle` parâmetros e o arco entre as interseções dessas linhas radial com a elipse.  
  
 Se o `sweepAngle` parâmetro é maior que 360 graus ou menor que-360 graus, ele será tratado como se fosse 360 graus ou -360 graus, respectivamente.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma caneta preta.  
  
-   Cria a posição e tamanho de um retângulo que delimita uma elipse completa.  
  
-   Define os ângulos no qual iniciar desenho (em relação ao eixo x) e por meio do qual desenhar (tanto no sentido horário).  
  
-   Desenha o segmento de pizza na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#76](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#76)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#76](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#76)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#76](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#76)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawPolygon">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Desenha um polígono definido por uma matriz de estruturas <see cref="T:System.Drawing.Point" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawPolygon">
      <MemberSignature Language="C#" Value="public void DrawPolygon (System.Drawing.Pen pen, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPolygon(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPolygon(System.Drawing.Pen,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPolygon(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawPolygon : System.Drawing.Pen * System.Drawing.Point[] -&gt; unit" Usage="graphics.DrawPolygon (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo do polígono.</param>
        <param name="points">Matriz de estruturas <see cref="T:System.Drawing.Point" /> que representa os vértices do polígono.</param>
        <summary>Desenha um polígono definido por uma matriz de estruturas <see cref="T:System.Drawing.Point" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada par de dois pontos consecutivos da matriz Especifica um lado do polígono. Além disso, se o último ponto e o primeiro ponto da matriz não coincidem, elas especificam o último lado do polígono.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma caneta preta.  
  
-   Cria uma matriz de sete pontos para os vértices do polígono.  
  
-   Desenha um polígono na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#78](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#78)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#78](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#78)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#78](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#78)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawPolygon">
      <MemberSignature Language="C#" Value="public void DrawPolygon (System.Drawing.Pen pen, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPolygon(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPolygon(System.Drawing.Pen,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPolygon(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawPolygon : System.Drawing.Pen * System.Drawing.PointF[] -&gt; unit" Usage="graphics.DrawPolygon (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo do polígono.</param>
        <param name="points">Matriz de estruturas <see cref="T:System.Drawing.PointF" /> que representa os vértices do polígono.</param>
        <summary>Desenha um polígono definido por uma matriz de estruturas <see cref="T:System.Drawing.PointF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada par de dois pontos consecutivos da matriz Especifica um lado do polígono. Além disso, se o último ponto e o primeiro ponto de matriz não coincidem, elas especificam o último lado do polígono.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma caneta preta.  
  
-   Cria uma matriz de sete pontos para os vértices do polígono.  
  
-   Desenha um polígono na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#77](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#77)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#77](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#77)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#77](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#77)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="points" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawRectangle">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Desenha um retângulo especificado por um par de coordenadas, uma largura e uma altura.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawRectangle">
      <MemberSignature Language="C#" Value="public void DrawRectangle (System.Drawing.Pen pen, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawRectangle(class System.Drawing.Pen pen, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawRectangle(System.Drawing.Pen,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawRectangle(System::Drawing::Pen ^ pen, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.DrawRectangle : System.Drawing.Pen * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawRectangle (pen, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="pen">Um <see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo do retângulo.</param>
        <param name="rect">Uma estrutura <see cref="T:System.Drawing.Rectangle" /> que representa o retângulo a ser desenhado.</param>
        <summary>Desenha um retângulo especificado por uma estrutura <see cref="T:System.Drawing.Rectangle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter informações sobre como desenhar um <xref:System.Drawing.RectangleF>, consulte <xref:System.Drawing.Graphics.DrawRectangles%28System.Drawing.Pen%2CSystem.Drawing.RectangleF%5B%5D%29>.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma caneta preta.  
  
-   Cria um retângulo.  
  
-   Desenha o retângulo para a tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#79](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#79)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#79](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#79)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#79](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#79)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawRectangle">
      <MemberSignature Language="C#" Value="public void DrawRectangle (System.Drawing.Pen pen, int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawRectangle(class System.Drawing.Pen pen, int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawRectangle(System.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawRectangle(System::Drawing::Pen ^ pen, int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.DrawRectangle : System.Drawing.Pen * int * int * int * int -&gt; unit" Usage="graphics.DrawRectangle (pen, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo do retângulo.</param>
        <param name="x">A coordenada X do canto superior esquerdo do retângulo a ser desenhado.</param>
        <param name="y">A coordenada y do canto superior esquerdo do retângulo a ser desenhado.</param>
        <param name="width">A largura do retângulo a ser desenhado.</param>
        <param name="height">A altura do retângulo a ser desenhado.</param>
        <summary>Desenha um retângulo especificado por um par de coordenadas, uma largura e uma altura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter informações sobre como desenhar um <xref:System.Drawing.RectangleF>, consulte <xref:System.Drawing.Graphics.DrawRectangles%28System.Drawing.Pen%2CSystem.Drawing.RectangleF%5B%5D%29>.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma caneta preta.  
  
-   Cria a posição e tamanho de um retângulo.  
  
-   Desenha o retângulo para a tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#80](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#80)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#80](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#80)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#80](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#80)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawRectangle">
      <MemberSignature Language="C#" Value="public void DrawRectangle (System.Drawing.Pen pen, float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawRectangle(class System.Drawing.Pen pen, float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawRectangle(System.Drawing.Pen,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawRectangle(System::Drawing::Pen ^ pen, float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.DrawRectangle : System.Drawing.Pen * single * single * single * single -&gt; unit" Usage="graphics.DrawRectangle (pen, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">Um <see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo do retângulo.</param>
        <param name="x">A coordenada X do canto superior esquerdo do retângulo a ser desenhada.</param>
        <param name="y">A coordenada y do canto superior esquerdo do retângulo a ser desenhada.</param>
        <param name="width">A largura do retângulo a ser desenhada.</param>
        <param name="height">A altura do retângulo a ser desenhada.</param>
        <summary>Desenha um retângulo especificado por um par de coordenadas, uma largura e uma altura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter informações sobre como desenhar um <xref:System.Drawing.RectangleF>, consulte <xref:System.Drawing.Graphics.DrawRectangles%28System.Drawing.Pen%2CSystem.Drawing.RectangleF%5B%5D%29>.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma caneta preta.  
  
-   Cria a posição e tamanho de um retângulo.  
  
-   Desenha o retângulo para a tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#81](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#81)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#81](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#81)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#81](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#81)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawRectangles">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Desenha uma série de retângulos especificados por estruturas de <see cref="T:System.Drawing.Rectangle" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawRectangles">
      <MemberSignature Language="C#" Value="public void DrawRectangles (System.Drawing.Pen pen, System.Drawing.Rectangle[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawRectangles(class System.Drawing.Pen pen, valuetype System.Drawing.Rectangle[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawRectangles(System.Drawing.Pen,System.Drawing.Rectangle[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawRectangles(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Rectangle&gt; ^ rects);" />
      <MemberSignature Language="F#" Value="member this.DrawRectangles : System.Drawing.Pen * System.Drawing.Rectangle[] -&gt; unit" Usage="graphics.DrawRectangles (pen, rects)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rects" Type="System.Drawing.Rectangle[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo dos contornos dos retângulos.</param>
        <param name="rects">Uma matriz de estruturas <see cref="T:System.Drawing.Rectangle" /> que representa os retângulos a serem desenhados.</param>
        <summary>Desenha uma série de retângulos especificados por estruturas de <see cref="T:System.Drawing.Rectangle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma caneta preta.  
  
-   Cria uma matriz de três retângulos.  
  
-   Desenha os retângulos na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#82](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#82)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#82](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#82)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#82](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="rects" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rects" /> é uma matriz de tamanho zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawRectangles">
      <MemberSignature Language="C#" Value="public void DrawRectangles (System.Drawing.Pen pen, System.Drawing.RectangleF[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawRectangles(class System.Drawing.Pen pen, valuetype System.Drawing.RectangleF[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawRectangles(System.Drawing.Pen,System.Drawing.RectangleF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawRectangles(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::RectangleF&gt; ^ rects);" />
      <MemberSignature Language="F#" Value="member this.DrawRectangles : System.Drawing.Pen * System.Drawing.RectangleF[] -&gt; unit" Usage="graphics.DrawRectangles (pen, rects)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rects" Type="System.Drawing.RectangleF[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina a cor, a largura e o estilo dos contornos dos retângulos.</param>
        <param name="rects">Uma matriz de estruturas <see cref="T:System.Drawing.RectangleF" /> que representa os retângulos a serem desenhados.</param>
        <summary>Desenha uma série de retângulos especificados por estruturas de <see cref="T:System.Drawing.RectangleF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma caneta preta.  
  
-   Cria uma matriz de três retângulos.  
  
-   Desenha os retângulos na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#83](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#83)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#83](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#83)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#83](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#83)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="rects" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rects" /> é uma matriz de tamanho zero.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawString">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Desenha a cadeia de texto especificada no local especificado com os objetos <see cref="T:System.Drawing.Brush" /> e <see cref="T:System.Drawing.Font" /> especificados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public void DrawString (string s, System.Drawing.Font font, System.Drawing.Brush brush, System.Drawing.PointF point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawString(string s, class System.Drawing.Font font, class System.Drawing.Brush brush, valuetype System.Drawing.PointF point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Drawing.PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawString(System::String ^ s, System::Drawing::Font ^ font, System::Drawing::Brush ^ brush, System::Drawing::PointF point);" />
      <MemberSignature Language="F#" Value="member this.DrawString : string * System.Drawing.Font * System.Drawing.Brush * System.Drawing.PointF -&gt; unit" Usage="graphics.DrawString (s, font, brush, point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="point" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="s">Cadeia de caracteres a ser extraída.</param>
        <param name="font"><see cref="T:System.Drawing.Font" /> que define o formato de texto da cadeia de caracteres.</param>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina a cor e a textura do texto extraído.</param>
        <param name="point">Estrutura <see cref="T:System.Drawing.PointF" /> que especifica o canto superior esquerdo do texto desenhado.</param>
        <summary>Desenha a cadeia de texto especificada no local especificado com os objetos <see cref="T:System.Drawing.Brush" /> e <see cref="T:System.Drawing.Font" /> especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma cadeia de caracteres de texto para desenhar.  
  
-   Define a fonte como Arial (16 pt).  
  
-   Cria um pincel sólido, preto para desenhar com.  
  
-   Cria um ponto para o canto superior esquerdo, na qual desenhar o texto.  
  
-   Desenha a cadeia de caracteres para a tela usando a fonte, Pincel e ponto de destino.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#84](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#84)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#84](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#84)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#84](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#84)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="s" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.DrawText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Point,System.Drawing.Color)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Usando fontes e texto</related>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public void DrawString (string s, System.Drawing.Font font, System.Drawing.Brush brush, System.Drawing.RectangleF layoutRectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawString(string s, class System.Drawing.Font font, class System.Drawing.Brush brush, valuetype System.Drawing.RectangleF layoutRectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Drawing.RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawString(System::String ^ s, System::Drawing::Font ^ font, System::Drawing::Brush ^ brush, System::Drawing::RectangleF layoutRectangle);" />
      <MemberSignature Language="F#" Value="member this.DrawString : string * System.Drawing.Font * System.Drawing.Brush * System.Drawing.RectangleF -&gt; unit" Usage="graphics.DrawString (s, font, brush, layoutRectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="layoutRectangle" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="s">Cadeia de caracteres a ser extraída.</param>
        <param name="font"><see cref="T:System.Drawing.Font" /> que define o formato de texto da cadeia de caracteres.</param>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina a cor e a textura do texto extraído.</param>
        <param name="layoutRectangle">Estrutura <see cref="T:System.Drawing.RectangleF" /> que especifica o local do texto extraído.</param>
        <summary>Desenha a cadeia de texto especificada no retângulo especificado com os objetos <see cref="T:System.Drawing.Brush" /> e <see cref="T:System.Drawing.Font" /> especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O texto representado pelo `s` parâmetro é desenhado dentro do retângulo representado pelo `layoutRectangle` parâmetro. Se o texto não couber dentro do retângulo, ela será truncada na palavra mais próxima. Para manipular ainda mais como a cadeia de caracteres é desenhada dentro do retângulo uso a <xref:System.Drawing.Graphics.DrawString%2A> sobrecarga que utiliza um <xref:System.Drawing.StringFormat>.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma cadeia de caracteres de texto para desenhar.  
  
-   Define a fonte como Arial (16 pt).  
  
-   Cria um pincel sólido, preto para desenhar com.  
  
-   Cria um retângulo no qual desenhar o texto.  
  
-   Desenha o retângulo para a tela.  
  
-   Desenha a cadeia de caracteres para a tela usando a fonte, Pincel e retângulo de destino.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#86](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#86)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#86](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#86)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#86](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#86)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="s" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.DrawText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Point,System.Drawing.Color)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Usando fontes e texto</related>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public void DrawString (string s, System.Drawing.Font font, System.Drawing.Brush brush, System.Drawing.PointF point, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawString(string s, class System.Drawing.Font font, class System.Drawing.Brush brush, valuetype System.Drawing.PointF point, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Drawing.PointF,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawString(System::String ^ s, System::Drawing::Font ^ font, System::Drawing::Brush ^ brush, System::Drawing::PointF point, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.DrawString : string * System.Drawing.Font * System.Drawing.Brush * System.Drawing.PointF * System.Drawing.StringFormat -&gt; unit" Usage="graphics.DrawString (s, font, brush, point, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="point" Type="System.Drawing.PointF" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">Cadeia de caracteres a ser extraída.</param>
        <param name="font"><see cref="T:System.Drawing.Font" /> que define o formato de texto da cadeia de caracteres.</param>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina a cor e a textura do texto extraído.</param>
        <param name="point">Estrutura <see cref="T:System.Drawing.PointF" /> que especifica o canto superior esquerdo do texto desenhado.</param>
        <param name="format"><see cref="T:System.Drawing.StringFormat" /> que especifica os atributos de formatação, como espaçamento de linha e alinhamento, que são aplicados ao texto desenhado.</param>
        <summary>Desenha a cadeia de texto especificada na localização com os objetos <see cref="T:System.Drawing.Brush" /> e <see cref="T:System.Drawing.Font" /> especificados usando os atributos de formatação do <see cref="T:System.Drawing.StringFormat" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma cadeia de caracteres de texto para desenhar.  
  
-   Define a fonte como Arial (16 pt).  
  
-   Cria um pincel sólido, preto para desenhar com.  
  
-   Cria um ponto para o canto superior esquerdo, na qual desenhar o texto.  
  
-   Define o formato da cadeia de caracteres para desenhar verticalmente.  
  
-   Desenha a cadeia de caracteres para a tela usando a fonte, pincel, ponto de destino e formato.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#85](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#85)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#85](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#85)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#85](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#85)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="s" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.DrawText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Point,System.Drawing.Color)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Usando fontes e texto</related>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public void DrawString (string s, System.Drawing.Font font, System.Drawing.Brush brush, System.Drawing.RectangleF layoutRectangle, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawString(string s, class System.Drawing.Font font, class System.Drawing.Brush brush, valuetype System.Drawing.RectangleF layoutRectangle, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawString(System::String ^ s, System::Drawing::Font ^ font, System::Drawing::Brush ^ brush, System::Drawing::RectangleF layoutRectangle, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.DrawString : string * System.Drawing.Font * System.Drawing.Brush * System.Drawing.RectangleF * System.Drawing.StringFormat -&gt; unit" Usage="graphics.DrawString (s, font, brush, layoutRectangle, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="layoutRectangle" Type="System.Drawing.RectangleF" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">Cadeia de caracteres a ser extraída.</param>
        <param name="font"><see cref="T:System.Drawing.Font" /> que define o formato de texto da cadeia de caracteres.</param>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina a cor e a textura do texto extraído.</param>
        <param name="layoutRectangle">Estrutura <see cref="T:System.Drawing.RectangleF" /> que especifica o local do texto extraído.</param>
        <param name="format"><see cref="T:System.Drawing.StringFormat" /> que especifica os atributos de formatação, como espaçamento de linha e alinhamento, que são aplicados ao texto desenhado.</param>
        <summary>Desenha a cadeia de texto especificada no retângulo especificado com os objetos <see cref="T:System.Drawing.Brush" /> e <see cref="T:System.Drawing.Font" /> especificados usando os atributos de formatação do <see cref="T:System.Drawing.StringFormat" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O texto representado pelo `s` parâmetro é desenhado dentro do retângulo representado pelo `layoutRectangle` parâmetro. Se o texto não couber dentro do retângulo, ela será truncada em palavra mais próxima, a menos que especificado de outra forma com o `format` parâmetro.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma cadeia de caracteres de texto para desenhar.  
  
-   Define a fonte como Arial (16 pt).  
  
-   Cria um pincel sólido, preto para desenhar com.  
  
-   Cria um retângulo no qual desenhar o texto.  
  
-   Desenha o retângulo para a tela.  
  
-   Define o formato da cadeia de caracteres para centralizá-la dentro do retângulo.  
  
-   Desenha a cadeia de caracteres para a tela usando a fonte, Pincel e retângulo de destino.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#87](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#87)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#87](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#87)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#87](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="s" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.DrawText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Point,System.Drawing.Color)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Usando fontes e texto</related>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public void DrawString (string s, System.Drawing.Font font, System.Drawing.Brush brush, float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawString(string s, class System.Drawing.Font font, class System.Drawing.Brush brush, float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawString(System::String ^ s, System::Drawing::Font ^ font, System::Drawing::Brush ^ brush, float x, float y);" />
      <MemberSignature Language="F#" Value="member this.DrawString : string * System.Drawing.Font * System.Drawing.Brush * single * single -&gt; unit" Usage="graphics.DrawString (s, font, brush, x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="s">Cadeia de caracteres a ser extraída.</param>
        <param name="font"><see cref="T:System.Drawing.Font" /> que define o formato de texto da cadeia de caracteres.</param>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina a cor e a textura do texto extraído.</param>
        <param name="x">A coordenada X do canto superior esquerdo do texto desenhado.</param>
        <param name="y">A coordenada Y do canto superior esquerdo do texto desenhado.</param>
        <summary>Desenha a cadeia de texto especificada no local especificado com os objetos <see cref="T:System.Drawing.Brush" /> e <see cref="T:System.Drawing.Font" /> especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma cadeia de caracteres de texto para desenhar.  
  
-   Define a fonte como Arial (16 pt).  
  
-   Cria um pincel preto sólido para desenhar com.  
  
-   Cria um ponto para o canto superior esquerdo, na qual desenhar o texto.  
  
-   Desenha a cadeia de caracteres para a tela usando a fonte, Pincel e ponto de destino.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#88](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#88)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#88](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#88)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#88](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#88)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="s" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.DrawText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Point,System.Drawing.Color)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Usando fontes e texto</related>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public void DrawString (string s, System.Drawing.Font font, System.Drawing.Brush brush, float x, float y, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawString(string s, class System.Drawing.Font font, class System.Drawing.Brush brush, float32 x, float32 y, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Single,System.Single,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawString(System::String ^ s, System::Drawing::Font ^ font, System::Drawing::Brush ^ brush, float x, float y, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.DrawString : string * System.Drawing.Font * System.Drawing.Brush * single * single * System.Drawing.StringFormat -&gt; unit" Usage="graphics.DrawString (s, font, brush, x, y, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">Cadeia de caracteres a ser extraída.</param>
        <param name="font"><see cref="T:System.Drawing.Font" /> que define o formato de texto da cadeia de caracteres.</param>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina a cor e a textura do texto extraído.</param>
        <param name="x">A coordenada X do canto superior esquerdo do texto desenhado.</param>
        <param name="y">A coordenada Y do canto superior esquerdo do texto desenhado.</param>
        <param name="format"><see cref="T:System.Drawing.StringFormat" /> que especifica os atributos de formatação, como espaçamento de linha e alinhamento, que são aplicados ao texto desenhado.</param>
        <summary>Desenha a cadeia de texto especificada na localização com os objetos <see cref="T:System.Drawing.Brush" /> e <see cref="T:System.Drawing.Font" /> especificados usando os atributos de formatação do <see cref="T:System.Drawing.StringFormat" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma cadeia de caracteres de texto para desenhar.  
  
-   Define a fonte como Arial (16 pt).  
  
-   Cria um pincel sólido, preto para desenhar com.  
  
-   Cria as coordenadas de um ponto para o canto superior esquerdo, na qual desenhar o texto.  
  
-   Define o formato da cadeia de caracteres para desenhar verticalmente  
  
-   Desenha a cadeia de caracteres para a tela usando a fonte, pincel, ponto de destino e formato.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#89](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#89)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#89](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#89)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#89](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#89)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="s" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.DrawText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Point,System.Drawing.Color)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Usando fontes e texto</related>
      </Docs>
    </Member>
    <Member MemberName="EndContainer">
      <MemberSignature Language="C#" Value="public void EndContainer (System.Drawing.Drawing2D.GraphicsContainer container);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndContainer(class System.Drawing.Drawing2D.GraphicsContainer container) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EndContainer(System.Drawing.Drawing2D.GraphicsContainer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndContainer (container As GraphicsContainer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndContainer(System::Drawing::Drawing2D::GraphicsContainer ^ container);" />
      <MemberSignature Language="F#" Value="member this.EndContainer : System.Drawing.Drawing2D.GraphicsContainer -&gt; unit" Usage="graphics.EndContainer container" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="container" Type="System.Drawing.Drawing2D.GraphicsContainer" />
      </Parameters>
      <Docs>
        <param name="container"><see cref="T:System.Drawing.Drawing2D.GraphicsContainer" /> que representa o contêiner restaurado por esse método.</param>
        <summary>Fecha o contêiner gráfico atual e restaura o estado deste <see cref="T:System.Drawing.Graphics" /> para o estado salvo por uma chamada ao método <see cref="M:System.Drawing.Graphics.BeginContainer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método com o <xref:System.Drawing.Graphics.BeginContainer%2A> método para criar contêineres de elementos gráficos aninhados. Contêineres de elementos gráficos reter estado de elementos gráficos, como a transformação, recorte e propriedades de processamento.  
  
 Quando você chama o <xref:System.Drawing.Graphics.BeginContainer%2A> método de um <xref:System.Drawing.Graphics>, um bloco de informações que mantém o estado do <xref:System.Drawing.Graphics> é colocado em uma pilha. O <xref:System.Drawing.Graphics.BeginContainer%2A> método retorna um <xref:System.Drawing.Drawing2D.GraphicsContainer> que identifica esse bloco de informações. Quando você passa o objeto de identificação para o <xref:System.Drawing.Graphics.EndContainer%2A> método, o bloco de informações é removido da pilha e é usado para restaurar o <xref:System.Drawing.Graphics> para o estado em que estava no momento do <xref:System.Drawing.Graphics.BeginContainer%2A> chamada de método.  
  
 Contêineres podem ser aninhados. ou seja, você pode chamar o <xref:System.Drawing.Graphics.BeginContainer%2A> método várias vezes antes de chamar o <xref:System.Drawing.Graphics.EndContainer%2A> método. Sempre que você chama o <xref:System.Drawing.Graphics.BeginContainer%2A> método, um bloco de informações é colocado na pilha, e você recebe um <xref:System.Drawing.Drawing2D.GraphicsContainer> para o bloco de informações. Quando você passa um desses objetos para o <xref:System.Drawing.Graphics.EndContainer%2A> método, o <xref:System.Drawing.Graphics> é retornado para o estado em que estava no momento das <xref:System.Drawing.Graphics.BeginContainer%2A> chamada de método que retornou que determinado <xref:System.Drawing.Drawing2D.GraphicsContainer>. O bloco de informações é colocado na pilha de por que <xref:System.Drawing.Graphics.BeginContainer%2A> chamada de método é removida da pilha, e todos os blocos de informações é colocado na pilha depois que <xref:System.Drawing.Graphics.BeginContainer%2A> chamada de método também serão removidos.  
  
 Chamadas para o <xref:System.Drawing.Graphics.Save%2A> blocos de informações de local do método na mesma pilha de chamadas para o <xref:System.Drawing.Graphics.BeginContainer%2A> método. Assim como uma <xref:System.Drawing.Graphics.EndContainer%2A> chamada de método é emparelhada com um <xref:System.Drawing.Graphics.BeginContainer%2A> chamada de método, um <xref:System.Drawing.Graphics.Restore%2A> chamada de método é emparelhada com um <xref:System.Drawing.Graphics.Save%2A> chamada de método.  
  
 Quando você chama o <xref:System.Drawing.Graphics.EndContainer%2A> todos os blocos de informações de método, colocado na pilha de (pelo <xref:System.Drawing.Graphics.Save%2A> método ou o <xref:System.Drawing.Graphics.BeginContainer%2A> método) após a chamada correspondente para o <xref:System.Drawing.Graphics.BeginContainer%2A> método são removidos da pilha. Da mesma forma, quando você chama o <xref:System.Drawing.Graphics.Restore%2A> todos os blocos de informações de método, colocado na pilha de (pelo <xref:System.Drawing.Graphics.Save%2A> método ou o <xref:System.Drawing.Graphics.BeginContainer%2A> método) após a chamada correspondente para o <xref:System.Drawing.Graphics.Save%2A> método são removidos da pilha.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Abre um novo contêiner de elementos gráficos e salva o contêiner antigo.  
  
-   Converte as coordenadas de mundo no contêiner.  
  
-   Preenche um retângulo vermelho a (convertido de coordenadas da) novo contêiner.  
  
-   Fecha o novo contêiner e restaura o contêiner salvo.  
  
-   Preenche um retângulo verde (para as coordenadas não convertidos) do contêiner salvo.  
  
 O resultado é um retângulo verde que overlies um retângulo vermelho do mesmo tamanho.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#90](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#90)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#90](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#90)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#90](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#90)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateMetafile">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Envia os registros do <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, um de cada vez, para um método de retorno de chamada para exibição em um ponto especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point destPoint, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point destPoint, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Point destPoint, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.Point" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destPoint">A estrutura <see cref="T:System.Drawing.Point" /> que especifica o local do canto superior esquerdo do metarquivo desenhado.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <summary>Envia os registros do <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, um de cada vez, para um método de retorno de chamada para exibição em um ponto especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um formulário que tenha um <xref:System.Drawing.Imaging.Metafile> como um dos seus membros privados. O <xref:System.Windows.Forms.Control.OnPaint%2A> chamadas de método <xref:System.Drawing.Graphics.EnumerateMetafile%2A>, que chama o formulário `MetafileCallback` método para cada registro de metarquivo. O `MetafileCallback` chamadas de método a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método. Observe que o `MetafileCallback` método recebe os dados de registro como um <xref:System.IntPtr>, mas o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método espera que os dados de registro para ser uma matriz de bytes. A chamada para <xref:System.Runtime.InteropServices.Marshal.Copy%2A> copia os dados de registro para uma matriz de bytes, para que ele pode ser passado para <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>.  
  
 [!code-csharp[System.Drawing.Graphics.EnumerateMetafile#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Graphics.EnumerateMetafile/CS/Form1.cs#1)]
 [!code-vb[System.Drawing.Graphics.EnumerateMetafile#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Graphics.EnumerateMetafile/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point[] destPoints, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point[] destPoints, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point[],System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point[] * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destPoints">Matriz de três estruturas <see cref="T:System.Drawing.Point" /> que definem um paralelogramo que determina o tamanho e o local do metarquivo desenhado.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <summary>Envia os registros do <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, um de cada vez, para um método de retorno de chamada para exibição em um paralelogramo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF destPoint, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF destPoint, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::PointF destPoint, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.PointF" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destPoint">A estrutura <see cref="T:System.Drawing.PointF" /> que especifica o local do canto superior esquerdo do metarquivo desenhado.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <summary>Envia os registros do <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, um de cada vez, para um método de retorno de chamada para exibição em um ponto especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF[] destPoints, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF[] destPoints, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF[],System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF[] * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destPoints">Matriz de três estruturas <see cref="T:System.Drawing.PointF" /> que definem um paralelogramo que determina o tamanho e o local do metarquivo desenhado.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <summary>Envia os registros do <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, um de cada vez, para um método de retorno de chamada para exibição em um paralelogramo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
 O `destPoints` parâmetro especifica três pontos de um paralelogramo. Os três <xref:System.Drawing.PointF> estruturas representarem os cantos superior esquerdo, superior direito e inferior esquerdo do paralelogramo. O quarto ponto é inferido das três primeiras para formar um paralelogramo. Metarquivo desenhado é dimensionado e distorcido para ajustar o paralelogramo.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Rectangle destRect, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Rectangle destRect, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Rectangle,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Rectangle destRect, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Rectangle * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destRect">A estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica o local e o tamanho do metarquivo desenhado.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <summary>Envia os registros do <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, um por vez, para um método de retorno de chamada para exibição em um retângulo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.RectangleF destRect, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.RectangleF destRect, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.RectangleF,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::RectangleF destRect, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.RectangleF * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destRect">A estrutura <see cref="T:System.Drawing.RectangleF" /> que especifica o local e o tamanho do metarquivo desenhado.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <summary>Envia os registros do <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, um por vez, para um método de retorno de chamada para exibição em um retângulo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point destPoint, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point destPoint, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Point destPoint, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.Point" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destPoint">A estrutura <see cref="T:System.Drawing.Point" /> que especifica o local do canto superior esquerdo do metarquivo desenhado.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <param name="callbackData">Ponteiro interno que é necessário, mas ignorado. Você pode passar <see cref="F:System.IntPtr.Zero" /> para esse parâmetro.</param>
        <summary>Envia os registros do <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, um de cada vez, para um método de retorno de chamada para exibição em um ponto especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point[] destPoints, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point[] destPoints, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point[],System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point[] * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destPoints">Matriz de três estruturas <see cref="T:System.Drawing.Point" /> que definem um paralelogramo que determina o tamanho e o local do metarquivo desenhado.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <param name="callbackData">Ponteiro interno que é necessário, mas ignorado. Você pode passar <see cref="F:System.IntPtr.Zero" /> para esse parâmetro.</param>
        <summary>Envia os registros do <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, um de cada vez, para um método de retorno de chamada para exibição em um paralelogramo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF destPoint, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF destPoint, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::PointF destPoint, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.PointF" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destPoint">A estrutura <see cref="T:System.Drawing.PointF" /> que especifica o local do canto superior esquerdo do metarquivo desenhado.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <param name="callbackData">Ponteiro interno que é necessário, mas ignorado. Você pode passar <see cref="F:System.IntPtr.Zero" /> para esse parâmetro.</param>
        <summary>Envia os registros do <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, um de cada vez, para um método de retorno de chamada para exibição em um ponto especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF[] destPoints, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF[] destPoints, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF[],System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF[] * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destPoints">Matriz de três estruturas <see cref="T:System.Drawing.PointF" /> que definem um paralelogramo que determina o tamanho e o local do metarquivo desenhado.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <param name="callbackData">Ponteiro interno que é necessário, mas ignorado. Você pode passar <see cref="F:System.IntPtr.Zero" /> para esse parâmetro.</param>
        <summary>Envia os registros do <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, um de cada vez, para um método de retorno de chamada para exibição em um paralelogramo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
 O `destPoints` parâmetro especifica três pontos de um paralelogramo. Os três <xref:System.Drawing.PointF> estruturas representarem os cantos superior esquerdo, superior direito e inferior esquerdo do paralelogramo. O quarto ponto é inferido das três primeiras para formar um paralelogramo. Metarquivo desenhado é dimensionado e distorcido para ajustar o paralelogramo.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Rectangle destRect, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Rectangle destRect, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Rectangle,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Rectangle destRect, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Rectangle * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destRect">A estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica o local e o tamanho do metarquivo desenhado.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <param name="callbackData">Ponteiro interno que é necessário, mas ignorado. Você pode passar <see cref="F:System.IntPtr.Zero" /> para esse parâmetro.</param>
        <summary>Envia os registros do <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, um por vez, para um método de retorno de chamada para exibição em um retângulo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.RectangleF destRect, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.RectangleF destRect, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.RectangleF,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::RectangleF destRect, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.RectangleF * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destRect">A estrutura <see cref="T:System.Drawing.RectangleF" /> que especifica o local e o tamanho do metarquivo desenhado.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <param name="callbackData">Ponteiro interno que é necessário, mas ignorado. Você pode passar <see cref="F:System.IntPtr.Zero" /> para esse parâmetro.</param>
        <summary>Envia os registros do <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, um por vez, para um método de retorno de chamada para exibição em um retângulo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point destPoint, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point destPoint, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Point destPoint, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.Point" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destPoint">A estrutura <see cref="T:System.Drawing.Point" /> que especifica o local do canto superior esquerdo do metarquivo desenhado.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <param name="callbackData">Ponteiro interno que é necessário, mas ignorado. Você pode passar <see cref="F:System.IntPtr.Zero" /> para esse parâmetro.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica informações de atributo de imagem para a imagem desenhada.</param>
        <summary>Envia os registros do <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, um de cada vez, para um método de retorno de chamada para exibição em um ponto especificado usando os atributos de imagem especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point destPoint, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point destPoint, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Point destPoint, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, srcRect, srcUnit, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.Point" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destPoint">A estrutura <see cref="T:System.Drawing.Point" /> que especifica o local do canto superior esquerdo do metarquivo desenhado.</param>
        <param name="srcRect">Estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica a parte do metarquivo, em relação ao seu canto superior esquerdo, a desenhar.</param>
        <param name="srcUnit">Membro da enumeração <see cref="T:System.Drawing.GraphicsUnit" /> que especifica a unidade de medida usada para determinar a parte do metarquivo contida no retângulo especificado pelo parâmetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <summary>Envia os registros em um retângulo selecionado de um <see cref="T:System.Drawing.Imaging.Metafile" />, um de cada vez, para um método de retorno de chamada para exibição em um ponto especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point[] destPoints, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point[] destPoints, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point[],System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point[] * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destPoints">Matriz de três estruturas <see cref="T:System.Drawing.Point" /> que definem um paralelogramo que determina o tamanho e o local do metarquivo desenhado.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <param name="callbackData">Ponteiro interno que é necessário, mas ignorado. Você pode passar <see cref="F:System.IntPtr.Zero" /> para esse parâmetro.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica informações de atributo de imagem para a imagem desenhada.</param>
        <summary>Envia os registros do <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, um de cada vez, para um método de retorno de chamada para exibição em um paralelogramo especificado usando os atributos de imagem especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
 O `destPoints` parâmetro especifica três pontos de um paralelogramo. Os três <xref:System.Drawing.Point> estruturas representarem os cantos superior esquerdo, superior direito e inferior esquerdo do paralelogramo. O quarto ponto é inferido das três primeiras para formar um paralelogramo. Metarquivo desenhado é dimensionado e distorcido para ajustar o paralelogramo.  
  
 Os atributos de imagem especificados pelo `imageAttr` substituição de parâmetro especificados quando o metarquivo foi escrito.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, srcRect, srcUnit, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destPoints">Matriz de três estruturas <see cref="T:System.Drawing.Point" /> que definem um paralelogramo que determina o tamanho e o local do metarquivo desenhado.</param>
        <param name="srcRect">Estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica a parte do metarquivo, em relação ao seu canto superior esquerdo, a desenhar.</param>
        <param name="srcUnit">Membro da enumeração <see cref="T:System.Drawing.GraphicsUnit" /> que especifica a unidade de medida usada para determinar a parte do metarquivo contida no retângulo especificado pelo parâmetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <summary>Envia os registros em um retângulo selecionado de um <see cref="T:System.Drawing.Imaging.Metafile" />, um de cada vez, para um método de retorno de chamada para exibição em um paralelogramo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
 O `destPoints` parâmetro especifica três pontos de um paralelogramo. Os três <xref:System.Drawing.Point> estruturas representarem os cantos superior esquerdo, superior direito e inferior esquerdo do paralelogramo. O quarto ponto é inferido das três primeiras para formar um paralelogramo. Metarquivo desenhado é dimensionado e distorcido para ajustar o paralelogramo.  
  
 Qualquer desenho ocorre fora do retângulo especificado pelo `srcRect` parâmetro será ignorado.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF destPoint, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF destPoint, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::PointF destPoint, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.PointF" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destPoint">A estrutura <see cref="T:System.Drawing.PointF" /> que especifica o local do canto superior esquerdo do metarquivo desenhado.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <param name="callbackData">Ponteiro interno que é necessário, mas ignorado. Você pode passar <see cref="F:System.IntPtr.Zero" /> para esse parâmetro.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica informações de atributo de imagem para a imagem desenhada.</param>
        <summary>Envia os registros do <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, um de cada vez, para um método de retorno de chamada para exibição em um ponto especificado usando os atributos de imagem especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo, chamando o método de específicos do <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
 Os atributos de imagem especificados pelo `imageAttr` substituição de parâmetro especificados quando o metarquivo foi escrito.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF destPoint, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF destPoint, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::PointF destPoint, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, srcRect, srcUnit, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.PointF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destPoint">A estrutura <see cref="T:System.Drawing.PointF" /> que especifica o local do canto superior esquerdo do metarquivo desenhado.</param>
        <param name="srcRect">Estrutura <see cref="T:System.Drawing.RectangleF" /> que especifica a parte do metarquivo, em relação ao seu canto superior esquerdo, a desenhar.</param>
        <param name="srcUnit">Membro da enumeração <see cref="T:System.Drawing.GraphicsUnit" /> que especifica a unidade de medida usada para determinar a parte do metarquivo contida no retângulo especificado pelo parâmetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <summary>Envia os registros em um retângulo selecionado de um <see cref="T:System.Drawing.Imaging.Metafile" />, um de cada vez, para um método de retorno de chamada para exibição em um ponto especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
 Qualquer desenho ocorre fora do retângulo especificado pelo `srcRect` parâmetro será ignorado.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF[] destPoints, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF[] destPoints, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF[],System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF[] * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destPoints">Matriz de três estruturas <see cref="T:System.Drawing.PointF" /> que definem um paralelogramo que determina o tamanho e o local do metarquivo desenhado.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <param name="callbackData">Ponteiro interno que é necessário, mas ignorado. Você pode passar <see cref="F:System.IntPtr.Zero" /> para esse parâmetro.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica informações de atributo de imagem para a imagem desenhada.</param>
        <summary>Envia os registros do <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, um de cada vez, para um método de retorno de chamada para exibição em um paralelogramo especificado usando os atributos de imagem especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
 O `destPoints` parâmetro especifica três pontos de um paralelogramo. Os três <xref:System.Drawing.PointF> estruturas representarem os cantos superior esquerdo, superior direito e inferior esquerdo do paralelogramo. O quarto ponto é inferido das três primeiras para formar um paralelogramo. Metarquivo desenhado é dimensionado e distorcido para ajustar o paralelogramo.  
  
 Os atributos de imagem especificados pelo `imageAttr` substituição de parâmetro especificados quando o metarquivo foi escrito.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, srcRect, srcUnit, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destPoints">Matriz de três estruturas <see cref="T:System.Drawing.PointF" /> que definem um paralelogramo que determina o tamanho e o local do metarquivo desenhado.</param>
        <param name="srcRect">Estrutura <see cref="T:System.Drawing.RectangleF" /> que especifica a parte do metarquivo, em relação ao seu canto superior esquerdo, a desenhar.</param>
        <param name="srcUnit">Membro da enumeração <see cref="T:System.Drawing.GraphicsUnit" /> que especifica a unidade de medida usada para determinar a parte do metarquivo contida no retângulo especificado pelo parâmetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <summary>Envia os registros em um retângulo selecionado de um <see cref="T:System.Drawing.Imaging.Metafile" />, um de cada vez, para um método de retorno de chamada para exibição em um paralelogramo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
 O `destPoints` parâmetro especifica três pontos de um paralelogramo. Os três <xref:System.Drawing.Point> estruturas representarem os cantos superior esquerdo, superior direito e inferior esquerdo do paralelogramo. O quarto ponto é inferido das três primeiras para formar um paralelogramo. Metarquivo desenhado é dimensionado e distorcido para ajustar o paralelogramo.  
  
 Qualquer desenho ocorre fora do retângulo especificado pelo `srcRect` parâmetro será ignorado.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Rectangle destRect, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Rectangle destRect, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Rectangle,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Rectangle destRect, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Rectangle * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destRect">A estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica o local e o tamanho do metarquivo desenhado.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <param name="callbackData">Ponteiro interno que é necessário, mas ignorado. Você pode passar <see cref="F:System.IntPtr.Zero" /> para esse parâmetro.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica informações de atributo de imagem para a imagem desenhada.</param>
        <summary>Envia os registros do <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, um de cada vez, para um método de retorno de chamada para exibição em um retângulo especificado usando os atributos de imagem especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
 Os atributos de imagem especificados pelo `imageAttr` substituição de parâmetro especificados quando o metarquivo foi escrito.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Rectangle destRect, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Rectangle destRect, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Rectangle,System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Rectangle destRect, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Rectangle * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, srcRect, srcUnit, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destRect">A estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica o local e o tamanho do metarquivo desenhado.</param>
        <param name="srcRect">Estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica a parte do metarquivo, em relação ao seu canto superior esquerdo, a desenhar.</param>
        <param name="srcUnit">Membro da enumeração <see cref="T:System.Drawing.GraphicsUnit" /> que especifica a unidade de medida usada para determinar a parte do metarquivo contida no retângulo especificado pelo parâmetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <summary>Envia os registros em um retângulo selecionado de um <see cref="T:System.Drawing.Imaging.Metafile" />, um de cada vez, para um método de retorno de chamada para exibição em um retângulo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
 Qualquer desenho ocorre fora do retângulo especificado pelo `srcRect` parâmetro será ignorado.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.RectangleF destRect, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.RectangleF destRect, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.RectangleF,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::RectangleF destRect, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.RectangleF * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destRect">A estrutura <see cref="T:System.Drawing.RectangleF" /> que especifica o local e o tamanho do metarquivo desenhado.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <param name="callbackData">Ponteiro interno que é necessário, mas ignorado. Você pode passar <see cref="F:System.IntPtr.Zero" /> para esse parâmetro.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica informações de atributo de imagem para a imagem desenhada.</param>
        <summary>Envia os registros do <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, um de cada vez, para um método de retorno de chamada para exibição em um retângulo especificado usando os atributos de imagem especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
 Os atributos de imagem especificados pelo `imageAttr` substituição de parâmetro especificados quando o metarquivo foi escrito.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.RectangleF destRect, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.RectangleF destRect, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.RectangleF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::RectangleF destRect, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.RectangleF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, srcRect, srcUnit, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destRect">A estrutura <see cref="T:System.Drawing.RectangleF" /> que especifica o local e o tamanho do metarquivo desenhado.</param>
        <param name="srcRect">Estrutura <see cref="T:System.Drawing.RectangleF" /> que especifica a parte do metarquivo, em relação ao seu canto superior esquerdo, a desenhar.</param>
        <param name="srcUnit">Membro da enumeração <see cref="T:System.Drawing.GraphicsUnit" /> que especifica a unidade de medida usada para determinar a parte do metarquivo contida no retângulo especificado pelo parâmetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <summary>Envia os registros em um retângulo selecionado de um <see cref="T:System.Drawing.Imaging.Metafile" />, um de cada vez, para um método de retorno de chamada para exibição em um retângulo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
 Qualquer desenho ocorre fora do retângulo especificado pelo `srcRect` parâmetro será ignorado.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point destPoint, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point destPoint, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Point destPoint, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, srcRect, srcUnit, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.Point" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destPoint">A estrutura <see cref="T:System.Drawing.Point" /> que especifica o local do canto superior esquerdo do metarquivo desenhado.</param>
        <param name="srcRect">Estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica a parte do metarquivo, em relação ao seu canto superior esquerdo, a desenhar.</param>
        <param name="srcUnit">Membro da enumeração <see cref="T:System.Drawing.GraphicsUnit" /> que especifica a unidade de medida usada para determinar a parte do metarquivo contida no retângulo especificado pelo parâmetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <param name="callbackData">Ponteiro interno que é necessário, mas ignorado. Você pode passar <see cref="F:System.IntPtr.Zero" /> para esse parâmetro.</param>
        <summary>Envia os registros em um retângulo selecionado de um <see cref="T:System.Drawing.Imaging.Metafile" />, um de cada vez, para um método de retorno de chamada para exibição em um ponto especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, srcRect, srcUnit, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destPoints">Matriz de três estruturas <see cref="T:System.Drawing.Point" /> que definem um paralelogramo que determina o tamanho e o local do metarquivo desenhado.</param>
        <param name="srcRect">Estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica a parte do metarquivo, em relação ao seu canto superior esquerdo, a desenhar.</param>
        <param name="srcUnit">Membro da enumeração <see cref="T:System.Drawing.GraphicsUnit" /> que especifica a unidade de medida usada para determinar a parte do metarquivo contida no retângulo especificado pelo parâmetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <param name="callbackData">Ponteiro interno que é necessário, mas ignorado. Você pode passar <see cref="F:System.IntPtr.Zero" /> para esse parâmetro.</param>
        <summary>Envia os registros em um retângulo selecionado de um <see cref="T:System.Drawing.Imaging.Metafile" />, um de cada vez, para um método de retorno de chamada para exibição em um paralelogramo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
 O `destPoints` parâmetro especifica três pontos de um paralelogramo. Os três <xref:System.Drawing.Point> estruturas representarem os cantos superior esquerdo, superior direito e inferior esquerdo do paralelogramo. O quarto ponto é inferido das três primeiras para formar um paralelogramo. Metarquivo desenhado é dimensionado e distorcido para ajustar o paralelogramo.  
  
 Qualquer desenho ocorre fora do retângulo especificado pelo `srcRect` parâmetro será ignorado.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF destPoint, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF destPoint, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::PointF destPoint, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, srcRect, srcUnit, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.PointF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destPoint">A estrutura <see cref="T:System.Drawing.PointF" /> que especifica o local do canto superior esquerdo do metarquivo desenhado.</param>
        <param name="srcRect">Estrutura <see cref="T:System.Drawing.RectangleF" /> que especifica a parte do metarquivo, em relação ao seu canto superior esquerdo, a desenhar.</param>
        <param name="srcUnit">Membro da enumeração <see cref="T:System.Drawing.GraphicsUnit" /> que especifica a unidade de medida usada para determinar a parte do metarquivo contida no retângulo especificado pelo parâmetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <param name="callbackData">Ponteiro interno que é necessário, mas ignorado. Você pode passar <see cref="F:System.IntPtr.Zero" /> para esse parâmetro.</param>
        <summary>Envia os registros em um retângulo selecionado de um <see cref="T:System.Drawing.Imaging.Metafile" />, um de cada vez, para um método de retorno de chamada para exibição em um ponto especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
 Qualquer desenho ocorre fora do retângulo especificado pelo `srcRect` parâmetro será ignorado.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, srcRect, srcUnit, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destPoints">Matriz de três estruturas <see cref="T:System.Drawing.PointF" /> que definem um paralelogramo que determina o tamanho e o local do metarquivo desenhado.</param>
        <param name="srcRect">Estrutura <see cref="T:System.Drawing.RectangleF" /> que especifica a parte do metarquivo, em relação ao seu canto superior esquerdo, a desenhar.</param>
        <param name="srcUnit">Membro da enumeração <see cref="T:System.Drawing.GraphicsUnit" /> que especifica a unidade de medida usada para determinar a parte do metarquivo contida no retângulo especificado pelo parâmetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <param name="callbackData">Ponteiro interno que é necessário, mas ignorado. Você pode passar <see cref="F:System.IntPtr.Zero" /> para esse parâmetro.</param>
        <summary>Envia os registros em um retângulo selecionado de um <see cref="T:System.Drawing.Imaging.Metafile" />, um de cada vez, para um método de retorno de chamada para exibição em um paralelogramo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
 O `destPoints` parâmetro especifica três pontos de um paralelogramo. Os três <xref:System.Drawing.PointF> estruturas representarem os cantos superior esquerdo, superior direito e inferior esquerdo do paralelogramo. O quarto ponto é inferido das três primeiras para formar um paralelogramo. Metarquivo desenhado é dimensionado e distorcido para ajustar o paralelogramo.  
  
 Qualquer desenho ocorre fora do retângulo especificado pelo `srcRect` parâmetro será ignorado.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Rectangle destRect, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Rectangle destRect, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Rectangle,System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Rectangle destRect, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Rectangle * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, srcRect, srcUnit, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destRect">A estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica o local e o tamanho do metarquivo desenhado.</param>
        <param name="srcRect">Estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica a parte do metarquivo, em relação ao seu canto superior esquerdo, a desenhar.</param>
        <param name="srcUnit">Membro da enumeração <see cref="T:System.Drawing.GraphicsUnit" /> que especifica a unidade de medida usada para determinar a parte do metarquivo contida no retângulo especificado pelo parâmetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <param name="callbackData">Ponteiro interno que é necessário, mas ignorado. Você pode passar <see cref="F:System.IntPtr.Zero" /> para esse parâmetro.</param>
        <summary>Envia os registros em um retângulo selecionado de um <see cref="T:System.Drawing.Imaging.Metafile" />, um de cada vez, para um método de retorno de chamada para exibição em um retângulo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
 Qualquer desenho ocorre fora do retângulo especificado pelo `srcRect` parâmetro será ignorado.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.RectangleF destRect, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.RectangleF destRect, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.RectangleF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::RectangleF destRect, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.RectangleF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, srcRect, srcUnit, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destRect">A estrutura <see cref="T:System.Drawing.RectangleF" /> que especifica o local e o tamanho do metarquivo desenhado.</param>
        <param name="srcRect">Estrutura <see cref="T:System.Drawing.RectangleF" /> que especifica a parte do metarquivo, em relação ao seu canto superior esquerdo, a desenhar.</param>
        <param name="srcUnit">Membro da enumeração <see cref="T:System.Drawing.GraphicsUnit" /> que especifica a unidade de medida usada para determinar a parte do metarquivo contida no retângulo especificado pelo parâmetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <param name="callbackData">Ponteiro interno que é necessário, mas ignorado. Você pode passar <see cref="F:System.IntPtr.Zero" /> para esse parâmetro.</param>
        <summary>Envia os registros em um retângulo selecionado de um <see cref="T:System.Drawing.Imaging.Metafile" />, um de cada vez, para um método de retorno de chamada para exibição em um retângulo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo`callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
 Qualquer desenho ocorre fora do retângulo especificado pelo `srcRect` parâmetro será ignorado.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point destPoint, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit unit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point destPoint, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit unit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Point destPoint, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit unit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, srcRect, unit, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.Point" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destPoint">A estrutura <see cref="T:System.Drawing.Point" /> que especifica o local do canto superior esquerdo do metarquivo desenhado.</param>
        <param name="srcRect">Estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica a parte do metarquivo, em relação ao seu canto superior esquerdo, a desenhar.</param>
        <param name="unit">Membro da enumeração <see cref="T:System.Drawing.GraphicsUnit" /> que especifica a unidade de medida usada para determinar a parte do metarquivo contida no retângulo especificado pelo parâmetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <param name="callbackData">Ponteiro interno que é necessário, mas ignorado. Você pode passar <see cref="F:System.IntPtr.Zero" /> para esse parâmetro.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica informações de atributo de imagem para a imagem desenhada.</param>
        <summary>Envia os registros em um retângulo especificado de um <see cref="T:System.Drawing.Imaging.Metafile" />, um de cada vez, para um método de retorno de chamada para exibição em um ponto especificado usando os atributos de imagem especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit unit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit unit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit unit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, srcRect, unit, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destPoints">Matriz de três estruturas <see cref="T:System.Drawing.Point" /> que definem um paralelogramo que determina o tamanho e o local do metarquivo desenhado.</param>
        <param name="srcRect">Estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica a parte do metarquivo, em relação ao seu canto superior esquerdo, a desenhar.</param>
        <param name="unit">Membro da enumeração <see cref="T:System.Drawing.GraphicsUnit" /> que especifica a unidade de medida usada para determinar a parte do metarquivo contida no retângulo especificado pelo parâmetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <param name="callbackData">Ponteiro interno que é necessário, mas ignorado. Você pode passar <see cref="F:System.IntPtr.Zero" /> para esse parâmetro.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica informações de atributo de imagem para a imagem desenhada.</param>
        <summary>Envia os registros em um retângulo especificado de um <see cref="T:System.Drawing.Imaging.Metafile" />, um de cada vez, para um método de retorno de chamada para exibição em um paralelogramo especificado usando os atributos de imagem especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
 O `destPoints` parâmetro especifica três pontos de um paralelogramo. Os três <xref:System.Drawing.Point> estruturas representarem os cantos superior esquerdo, superior direito e inferior esquerdo do paralelogramo. O quarto ponto é inferido das três primeiras para formar um paralelogramo. Metarquivo desenhado é dimensionado e distorcido para ajustar o paralelogramo.  
  
 Qualquer desenho ocorre fora do retângulo especificado pelo `srcRect` parâmetro será ignorado.  
  
 Os atributos de imagem especificados pelo `imageAttr` substituição de parâmetro especificados quando o metarquivo foi escrito.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF destPoint, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit unit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF destPoint, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit unit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::PointF destPoint, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit unit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, srcRect, unit, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.PointF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destPoint">A estrutura <see cref="T:System.Drawing.PointF" /> que especifica o local do canto superior esquerdo do metarquivo desenhado.</param>
        <param name="srcRect">Estrutura <see cref="T:System.Drawing.RectangleF" /> que especifica a parte do metarquivo, em relação ao seu canto superior esquerdo, a desenhar.</param>
        <param name="unit">Membro da enumeração <see cref="T:System.Drawing.GraphicsUnit" /> que especifica a unidade de medida usada para determinar a parte do metarquivo contida no retângulo especificado pelo parâmetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <param name="callbackData">Ponteiro interno que é necessário, mas ignorado. Você pode passar <see cref="F:System.IntPtr.Zero" /> para esse parâmetro.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica informações de atributo de imagem para a imagem desenhada.</param>
        <summary>Envia os registros em um retângulo especificado de um <see cref="T:System.Drawing.Imaging.Metafile" />, um de cada vez, para um método de retorno de chamada para exibição em um ponto especificado usando os atributos de imagem especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
 Qualquer desenho ocorre fora do retângulo especificado pelo `srcRect` parâmetro será ignorado.  
  
 Os atributos de imagem especificados pelo `imageAttr` substituição de parâmetro especificados quando o metarquivo foi escrito.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit unit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit unit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit unit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, srcRect, unit, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destPoints">Matriz de três estruturas <see cref="T:System.Drawing.PointF" /> que definem um paralelogramo que determina o tamanho e o local do metarquivo desenhado.</param>
        <param name="srcRect">Estrutura <see cref="T:System.Drawing.RectangleF" /> que especifica a parte do metarquivo, em relação ao seu canto superior esquerdo, a desenhar.</param>
        <param name="unit">Membro da enumeração <see cref="T:System.Drawing.GraphicsUnit" /> que especifica a unidade de medida usada para determinar a parte do metarquivo contida no retângulo especificado pelo parâmetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <param name="callbackData">Ponteiro interno que é necessário, mas ignorado. Você pode passar <see cref="F:System.IntPtr.Zero" /> para esse parâmetro.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica informações de atributo de imagem para a imagem desenhada.</param>
        <summary>Envia os registros em um retângulo especificado de um <see cref="T:System.Drawing.Imaging.Metafile" />, um de cada vez, para um método de retorno de chamada para exibição em um paralelogramo especificado usando os atributos de imagem especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
 O `destPoints` parâmetro especifica três pontos de um paralelogramo. Os três <xref:System.Drawing.PointF> estruturas representarem os cantos superior esquerdo, superior direito e inferior esquerdo do paralelogramo. O quarto ponto é inferido das três primeiras para formar um paralelogramo. Metarquivo desenhado é dimensionado e distorcido para ajustar o paralelogramo.  
  
 Qualquer desenho ocorre fora do retângulo especificado pelo `srcRect` parâmetro será ignorado.  
  
 Os atributos de imagem especificados pelo `imageAttr` substituição de parâmetro especificados quando o metarquivo foi escrito.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Rectangle destRect, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit unit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Rectangle destRect, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit unit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Rectangle,System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Rectangle destRect, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit unit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Rectangle * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, srcRect, unit, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destRect">A estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica o local e o tamanho do metarquivo desenhado.</param>
        <param name="srcRect">Estrutura <see cref="T:System.Drawing.Rectangle" /> que especifica a parte do metarquivo, em relação ao seu canto superior esquerdo, a desenhar.</param>
        <param name="unit">Membro da enumeração <see cref="T:System.Drawing.GraphicsUnit" /> que especifica a unidade de medida usada para determinar a parte do metarquivo contida no retângulo especificado pelo parâmetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <param name="callbackData">Ponteiro interno que é necessário, mas ignorado. Você pode passar <see cref="F:System.IntPtr.Zero" /> para esse parâmetro.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica informações de atributo de imagem para a imagem desenhada.</param>
        <summary>Envia os registros em um retângulo especificado de um <see cref="T:System.Drawing.Imaging.Metafile" />, um de cada vez, para um método de retorno de chamada para exibição em um retângulo especificado usando os atributos de imagem especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
 Qualquer desenho ocorre fora do retângulo especificado pelo `srcRect` parâmetro será ignorado.  
  
 Os atributos de imagem especificados pelo `imageAttr` substituição de parâmetro especificados quando o metarquivo foi escrito.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.RectangleF destRect, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit unit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.RectangleF destRect, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit unit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.RectangleF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::RectangleF destRect, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit unit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.RectangleF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, srcRect, unit, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> para enumerar.</param>
        <param name="destRect">A estrutura <see cref="T:System.Drawing.RectangleF" /> que especifica o local e o tamanho do metarquivo desenhado.</param>
        <param name="srcRect">Estrutura <see cref="T:System.Drawing.RectangleF" /> que especifica a parte do metarquivo, em relação ao seu canto superior esquerdo, a desenhar.</param>
        <param name="unit">Membro da enumeração <see cref="T:System.Drawing.GraphicsUnit" /> que especifica a unidade de medida usada para determinar a parte do metarquivo contida no retângulo especificado pelo parâmetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado de <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica o método para o qual os registros de metarquivo são enviados.</param>
        <param name="callbackData">Ponteiro interno que é necessário, mas ignorado. Você pode passar <see cref="F:System.IntPtr.Zero" /> para esse parâmetro.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica informações de atributo de imagem para a imagem desenhada.</param>
        <summary>Envia os registros em um retângulo especificado de um <see cref="T:System.Drawing.Imaging.Metafile" />, um de cada vez, para um método de retorno de chamada para exibição em um retângulo especificado usando os atributos de imagem especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método enumera os registros contidos no metarquivo especificado. Cada registro individualmente é enviado para um método de retorno de chamada especificado pelo `callback` parâmetro. Normalmente, as chamadas de método de retorno de chamada a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método "reproduzir", ou desenho, o registro.  
  
 Se o método de retorno de chamada chama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, deverá fazê-lo chamando o <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específico <xref:System.Drawing.Imaging.Metafile> que está sendo enumerado.  
  
 Qualquer desenho ocorre fora do retângulo especificado pelo `srcRect` parâmetro será ignorado.  
  
 Os atributos de imagem especificados pelo `imageAttr` substituição de parâmetro especificados quando o metarquivo foi escrito.  
  
   
  
## Examples  
 Para obter um exemplo de código, consulte <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imagens, bitmaps e metarquivos</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExcludeClip">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Atualiza a região de recorte deste <see cref="T:System.Drawing.Graphics" /> para excluir a área especificada por um <see cref="T:System.Drawing.Rectangle" /> estrutura.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExcludeClip">
      <MemberSignature Language="C#" Value="public void ExcludeClip (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExcludeClip(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ExcludeClip(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExcludeClip (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExcludeClip(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.ExcludeClip : System.Drawing.Rectangle -&gt; unit" Usage="graphics.ExcludeClip rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect"><see cref="T:System.Drawing.Rectangle" /> estrutura que especifica o retângulo para excluir da região de recorte.</param>
        <summary>Atualiza a região de recorte deste <see cref="T:System.Drawing.Graphics" /> para excluir a área especificada por um <see cref="T:System.Drawing.Rectangle" /> estrutura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método exclui a área especificada pela `rect` parâmetro da região de recorte atual e o atribui a área resultante para o <xref:System.Drawing.Graphics.Clip%2A> propriedade deste <xref:System.Drawing.Graphics>.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um pixel 100 pelo retângulo de 100 pixels cujo canto superior esquerdo está na coordenada (100, 100).  
  
-   Cria uma região definida pelo retângulo.  
  
-   Define a região de recorte para excluir a região retangular.  
  
-   Preenche um pixel de 300 por 300 retângulo de pixels cujo canto superior esquerdo está na coordenada (0, 0) com um pincel azul sólido.  
  
 O resultado é um retângulo azul com uma região quadrada em direção a seu canto inferior direito ausente.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#92](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#92)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#92](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#92)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#92](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#92)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExcludeClip">
      <MemberSignature Language="C#" Value="public void ExcludeClip (System.Drawing.Region region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExcludeClip(class System.Drawing.Region region) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ExcludeClip(System.Drawing.Region)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExcludeClip(System::Drawing::Region ^ region);" />
      <MemberSignature Language="F#" Value="member this.ExcludeClip : System.Drawing.Region -&gt; unit" Usage="graphics.ExcludeClip region" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
      </Parameters>
      <Docs>
        <param name="region"><see cref="T:System.Drawing.Region" /> que especifica a região a ser excluída da região de recorte.</param>
        <summary>Atualiza a região de recorte deste <see cref="T:System.Drawing.Graphics" /> para excluir a área especificada por um <see cref="T:System.Drawing.Region" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método exclui a área especificada pela `region` parâmetro da região de recorte atual e o atribui a área resultante para o <xref:System.Drawing.Graphics.Clip%2A> propriedade deste <xref:System.Drawing.Graphics>.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um pixel 100 pelo retângulo de 100 pixels cujo canto superior esquerdo está na coordenada (100, 100).  
  
-   Define a região de recorte para excluir o retângulo.  
  
-   Preenche um pixel de 300 por 300 retângulo de pixels cujo canto superior esquerdo está na coordenada (0, 0) com um pincel azul sólido.  
  
 O resultado é um retângulo azul com uma área quadrada em direção a seu canto inferior direito ausente.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#91](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#91)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#91](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#91)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#91](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#91)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillClosedCurve">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Preenche o interior de uma curva spline cardinal fechada definido por uma matriz de estruturas <see cref="T:System.Drawing.Point" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillClosedCurve">
      <MemberSignature Language="C#" Value="public void FillClosedCurve (System.Drawing.Brush brush, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillClosedCurve(class System.Drawing.Brush brush, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillClosedCurve(System.Drawing.Brush,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillClosedCurve(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.FillClosedCurve : System.Drawing.Brush * System.Drawing.Point[] -&gt; unit" Usage="graphics.FillClosedCurve (brush, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina as características do preenchimento.</param>
        <param name="points">Matriz de estruturas <see cref="T:System.Drawing.Point" /> que definem o spline.</param>
        <summary>Preenche o interior de uma curva spline cardinal fechada definido por uma matriz de estruturas <see cref="T:System.Drawing.Point" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método preenche o interior de um spline cardinal fechado que passa por cada ponto na matriz. Se o último ponto não coincide com o primeiro ponto, um segmento de curva adicionais é adicionado a partir do último ponto até o primeiro ponto para fechá-la.  
  
 A matriz de pontos deve conter pelo menos quatro <xref:System.Drawing.Point> estruturas.  
  
 Esse método usa uma tensão de padrão de 0,5.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um pincel vermelho sólido.  
  
-   Cria uma matriz de quatro pontos para definir um spline.  
  
-   Preenche a curva na tela.  
  
 A curva tem uma tensão de padrão de 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#93](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#93)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#93](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#93)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#93](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#93)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="points" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillClosedCurve">
      <MemberSignature Language="C#" Value="public void FillClosedCurve (System.Drawing.Brush brush, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillClosedCurve(class System.Drawing.Brush brush, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillClosedCurve(System.Drawing.Brush,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillClosedCurve(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.FillClosedCurve : System.Drawing.Brush * System.Drawing.PointF[] -&gt; unit" Usage="graphics.FillClosedCurve (brush, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina as características do preenchimento.</param>
        <param name="points">Matriz de estruturas <see cref="T:System.Drawing.PointF" /> que definem o spline.</param>
        <summary>Preenche o interior de uma curva spline cardinal fechada definido por uma matriz de estruturas <see cref="T:System.Drawing.PointF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método preenche o interior de um spline cardinal fechado que passa por cada ponto na matriz. Se o último ponto não coincide com o primeiro ponto, um segmento de curva adicionais é adicionado a partir do último ponto até o primeiro ponto para fechá-la.  
  
 A matriz de pontos deve conter pelo menos quatro <xref:System.Drawing.PointF> estruturas.  
  
 Esse método usa uma tensão de padrão de 0,5.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um pincel vermelho sólido.  
  
-   Cria uma matriz de quatro pontos para definir um spline.  
  
-   Preenche a curva na tela.  
  
 A curva tem uma tensão de padrão de 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#96](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#96)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#96](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#96)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#96](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#96)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="points" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillClosedCurve">
      <MemberSignature Language="C#" Value="public void FillClosedCurve (System.Drawing.Brush brush, System.Drawing.Point[] points, System.Drawing.Drawing2D.FillMode fillmode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillClosedCurve(class System.Drawing.Brush brush, valuetype System.Drawing.Point[] points, valuetype System.Drawing.Drawing2D.FillMode fillmode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillClosedCurve(System.Drawing.Brush,System.Drawing.Point[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillClosedCurve(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::Point&gt; ^ points, System::Drawing::Drawing2D::FillMode fillmode);" />
      <MemberSignature Language="F#" Value="member this.FillClosedCurve : System.Drawing.Brush * System.Drawing.Point[] * System.Drawing.Drawing2D.FillMode -&gt; unit" Usage="graphics.FillClosedCurve (brush, points, fillmode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="fillmode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina as características do preenchimento.</param>
        <param name="points">Matriz de estruturas <see cref="T:System.Drawing.Point" /> que definem o spline.</param>
        <param name="fillmode">Membro da enumeração <see cref="T:System.Drawing.Drawing2D.FillMode" /> que determina como a curva é preenchida.</param>
        <summary>Preenche o interior de uma curva spline cardinal fechada definido por uma matriz de estruturas <see cref="T:System.Drawing.Point" /> usando o modo de preenchimento especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método preenche o interior de um spline cardinal fechado que passa por cada ponto na matriz. Se o último ponto não coincide com o primeiro ponto, um segmento de curva adicionais é adicionado a partir do último ponto até o primeiro ponto para fechá-la.  
  
 A matriz de pontos deve conter pelo menos quatro <xref:System.Drawing.Point> estruturas.  
  
 Esse método usa uma tensão de padrão de 0,5.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um pincel vermelho sólido.  
  
-   Cria uma matriz de quatro pontos para definir um spline.  
  
-   Define o modo de preenchimento como <xref:System.Drawing.Drawing2D.FillMode.Winding>.  
  
-   Preenche a curva na tela.  
  
 A curva tem uma tensão de padrão de 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#94](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#94)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#94](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#94)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#94](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#94)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="points" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillClosedCurve">
      <MemberSignature Language="C#" Value="public void FillClosedCurve (System.Drawing.Brush brush, System.Drawing.PointF[] points, System.Drawing.Drawing2D.FillMode fillmode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillClosedCurve(class System.Drawing.Brush brush, valuetype System.Drawing.PointF[] points, valuetype System.Drawing.Drawing2D.FillMode fillmode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillClosedCurve(System.Drawing.Brush,System.Drawing.PointF[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillClosedCurve(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::PointF&gt; ^ points, System::Drawing::Drawing2D::FillMode fillmode);" />
      <MemberSignature Language="F#" Value="member this.FillClosedCurve : System.Drawing.Brush * System.Drawing.PointF[] * System.Drawing.Drawing2D.FillMode -&gt; unit" Usage="graphics.FillClosedCurve (brush, points, fillmode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="fillmode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina as características do preenchimento.</param>
        <param name="points">Matriz de estruturas <see cref="T:System.Drawing.PointF" /> que definem o spline.</param>
        <param name="fillmode">Membro da enumeração <see cref="T:System.Drawing.Drawing2D.FillMode" /> que determina como a curva é preenchida.</param>
        <summary>Preenche o interior de uma curva spline cardinal fechada definido por uma matriz de estruturas <see cref="T:System.Drawing.PointF" /> usando o modo de preenchimento especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método preenche o interior de um spline cardinal fechado que passa por cada ponto na matriz. Se o último ponto não coincide com o primeiro ponto, um segmento de curva adicionais é adicionado a partir do último ponto até o primeiro ponto para fechá-la.  
  
 A matriz de pontos deve conter pelo menos quatro <xref:System.Drawing.Point> estruturas.  
  
 Esse método usa uma tensão de padrão de 0,5.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um pincel vermelho sólido.  
  
-   Cria uma matriz de quatro pontos para definir um spline.  
  
-   Define o modo de preenchimento como <xref:System.Drawing.Drawing2D.FillMode.Winding>.  
  
-   Preenche a curva na tela.  
  
 A curva tem uma tensão de padrão de 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#97](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#97)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#97](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#97)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#97](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#97)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="points" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillClosedCurve">
      <MemberSignature Language="C#" Value="public void FillClosedCurve (System.Drawing.Brush brush, System.Drawing.Point[] points, System.Drawing.Drawing2D.FillMode fillmode, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillClosedCurve(class System.Drawing.Brush brush, valuetype System.Drawing.Point[] points, valuetype System.Drawing.Drawing2D.FillMode fillmode, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillClosedCurve(System.Drawing.Brush,System.Drawing.Point[],System.Drawing.Drawing2D.FillMode,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillClosedCurve(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::Point&gt; ^ points, System::Drawing::Drawing2D::FillMode fillmode, float tension);" />
      <MemberSignature Language="F#" Value="member this.FillClosedCurve : System.Drawing.Brush * System.Drawing.Point[] * System.Drawing.Drawing2D.FillMode * single -&gt; unit" Usage="graphics.FillClosedCurve (brush, points, fillmode, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="fillmode" Type="System.Drawing.Drawing2D.FillMode" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina as características do preenchimento.</param>
        <param name="points">Matriz de estruturas <see cref="T:System.Drawing.Point" /> que definem o spline.</param>
        <param name="fillmode">Membro da enumeração <see cref="T:System.Drawing.Drawing2D.FillMode" /> que determina como a curva é preenchida.</param>
        <param name="tension">Valor maior ou igual a 0.0F que especifica a tensão da curva.</param>
        <summary>Preenche o interior de uma curva spline cardinal fechada definido por uma matriz de estruturas <see cref="T:System.Drawing.Point" /> usando a tensão e o modo de preenchimento especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método preenche o interior de um spline cardinal fechado que passa por cada ponto na matriz. Se o último ponto não coincide com o primeiro ponto, um segmento de curva adicionais é adicionado a partir do último ponto até o primeiro ponto para fechá-la.  
  
 A matriz de pontos deve conter pelo menos quatro <xref:System.Drawing.Point> estruturas.  
  
 O `tension` parâmetro determina a forma de spline. Se o valor da `tension` parâmetro é 0.0F, esse método desenha segmentos de linha reta para conectar os pontos. Normalmente, o `tension` parâmetro é menor ou igual a 1.0F. Valores ao longo do 1.0F produzem resultados incomuns.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um pincel vermelho sólido.  
  
-   Cria uma matriz de quatro pontos para definir um spline.  
  
-   Define o modo de preenchimento como <xref:System.Drawing.Drawing2D.FillMode.Winding>.  
  
-   Define a tensão como 1.0.  
  
-   Preenche a curva na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#95](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#95)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#95](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#95)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#95](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#95)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="points" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillClosedCurve">
      <MemberSignature Language="C#" Value="public void FillClosedCurve (System.Drawing.Brush brush, System.Drawing.PointF[] points, System.Drawing.Drawing2D.FillMode fillmode, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillClosedCurve(class System.Drawing.Brush brush, valuetype System.Drawing.PointF[] points, valuetype System.Drawing.Drawing2D.FillMode fillmode, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillClosedCurve(System.Drawing.Brush,System.Drawing.PointF[],System.Drawing.Drawing2D.FillMode,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillClosedCurve(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::PointF&gt; ^ points, System::Drawing::Drawing2D::FillMode fillmode, float tension);" />
      <MemberSignature Language="F#" Value="member this.FillClosedCurve : System.Drawing.Brush * System.Drawing.PointF[] * System.Drawing.Drawing2D.FillMode * single -&gt; unit" Usage="graphics.FillClosedCurve (brush, points, fillmode, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="fillmode" Type="System.Drawing.Drawing2D.FillMode" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="brush">Uma estrutura <see cref="T:System.Drawing.Brush" /> que determina as características do preenchimento.</param>
        <param name="points">Matriz de estruturas <see cref="T:System.Drawing.PointF" /> que definem o spline.</param>
        <param name="fillmode">Membro da enumeração <see cref="T:System.Drawing.Drawing2D.FillMode" /> que determina como a curva é preenchida.</param>
        <param name="tension">Valor maior ou igual a 0.0F que especifica a tensão da curva.</param>
        <summary>Preenche o interior de uma curva spline cardinal fechada definido por uma matriz de estruturas <see cref="T:System.Drawing.PointF" /> usando a tensão e o modo de preenchimento especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método preenche o interior de um spline cardinal fechado que passa por cada ponto na matriz. Se o último ponto não coincide com o primeiro ponto, um segmento de curva adicionais é adicionado a partir do último ponto até o primeiro ponto para fechá-la.  
  
 A matriz de pontos deve conter pelo menos quatro <xref:System.Drawing.Point> estruturas.  
  
 O `tension` parâmetro determina a forma de spline. Se o valor da `tension` parâmetro é 0.0F, esse método desenha segmentos de linha reta para conectar os pontos. Normalmente, o `tension` parâmetro é menor ou igual a 1.0F. Valores ao longo do 1.0F produzem resultados incomuns.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um pincel vermelho sólido.  
  
-   Cria uma matriz de quatro pontos para definir um spline.  
  
-   Define o modo de preenchimento como <xref:System.Drawing.Drawing2D.FillMode.Winding>.  
  
-   Define a tensão como 1.0.  
  
-   Preenche a curva na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#98](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#98)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#98](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#98)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#98](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="points" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillEllipse">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Preenche o interior de uma elipse definida por um retângulo delimitador especificado por um par de coordenadas, uma largura e uma altura.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillEllipse">
      <MemberSignature Language="C#" Value="public void FillEllipse (System.Drawing.Brush brush, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillEllipse(class System.Drawing.Brush brush, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillEllipse(System.Drawing.Brush,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillEllipse(System::Drawing::Brush ^ brush, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.FillEllipse : System.Drawing.Brush * System.Drawing.Rectangle -&gt; unit" Usage="graphics.FillEllipse (brush, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina as características do preenchimento.</param>
        <param name="rect">Estrutura <see cref="T:System.Drawing.Rectangle" /> que representa o retângulo delimitador que define a elipse.</param>
        <summary>Preenche o interior de uma elipse definida por um retângulo delimitador especificado por uma estrutura <see cref="T:System.Drawing.Rectangle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método preenche o interior de uma elipse com um <xref:System.Drawing.Brush>. A elipse é definida pelo retângulo delimitador representado pelo `rect` parâmetro.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um pincel vermelho sólido.  
  
-   Cria um retângulo que delimita uma elipse.  
  
-   Preenche a elipse na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#99](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#99)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#99](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#99)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#99](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#99)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillEllipse">
      <MemberSignature Language="C#" Value="public void FillEllipse (System.Drawing.Brush brush, System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillEllipse(class System.Drawing.Brush brush, valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillEllipse(System.Drawing.Brush,System.Drawing.RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillEllipse(System::Drawing::Brush ^ brush, System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.FillEllipse : System.Drawing.Brush * System.Drawing.RectangleF -&gt; unit" Usage="graphics.FillEllipse (brush, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina as características do preenchimento.</param>
        <param name="rect">Estrutura <see cref="T:System.Drawing.RectangleF" /> que representa o retângulo delimitador que define a elipse.</param>
        <summary>Preenche o interior de uma elipse definida por um retângulo delimitador especificado por uma estrutura <see cref="T:System.Drawing.RectangleF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método preenche o interior de uma elipse com um <xref:System.Drawing.Brush>. A elipse é definida pelo retângulo delimitador representado pelo `rect` parâmetro.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um pincel vermelho sólido.  
  
-   Cria um retângulo que delimita uma elipse.  
  
-   Preenche a elipse na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#100](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#100)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#100](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#100)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#100](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#100)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillEllipse">
      <MemberSignature Language="C#" Value="public void FillEllipse (System.Drawing.Brush brush, int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillEllipse(class System.Drawing.Brush brush, int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillEllipse(System.Drawing.Brush,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillEllipse(System::Drawing::Brush ^ brush, int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.FillEllipse : System.Drawing.Brush * int * int * int * int -&gt; unit" Usage="graphics.FillEllipse (brush, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina as características do preenchimento.</param>
        <param name="x">A coordenada X do canto superior esquerdo do retângulo delimitador que define a elipse.</param>
        <param name="y">A coordenada y do canto superior esquerdo do retângulo delimitador que define a elipse.</param>
        <param name="width">Largura do retângulo delimitador que define a elipse.</param>
        <param name="height">Altura do retângulo delimitador que define a elipse.</param>
        <summary>Preenche o interior de uma elipse definida por um retângulo delimitador especificado por um par de coordenadas, uma largura e uma altura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método preenche o interior de uma elipse com um <xref:System.Drawing.Brush>. A elipse é definida por representada pelo retângulo delimitador do `x`, `y`, `width`, e `height` parâmetros.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um pincel vermelho sólido.  
  
-   Cria o local e o tamanho de um retângulo que delimita uma elipse.  
  
-   Preenche a elipse na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#101](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#101)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#101](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#101)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#101](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#101)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillEllipse">
      <MemberSignature Language="C#" Value="public void FillEllipse (System.Drawing.Brush brush, float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillEllipse(class System.Drawing.Brush brush, float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillEllipse(System.Drawing.Brush,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillEllipse(System::Drawing::Brush ^ brush, float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.FillEllipse : System.Drawing.Brush * single * single * single * single -&gt; unit" Usage="graphics.FillEllipse (brush, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina as características do preenchimento.</param>
        <param name="x">A coordenada X do canto superior esquerdo do retângulo delimitador que define a elipse.</param>
        <param name="y">A coordenada y do canto superior esquerdo do retângulo delimitador que define a elipse.</param>
        <param name="width">Largura do retângulo delimitador que define a elipse.</param>
        <param name="height">Altura do retângulo delimitador que define a elipse.</param>
        <summary>Preenche o interior de uma elipse definida por um retângulo delimitador especificado por um par de coordenadas, uma largura e uma altura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método preenche o interior de uma elipse com um <xref:System.Drawing.Brush>. A elipse é definida por representada pelo retângulo delimitador do `x`, `y`, `width`, e `height` parâmetros.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um pincel vermelho sólido.  
  
-   Cria o local e o tamanho de um retângulo que delimita uma elipse.  
  
-   Preenche a elipse na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#102](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#102)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#102](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#102)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#102](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#102)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillPath">
      <MemberSignature Language="C#" Value="public void FillPath (System.Drawing.Brush brush, System.Drawing.Drawing2D.GraphicsPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPath(class System.Drawing.Brush brush, class System.Drawing.Drawing2D.GraphicsPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPath(System.Drawing.Brush,System.Drawing.Drawing2D.GraphicsPath)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPath(System::Drawing::Brush ^ brush, System::Drawing::Drawing2D::GraphicsPath ^ path);" />
      <MemberSignature Language="F#" Value="member this.FillPath : System.Drawing.Brush * System.Drawing.Drawing2D.GraphicsPath -&gt; unit" Usage="graphics.FillPath (brush, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="path" Type="System.Drawing.Drawing2D.GraphicsPath" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina as características do preenchimento.</param>
        <param name="path"><see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> que representa o caminho a ser preenchido.</param>
        <summary>Preenche o interior de um <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Drawing.Drawing2D.GraphicsPath> consiste em uma série de segmentos de linha e a curva. Se o caminho representado pelo `path` parâmetro não for fechado, um segmento adicional é adicionado do último ponto até o primeiro ponto para fechar o caminho.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um pincel vermelho sólido.  
  
-   Cria um objeto de caminho de gráficos.  
  
-   Adiciona uma elipse ao caminho de gráficos.  
  
-   Preenche o caminho na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#103](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#103)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#103](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#103)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#103](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#103)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="path" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillPie">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Preenche o interior de uma fatia da pizza definida por uma elipse especificada por um par de coordenadas, uma largura, uma altura e duas linhas radiais.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillPie">
      <MemberSignature Language="C#" Value="public void FillPie (System.Drawing.Brush brush, System.Drawing.Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPie(class System.Drawing.Brush brush, valuetype System.Drawing.Rectangle rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPie(System.Drawing.Brush,System.Drawing.Rectangle,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPie(System::Drawing::Brush ^ brush, System::Drawing::Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.FillPie : System.Drawing.Brush * System.Drawing.Rectangle * single * single -&gt; unit" Usage="graphics.FillPie (brush, rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina as características do preenchimento.</param>
        <param name="rect">A estrutura de <see cref="T:System.Drawing.Rectangle" /> que representa o retângulo delimitador que define a elipse de onde provém a fatia da pizza.</param>
        <param name="startAngle">Ângulo em graus medido no sentido horário do eixo x até o primeiro lado da fatia da pizza.</param>
        <param name="sweepAngle">Ângulo em graus medido no sentido horário do parâmetro <paramref name="startAngle" /> até o segundo lado da fatia da pizza.</param>
        <summary>Preenche o interior de uma fatia da pizza definida por uma elipse especificada por uma estrutura de <see cref="T:System.Drawing.RectangleF" /> e duas linhas radiais.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método preenche o interior de uma fatia da pizza definida por um arco de uma elipse e as duas linhas radiais que fazem interseção com os pontos de extremidade do arco. A elipse é definida pelo retângulo delimitador. A fatia da pizza consiste em duas linhas radiais definidas pelos `startAngle` e `sweepAngle` parâmetros e o arco entre as interseções dessas linhas radial com a elipse.  
  
 Se o `sweepAngle` parâmetro é maior que 360 graus ou menor que-360 graus, ele será tratado como se fosse 360 graus ou -360 graus, respectivamente.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um pincel vermelho sólido.  
  
-   Cria um retângulo que delimita uma elipse.  
  
-   Define o ângulo inicial (em relação ao eixo x) e o ângulo de flecha (tanto no sentido horário).  
  
-   Preenche a área em forma de pizza da elipse na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#104](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#104)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#104](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#104)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#104](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#104)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillPie">
      <MemberSignature Language="C#" Value="public void FillPie (System.Drawing.Brush brush, int x, int y, int width, int height, int startAngle, int sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPie(class System.Drawing.Brush brush, int32 x, int32 y, int32 width, int32 height, int32 startAngle, int32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPie(System.Drawing.Brush,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPie(System::Drawing::Brush ^ brush, int x, int y, int width, int height, int startAngle, int sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.FillPie : System.Drawing.Brush * int * int * int * int * int * int -&gt; unit" Usage="graphics.FillPie (brush, x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="startAngle" Type="System.Int32" />
        <Parameter Name="sweepAngle" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina as características do preenchimento.</param>
        <param name="x">A coordenada X do canto superior esquerdo do retângulo delimitador que define a elipse da qual a fatia da pizza é obtida.</param>
        <param name="y">A coordenada Y do canto superior esquerdo do retângulo delimitador que define a elipse da qual a fatia da pizza é obtida.</param>
        <param name="width">A largura do retângulo delimitador que define a elipse da qual a fatia da pizza é obtida.</param>
        <param name="height">A altura do retângulo delimitador que define a elipse da qual a fatia da pizza é obtida.</param>
        <param name="startAngle">Ângulo em graus medido no sentido horário do eixo x até o primeiro lado da fatia da pizza.</param>
        <param name="sweepAngle">Ângulo em graus medido no sentido horário do parâmetro <paramref name="startAngle" /> até o segundo lado da fatia da pizza.</param>
        <summary>Preenche o interior de uma fatia da pizza definida por uma elipse especificada por um par de coordenadas, uma largura, uma altura e duas linhas radiais.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método preenche o interior de uma fatia da pizza definida por um arco de uma elipse e as duas linhas radiais que fazem interseção com os pontos de extremidade do arco. A elipse é definida pelo retângulo delimitador. A fatia da pizza consiste em duas linhas radiais definidas pelos `startAngle` e `sweepAngle` parâmetros e o arco entre as interseções dessas linhas radial com a elipse.  
  
 Se o `sweepAngle` parâmetro é maior que 360 graus ou menor que-360 graus, ele será tratado como se fosse 360 graus ou -360 graus, respectivamente.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um pincel vermelho sólido.  
  
-   Cria o local e o tamanho de um retângulo que delimita uma elipse.  
  
-   Define o ângulo inicial (em relação ao eixo x) e o ângulo de flecha (tanto no sentido horário).  
  
-   Preenche a área em forma de pizza da elipse na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#105](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#105)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#105](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#105)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#105](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#105)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillPie">
      <MemberSignature Language="C#" Value="public void FillPie (System.Drawing.Brush brush, float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPie(class System.Drawing.Brush brush, float32 x, float32 y, float32 width, float32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPie(System.Drawing.Brush,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPie(System::Drawing::Brush ^ brush, float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.FillPie : System.Drawing.Brush * single * single * single * single * single * single -&gt; unit" Usage="graphics.FillPie (brush, x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina as características do preenchimento.</param>
        <param name="x">A coordenada X do canto superior esquerdo do retângulo delimitador que define a elipse da qual a fatia da pizza é obtida.</param>
        <param name="y">A coordenada Y do canto superior esquerdo do retângulo delimitador que define a elipse da qual a fatia da pizza é obtida.</param>
        <param name="width">A largura do retângulo delimitador que define a elipse da qual a fatia da pizza é obtida.</param>
        <param name="height">A altura do retângulo delimitador que define a elipse da qual a fatia da pizza é obtida.</param>
        <param name="startAngle">Ângulo em graus medido no sentido horário do eixo x até o primeiro lado da fatia da pizza.</param>
        <param name="sweepAngle">Ângulo em graus medido no sentido horário do parâmetro <paramref name="startAngle" /> até o segundo lado da fatia da pizza.</param>
        <summary>Preenche o interior de uma fatia da pizza definida por uma elipse especificada por um par de coordenadas, uma largura, uma altura e duas linhas radiais.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método preenche o interior de uma fatia da pizza definida por um arco de uma elipse e as duas linhas radiais que fazem interseção com os pontos de extremidade do arco. A elipse é definida pelo retângulo delimitador. A fatia da pizza consiste em duas linhas radiais definidas pelos `startAngle` e `sweepAngle` parâmetros e o arco entre as interseções dessas linhas radial com a elipse.  
  
 Se o `sweepAngle` parâmetro é maior que 360 graus ou menor que-360 graus, ele será tratado como se fosse 360 graus ou -360 graus, respectivamente.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um pincel vermelho sólido.  
  
-   Cria o local e o tamanho de um retângulo que delimita uma elipse.  
  
-   Define o ângulo inicial (em relação ao eixo x) e o ângulo de flecha (tanto no sentido horário).  
  
-   Preenche a área em forma de pizza da elipse na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#106](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#106)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#106](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#106)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#106](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#106)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillPolygon">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Preenche o interior de um polígono definido por uma matriz de pontos especificada por estruturas <see cref="T:System.Drawing.Point" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillPolygon">
      <MemberSignature Language="C#" Value="public void FillPolygon (System.Drawing.Brush brush, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPolygon(class System.Drawing.Brush brush, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPolygon(System.Drawing.Brush,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPolygon(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.FillPolygon : System.Drawing.Brush * System.Drawing.Point[] -&gt; unit" Usage="graphics.FillPolygon (brush, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina as características do preenchimento.</param>
        <param name="points">Matriz de estruturas <see cref="T:System.Drawing.Point" /> que representa os vértices do polígono a serem preenchidos.</param>
        <summary>Preenche o interior de um polígono definido por uma matriz de pontos especificada por estruturas <see cref="T:System.Drawing.Point" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos os dois pontos consecutivos na matriz de especificam um lado do polígono. Além disso, se o último ponto e o primeiro ponto não coincidem, eles especificam o lado de fechamento do polígono.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um pincel azul sólido.  
  
-   Cria uma matriz de sete pontos para definir um polígono.  
  
-   Preenche a área em forma de polígono na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#107](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#107)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#107](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#107)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#107](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#107)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="points" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillPolygon">
      <MemberSignature Language="C#" Value="public void FillPolygon (System.Drawing.Brush brush, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPolygon(class System.Drawing.Brush brush, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPolygon(System.Drawing.Brush,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPolygon(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.FillPolygon : System.Drawing.Brush * System.Drawing.PointF[] -&gt; unit" Usage="graphics.FillPolygon (brush, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina as características do preenchimento.</param>
        <param name="points">Matriz de estruturas <see cref="T:System.Drawing.PointF" /> que representa os vértices do polígono a serem preenchidos.</param>
        <summary>Preenche o interior de um polígono definido por uma matriz de pontos especificada por estruturas <see cref="T:System.Drawing.PointF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos os dois pontos consecutivos na matriz de especificam um lado do polígono. Além disso, se o último ponto e o primeiro ponto não coincidem, eles especificam o lado de fechamento do polígono.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um pincel azul sólido.  
  
-   Cria uma matriz de sete pontos para definir um polígono.  
  
-   Preenche a área em forma de polígono na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#109](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#109)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#109](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#109)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#109](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#109)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="points" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillPolygon">
      <MemberSignature Language="C#" Value="public void FillPolygon (System.Drawing.Brush brush, System.Drawing.Point[] points, System.Drawing.Drawing2D.FillMode fillMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPolygon(class System.Drawing.Brush brush, valuetype System.Drawing.Point[] points, valuetype System.Drawing.Drawing2D.FillMode fillMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPolygon(System.Drawing.Brush,System.Drawing.Point[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPolygon(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::Point&gt; ^ points, System::Drawing::Drawing2D::FillMode fillMode);" />
      <MemberSignature Language="F#" Value="member this.FillPolygon : System.Drawing.Brush * System.Drawing.Point[] * System.Drawing.Drawing2D.FillMode -&gt; unit" Usage="graphics.FillPolygon (brush, points, fillMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="fillMode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina as características do preenchimento.</param>
        <param name="points">Matriz de estruturas <see cref="T:System.Drawing.Point" /> que representa os vértices do polígono a serem preenchidos.</param>
        <param name="fillMode">Membro da enumeração <see cref="T:System.Drawing.Drawing2D.FillMode" /> que determina o estilo do preenchimento.</param>
        <summary>Preenche o interior de um polígono definido por uma matriz de pontos especificada por estruturas <see cref="T:System.Drawing.Point" /> usando o modo de preenchimento especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos os dois pontos consecutivos na matriz de especificam um lado do polígono. Além disso, se o último ponto e o primeiro ponto não coincidem, eles especificam o lado de fechamento do polígono.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um pincel azul sólido.  
  
-   Cria uma matriz de sete pontos para definir um polígono.  
  
-   Define o modo de preenchimento como <xref:System.Drawing.Drawing2D.FillMode.Winding>.  
  
-   Preenche a área em forma de polígono na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#108](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#108)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#108](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#108)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#108](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#108)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="points" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillPolygon">
      <MemberSignature Language="C#" Value="public void FillPolygon (System.Drawing.Brush brush, System.Drawing.PointF[] points, System.Drawing.Drawing2D.FillMode fillMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPolygon(class System.Drawing.Brush brush, valuetype System.Drawing.PointF[] points, valuetype System.Drawing.Drawing2D.FillMode fillMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPolygon(System.Drawing.Brush,System.Drawing.PointF[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPolygon(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::PointF&gt; ^ points, System::Drawing::Drawing2D::FillMode fillMode);" />
      <MemberSignature Language="F#" Value="member this.FillPolygon : System.Drawing.Brush * System.Drawing.PointF[] * System.Drawing.Drawing2D.FillMode -&gt; unit" Usage="graphics.FillPolygon (brush, points, fillMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="fillMode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina as características do preenchimento.</param>
        <param name="points">Matriz de estruturas <see cref="T:System.Drawing.PointF" /> que representa os vértices do polígono a serem preenchidos.</param>
        <param name="fillMode">Membro da enumeração <see cref="T:System.Drawing.Drawing2D.FillMode" /> que determina o estilo do preenchimento.</param>
        <summary>Preenche o interior de um polígono definido por uma matriz de pontos especificada por estruturas <see cref="T:System.Drawing.PointF" /> usando o modo de preenchimento especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos os dois pontos consecutivos na matriz de especificam um lado do polígono. Além disso, se o último ponto e o primeiro ponto não coincidem, eles especificam o lado de fechamento do polígono.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa a ação a seguir:  
  
-   Cria um pincel azul sólido.  
  
-   Cria uma matriz de sete pontos para definir um polígono.  
  
-   Define o modo de preenchimento como <xref:System.Drawing.Drawing2D.FillMode.Winding>.  
  
-   Preenche a área em forma de polígono na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#110](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#110)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#110](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#110)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#110](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#110)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="points" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillRectangle">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Preenche o interior de um retângulo especificado por um par de coordenadas, uma largura e uma altura.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillRectangle">
      <MemberSignature Language="C#" Value="public void FillRectangle (System.Drawing.Brush brush, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRectangle(class System.Drawing.Brush brush, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRectangle(System.Drawing.Brush,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRectangle(System::Drawing::Brush ^ brush, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.FillRectangle : System.Drawing.Brush * System.Drawing.Rectangle -&gt; unit" Usage="graphics.FillRectangle (brush, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina as características do preenchimento.</param>
        <param name="rect">Estrutura <see cref="T:System.Drawing.Rectangle" /> que representa o retângulo a ser preenchido.</param>
        <summary>Preenche o interior de um retângulo especificado por uma estrutura <see cref="T:System.Drawing.Rectangle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método preenche o interior do retângulo definido pelo `rect` parâmetro, incluindo o canto superior esquerdo especificado de canto e até o calculado diminuir e inferior.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa a ação a seguir:  
  
-   Cria um pincel azul sólido.  
  
-   Cria um retângulo.  
  
-   Preenche a área retangular na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#111](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#111)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#111](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#111)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#111](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#111)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillRectangle">
      <MemberSignature Language="C#" Value="public void FillRectangle (System.Drawing.Brush brush, System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRectangle(class System.Drawing.Brush brush, valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRectangle(System.Drawing.Brush,System.Drawing.RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRectangle(System::Drawing::Brush ^ brush, System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.FillRectangle : System.Drawing.Brush * System.Drawing.RectangleF -&gt; unit" Usage="graphics.FillRectangle (brush, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina as características do preenchimento.</param>
        <param name="rect">Estrutura <see cref="T:System.Drawing.RectangleF" /> que representa o retângulo a ser preenchido.</param>
        <summary>Preenche o interior de um retângulo especificado por uma estrutura <see cref="T:System.Drawing.RectangleF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método preenche o interior do retângulo definido pelo `rect` parâmetro, incluindo o canto superior esquerdo especificado de canto e até o calculado diminuir e inferior.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa a ação a seguir:  
  
-   Cria um pincel azul sólido.  
  
-   Cria um retângulo.  
  
-   Preenche a área retangular na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#112](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#112)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#112](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#112)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#112](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#112)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillRectangle">
      <MemberSignature Language="C#" Value="public void FillRectangle (System.Drawing.Brush brush, int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRectangle(class System.Drawing.Brush brush, int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRectangle(System.Drawing.Brush,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRectangle(System::Drawing::Brush ^ brush, int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.FillRectangle : System.Drawing.Brush * int * int * int * int -&gt; unit" Usage="graphics.FillRectangle (brush, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina as características do preenchimento.</param>
        <param name="x">A coordenada X do canto superior esquerdo do retângulo a ser preenchido.</param>
        <param name="y">A coordenada y do canto superior esquerdo do retângulo a ser preenchido.</param>
        <param name="width">Largura do retângulo a ser preenchido.</param>
        <param name="height">Altura do retângulo a ser preenchido.</param>
        <summary>Preenche o interior de um retângulo especificado por um par de coordenadas, uma largura e uma altura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método preenche o interior do retângulo definido pela`x`, `y`, `width`, e `height` parâmetros, incluindo o canto superior esquerdo especificado de canto e até o calculado diminuir e inferior.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa a ação a seguir:  
  
-   Cria um pincel azul sólido.  
  
-   Cria o local e o tamanho de um retângulo.  
  
-   Preenche a área retangular na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#113](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#113)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#113](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#113)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#113](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#113)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillRectangle">
      <MemberSignature Language="C#" Value="public void FillRectangle (System.Drawing.Brush brush, float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRectangle(class System.Drawing.Brush brush, float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRectangle(System.Drawing.Brush,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRectangle(System::Drawing::Brush ^ brush, float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.FillRectangle : System.Drawing.Brush * single * single * single * single -&gt; unit" Usage="graphics.FillRectangle (brush, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina as características do preenchimento.</param>
        <param name="x">A coordenada X do canto superior esquerdo do retângulo a ser preenchido.</param>
        <param name="y">A coordenada y do canto superior esquerdo do retângulo a ser preenchido.</param>
        <param name="width">Largura do retângulo a ser preenchido.</param>
        <param name="height">Altura do retângulo a ser preenchido.</param>
        <summary>Preenche o interior de um retângulo especificado por um par de coordenadas, uma largura e uma altura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método preenche o interior do retângulo definido pela `x`, `y`, `width`, e `height` parâmetros, incluindo o canto superior esquerdo especificado de canto e até o calculado diminuir e inferior.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa a ação a seguir:  
  
-   Cria um pincel azul sólido.  
  
-   Cria o local e o tamanho de um retângulo.  
  
-   Preenche a área retangular na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#114](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#114)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#114](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#114)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#114](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#114)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillRectangles">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Preenche os interiores de uma série de retângulos especificados por estruturas <see cref="T:System.Drawing.Rectangle" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillRectangles">
      <MemberSignature Language="C#" Value="public void FillRectangles (System.Drawing.Brush brush, System.Drawing.Rectangle[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRectangles(class System.Drawing.Brush brush, valuetype System.Drawing.Rectangle[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRectangles(System.Drawing.Brush,System.Drawing.Rectangle[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRectangles(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::Rectangle&gt; ^ rects);" />
      <MemberSignature Language="F#" Value="member this.FillRectangles : System.Drawing.Brush * System.Drawing.Rectangle[] -&gt; unit" Usage="graphics.FillRectangles (brush, rects)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rects" Type="System.Drawing.Rectangle[]" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina as características do preenchimento.</param>
        <param name="rects">Uma matriz de estruturas <see cref="T:System.Drawing.Rectangle" /> que representa os retângulos a serem preenchidos.</param>
        <summary>Preenche os interiores de uma série de retângulos especificados por estruturas <see cref="T:System.Drawing.Rectangle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa a ação a seguir:  
  
-   Cria um pincel azul sólido.  
  
-   Cria uma matriz de três retângulos.  
  
-   Preenche as três áreas retangulares na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#115](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#115)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#115](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#115)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#115](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#115)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="rects" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rects" /> é uma matriz de tamanho zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillRectangles">
      <MemberSignature Language="C#" Value="public void FillRectangles (System.Drawing.Brush brush, System.Drawing.RectangleF[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRectangles(class System.Drawing.Brush brush, valuetype System.Drawing.RectangleF[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRectangles(System.Drawing.Brush,System.Drawing.RectangleF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRectangles(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::RectangleF&gt; ^ rects);" />
      <MemberSignature Language="F#" Value="member this.FillRectangles : System.Drawing.Brush * System.Drawing.RectangleF[] -&gt; unit" Usage="graphics.FillRectangles (brush, rects)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rects" Type="System.Drawing.RectangleF[]" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina as características do preenchimento.</param>
        <param name="rects">Uma matriz de estruturas <see cref="T:System.Drawing.RectangleF" /> que representa os retângulos a serem preenchidos.</param>
        <summary>Preenche os interiores de uma série de retângulos especificados por estruturas <see cref="T:System.Drawing.RectangleF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa a ação a seguir:  
  
-   Cria um pincel azul sólido.  
  
-   Cria uma matriz de três retângulos.  
  
-   Preenche as três áreas retangulares na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#116](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#116)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#116](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#116)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#116](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#116)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="rects" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="Rects" /> é uma matriz de tamanho zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillRegion">
      <MemberSignature Language="C#" Value="public void FillRegion (System.Drawing.Brush brush, System.Drawing.Region region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRegion(class System.Drawing.Brush brush, class System.Drawing.Region region) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRegion(System.Drawing.Brush,System.Drawing.Region)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRegion(System::Drawing::Brush ^ brush, System::Drawing::Region ^ region);" />
      <MemberSignature Language="F#" Value="member this.FillRegion : System.Drawing.Brush * System.Drawing.Region -&gt; unit" Usage="graphics.FillRegion (brush, region)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="region" Type="System.Drawing.Region" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina as características do preenchimento.</param>
        <param name="region"><see cref="T:System.Drawing.Region" /> que representa a área a ser preenchida.</param>
        <summary>Preenche o interior de um <see cref="T:System.Drawing.Region" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Drawing.Region> é composta por retângulos e caminhos. Se a região não estiver fechada, um segmento adicional é adicionado do último ponto até o primeiro ponto para fechá-la.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa a ação a seguir:  
  
-   Cria um pincel azul sólido.  
  
-   Cria um retângulo.  
  
-   Cria uma região retangular.  
  
-   Preenche a região retangular na tela.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#117](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#117)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#117](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#117)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#117](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#117)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="region" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Graphics ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Graphics ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="graphics.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permite que um objeto tente liberar recursos e executar outras operações de limpeza antes de ser recuperado pela coleta de lixo.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Força a execução de todas as operações de gráfico pendentes e retorna imediatamente sem esperar as operações serem finalizadas.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="graphics.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Força a execução de todas as operações de gráfico pendentes e retorna imediatamente sem esperar as operações serem finalizadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método inicia uma liberação e retorna imediatamente sem esperar que qualquer operação de elementos gráficos em execução no momento concluir.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush (System.Drawing.Drawing2D.FlushIntention intention);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush(valuetype System.Drawing.Drawing2D.FlushIntention intention) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Flush(System.Drawing.Drawing2D.FlushIntention)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush (intention As FlushIntention)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush(System::Drawing::Drawing2D::FlushIntention intention);" />
      <MemberSignature Language="F#" Value="member this.Flush : System.Drawing.Drawing2D.FlushIntention -&gt; unit" Usage="graphics.Flush intention" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="intention" Type="System.Drawing.Drawing2D.FlushIntention" />
      </Parameters>
      <Docs>
        <param name="intention">Membro da enumeração <see cref="T:System.Drawing.Drawing2D.FlushIntention" /> que especifica se o método retorna imediatamente ou aguarda a conclusão de eventuais operações existentes.</param>
        <summary>Força a execução de todas as operações gráficas pendentes, com ou sem espera do método para retornar antes da conclusão das operações, conforme especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um valor de <xref:System.Drawing.Drawing2D.FlushIntention.Flush> para o `intention` parâmetro especifica que o método retornará imediatamente depois do início de liberação, enquanto um valor de <xref:System.Drawing.Drawing2D.FlushIntention.Sync> Especifica que o método esperar antes de retornar até que todas as operações existentes sejam concluídos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="FromHdc">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria um novo <see cref="T:System.Drawing.Graphics" /> do identificador especificado para um contexto de dispositivo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromHdc">
      <MemberSignature Language="C#" Value="public static System.Drawing.Graphics FromHdc (IntPtr hdc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Graphics FromHdc(native int hdc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FromHdc(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHdc (hdc As IntPtr) As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Graphics ^ FromHdc(IntPtr hdc);" />
      <MemberSignature Language="F#" Value="static member FromHdc : nativeint -&gt; System.Drawing.Graphics" Usage="System.Drawing.Graphics.FromHdc hdc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hdc" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hdc">Identificador para um contexto de dispositivo.</param>
        <summary>Cria um novo <see cref="T:System.Drawing.Graphics" /> do identificador especificado para um contexto de dispositivo.</summary>
        <returns>Esse método retorna um novo <see cref="T:System.Drawing.Graphics" /> para o contexto de dispositivo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você sempre deve chamar o <xref:System.Drawing.Graphics.Dispose%2A> método para liberar o <xref:System.Drawing.Graphics> e os recursos criados por relacionados a <xref:System.Drawing.Graphics.FromHdc%2A> método.  
  
 Mesmo se o dispositivo de vídeo tem um perfil de cor ICM associado, [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] não usará esse perfil por padrão. Para habilitar o ICM para um <xref:System.Drawing.Graphics>, construa a <xref:System.Drawing.Graphics> de um HDC depois de passar o HDC (e ICM_ON) para o `SetICMMode` função. Em seguida, qualquer drawing feita pelo <xref:System.Drawing.Graphics> será ajustada de acordo com o perfil ICM associado com o dispositivo de vídeo. Habilitar o ICM resultará em desempenho mais lento.  
  
 O estado do contexto do dispositivo (modo de mapeamento, unidade lógica e assim por diante) no momento em que você chame <xref:System.Drawing.Graphics.FromHdc%2A> pode afetar o processamento feito pelo <xref:System.Drawing.Graphics>.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa a ação a seguir:  
  
-   Cria uma variável do tipo ponteiro interno `hdc` e a define como o identificador para o contexto de dispositivo do objeto graphics do formulário.  
  
-   Cria um novo objeto de elementos gráficos usando `hdc`.  
  
-   Desenha um retângulo com o novo objeto de elementos gráficos (na tela).  
  
-   Libera o novo objeto de elementos gráficos usando `hdc`.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#118](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#118)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#118](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#118)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#118](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#118)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromHdc">
      <MemberSignature Language="C#" Value="public static System.Drawing.Graphics FromHdc (IntPtr hdc, IntPtr hdevice);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Graphics FromHdc(native int hdc, native int hdevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FromHdc(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHdc (hdc As IntPtr, hdevice As IntPtr) As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Graphics ^ FromHdc(IntPtr hdc, IntPtr hdevice);" />
      <MemberSignature Language="F#" Value="static member FromHdc : nativeint * nativeint -&gt; System.Drawing.Graphics" Usage="System.Drawing.Graphics.FromHdc (hdc, hdevice)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hdc" Type="System.IntPtr" />
        <Parameter Name="hdevice" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hdc">Identificador para um contexto de dispositivo.</param>
        <param name="hdevice">Identificador de um dispositivo.</param>
        <summary>Cria um novo <see cref="T:System.Drawing.Graphics" /> do identificador especificado para um contexto de dispositivo e identificador de um dispositivo.</summary>
        <returns>Esse método retorna um novo <see cref="T:System.Drawing.Graphics" /> para o dispositivo e contexto de dispositivo especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você sempre deve chamar o <xref:System.Drawing.Graphics.Dispose%2A> método para liberar o <xref:System.Drawing.Graphics> e os recursos criados por relacionados a <xref:System.Drawing.Graphics.FromHdc%2A> método.  
  
 Mesmo se o dispositivo de vídeo tem um perfil de cor ICM associado, [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] não usará esse perfil por padrão. Para habilitar o ICM para um <xref:System.Drawing.Graphics>, construa a <xref:System.Drawing.Graphics> de um HDC depois de passar o HDC (e ICM_ON) para o `SetICMMode` função. Em seguida, qualquer drawing feita pelo <xref:System.Drawing.Graphics> será ajustada de acordo com o perfil ICM associado com o dispositivo de vídeo. Habilitar o ICM resultará em desempenho mais lento.  
  
 O estado do contexto do dispositivo (modo de mapeamento, unidade lógica e assim por diante) no momento em que você chame <xref:System.Drawing.Graphics.FromHdc%2A> pode afetar o processamento feito pelo <xref:System.Drawing.Graphics>.  
  
 O identificador do dispositivo é normalmente usado para recursos específicos da impressora de consulta.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para acesso a código não gerenciado. Relacionado a enumeração: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="FromHdcInternal">
      <MemberSignature Language="C#" Value="public static System.Drawing.Graphics FromHdcInternal (IntPtr hdc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Graphics FromHdcInternal(native int hdc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FromHdcInternal(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHdcInternal (hdc As IntPtr) As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Graphics ^ FromHdcInternal(IntPtr hdc);" />
      <MemberSignature Language="F#" Value="static member FromHdcInternal : nativeint -&gt; System.Drawing.Graphics" Usage="System.Drawing.Graphics.FromHdcInternal hdc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hdc" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hdc">Identificador para um contexto de dispositivo.</param>
        <summary>Retorna um <see cref="T:System.Drawing.Graphics" /> para o contexto de dispositivo especificado.</summary>
        <returns>Um <see cref="T:System.Drawing.Graphics" /> para o contexto de dispositivo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método não deve ser usado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromHwnd">
      <MemberSignature Language="C#" Value="public static System.Drawing.Graphics FromHwnd (IntPtr hwnd);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Graphics FromHwnd(native int hwnd) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FromHwnd(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHwnd (hwnd As IntPtr) As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Graphics ^ FromHwnd(IntPtr hwnd);" />
      <MemberSignature Language="F#" Value="static member FromHwnd : nativeint -&gt; System.Drawing.Graphics" Usage="System.Drawing.Graphics.FromHwnd hwnd" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hwnd" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hwnd">Identificador para uma janela.</param>
        <summary>Cria um novo <see cref="T:System.Drawing.Graphics" /> do identificador especificado para a janela.</summary>
        <returns>Esse método retorna um novo <see cref="T:System.Drawing.Graphics" /> para o identificador de janela especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você sempre deve chamar o <xref:System.Drawing.Graphics.Dispose%2A> método para liberar o <xref:System.Drawing.Graphics> e os recursos criados por relacionados a <xref:System.Drawing.Graphics.FromHwnd%2A> método.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro da <xref:System.Windows.Forms.Control.Paint> manipulador de eventos, bem como `thisForm`, o <xref:System.Windows.Forms.Form> para o exemplo. O código executa as seguintes ações:  
  
-   Cria uma nova variável de ponteiro interno `hwnd` e define-a para a alça do formulário de exemplo.  
  
-   Cria um novo <xref:System.Drawing.Graphics> do identificador.  
  
-   Desenha um retângulo para a nova <xref:System.Drawing.Graphics> usando uma caneta de vermelha.  
  
-   Descarta o novo <xref:System.Drawing.Graphics>.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#119](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#119)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#119](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#119)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#119](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#119)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para acesso a código não gerenciado. Relacionado a enumeração: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="FromHwndInternal">
      <MemberSignature Language="C#" Value="public static System.Drawing.Graphics FromHwndInternal (IntPtr hwnd);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Graphics FromHwndInternal(native int hwnd) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FromHwndInternal(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHwndInternal (hwnd As IntPtr) As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Graphics ^ FromHwndInternal(IntPtr hwnd);" />
      <MemberSignature Language="F#" Value="static member FromHwndInternal : nativeint -&gt; System.Drawing.Graphics" Usage="System.Drawing.Graphics.FromHwndInternal hwnd" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hwnd" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hwnd">Identificador para uma janela.</param>
        <summary>Cria um novo <see cref="T:System.Drawing.Graphics" /> para o identificador do Windows especificado.</summary>
        <returns>Um <see cref="T:System.Drawing.Graphics" /> para o identificador do Windows especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método não deve ser usado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromImage">
      <MemberSignature Language="C#" Value="public static System.Drawing.Graphics FromImage (System.Drawing.Image image);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Graphics FromImage(class System.Drawing.Image image) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FromImage(System.Drawing.Image)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Graphics ^ FromImage(System::Drawing::Image ^ image);" />
      <MemberSignature Language="F#" Value="static member FromImage : System.Drawing.Image -&gt; System.Drawing.Graphics" Usage="System.Drawing.Graphics.FromImage image" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
      </Parameters>
      <Docs>
        <param name="image">O <see cref="T:System.Drawing.Image" /> por meio do qual o novo <see cref="T:System.Drawing.Graphics" /> será criado.</param>
        <summary>Cria um novo <see cref="T:System.Drawing.Graphics" /> com base no <see cref="T:System.Drawing.Image" /> especificado.</summary>
        <returns>Esse método retorna um novo <see cref="T:System.Drawing.Graphics" /> para o <see cref="T:System.Drawing.Image" /> especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a imagem tem um formato de pixel indexado, esse método gerará uma exceção com a mensagem, "um objeto gráfico não pode ser criado de uma imagem que tem um formato de pixel indexado". Os formatos de pixel indexados são mostrados na lista a seguir.  
  
-   <xref:System.Drawing.Imaging.PixelFormat.Format1bppIndexed>  
  
-   <xref:System.Drawing.Imaging.PixelFormat.Format4bppIndexed>  
  
-   <xref:System.Drawing.Imaging.PixelFormat.Format8bppIndexed>  
  
 Você pode salvar a imagem indexada como outro formato usando o <xref:System.Drawing.Image.Save%28System.String%2CSystem.Drawing.Imaging.ImageFormat%29> método e, em seguida, recupere um <xref:System.Drawing.Graphics> objeto para a nova imagem.  
  
 Esse método também gera uma exceção se a imagem tiver qualquer um dos seguintes formatos de pixel.  
  
-   <xref:System.Drawing.Imaging.PixelFormat.Undefined>  
  
-   <xref:System.Drawing.Imaging.PixelFormat.DontCare>  
  
-   <xref:System.Drawing.Imaging.PixelFormat.Format16bppArgb1555>  
  
-   <xref:System.Drawing.Imaging.PixelFormat.Format16bppGrayScale>  
  
 Você sempre deve chamar o <xref:System.Drawing.Graphics.Dispose%2A> método para liberar o <xref:System.Drawing.Graphics> e os recursos criados por relacionados a <xref:System.Drawing.Graphics.FromImage%2A> método.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa a ação a seguir:  
  
-   Cria um <xref:System.Drawing.Image> de uma gráfico SampImag.jpg de arquivos na pasta de exemplo.  
  
-   Cria uma <xref:System.Drawing.Graphics> do <xref:System.Drawing.Image>.  
  
-   Altera a imagem ao preencher um retângulo dentro dele.  
  
-   Desenha o <xref:System.Drawing.Image> na tela.  
  
-   Libera o criado <xref:System.Drawing.Graphics>.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#120](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#120)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#120](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#120)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#120](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Exception"><paramref name="image" /> tem um formato de pixel indexado ou seu formato é indefinido.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/737bae30-e599-4e1d-bf30-bab8280b32be">Como criar um bitmap em tempo de execução</related>
        <related type="Article" href="https://msdn.microsoft.com/library/a626d701-bd99-4fd8-b92f-7b8f794e042b">Trabalhando com imagens, bitmaps, ícones e metarquivos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/162861f9-f050-445e-8abb-b2c43a918b8b">Como criar objetos gráficos para desenho</related>
      </Docs>
    </Member>
    <Member MemberName="GetContextInfo">
      <MemberSignature Language="C#" Value="public object GetContextInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetContextInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.GetContextInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContextInfo () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetContextInfo();" />
      <MemberSignature Language="F#" Value="member this.GetContextInfo : unit -&gt; obj" Usage="graphics.GetContextInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém o contexto gráfico cumulativo.</summary>
        <returns>Um <see cref="T:System.Object" /> representando o contexto gráfico cumulativo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é uma matriz de objetos em que o primeiro elemento contém a região de recorte cumulativa e o segundo elemento contém a matriz de traduzir/transformar cumulativa.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHalftonePalette">
      <MemberSignature Language="C#" Value="public static IntPtr GetHalftonePalette ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetHalftonePalette() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.GetHalftonePalette" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHalftonePalette () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetHalftonePalette();" />
      <MemberSignature Language="F#" Value="static member GetHalftonePalette : unit -&gt; nativeint" Usage="System.Drawing.Graphics.GetHalftonePalette " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém um identificador para a paleta de meio-tom atual do Windows.</summary>
        <returns>Ponteiro interno que especifica o identificador para a paleta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A finalidade de <xref:System.Drawing.Graphics.GetHalftonePalette%2A> método é habilitar [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] para produzir o meio-tom qualidade melhor quando a exibição usa 8 bits por pixel. Para exibir uma imagem usando a paleta de meio-tom, use o procedimento a seguir.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Define a interoperabilidade <xref:System.Runtime.InteropServices.DllImportAttribute> atributos para o arquivo gdi32.dll arquivo de DLL do Windows, que contém o necessário [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] funções.  
  
-   Define o `SelectPalette` e `RealizePalette` funções nessa DLL como externo.  
  
-   Cria uma imagem de um arquivo de imagem existente SampImag.jpg (que deve estar na mesma pasta que o arquivo de código de exemplo) e desenha a imagem na tela.  
  
-   Cria variáveis de tipo de ponteiro interno e define seus valores para o identificador para o objeto de elementos gráficos e na paleta de meio-tom atual do Windows, respectivamente.  
  
-   Seleciona e percebe a paleta de meio-tom.  
  
-   Cria um novo objeto de elementos gráficos usando o `hdc` parâmetro.  
  
-   Desenha a imagem novamente.  
  
-   Libera o identificador para o contexto de dispositivo.  
  
 O resultado é dois renderizações da imagem de exemplo: uma com a paleta de 16 bits e outra com a paleta de 8 bits.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#121](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#121)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#121](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#121)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#121](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#121)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHdc">
      <MemberSignature Language="C#" Value="public IntPtr GetHdc ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance native int GetHdc() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.GetHdc" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHdc () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IntPtr GetHdc();" />
      <MemberSignature Language="F#" Value="abstract member GetHdc : unit -&gt; nativeint&#xA;override this.GetHdc : unit -&gt; nativeint" Usage="graphics.GetHdc " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Drawing.IDeviceContext.GetHdc</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém o identificador para o contexto de dispositivo associado a este <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns>Identificador para o contexto de dispositivo associado a este <see cref="T:System.Drawing.Graphics" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O contexto de dispositivo é uma estrutura do Windows baseada em [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] que define um conjunto de objetos gráficos e seus atributos associados, bem como os modos de gráficos que afetam a saída. Esse método retorna esse contexto de dispositivo, com exceção de uma fonte. Como uma fonte não estiver selecionada, chamadas para o <xref:System.Drawing.Font.FromHdc%2A> método usando um identificador retornado do <xref:System.Drawing.Graphics.GetHdc%2A> método falhará.  
  
 Chamadas para o <xref:System.Drawing.Graphics.GetHdc%2A> e <xref:System.Drawing.Graphics.ReleaseHdc%2A> métodos devem aparecer em pares. Durante o escopo de um <xref:System.Drawing.Graphics.GetHdc%2A> e <xref:System.Drawing.Graphics.ReleaseHdc%2A> par de métodos, você geralmente fazer somente chamadas para [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] funções. Chama nesse escopo feitas [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] métodos do <xref:System.Drawing.Graphics> que produziu o `hdc` parâmetro falhar com um `ObjectBusy` erro. Além disso, [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] ignora as alterações de estado feitas para o <xref:System.Drawing.Graphics> da `hdc` parâmetro em operações subsequentes.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O exemplo ilustra a chamada de um Windows [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] função para executar a mesma tarefa como uma [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] <xref:System.Drawing.Graphics> método. O código executa as seguintes ações:  
  
-   Define a interoperabilidade <xref:System.Runtime.InteropServices.DllImportAttribute> atributo para o arquivo gdi32.dll arquivo de DLL do Windows. Essa DLL contém os detalhes desejados [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] função.  
  
-   Define o <xref:System.Drawing.Rectangle> função nessa DLL como externo.  
  
-   Cria uma caneta de vermelha.  
  
-   Com a caneta desenha um retângulo para a tela usando o [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] <xref:System.Drawing.Graphics.DrawRectangle%2A> método.  
  
-   Define uma variável do tipo ponteiro interno `hdc` e define seu valor como o identificador para o contexto de dispositivo do formulário.  
  
-   Desenha um retângulo para a tela usando o [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] <xref:System.Drawing.Rectangle> função.  
  
-   Libera o contexto de dispositivo, representado pelo `hdc` parâmetro.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#122](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#122)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#122](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#122)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#122](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#122)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para acesso a código não gerenciado. Relacionado a enumeração: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetNearestColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color GetNearestColor (System.Drawing.Color color);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Color GetNearestColor(valuetype System.Drawing.Color color) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.GetNearestColor(System.Drawing.Color)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Color GetNearestColor(System::Drawing::Color color);" />
      <MemberSignature Language="F#" Value="member this.GetNearestColor : System.Drawing.Color -&gt; System.Drawing.Color" Usage="graphics.GetNearestColor color" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="color" Type="System.Drawing.Color" />
      </Parameters>
      <Docs>
        <param name="color">Estrutura <see cref="T:System.Drawing.Color" /> para a qual encontrar uma correspondência.</param>
        <summary>Obtém a cor mais próxima da estrutura <see cref="T:System.Drawing.Color" /> especificada.</summary>
        <returns>Uma estrutura <see cref="T:System.Drawing.Color" /> que representa a cor mais próxima àquela especificada com o parâmetro <paramref name="color" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma cor arbitrária com coordenadas ARGB (255, 165, 63, 136).  
  
-   Cria um pincel sólido e define sua cor para a cor especificada.  
  
-   Preenche uma elipse usando a cor arbitrária.  
  
-   Cria uma segunda cor e define seu valor como o sistema mais próximo cor ARGB.  
  
-   Preenche uma segunda elipse com essa cor.  
  
 O resultado será duas elipses: o primeiro desenhado com a cor especificada arbitrária e a segunda desenhado com a cor do sistema mais próximo da cor especificada.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#123](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#123)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#123](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#123)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#123](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#123)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InterpolationMode">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.InterpolationMode InterpolationMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.InterpolationMode InterpolationMode" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.InterpolationMode" />
      <MemberSignature Language="VB.NET" Value="Public Property InterpolationMode As InterpolationMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::InterpolationMode InterpolationMode { System::Drawing::Drawing2D::InterpolationMode get(); void set(System::Drawing::Drawing2D::InterpolationMode value); };" />
      <MemberSignature Language="F#" Value="member this.InterpolationMode : System.Drawing.Drawing2D.InterpolationMode with get, set" Usage="System.Drawing.Graphics.InterpolationMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.InterpolationMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o modo de interpolação associado a esse <see cref="T:System.Drawing.Graphics" />.</summary>
        <value>Um dos valores de <see cref="T:System.Drawing.Drawing2D.InterpolationMode" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O modo de interpolação determina como o intermediário valores entre dois pontos de extremidade são calculados.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IntersectClip">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Atualiza a região de recorte deste <see cref="T:System.Drawing.Graphics" /> para a interseção da região de recorte atual e a estrutura <see cref="T:System.Drawing.Rectangle" /> especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IntersectClip">
      <MemberSignature Language="C#" Value="public void IntersectClip (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void IntersectClip(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IntersectClip(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub IntersectClip (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void IntersectClip(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.IntersectClip : System.Drawing.Rectangle -&gt; unit" Usage="graphics.IntersectClip rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">A estrutura <see cref="T:System.Drawing.Rectangle" /> para interseccionar com a região de recorte atual.</param>
        <summary>Atualiza a região de recorte deste <see cref="T:System.Drawing.Graphics" /> para a interseção da região de recorte atual e a estrutura <see cref="T:System.Drawing.Rectangle" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método atribui para a <xref:System.Drawing.Graphics.Clip%2A> propriedade deste <xref:System.Drawing.Graphics> área representada pela interseção da região de recorte atual e o retângulo especificado pelo `rect` parâmetro.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um retângulo com o canto superior esquerdo em (0, 0) e define a região de recorte para esse retângulo.  
  
-   Cria um segundo retângulo com o canto superior esquerdo em (100, 100) e define a região de recorte para a interseção desse retângulo e a região de recorte atual (o primeiro retângulo).  
  
-   Preenche um retângulo grande que inclui os dois retângulos anteriores com um pincel azul sólido.  
  
-   Redefine a região de recorte para infinito.  
  
-   Desenha retângulos em torno de duas áreas de recorte. Ele usa uma caneta preta para o primeiro retângulo de recorte e uma caneta de vermelha para a segunda região de recorte.  
  
 O resultado é que apenas a interseção de dois retângulos é preenchida com azul.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#124](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#124)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#124](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#124)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#124](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#124)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IntersectClip">
      <MemberSignature Language="C#" Value="public void IntersectClip (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void IntersectClip(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IntersectClip(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub IntersectClip (rect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void IntersectClip(System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.IntersectClip : System.Drawing.RectangleF -&gt; unit" Usage="graphics.IntersectClip rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">A estrutura <see cref="T:System.Drawing.RectangleF" /> para interseccionar com a região de recorte atual.</param>
        <summary>Atualiza a região de recorte deste <see cref="T:System.Drawing.Graphics" /> para a interseção da região de recorte atual e a estrutura <see cref="T:System.Drawing.RectangleF" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método atribui para a <xref:System.Drawing.Graphics.Clip%2A> propriedade deste <xref:System.Drawing.Graphics> área representada pela interseção da região de recorte atual e o retângulo especificado pelo `rect` parâmetro.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um retângulo com o canto superior esquerdo em (0, 0) e define a região de recorte para esse retângulo.  
  
-   Cria um segundo retângulo com o canto superior esquerdo em (100, 100) e define a região de recorte para a interseção desse retângulo e a região de recorte atual (o primeiro retângulo).  
  
-   Preenche um retângulo grande que inclui os dois retângulos anteriores com um pincel azul sólido.  
  
-   Redefine a região de recorte para infinito.  
  
-   Desenha retângulos em torno de duas áreas de recorte. Ele usa uma caneta preta para o primeiro retângulo de recorte e uma caneta de vermelha para a segunda região de recorte.  
  
 O resultado é que apenas a interseção de dois retângulos é preenchida com azul.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#125](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#125)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#125](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#125)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#125](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#125)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IntersectClip">
      <MemberSignature Language="C#" Value="public void IntersectClip (System.Drawing.Region region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void IntersectClip(class System.Drawing.Region region) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IntersectClip(System.Drawing.Region)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void IntersectClip(System::Drawing::Region ^ region);" />
      <MemberSignature Language="F#" Value="member this.IntersectClip : System.Drawing.Region -&gt; unit" Usage="graphics.IntersectClip region" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
      </Parameters>
      <Docs>
        <param name="region"><see cref="T:System.Drawing.Region" /> para interseccionar com a região atual.</param>
        <summary>Atualiza a região de recorte deste <see cref="T:System.Drawing.Graphics" /> para a interseção da região de recorte atual e a <see cref="T:System.Drawing.Region" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método atribui para a <xref:System.Drawing.Graphics.Clip%2A> propriedade deste <xref:System.Drawing.Graphics> área representada pela interseção da região de recorte atual e a região especificada pelo `region` parâmetro.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um retângulo com o canto superior esquerdo em (0, 0).  
  
-   Cria uma região, define como o retângulo e define a região de recorte para essa região.  
  
-   Cria um segundo retângulo com o canto superior esquerdo em (100, 100).  
  
-   Cria uma região, define como o segundo retângulo e define a região de recorte para a interseção de nesta região e a região de recorte atual (o primeiro retângulo) usando um modo de combinar de <xref:System.Drawing.Drawing2D.CombineMode.Replace>.  
  
-   Preenche um retângulo grande que inclui a ambas as regiões anteriores com um pincel azul sólido.  
  
-   Redefine a região de recorte para infinito.  
  
-   Desenha retângulos em torno de duas áreas de recorte. Ele usa uma caneta preta para a primeira região de recorte e uma caneta de vermelha para a segunda região de recorte.  
  
 O resultado é que apenas a interseção de duas regiões é preenchida com azul.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#126](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#126)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#126](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#126)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#126](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#126)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClipEmpty">
      <MemberSignature Language="C#" Value="public bool IsClipEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClipEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.IsClipEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClipEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClipEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClipEmpty : bool" Usage="System.Drawing.Graphics.IsClipEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a área de recorte deste <see cref="T:System.Drawing.Graphics" /> está vazia.</summary>
        <value><see langword="true" /> Se a região de recorte deste <see cref="T:System.Drawing.Graphics" /> estiver vazio; caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsVisible">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica se o ponto especificado por um par de coordenadas está contido na região de recorte visível deste <see cref="T:System.Drawing.Graphics" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::Point point);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.Point -&gt; bool" Usage="graphics.IsVisible point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="point">A estrutura <see cref="T:System.Drawing.Point" /> para testar quanto à visibilidade.</param>
        <summary>Indica se a estrutura <see cref="T:System.Drawing.Point" /> especificada está contida na região de recorte visível deste <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns><see langword="true" /> se o ponto especificado pelo parâmetro <paramref name="point" /> está contido dentro da região de recorte visível deste <see cref="T:System.Drawing.Graphics" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma região de recorte retangular e a define como a região de recorte para o objeto de gráfico do formulário usando <xref:System.Drawing.Drawing2D.CombineMode.Replace>.  
  
-   Cria dois pontos, um dentro da região de recorte e outro fora.  
  
-   Testa cada um dos pontos para visibilidade e desenha apenas aquele visível.  
  
 O resultado é um pequeno círculo vermelho, que está dentro da região de recorte.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#127](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#127)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#127](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#127)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#127](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#127)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.PointF point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.PointF point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Drawing.PointF)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (point As PointF) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::PointF point);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.PointF -&gt; bool" Usage="graphics.IsVisible point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="point">A estrutura <see cref="T:System.Drawing.PointF" /> para testar quanto à visibilidade.</param>
        <summary>Indica se a estrutura <see cref="T:System.Drawing.PointF" /> especificada está contida na região de recorte visível deste <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns><see langword="true" /> se o ponto especificado pelo parâmetro <paramref name="point" /> está contido dentro da região de recorte visível deste <see cref="T:System.Drawing.Graphics" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma região de recorte retangular e a define como a região de recorte para os gráficos do formulário usando <xref:System.Drawing.Drawing2D.CombineMode.Replace>.  
  
-   Cria dois pontos, um dentro da região de recorte e outro fora.  
  
-   Testa cada um dos pontos para visibilidade e desenha apenas aquele visível.  
  
 O resultado é um pequeno círculo vermelho, que está dentro da região de recorte.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#128](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#128)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#128](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#128)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#128](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#128)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (rect As Rectangle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.Rectangle -&gt; bool" Usage="graphics.IsVisible rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">A estrutura <see cref="T:System.Drawing.Rectangle" /> para testar quanto à visibilidade.</param>
        <summary>Indica se o retângulo especificado por uma estrutura <see cref="T:System.Drawing.Rectangle" /> está contido na região de recorte visível deste <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns><see langword="true" /> se o retângulo especificado pelo parâmetro <paramref name="rect" /> está contido dentro da região de recorte visível deste <see cref="T:System.Drawing.Graphics" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma região de recorte retangular e a define como a região de recorte para o objeto de gráfico do formulário usando <xref:System.Drawing.Drawing2D.CombineMode.Replace>.  
  
-   Cria o local e tamanho de dois retângulos, um dentro da região de recorte e outro fora.  
  
-   Testa cada um dos retângulos para visibilidade e desenha apenas aquele visível.  
  
 O resultado é um pequeno retângulo vermelho, que está dentro da região de recorte.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#129](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#129)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#129](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#129)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#129](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#129)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (rect As RectangleF) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.RectangleF -&gt; bool" Usage="graphics.IsVisible rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">A estrutura <see cref="T:System.Drawing.RectangleF" /> para testar quanto à visibilidade.</param>
        <summary>Indica se o retângulo especificado por uma estrutura <see cref="T:System.Drawing.RectangleF" /> está contido na região de recorte visível deste <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns><see langword="true" /> se o retângulo especificado pelo parâmetro <paramref name="rect" /> está contido dentro da região de recorte visível deste <see cref="T:System.Drawing.Graphics" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma região de recorte retangular e a define como a região de recorte para o objeto de gráfico do formulário usando <xref:System.Drawing.Drawing2D.CombineMode.Replace>.  
  
-   Cria dois retângulos, um dentro da região de recorte e outro fora.  
  
-   Testa cada um dos retângulos para visibilidade e desenha apenas aquele visível.  
  
 O resultado é um pequeno retângulo vermelho, que está dentro da região de recorte.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#130](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#130)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#130](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#130)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#130](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#130)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Integer, y As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(int x, int y);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : int * int -&gt; bool" Usage="graphics.IsVisible (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">A coordenada X do ponto a ser testado quanto à visibilidade.</param>
        <param name="y">A coordenada Y do ponto a ser testado quanto à visibilidade.</param>
        <summary>Indica se o ponto especificado por um par de coordenadas está contido na região de recorte visível deste <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns><see langword="true" /> se o ponto definido pelos parâmetros <paramref name="x" /> e <paramref name="y" /> está contido dentro da região de recorte visível deste <see cref="T:System.Drawing.Graphics" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma região de recorte retangular e a define como a região de recorte para o objeto de gráfico do formulário usando <xref:System.Drawing.Drawing2D.CombineMode.Replace>.  
  
-   Cria dois pontos, um dentro da região de recorte e outro fora.  
  
-   Testa cada um dos pontos para visibilidade e desenha apenas aquele visível.  
  
 O resultado é um pequeno círculo vermelho, que está dentro da região de recorte.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#131](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#131)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#131](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#131)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#131](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#131)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Single, y As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(float x, float y);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : single * single -&gt; bool" Usage="graphics.IsVisible (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">A coordenada X do ponto a ser testado quanto à visibilidade.</param>
        <param name="y">A coordenada Y do ponto a ser testado quanto à visibilidade.</param>
        <summary>Indica se o ponto especificado por um par de coordenadas está contido na região de recorte visível deste <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns><see langword="true" /> se o ponto definido pelos parâmetros <paramref name="x" /> e <paramref name="y" /> está contido dentro da região de recorte visível deste <see cref="T:System.Drawing.Graphics" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma região de recorte retangular e a define como a região de recorte para o objeto de gráfico do formulário usando <xref:System.Drawing.Drawing2D.CombineMode.Replace>.  
  
-   Cria dois pontos, um dentro da região de recorte e outro fora.  
  
-   Testa cada um dos pontos para visibilidade e desenha apenas aquele visível.  
  
 O resultado é um pequeno círculo vermelho, que está dentro da região de recorte.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#133](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#133)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#133](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#133)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#133](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#133)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Integer, y As Integer, width As Integer, height As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : int * int * int * int -&gt; bool" Usage="graphics.IsVisible (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">A coordenada X do canto superior esquerdo do retângulo a ser testado quanto à visibilidade.</param>
        <param name="y">A coordenada Y do canto superior esquerdo do retângulo a ser testado quanto à visibilidade.</param>
        <param name="width">A largura do retângulo a testar quanto à visibilidade.</param>
        <param name="height">A altura do retângulo a testar quanto à visibilidade.</param>
        <summary>Indica se o retângulo especificado por um par de coordenadas, uma largura e uma altura está contido na região de recorte visível deste <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns><see langword="true" /> se o retângulo definido pelos parâmetros <paramref name="x" />, <paramref name="y" />, <paramref name="width" /> e <paramref name="height" /> está contido dentro da região de recorte visível deste <see cref="T:System.Drawing.Graphics" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma região de recorte retangular e a define como a região de recorte para o objeto de gráfico do formulário usando <xref:System.Drawing.Drawing2D.CombineMode.Replace>.  
  
-   Cria o local e tamanho de dois retângulos, um dentro da região de recorte e outro fora.  
  
-   Testa cada um dos retângulos para visibilidade e desenha apenas aquele visível.  
  
 O resultado é um pequeno retângulo vermelho, que está dentro da região de recorte.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#132](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#132)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#132](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#132)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#132](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#132)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Single, y As Single, width As Single, height As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : single * single * single * single -&gt; bool" Usage="graphics.IsVisible (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">A coordenada X do canto superior esquerdo do retângulo a ser testado quanto à visibilidade.</param>
        <param name="y">A coordenada Y do canto superior esquerdo do retângulo a ser testado quanto à visibilidade.</param>
        <param name="width">A largura do retângulo a testar quanto à visibilidade.</param>
        <param name="height">A altura do retângulo a testar quanto à visibilidade.</param>
        <summary>Indica se o retângulo especificado por um par de coordenadas, uma largura e uma altura está contido na região de recorte visível deste <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns><see langword="true" /> se o retângulo definido pelos parâmetros <paramref name="x" />, <paramref name="y" />, <paramref name="width" /> e <paramref name="height" /> está contido dentro da região de recorte visível deste <see cref="T:System.Drawing.Graphics" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma região de recorte retangular e a define como a região de recorte para o objeto de gráfico do formulário usando <xref:System.Drawing.Drawing2D.CombineMode.Replace>.  
  
-   Cria o local e tamanho de dois retângulos, um dentro da região de recorte e outro fora.  
  
-   Testa cada um dos retângulos para visibilidade e desenha apenas aquele visível.  
  
 O resultado é um pequeno retângulo vermelho, que está dentro da região de recorte.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#134](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#134)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#134](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#134)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#134](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#134)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisibleClipEmpty">
      <MemberSignature Language="C#" Value="public bool IsVisibleClipEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisibleClipEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.IsVisibleClipEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisibleClipEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisibleClipEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisibleClipEmpty : bool" Usage="System.Drawing.Graphics.IsVisibleClipEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a área de recorte visível deste <see cref="T:System.Drawing.Graphics" /> está vazia.</summary>
        <value><see langword="true" /> Se a parte visível da região de recorte desse <see cref="T:System.Drawing.Graphics" /> estiver vazio; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A região de recorte visível é a interseção da região de recorte deste `Graphics` e a região de recorte da janela.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureCharacterRanges">
      <MemberSignature Language="C#" Value="public System.Drawing.Region[] MeasureCharacterRanges (string text, System.Drawing.Font font, System.Drawing.RectangleF layoutRect, System.Drawing.StringFormat stringFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Region[] MeasureCharacterRanges(string text, class System.Drawing.Font font, valuetype System.Drawing.RectangleF layoutRect, class System.Drawing.StringFormat stringFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Drawing::Region ^&gt; ^ MeasureCharacterRanges(System::String ^ text, System::Drawing::Font ^ font, System::Drawing::RectangleF layoutRect, System::Drawing::StringFormat ^ stringFormat);" />
      <MemberSignature Language="F#" Value="member this.MeasureCharacterRanges : string * System.Drawing.Font * System.Drawing.RectangleF * System.Drawing.StringFormat -&gt; System.Drawing.Region[]" Usage="graphics.MeasureCharacterRanges (text, font, layoutRect, stringFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Region[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="layoutRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="stringFormat" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="text">Cadeia de caracteres a ser medida.</param>
        <param name="font"><see cref="T:System.Drawing.Font" /> que define o formato de texto da cadeia de caracteres.</param>
        <param name="layoutRect">Estrutura <see cref="T:System.Drawing.RectangleF" /> que especifica o retângulo de layout para a cadeia de caracteres.</param>
        <param name="stringFormat"><see cref="T:System.Drawing.StringFormat" /> que representa as informações de formatação, como o espaçamento entre linhas, para a cadeia de caracteres.</param>
        <summary>Obtém uma matriz de objetos <see cref="T:System.Drawing.Region" />, cada um deles limita um intervalo de posições de caractere na cadeia de caracteres especificada.</summary>
        <returns>Esse método retorna uma matriz de objetos <see cref="T:System.Drawing.Region" />, cada um deles limita um intervalo de posições de caractere na cadeia de caracteres especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As regiões retornadas por esse método são dependentes de resolução, portanto, pode haver uma pequena perda de precisão que cadeias de caracteres são registradas em um metarquivo em uma resolução e reproduzidas posteriormente com uma resolução diferente.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Define uma cadeia de caracteres "primeiro e segundo intervalos" e uma fonte para exibição da cadeia de caracteres ("Times New Roman", ponto de 16).  
  
-   Conjuntos de dois intervalos de caracteres na cadeia de caracteres (que correspondem às palavras "First" e "Depois").  
  
-   Cria um retângulo no qual exibir a cadeia de caracteres.  
  
-   Define a formatação da cadeia de caracteres ¾ incluindo os intervalos de dois caracteres.  
  
-   Desenha a cadeia de caracteres na tela.  
  
-   Mede os intervalos de caracteres e determina a retângulos que delimitam os dois intervalos especificados.  
  
-   Desenha os dois retângulos na tela.  
  
 O resultado é a cadeia de caracteres exibida com o primeiro intervalo limitado ("First") por um retângulo vermelho e o segundo intervalo limitado ("segundo") por um retângulo azul.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#135](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#135)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#135](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#135)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#135](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#135)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font)" />
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="MeasureString">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Mede a cadeia de caracteres especificada quando desenhada com o <see cref="T:System.Drawing.Font" /> especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
      </Parameters>
      <Docs>
        <param name="text">Cadeia de caracteres a ser medida.</param>
        <param name="font"><see cref="T:System.Drawing.Font" /> que define o formato de texto da cadeia de caracteres.</param>
        <summary>Mede a cadeia de caracteres especificada quando desenhada com o <see cref="T:System.Drawing.Font" /> especificado.</summary>
        <returns>Este método retorna uma estrutura <see cref="T:System.Drawing.SizeF" /> que representa o tamanho, nas unidades especificadas pela propriedade <see cref="P:System.Drawing.Graphics.PageUnit" />, da cadeia de caracteres especificada pelo parâmetro <paramref name="text" /> conforme desenhada com o parâmetro <paramref name="font" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Drawing.Graphics.MeasureString%2A> método foi projetado para uso com o indivíduo cadeias de caracteres e inclui uma pequena quantidade de espaço extra antes e após a cadeia de caracteres para permitir em saliência em relação a glifos. Além disso, o <xref:System.Drawing.Graphics.DrawString%2A> método ajusta os pontos de glifo para otimizar a qualidade do vídeo e podem exibir uma cadeia de caracteres mais estreita que relatado pelo <xref:System.Drawing.Graphics.MeasureString%2A>. Para obter métricas adequadas para cadeias de caracteres adjacentes no layout (por exemplo, ao implementar texto formatado), use o <xref:System.Drawing.Graphics.MeasureCharacterRanges%2A> método ou um dos <xref:System.Drawing.Graphics.MeasureString%2A> métodos que usa um <xref:System.Drawing.StringFormat>e passe <xref:System.Drawing.StringFormat.GenericTypographic%2A>. Além disso, verifique se o <xref:System.Drawing.Graphics.TextRenderingHint%2A> para o <xref:System.Drawing.Graphics> é <xref:System.Drawing.Text.TextRenderingHint.AntiAlias>.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma cadeia de caracteres de medidas.  
  
-   Cria um objeto de fonte e define como Arial (16 pontos).  
  
-   Cria um objeto de tamanho e usa a ele e o objeto de fonte para medir o tamanho da cadeia de caracteres.  
  
-   Desenha um retângulo vermelho usando o tamanho medido da cadeia de caracteres.  
  
-   Desenha a cadeia de caracteres dentro do retângulo desenhado.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#136](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#136)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#136](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#136)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#136](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#136)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="font" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Usando fontes e texto</related>
      </Docs>
    </Member>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font, System.Drawing.SizeF layoutArea);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font, valuetype System.Drawing.SizeF layoutArea) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font,System.Drawing.SizeF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font, System::Drawing::SizeF layoutArea);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font * System.Drawing.SizeF -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font, layoutArea)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="layoutArea" Type="System.Drawing.SizeF" />
      </Parameters>
      <Docs>
        <param name="text">Cadeia de caracteres a ser medida.</param>
        <param name="font"><see cref="T:System.Drawing.Font" /> define o formato de texto da cadeia de caracteres.</param>
        <param name="layoutArea">A estrutura <see cref="T:System.Drawing.SizeF" /> que especifica a área de layout máximo para o texto.</param>
        <summary>Mede a cadeia de caracteres especificada desenhada com o <see cref="T:System.Drawing.Font" /> especificado dentro de uma área de layout especificada.</summary>
        <returns>Este método retorna uma estrutura <see cref="T:System.Drawing.SizeF" /> que representa o tamanho, nas unidades especificadas pela propriedade <see cref="P:System.Drawing.Graphics.PageUnit" />, da cadeia de caracteres especificada pelo parâmetro <paramref name="text" /> conforme desenhada com o parâmetro <paramref name="font" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Drawing.Graphics.MeasureString%2A> método foi projetado para uso com o indivíduo cadeias de caracteres e inclui uma pequena quantidade de espaço extra antes e após a cadeia de caracteres para permitir em saliência em relação a glifos. Além disso, o <xref:System.Drawing.Graphics.DrawString%2A> método ajusta os pontos de glifo para otimizar a qualidade do vídeo e podem exibir uma cadeia de caracteres mais estreita que relatado pelo <xref:System.Drawing.Graphics.MeasureString%2A>. Para obter métricas adequadas para cadeias de caracteres adjacentes no layout (por exemplo, ao implementar texto formatado), use o <xref:System.Drawing.Graphics.MeasureCharacterRanges%2A> método ou um dos <xref:System.Drawing.Graphics.MeasureString%2A> métodos que usa um <xref:System.Drawing.StringFormat>e passe <xref:System.Drawing.StringFormat.GenericTypographic%2A>. Além disso, verifique se o <xref:System.Drawing.Graphics.TextRenderingHint%2A> para o <xref:System.Drawing.Graphics> é <xref:System.Drawing.Text.TextRenderingHint.AntiAlias>.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma cadeia de caracteres para medir e um objeto de fonte definida como Arial (16 pontos).  
  
-   Define o tamanho máximo do layout da cadeia de caracteres.  
  
-   Cria um objeto de tamanho e usa, o objeto de fonte e o tamanho máximo de layout para medir o tamanho da cadeia de caracteres.  
  
-   Desenha um retângulo vermelho usando o tamanho medido da cadeia de caracteres.  
  
-   Desenha a cadeia de caracteres dentro do retângulo desenhado.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#138](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#138)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#138](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#138)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#138](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#138)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="font" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Usando fontes e texto</related>
      </Docs>
    </Member>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font, int width);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font, int32 width) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font, int width);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font * int -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font, width)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="width" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text">Cadeia de caracteres a ser medida.</param>
        <param name="font"><see cref="T:System.Drawing.Font" /> que define o formato da cadeia de caracteres.</param>
        <param name="width">Largura máxima da cadeia de caracteres em pixels.</param>
        <summary>Mede a cadeia de caracteres especificada quando desenhada com o <see cref="T:System.Drawing.Font" /> especificado.</summary>
        <returns>Este método retorna uma estrutura <see cref="T:System.Drawing.SizeF" /> que representa o tamanho, em unidades especificadas pela propriedade <see cref="P:System.Drawing.Graphics.PageUnit" />, da cadeia de caracteres especificada no parâmetro <paramref name="text" /> desenhada com o parâmetro <paramref name="font" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `width` parâmetro especifica o valor máximo do componente de largura de retornado <xref:System.Drawing.SizeF> estrutura (<xref:System.Drawing.SizeF.Width%2A>). Se o `width` parâmetro é menor que a largura real da cadeia de caracteres, retornada <xref:System.Drawing.SizeF.Width%2A> componente será truncado para um valor que representa o número máximo de caracteres que se ajustarão na largura especificada. Para acomodar a cadeia de caracteres inteira, retornada <xref:System.Drawing.SizeF.Height%2A> componente é ajustado para um valor que permite exibir a cadeia de caracteres com encapsulamento de caractere.  
  
 O <xref:System.Drawing.Graphics.MeasureString%2A> método foi projetado para uso com o indivíduo cadeias de caracteres e inclui uma pequena quantidade de espaço extra antes e após a cadeia de caracteres para permitir em saliência em relação a glifos. Além disso, o <xref:System.Drawing.Graphics.DrawString%2A> método ajusta os pontos de glifo para otimizar a qualidade do vídeo e podem exibir uma cadeia de caracteres mais estreita que relatado pelo <xref:System.Drawing.Graphics.MeasureString%2A>. Para obter métricas adequadas para cadeias de caracteres adjacentes no layout (por exemplo, ao implementar texto formatado), use o <xref:System.Drawing.Graphics.MeasureCharacterRanges%2A> método ou um dos <xref:System.Drawing.Graphics.MeasureString%2A> métodos que usa um <xref:System.Drawing.StringFormat>e passe <xref:System.Drawing.StringFormat.GenericTypographic%2A>. Além disso, verifique se o <xref:System.Drawing.Graphics.TextRenderingHint%2A> para o <xref:System.Drawing.Graphics> é <xref:System.Drawing.Text.TextRenderingHint.AntiAlias>.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma cadeia de caracteres para medir e um objeto de fonte definida como Arial (16 pontos).  
  
-   Define a largura máxima da cadeia de caracteres.  
  
-   Cria um objeto de tamanho e usa, o objeto de fonte e a largura máxima da cadeia de caracteres para medir o tamanho da cadeia de caracteres.  
  
-   Desenha um retângulo vermelho usando o tamanho medido da cadeia de caracteres.  
  
-   Desenha a cadeia de caracteres dentro do retângulo desenhado.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#141](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#141)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#141](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#141)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#141](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#141)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="font" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Usando fontes e texto</related>
      </Docs>
    </Member>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font, System.Drawing.PointF origin, System.Drawing.StringFormat stringFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font, valuetype System.Drawing.PointF origin, class System.Drawing.StringFormat stringFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font,System.Drawing.PointF,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font, System::Drawing::PointF origin, System::Drawing::StringFormat ^ stringFormat);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font * System.Drawing.PointF * System.Drawing.StringFormat -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font, origin, stringFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="origin" Type="System.Drawing.PointF" />
        <Parameter Name="stringFormat" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="text">Cadeia de caracteres a ser medida.</param>
        <param name="font"><see cref="T:System.Drawing.Font" /> define o formato de texto da cadeia de caracteres.</param>
        <param name="origin">A estrutura <see cref="T:System.Drawing.PointF" /> que representa o canto superior esquerdo da cadeia de caracteres.</param>
        <param name="stringFormat"><see cref="T:System.Drawing.StringFormat" /> que representa as informações de formatação, como o espaçamento entre linhas, para a cadeia de caracteres.</param>
        <summary>Mede a cadeia de caracteres especificada quando desenhada com o <see cref="T:System.Drawing.Font" /> especificado e formatada com o <see cref="T:System.Drawing.StringFormat" /> especificado.</summary>
        <returns>Este método retorna uma estrutura <see cref="T:System.Drawing.SizeF" /> que representa o tamanho, nas unidades especificadas pela propriedade <see cref="P:System.Drawing.Graphics.PageUnit" />, da cadeia de caracteres especificada pelo parâmetro <paramref name="text" /> conforme desenhado com o parâmetro <paramref name="font" /> e o parâmetro <paramref name="stringFormat" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Drawing.Graphics.MeasureString%2A> método foi projetado para uso com o indivíduo cadeias de caracteres e inclui uma pequena quantidade de espaço extra antes e após a cadeia de caracteres para permitir em saliência em relação a glifos. Além disso, o <xref:System.Drawing.Graphics.DrawString%2A> método ajusta os pontos de glifo para otimizar a qualidade do vídeo e podem exibir uma cadeia de caracteres mais estreita que relatado pelo <xref:System.Drawing.Graphics.MeasureString%2A>. Para obter métricas adequadas para cadeias de caracteres adjacentes no layout (por exemplo, ao implementar texto formatado), use o <xref:System.Drawing.Graphics.MeasureCharacterRanges%2A> método ou um dos <xref:System.Drawing.Graphics.MeasureString%2A> métodos que usa um <xref:System.Drawing.StringFormat>e passe <xref:System.Drawing.StringFormat.GenericTypographic%2A>. Além disso, verifique se o <xref:System.Drawing.Graphics.TextRenderingHint%2A> para o <xref:System.Drawing.Graphics> é <xref:System.Drawing.Text.TextRenderingHint.AntiAlias>.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma cadeia de caracteres para medir e um objeto de fonte definida como Arial (16 pontos)  
  
-   Cria um ponto para localizar o canto superior esquerdo da cadeia de caracteres.  
  
-   Cria um objeto de cadeia de caracteres de formato e define seus sinalizadores de formato para <xref:System.Drawing.StringFormatFlags.DirectionVertical>.  
  
-   Cria um objeto de tamanho para medir a cadeia de caracteres.  
  
-   Mede o tamanho da cadeia de caracteres, usando a cadeia de caracteres, o objeto de fonte, o ponto de localização e o formato de cadeia de caracteres.  
  
-   Desenha um retângulo vermelho usando o ponto de localização e o tamanho medido da cadeia de caracteres.  
  
-   Desenha a cadeia de caracteres dentro do retângulo desenhado.  
  
 O resultado é um retângulo vertical colocando uma cadeia de caracteres vertical.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#137](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#137)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#137](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#137)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#137](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#137)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="font" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Usando fontes e texto</related>
      </Docs>
    </Member>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font, System.Drawing.SizeF layoutArea, System.Drawing.StringFormat stringFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font, valuetype System.Drawing.SizeF layoutArea, class System.Drawing.StringFormat stringFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font,System.Drawing.SizeF,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font, System::Drawing::SizeF layoutArea, System::Drawing::StringFormat ^ stringFormat);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font * System.Drawing.SizeF * System.Drawing.StringFormat -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font, layoutArea, stringFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="layoutArea" Type="System.Drawing.SizeF" />
        <Parameter Name="stringFormat" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="text">Cadeia de caracteres a ser medida.</param>
        <param name="font"><see cref="T:System.Drawing.Font" /> define o formato de texto da cadeia de caracteres.</param>
        <param name="layoutArea">A estrutura <see cref="T:System.Drawing.SizeF" /> que especifica a área de layout máximo para o texto.</param>
        <param name="stringFormat"><see cref="T:System.Drawing.StringFormat" /> que representa as informações de formatação, como o espaçamento entre linhas, para a cadeia de caracteres.</param>
        <summary>Mede a cadeia de caracteres especificada quando desenhada com o <see cref="T:System.Drawing.Font" /> especificado e formatada com o <see cref="T:System.Drawing.StringFormat" /> especificado.</summary>
        <returns>Este método retorna uma estrutura <see cref="T:System.Drawing.SizeF" /> que representa o tamanho, nas unidades especificadas pela propriedade <see cref="P:System.Drawing.Graphics.PageUnit" />, da cadeia de caracteres especificada no parâmetro <paramref name="text" />, conforme desenhada com os parâmetros <paramref name="font" /> e <paramref name="stringFormat" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Drawing.Graphics.MeasureString%2A> método foi projetado para uso com o indivíduo cadeias de caracteres e inclui uma pequena quantidade de espaço extra antes e após a cadeia de caracteres para permitir em saliência em relação a glifos. Além disso, o <xref:System.Drawing.Graphics.DrawString%2A> método ajusta os pontos de glifo para otimizar a qualidade do vídeo e podem exibir uma cadeia de caracteres mais estreita que relatado pelo <xref:System.Drawing.Graphics.MeasureString%2A>. Para obter métricas adequadas para cadeias de caracteres adjacentes no layout (por exemplo, ao implementar texto formatado), use o <xref:System.Drawing.Graphics.MeasureCharacterRanges%2A> método ou um dos <xref:System.Drawing.Graphics.MeasureString%2A> métodos que usa um <xref:System.Drawing.StringFormat>e passe <xref:System.Drawing.StringFormat.GenericTypographic%2A>. Além disso, verifique se o <xref:System.Drawing.Graphics.TextRenderingHint%2A> para o <xref:System.Drawing.Graphics> é <xref:System.Drawing.Text.TextRenderingHint.AntiAlias>.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma cadeia de caracteres para medir e um objeto de fonte definida como Arial (16 pontos).  
  
-   Define o tamanho máximo do layout da cadeia de caracteres, criando um objeto de tamanho para medir a cadeia de caracteres.  
  
-   Cria um objeto de cadeia de caracteres de formato e define seus sinalizadores de formato para <xref:System.Drawing.StringFormatFlags.DirectionVertical>.  
  
-   Mede o tamanho da cadeia de caracteres, usando a cadeia de caracteres, o objeto de fonte, o tamanho máximo de layout e o formato de cadeia de caracteres.  
  
-   Desenha um retângulo vermelho usando o tamanho medido da cadeia de caracteres.  
  
-   Desenha a cadeia de caracteres dentro do retângulo desenhado.  
  
 O resultado é um retângulo vertical colocando uma cadeia de caracteres vertical.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#139](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#139)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#139](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#139)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#139](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#139)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="font" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Usando fontes e texto</related>
      </Docs>
    </Member>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font, int width, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font, int32 width, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font,System.Int32,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font, int width, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font * int * System.Drawing.StringFormat -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font, width, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="text">Cadeia de caracteres a ser medida.</param>
        <param name="font"><see cref="T:System.Drawing.Font" /> que define o formato de texto da cadeia de caracteres.</param>
        <param name="width">Largura máxima da cadeia de caracteres.</param>
        <param name="format"><see cref="T:System.Drawing.StringFormat" /> que representa as informações de formatação, como o espaçamento entre linhas, para a cadeia de caracteres.</param>
        <summary>Mede a cadeia de caracteres especificada quando desenhada com o <see cref="T:System.Drawing.Font" /> especificado e formatada com o <see cref="T:System.Drawing.StringFormat" /> especificado.</summary>
        <returns>Este método retorna uma estrutura <see cref="T:System.Drawing.SizeF" /> que representa o tamanho, nas unidades especificadas pela propriedade <see cref="P:System.Drawing.Graphics.PageUnit" />, da cadeia de caracteres especificada no parâmetro <paramref name="text" />, conforme desenhada com os parâmetros <paramref name="font" /> e <paramref name="stringFormat" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Drawing.Graphics.MeasureString%2A> método foi projetado para uso com o indivíduo cadeias de caracteres e inclui uma pequena quantidade de espaço extra antes e após a cadeia de caracteres para permitir em saliência em relação a glifos. Além disso, o <xref:System.Drawing.Graphics.DrawString%2A> método ajusta os pontos de glifo para otimizar a qualidade do vídeo e podem exibir uma cadeia de caracteres mais estreita que relatado pelo <xref:System.Drawing.Graphics.MeasureString%2A>. Para obter métricas adequadas para cadeias de caracteres adjacentes no layout (por exemplo, ao implementar texto formatado), use o <xref:System.Drawing.Graphics.MeasureCharacterRanges%2A> método ou um dos <xref:System.Drawing.Graphics.MeasureString%2A> métodos que usa um <xref:System.Drawing.StringFormat>e passe <xref:System.Drawing.StringFormat.GenericTypographic%2A>. Além disso, verifique se o <xref:System.Drawing.Graphics.TextRenderingHint%2A> para o <xref:System.Drawing.Graphics> é <xref:System.Drawing.Text.TextRenderingHint.AntiAlias>.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma cadeia de caracteres para medidas e uma fonte objeto defini-lo como Arial (16 pontos).  
  
-   Define a largura máxima da cadeia de caracteres.  
  
-   Cria um objeto de cadeia de caracteres de formato e define seus sinalizadores de formato para <xref:System.Drawing.StringFormatFlags.DirectionVertical>.  
  
-   Cria um objeto de tamanho para medir a cadeia de caracteres.  
  
-   Mede o tamanho da cadeia de caracteres, usando a cadeia de caracteres, o objeto de fonte, a largura máxima e o formato de cadeia de caracteres.  
  
-   Desenha um retângulo vermelho usando o tamanho medido da cadeia de caracteres.  
  
-   Desenha a cadeia de caracteres dentro do retângulo desenhado.  
  
 O resultado é um retângulo vertical colocando uma cadeia de caracteres vertical.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#142](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#142)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#142](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#142)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#142](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#142)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="font" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Usando fontes e texto</related>
      </Docs>
    </Member>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font, System.Drawing.SizeF layoutArea, System.Drawing.StringFormat stringFormat, out int charactersFitted, out int linesFilled);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font, valuetype System.Drawing.SizeF layoutArea, class System.Drawing.StringFormat stringFormat, [out] int32&amp; charactersFitted, [out] int32&amp; linesFilled) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font,System.Drawing.SizeF,System.Drawing.StringFormat,System.Int32@,System.Int32@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font, System::Drawing::SizeF layoutArea, System::Drawing::StringFormat ^ stringFormat, [Runtime::InteropServices::Out] int % charactersFitted, [Runtime::InteropServices::Out] int % linesFilled);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font * System.Drawing.SizeF * System.Drawing.StringFormat *  *  -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font, layoutArea, stringFormat, charactersFitted, linesFilled)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="layoutArea" Type="System.Drawing.SizeF" />
        <Parameter Name="stringFormat" Type="System.Drawing.StringFormat" />
        <Parameter Name="charactersFitted" Type="System.Int32" RefType="out" />
        <Parameter Name="linesFilled" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="text">Cadeia de caracteres a ser medida.</param>
        <param name="font"><see cref="T:System.Drawing.Font" /> que define o formato de texto da cadeia de caracteres.</param>
        <param name="layoutArea">A estrutura <see cref="T:System.Drawing.SizeF" /> que especifica a área de layout máximo para o texto.</param>
        <param name="stringFormat"><see cref="T:System.Drawing.StringFormat" /> que representa as informações de formatação, como o espaçamento entre linhas, para a cadeia de caracteres.</param>
        <param name="charactersFitted">O número de caracteres na cadeia de caracteres.</param>
        <param name="linesFilled">O número de linhas de texto na cadeia de caracteres.</param>
        <summary>Mede a cadeia de caracteres especificada quando desenhada com o <see cref="T:System.Drawing.Font" /> especificado e formatada com o <see cref="T:System.Drawing.StringFormat" /> especificado.</summary>
        <returns>Esse método retorna uma estrutura <see cref="T:System.Drawing.SizeF" /> que representa o tamanho, em unidades especificadas pela propriedade <see cref="P:System.Drawing.Graphics.PageUnit" />, da cadeia de caracteres do parâmetro <paramref name="text" /> desenhada com os parâmetros <paramref name="font" /> e <paramref name="stringFormat" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Drawing.Graphics.MeasureString%2A> método foi projetado para uso com o indivíduo cadeias de caracteres e inclui uma pequena quantidade de espaço extra antes e após a cadeia de caracteres para permitir em saliência em relação a glifos. Além disso, o <xref:System.Drawing.Graphics.DrawString%2A> método ajusta os pontos de glifo para otimizar a qualidade do vídeo e podem exibir uma cadeia de caracteres mais estreita que relatado pelo <xref:System.Drawing.Graphics.MeasureString%2A>. Para obter métricas adequadas para cadeias de caracteres adjacentes no layout (por exemplo, ao implementar texto formatado), use o <xref:System.Drawing.Graphics.MeasureCharacterRanges%2A> método ou um dos <xref:System.Drawing.Graphics.MeasureString%2A> métodos que usa um <xref:System.Drawing.StringFormat> e passe <xref:System.Drawing.StringFormat.GenericTypographic%2A>. Também verifique se o <xref:System.Drawing.Graphics.TextRenderingHint%2A> para o <xref:System.Drawing.Graphics> é <xref:System.Drawing.Text.TextRenderingHint.AntiAlias>.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria uma cadeia de caracteres para medir e um objeto de fonte definida como Arial (16 pontos)  
  
-   Define o tamanho máximo do layout da cadeia de caracteres.  
  
-   Cria um objeto de cadeia de caracteres de formato e define seus sinalizadores de formato para <xref:System.Drawing.StringFormatFlags.DirectionVertical>.  
  
-   Cria as variáveis de inteiro `charactersFitted` e `linesFilled` e um objeto de tamanho para medir a cadeia de caracteres.  
  
-   Mede o tamanho da cadeia de caracteres e determina o número de linhas preenchidas, usando a cadeia de caracteres, o objeto de fonte, o tamanho máximo de layout e o formato de cadeia de caracteres e caracteres ajustados.  
  
-   Desenha um retângulo vermelho usando o tamanho medido da cadeia de caracteres.  
  
-   Desenha a cadeia de caracteres dentro do retângulo desenhado.  
  
-   Desenha os valores do número de linhas preenchidas e ajustados de caracteres.  
  
 O resultado é um retângulo vertical colocando uma cadeia de caracteres vertical.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#140](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#140)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#140](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#140)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#140](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#140)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="font" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Usando fontes e texto</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyTransform">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Multiplica a transformação global deste <see cref="T:System.Drawing.Graphics" /> e especificou o <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyTransform">
      <MemberSignature Language="C#" Value="public void MultiplyTransform (System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MultiplyTransform(class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MultiplyTransform(System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MultiplyTransform(System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberSignature Language="F#" Value="member this.MultiplyTransform : System.Drawing.Drawing2D.Matrix -&gt; unit" Usage="graphics.MultiplyTransform matrix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">4x4 <see cref="T:System.Drawing.Drawing2D.Matrix" /> que multiplica a transformação global.</param>
        <summary>Multiplica a transformação global deste <see cref="T:System.Drawing.Graphics" /> e especificou o <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método precede a matriz especificada o `matrix` parâmetro, para que o resultado é `matrix` x transformação global.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um `transformMatrix` matriz (uma dois por dois matriz de identidade além de um vetor de conversão de zero).  
  
-   Converte a matriz de transformação por um vetor (200, 100).  
  
-   A matriz de transformação global do formulário Windows gira 30 graus, precede a matriz de rotação de 30 graus à matriz de transformação do formulário.  
  
-   Multiplica a matriz de transformação de mundo girado pelo traduzido `transformMatrix`e precede o `transformMatrix` à matriz de transformação de mundo.  
  
-   Desenha uma elipse girada, traduzida.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#143](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#143)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#143](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#143)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#143](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#143)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/0659fe00-9e0c-41c4-9118-016f2404c905">Representação matricial de transformações</related>
      </Docs>
    </Member>
    <Member MemberName="MultiplyTransform">
      <MemberSignature Language="C#" Value="public void MultiplyTransform (System.Drawing.Drawing2D.Matrix matrix, System.Drawing.Drawing2D.MatrixOrder order);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MultiplyTransform(class System.Drawing.Drawing2D.Matrix matrix, valuetype System.Drawing.Drawing2D.MatrixOrder order) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MultiplyTransform(System.Drawing.Drawing2D.Matrix,System.Drawing.Drawing2D.MatrixOrder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MultiplyTransform(System::Drawing::Drawing2D::Matrix ^ matrix, System::Drawing::Drawing2D::MatrixOrder order);" />
      <MemberSignature Language="F#" Value="member this.MultiplyTransform : System.Drawing.Drawing2D.Matrix * System.Drawing.Drawing2D.MatrixOrder -&gt; unit" Usage="graphics.MultiplyTransform (matrix, order)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="order" Type="System.Drawing.Drawing2D.MatrixOrder" />
      </Parameters>
      <Docs>
        <param name="matrix">4x4 <see cref="T:System.Drawing.Drawing2D.Matrix" /> que multiplica a transformação global.</param>
        <param name="order">Membro da enumeração <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> que determina a ordem da multiplicação.</param>
        <summary>Multiplica a transformação global deste <see cref="T:System.Drawing.Graphics" /> e especificou o <see cref="T:System.Drawing.Drawing2D.Matrix" /> na ordem especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um valor de <xref:System.Drawing.Drawing2D.MatrixOrder.Prepend> para o `order` parâmetro especifica que a ordem da multiplicação é `matrix` x transformação global. Um valor de <xref:System.Drawing.Drawing2D.MatrixOrder.Append> para `order` Especifica que a ordem da multiplicação é a transformação global x `matrix`.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um `transformMatrix` matriz (uma dois por dois matriz de identidade além de um vetor de conversão de zero).  
  
-   Converte a matriz de transformação por um vetor (200, 100).  
  
-   A matriz de transformação global do formulário Windows gira 30 graus, acrescentando a matriz de rotação de 30 graus à matriz de transformação do formulário.  
  
-   Multiplica a matriz de transformação de mundo girado pelo traduzido `transformMatrix`, acrescentando o `transformMatrix` à matriz de transformação de mundo.  
  
-   Desenha uma elipse girada, traduzida.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#144](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#144)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#144](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#144)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#144](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#144)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/0659fe00-9e0c-41c4-9118-016f2404c905">Representação matricial de transformações</related>
      </Docs>
    </Member>
    <Member MemberName="PageScale">
      <MemberSignature Language="C#" Value="public float PageScale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 PageScale" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.PageScale" />
      <MemberSignature Language="VB.NET" Value="Public Property PageScale As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float PageScale { float get(); void set(float value); };" />
      <MemberSignature Language="F#" Value="member this.PageScale : single with get, set" Usage="System.Drawing.Graphics.PageScale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o dimensionamento entre unidades do mundo e de página para este <see cref="T:System.Drawing.Graphics" />.</summary>
        <value>Esta propriedade especifica um valor para o dimensionamento entre unidades de mundo e de página para este <see cref="T:System.Drawing.Graphics" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Drawing.Graphics.PageScale%2A> e <xref:System.Drawing.Graphics.TranslateTransform%2A> membros para alterar a escala e a origem quando você desenhar um retângulo.  
  
 Este exemplo é projetado para ser usado com o Windows Forms. Cole o código em um formulário e chame o `ChangePageScaleAndTranslateTransform` método ao lidar com o formulário <xref:System.Windows.Forms.Control.Paint> evento, passando `e` como <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-cpp[System.Drawing.GraphicsProperties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CPP/form1.cpp#2)]
 [!code-csharp[System.Drawing.GraphicsProperties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CS/form1.cs#2)]
 [!code-vb[System.Drawing.GraphicsProperties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/c61ff50a-eb1d-4e6c-83cd-f7e9764cfa9f">Tipos de sistemas de coordenadas</related>
      </Docs>
    </Member>
    <Member MemberName="PageUnit">
      <MemberSignature Language="C#" Value="public System.Drawing.GraphicsUnit PageUnit { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.GraphicsUnit PageUnit" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.PageUnit" />
      <MemberSignature Language="VB.NET" Value="Public Property PageUnit As GraphicsUnit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::GraphicsUnit PageUnit { System::Drawing::GraphicsUnit get(); void set(System::Drawing::GraphicsUnit value); };" />
      <MemberSignature Language="F#" Value="member this.PageUnit : System.Drawing.GraphicsUnit with get, set" Usage="System.Drawing.Graphics.PageUnit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.GraphicsUnit</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a unidade de medida usada para as coordenadas da página neste <see cref="T:System.Drawing.Graphics" />.</summary>
        <value>Um dos valores de <see cref="T:System.Drawing.GraphicsUnit" /> além de <see cref="F:System.Drawing.GraphicsUnit.World" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A unidade de gráficos é a unidade de medida usadas para as coordenadas da página neste <xref:System.Drawing.Graphics>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o efeito de alterar o <xref:System.Drawing.Graphics.PageUnit%2A> propriedade.  
  
 Este exemplo é projetado para ser usado com o Windows Forms. Cole o código em um formulário e chame o `ChangePageUnit` método ao lidar com o formulário <xref:System.Windows.Forms.Control.Paint> evento, passando `e` como <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-cpp[System.Drawing.GraphicsProperties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CPP/form1.cpp#3)]
 [!code-csharp[System.Drawing.GraphicsProperties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CS/form1.cs#3)]
 [!code-vb[System.Drawing.GraphicsProperties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><see cref="P:System.Drawing.Graphics.PageUnit" /> é definido como <see cref="F:System.Drawing.GraphicsUnit.World" />, que não é uma unidade física.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/c61ff50a-eb1d-4e6c-83cd-f7e9764cfa9f">Tipos de sistemas de coordenadas</related>
      </Docs>
    </Member>
    <Member MemberName="PixelOffsetMode">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.PixelOffsetMode PixelOffsetMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.PixelOffsetMode PixelOffsetMode" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.PixelOffsetMode" />
      <MemberSignature Language="VB.NET" Value="Public Property PixelOffsetMode As PixelOffsetMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::PixelOffsetMode PixelOffsetMode { System::Drawing::Drawing2D::PixelOffsetMode get(); void set(System::Drawing::Drawing2D::PixelOffsetMode value); };" />
      <MemberSignature Language="F#" Value="member this.PixelOffsetMode : System.Drawing.Drawing2D.PixelOffsetMode with get, set" Usage="System.Drawing.Graphics.PixelOffsetMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.PixelOffsetMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que especifica como os pixels são deslocados durante a renderização deste <see cref="T:System.Drawing.Graphics" />.</summary>
        <value>Esta propriedade especifica um membro da enumeração <see cref="T:System.Drawing.Drawing2D.PixelOffsetMode" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa propriedade para especificar qualquer um dos mais alta renderização de mais rápida qualidade, renderização mais lenta ou de qualidade inferior, do conteúdo deste <xref:System.Drawing.Graphics> objeto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReleaseHdc">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libera um identificador de contexto de dispositivo obtido por uma chamada anterior ao método <see cref="M:System.Drawing.Graphics.GetHdc" /> deste <see cref="T:System.Drawing.Graphics" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReleaseHdc">
      <MemberSignature Language="C#" Value="public void ReleaseHdc ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseHdc() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ReleaseHdc" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseHdc ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseHdc();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseHdc : unit -&gt; unit&#xA;override this.ReleaseHdc : unit -&gt; unit" Usage="graphics.ReleaseHdc " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Drawing.IDeviceContext.ReleaseHdc</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera um identificador de contexto de dispositivo obtido por uma chamada anterior ao método <see cref="M:System.Drawing.Graphics.GetHdc" /> deste <see cref="T:System.Drawing.Graphics" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Graphics.GetHdc%2A> e <xref:System.Drawing.Graphics.ReleaseHdc%2A> são dois métodos que permitem obter e liberar o identificador para um dispositivo do Windows. Você sempre deve seguir uma chamada para <xref:System.Drawing.Graphics.GetHdc%2A> com uma chamada para <xref:System.Drawing.Graphics.ReleaseHdc%2A> quando tiver terminado com o identificador do Windows.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para acesso a código não gerenciado. Relacionado a enumeração: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <altmember cref="T:System.Drawing.IDeviceContext" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseHdc">
      <MemberSignature Language="C#" Value="public void ReleaseHdc (IntPtr hdc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseHdc(native int hdc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ReleaseHdc(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseHdc (hdc As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseHdc(IntPtr hdc);" />
      <MemberSignature Language="F#" Value="member this.ReleaseHdc : nativeint -&gt; unit" Usage="graphics.ReleaseHdc hdc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hdc" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hdc">Identificador para um contexto de dispositivo obtido por uma chamada anterior ao método <see cref="M:System.Drawing.Graphics.GetHdc" /> desse <see cref="T:System.Drawing.Graphics" />.</param>
        <summary>Libera um identificador de contexto de dispositivo obtido por uma chamada anterior ao método <see cref="M:System.Drawing.Graphics.GetHdc" /> deste <see cref="T:System.Drawing.Graphics" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O contexto de dispositivo é uma estrutura do Windows baseada em [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] que define um conjunto de objetos gráficos e seus atributos associados, bem como os modos de gráficos que afetam a saída.  
  
 Chamadas para o <xref:System.Drawing.Graphics.GetHdc%2A> e <xref:System.Drawing.Graphics.ReleaseHdc%2A> métodos devem aparecer em pares. Durante o escopo de um <xref:System.Drawing.Graphics.GetHdc%2A> e <xref:System.Drawing.Graphics.ReleaseHdc%2A> par de métodos, você geralmente faz chamadas somente a [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] funções. Chama nesse escopo feitas [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] métodos do <xref:System.Drawing.Graphics> que produziu o `hdc` parâmetro falhar com um `ObjectBusy` erro. Além disso, [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] ignora as alterações de estado feitas para o <xref:System.Drawing.Graphics> da `hdc` parâmetro em operações subsequentes.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O exemplo ilustra a chamada de um Windows [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] função para executar a mesma tarefa como uma [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] <xref:System.Drawing.Graphics> método. O código executa as seguintes ações:  
  
-   Define a interoperabilidade <xref:System.Runtime.InteropServices.DllImportAttribute> atributo para o arquivo gdi32.dll arquivo de DLL do Windows. Essa DLL contém o estado desejado [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] função e ela define o <xref:System.Drawing.Rectangle> função nessa DLL como externo.  
  
-   Cria uma caneta de vermelha.  
  
-   Com a caneta desenha um retângulo para a tela usando o [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] <xref:System.Drawing.Graphics.DrawRectangle%2A> método.  
  
-   Define uma variável do tipo ponteiro interno `hdc` e define seu valor como o identificador para o contexto de dispositivo do formulário.  
  
-   Desenha um retângulo para a tela usando o [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] <xref:System.Drawing.Rectangle> função.  
  
-   Libera o contexto de dispositivo, representado pelo `hdc` parâmetro.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#145](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#145)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#145](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#145)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#145](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#145)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para acesso a código não gerenciado. Relacionado a enumeração: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseHdcInternal">
      <MemberSignature Language="C#" Value="public void ReleaseHdcInternal (IntPtr hdc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseHdcInternal(native int hdc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ReleaseHdcInternal(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseHdcInternal (hdc As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseHdcInternal(IntPtr hdc);" />
      <MemberSignature Language="F#" Value="member this.ReleaseHdcInternal : nativeint -&gt; unit" Usage="graphics.ReleaseHdcInternal hdc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hdc" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hdc">Identificador para um contexto de dispositivo.</param>
        <summary>Libera um identificador para um contexto de dispositivo.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para acesso a código não gerenciado. Relacionado a enumeração: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="RenderingOrigin">
      <MemberSignature Language="C#" Value="public System.Drawing.Point RenderingOrigin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point RenderingOrigin" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.RenderingOrigin" />
      <MemberSignature Language="VB.NET" Value="Public Property RenderingOrigin As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point RenderingOrigin { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberSignature Language="F#" Value="member this.RenderingOrigin : System.Drawing.Point with get, set" Usage="System.Drawing.Graphics.RenderingOrigin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a origem de renderização deste <see cref="T:System.Drawing.Graphics" /> para pincéis de hachura e pontilhamento.</summary>
        <value>Uma estrutura <see cref="T:System.Drawing.Point" /> que representa a origem para pontilhamentos de 8 bits por pixel e de 16 bits por pixel e que também é usada para definir a origem dos pincéis de hachura.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetClip">
      <MemberSignature Language="C#" Value="public void ResetClip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetClip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ResetClip" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetClip ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetClip();" />
      <MemberSignature Language="F#" Value="member this.ResetClip : unit -&gt; unit" Usage="graphics.ResetClip " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Redefine a região de recorte desse <see cref="T:System.Drawing.Graphics" /> para uma região infinita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando a região de recorte de um <xref:System.Drawing.Graphics> é infinito, os itens que este <xref:System.Drawing.Graphics> desenha não é cortadas.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um retângulo com o canto superior esquerdo em (0, 0) e define a região de recorte para esse retângulo.  
  
-   Cria um segundo retângulo com o canto superior esquerdo em (100, 100) e define a região de recorte para a interseção desse retângulo e a região de recorte atual (o primeiro retângulo).  
  
-   Preenche um retângulo grande que inclui os dois retângulos anteriores com um pincel azul sólido.  
  
-   Redefine a região de recorte para infinito.  
  
-   Desenha retângulos em torno de duas áreas de recorte; Ele usa uma caneta preta para o primeiro retângulo de recorte e uma caneta de vermelha para a segunda região de recorte.  
  
 O resultado é que apenas a interseção de dois retângulos é preenchida com azul.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#146](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#146)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#146](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#146)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#146](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#146)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetTransform">
      <MemberSignature Language="C#" Value="public void ResetTransform ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetTransform() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ResetTransform" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetTransform ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetTransform();" />
      <MemberSignature Language="F#" Value="member this.ResetTransform : unit -&gt; unit" Usage="graphics.ResetTransform " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Redefine a matriz de transformação global desse <see cref="T:System.Drawing.Graphics" /> para a matriz de identidade.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A matriz de identidade representa uma transformação sem escala, rotação ou translação. Redefinindo a transformação global deste <xref:System.Drawing.Graphics> para a matriz de identidade, significa que sua transformação world não altera a geometria de itens transformados.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Converte a transformação de mundo do formulário do Windows por um vetor de (100, 0).  
  
-   Salva o estado de gráficos do formulário.  
  
-   Redefine a transformação de mundo do formulário para uma identidade e preenche um retângulo com um pincel vermelho sólido.  
  
-   Restaura o estado dos gráficos traduzido e preenche um retângulo com um pincel azul sólido.  
  
 O resultado é um retângulo de vermelho não traduzido e um retângulo de preenchimento azul traduzido.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#147](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#147)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#147](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#147)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#147](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#147)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restore">
      <MemberSignature Language="C#" Value="public void Restore (System.Drawing.Drawing2D.GraphicsState gstate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Restore(class System.Drawing.Drawing2D.GraphicsState gstate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Restore(System.Drawing.Drawing2D.GraphicsState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Restore (gstate As GraphicsState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Restore(System::Drawing::Drawing2D::GraphicsState ^ gstate);" />
      <MemberSignature Language="F#" Value="member this.Restore : System.Drawing.Drawing2D.GraphicsState -&gt; unit" Usage="graphics.Restore gstate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gstate" Type="System.Drawing.Drawing2D.GraphicsState" />
      </Parameters>
      <Docs>
        <param name="gstate"><see cref="T:System.Drawing.Drawing2D.GraphicsState" /> que representa o estado para o qual restaurar este <see cref="T:System.Drawing.Graphics" />.</param>
        <summary>Restaura o estado desse <see cref="T:System.Drawing.Graphics" /> para o estado representado por um <see cref="T:System.Drawing.Drawing2D.GraphicsState" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você chama o <xref:System.Drawing.Graphics.Save%2A> método de um <xref:System.Drawing.Graphics>, um bloco de informações que mantém o estado do <xref:System.Drawing.Graphics> é colocado em uma pilha. O <xref:System.Drawing.Graphics.Save%2A> método retorna um <xref:System.Drawing.Drawing2D.GraphicsState> que identifica esse bloco de informações. Quando você passa a identifica <xref:System.Drawing.Drawing2D.GraphicsState> para o <xref:System.Drawing.Graphics.Restore%2A> método, o bloco de informações é removido da pilha e é usado para restaurar o <xref:System.Drawing.Graphics> para o estado em que estava no momento do <xref:System.Drawing.Graphics.Save%2A> chamada de método. Observe que o <xref:System.Drawing.Drawing2D.GraphicsState> retornado por uma determinada chamada para o <xref:System.Drawing.Graphics.Save%2A> método pode ser passado apenas uma vez para o `Restore` método.  
  
 Chamadas para o <xref:System.Drawing.Graphics.Save%2A> método pode ser aninhado; ou seja, você pode chamar o <xref:System.Drawing.Graphics.Save%2A> método várias vezes antes de chamar o <xref:System.Drawing.Graphics.Restore%2A> método. Sempre que você chama o <xref:System.Drawing.Graphics.Save%2A> método, um bloco de informações é colocado na pilha, e você recebe um <xref:System.Drawing.Drawing2D.GraphicsState> para o bloco de informações. Quando você passa um desses objetos para o <xref:System.Drawing.Graphics.Restore%2A> método, o <xref:System.Drawing.Graphics> é retornado para o estado em que estava no momento das <xref:System.Drawing.Graphics.Save%2A> chamada de método que retornou que determinado <xref:System.Drawing.Drawing2D.GraphicsState>. O bloco de informações é colocado na pilha de por que <xref:System.Drawing.Graphics.Save%2A> chamada de método é removida da pilha, e todos os blocos de informações é colocado na pilha depois que <xref:System.Drawing.Graphics.Save%2A> chamada de método também serão removidos.  
  
 Chamadas para o <xref:System.Drawing.Graphics.BeginContainer%2A> blocos de informações de local do método na mesma pilha de chamadas para o <xref:System.Drawing.Graphics.Save%2A> método. Assim como uma <xref:System.Drawing.Graphics.Restore%2A> chamada é emparelhada com um <xref:System.Drawing.Graphics.Save%2A> chamar, um <xref:System.Drawing.Graphics.EndContainer%2A> chamada de método é emparelhada com um <xref:System.Drawing.Graphics.BeginContainer%2A> chamada de método.  
  
 Quando você chama o <xref:System.Drawing.Graphics.Restore%2A> todos os blocos de informações de método, colocado na pilha de (pelo <xref:System.Drawing.Graphics.Save%2A> método ou o <xref:System.Drawing.Graphics.BeginContainer%2A> método) após a chamada correspondente para o <xref:System.Drawing.Graphics.Save%2A> método são removidos da pilha. Da mesma forma, quando você chama o <xref:System.Drawing.Graphics.EndContainer%2A> todos os blocos de informações de método, colocado na pilha de (pelo <xref:System.Drawing.Graphics.Save%2A> método ou o <xref:System.Drawing.Graphics.BeginContainer%2A> método) após a chamada correspondente para o <xref:System.Drawing.Graphics.BeginContainer%2A> método são removidos da pilha.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Converte a transformação de mundo do formulário do Windows por um vetor de (100, 0).  
  
-   Salva o estado de gráficos do formulário.  
  
-   Redefine a transformação de mundo do formulário para uma identidade e preenche um retângulo com um pincel vermelho sólido.  
  
-   Restaura o estado dos gráficos traduzido e preenche um segundo retângulo com um pincel azul sólido.  
  
 O resultado é um retângulo de vermelho não traduzido e um retângulo de preenchimento azul traduzido.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#148](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#148)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#148](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#148)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#148](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#148)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RotateTransform">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aplica a rotação especificada à matriz de transformação desse <see cref="T:System.Drawing.Graphics" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RotateTransform">
      <MemberSignature Language="C#" Value="public void RotateTransform (float angle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RotateTransform(float32 angle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.RotateTransform(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RotateTransform (angle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RotateTransform(float angle);" />
      <MemberSignature Language="F#" Value="member this.RotateTransform : single -&gt; unit" Usage="graphics.RotateTransform angle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="angle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="angle">Ângulo de rotação em graus.</param>
        <summary>Aplica a rotação especificada à matriz de transformação desse <see cref="T:System.Drawing.Graphics" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A operação de rotação consiste de multiplicação de matriz de transformação por uma matriz cujos elementos são derivados de `angle` parâmetro. Esse método se aplica a rotação precedendo-a matriz de transformação.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Converte a matriz de transformação global do formulário Windows pelo vetor (100, 0).  
  
-   Gira a transformação global por um ângulo de 30 graus, acrescentando a matriz de rotação para a matriz de transformação de mundo.  
  
-   Desenha uma elipse girada, traduzida com uma caneta azul.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#149](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#149)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#149](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#149)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#149](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#149)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RotateTransform">
      <MemberSignature Language="C#" Value="public void RotateTransform (float angle, System.Drawing.Drawing2D.MatrixOrder order);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RotateTransform(float32 angle, valuetype System.Drawing.Drawing2D.MatrixOrder order) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.RotateTransform(System.Single,System.Drawing.Drawing2D.MatrixOrder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RotateTransform (angle As Single, order As MatrixOrder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RotateTransform(float angle, System::Drawing::Drawing2D::MatrixOrder order);" />
      <MemberSignature Language="F#" Value="member this.RotateTransform : single * System.Drawing.Drawing2D.MatrixOrder -&gt; unit" Usage="graphics.RotateTransform (angle, order)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="angle" Type="System.Single" />
        <Parameter Name="order" Type="System.Drawing.Drawing2D.MatrixOrder" />
      </Parameters>
      <Docs>
        <param name="angle">Ângulo de rotação em graus.</param>
        <param name="order">Membro da enumeração <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> que especifica se a rotação é acrescentada ou anexada à transformação da matriz.</param>
        <summary>Aplica a rotação especificada à matriz de transformação desse <see cref="T:System.Drawing.Graphics" /> na ordem especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A operação de rotação consiste de multiplicação de matriz de transformação por uma matriz cujos elementos são derivados de `angle` parâmetro. Esse método precede ou acrescenta a matriz de transformação a <xref:System.Drawing.Graphics> pela matriz de rotação de acordo com o `order` parâmetro.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Converte a matriz de transformação global do formulário Windows pelo vetor (100, 0).  
  
-   Gira a transformação de mundo por um ângulo de 30 graus, acrescentando a matriz de rotação para a matriz de transformação de mundo com <xref:System.Drawing.Drawing2D.MatrixOrder.Append>.  
  
-   Desenha uma elipse traduzida, girada com uma caneta azul.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#150](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#150)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#150](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#150)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#150](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#150)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.GraphicsState Save ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Drawing2D.GraphicsState Save() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Save" />
      <MemberSignature Language="VB.NET" Value="Public Function Save () As GraphicsState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Drawing2D::GraphicsState ^ Save();" />
      <MemberSignature Language="F#" Value="member this.Save : unit -&gt; System.Drawing.Drawing2D.GraphicsState" Usage="graphics.Save " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.GraphicsState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Salva o estado atual deste <see cref="T:System.Drawing.Graphics" /> e identifica o estado salvo com um <see cref="T:System.Drawing.Drawing2D.GraphicsState" />.</summary>
        <returns>Esse método retorna um <see cref="T:System.Drawing.Drawing2D.GraphicsState" /> que representa o estado salvo deste <see cref="T:System.Drawing.Graphics" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você chama o <xref:System.Drawing.Graphics.Save%2A> método de um <xref:System.Drawing.Graphics>, um bloco de informações que mantém o estado do <xref:System.Drawing.Graphics> é colocado em uma pilha. O <xref:System.Drawing.Graphics.Save%2A> método retorna um <xref:System.Drawing.Drawing2D.GraphicsState> que identifica esse bloco de informações. Quando você passa a identifica <xref:System.Drawing.Drawing2D.GraphicsState> para o <xref:System.Drawing.Graphics.Restore%2A> método, o bloco de informações é removido da pilha e é usado para restaurar o <xref:System.Drawing.Graphics> para o estado em que estava no momento do <xref:System.Drawing.Graphics.Save%2A> chamada de método. Observe que o <xref:System.Drawing.Drawing2D.GraphicsState> retornado por uma determinada chamada para o <xref:System.Drawing.Graphics.Save%2A> método pode ser passado apenas uma vez para o <xref:System.Drawing.Graphics.Restore%2A> método.  
  
 Chamadas para o <xref:System.Drawing.Graphics.Save%2A> método pode ser aninhado; ou seja, você pode chamar o <xref:System.Drawing.Graphics.Save%2A> método várias vezes antes de chamar o <xref:System.Drawing.Graphics.Restore%2A> método. Sempre que você chama o <xref:System.Drawing.Graphics.Save%2A> método, um bloco de informações é colocado na pilha, e você recebe um <xref:System.Drawing.Drawing2D.GraphicsState> para o bloco de informações. Quando você passa um desses objetos para o <xref:System.Drawing.Graphics.Restore%2A> método, o <xref:System.Drawing.Graphics> é retornado para o estado em que estava no momento das <xref:System.Drawing.Graphics.Save%2A> chamada de método que retornou que determinado <xref:System.Drawing.Drawing2D.GraphicsState>. O bloco de informações é colocado na pilha de por que <xref:System.Drawing.Graphics.Save%2A> chamada de método é removida da pilha, e todos os blocos de informações é colocado na pilha depois que <xref:System.Drawing.Graphics.Save%2A> chamada de método também serão removidos.  
  
 Chamadas para o <xref:System.Drawing.Graphics.BeginContainer%2A> blocos de informações de local do método na mesma pilha de chamadas para o <xref:System.Drawing.Graphics.Save%2A> método. Assim como uma <xref:System.Drawing.Graphics.Restore%2A> chamada é emparelhada com um <xref:System.Drawing.Graphics.Save%2A> chamar, um <xref:System.Drawing.Graphics.EndContainer%2A> chamada de método é emparelhada com um <xref:System.Drawing.Graphics.BeginContainer%2A> chamada de método.  
  
 Quando você chama o <xref:System.Drawing.Graphics.Restore%2A> todos os blocos de informações de método, colocado na pilha de (pelo <xref:System.Drawing.Graphics.Save%2A> método ou o <xref:System.Drawing.Graphics.BeginContainer%2A> método) após a chamada correspondente para o <xref:System.Drawing.Graphics.Save%2A> método são removidos da pilha. Da mesma forma, quando você chama o <xref:System.Drawing.Graphics.EndContainer%2A> todos os blocos de informações de método, colocado na pilha de (pelo <xref:System.Drawing.Graphics.Save%2A> método ou o <xref:System.Drawing.Graphics.BeginContainer%2A> método) após a chamada correspondente para o <xref:System.Drawing.Graphics.BeginContainer%2A> método são removidos da pilha.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Converte a transformação de mundo do formulário do Windows por um vetor de (100, 0).  
  
-   Salva o estado de gráficos do formulário.  
  
-   Redefine a transformação de mundo do formulário para uma identidade (matriz de identidade de 2 x 2 mais uma translação do vetor de zero) e preenche um retângulo com um pincel vermelho sólido.  
  
-   Restaura o estado dos gráficos traduzido e preenche um retângulo com um pincel azul sólido.  
  
 O resultado é um retângulo preenchido em vermelha não traduzido à esquerda e um retângulo preenchido em azul traduzido à direita do formulário.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#151](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#151)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#151](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#151)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#151](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#151)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ScaleTransform">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aplica a operação de colocação em escala especificada à matriz de transformação desse <see cref="T:System.Drawing.Graphics" /> precedendo-a à matriz de transformação do objeto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ScaleTransform">
      <MemberSignature Language="C#" Value="public void ScaleTransform (float sx, float sy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScaleTransform(float32 sx, float32 sy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ScaleTransform(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScaleTransform (sx As Single, sy As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScaleTransform(float sx, float sy);" />
      <MemberSignature Language="F#" Value="member this.ScaleTransform : single * single -&gt; unit" Usage="graphics.ScaleTransform (sx, sy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sx" Type="System.Single" />
        <Parameter Name="sy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="sx">Fator de escala na direção x.</param>
        <param name="sy">Fator de escala na direção y.</param>
        <summary>Aplica a operação de colocação em escala especificada à matriz de transformação desse <see cref="T:System.Drawing.Graphics" /> precedendo-a à matriz de transformação do objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A operação de dimensionamento consiste em multiplicar a matriz de transformação por uma diagonal matriz cujos elementos são (`sx`, `sy`, 1). Esse método precede a matriz de transformação de <xref:System.Drawing.Graphics> pela matriz de colocação em escala.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   A matriz de transformação global do formulário Windows gira 30 graus.  
  
-   Dimensiona essa matriz por um fator de 3 na direção x e um fator de 1 na direção y acrescentando a transformação de colocação em escala.  
  
-   Desenha um retângulo girado, dimensionado com uma caneta azul.  
  
 O resultado ainda é um retângulo.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#152](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#152)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#152](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#152)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#152](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#152)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleTransform">
      <MemberSignature Language="C#" Value="public void ScaleTransform (float sx, float sy, System.Drawing.Drawing2D.MatrixOrder order);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScaleTransform(float32 sx, float32 sy, valuetype System.Drawing.Drawing2D.MatrixOrder order) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ScaleTransform(System.Single,System.Single,System.Drawing.Drawing2D.MatrixOrder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScaleTransform (sx As Single, sy As Single, order As MatrixOrder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScaleTransform(float sx, float sy, System::Drawing::Drawing2D::MatrixOrder order);" />
      <MemberSignature Language="F#" Value="member this.ScaleTransform : single * single * System.Drawing.Drawing2D.MatrixOrder -&gt; unit" Usage="graphics.ScaleTransform (sx, sy, order)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sx" Type="System.Single" />
        <Parameter Name="sy" Type="System.Single" />
        <Parameter Name="order" Type="System.Drawing.Drawing2D.MatrixOrder" />
      </Parameters>
      <Docs>
        <param name="sx">Fator de escala na direção x.</param>
        <param name="sy">Fator de escala na direção y.</param>
        <param name="order">Membro da enumeração <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> que especifica se a operação de colocação em escala precede ou é acrescentada à matriz de transformação.</param>
        <summary>Aplica a operação de colocação em escala especificada à matriz de transformação desse <see cref="T:System.Drawing.Graphics" /> na ordem especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A operação de dimensionamento consiste em multiplicar a matriz de transformação por uma diagonal matriz cujos elementos são (`sx`, `sy`, 1). Esse método precede ou acrescenta a matriz de transformação a <xref:System.Drawing.Graphics> pela matriz de colocação em escala de acordo com o `order` parâmetro.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   A matriz de transformação global do formulário Windows gira 30 graus.  
  
-   Dimensiona essa matriz por um fator de 3 na direção x e um fator de 1 na direção y, acrescentando a transformação de colocação em escala com o <xref:System.Drawing.Drawing2D.MatrixOrder.Append> membro.  
  
-   Desenha um retângulo girado, dimensionado com uma caneta azul.  
  
 O resultado é um paralelogramo.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#153](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#153)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#153](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#153)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#153](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#153)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetClip">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Define a área de recorte desse <see cref="T:System.Drawing.Graphics" /> para a propriedade <see langword="Clip" /> do <see cref="T:System.Drawing.Graphics" /> especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Drawing2D.GraphicsPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(class System.Drawing.Drawing2D.GraphicsPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Drawing2D.GraphicsPath)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetClip (path As GraphicsPath)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Drawing2D::GraphicsPath ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Drawing2D.GraphicsPath -&gt; unit" Usage="graphics.SetClip path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.Drawing.Drawing2D.GraphicsPath" />
      </Parameters>
      <Docs>
        <param name="path"><see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> que representa a nova região de recorte.</param>
        <summary>Define a área de recorte deste <see cref="T:System.Drawing.Graphics" /> para o <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o caminho de gráficos é representado pelo `path` parâmetro não for fechado, um segmento adicional é adicionado do último ponto até o primeiro ponto para fechar o caminho.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um caminho de gráficos e adiciona uma elipse ao caminho.  
  
-   Define a região de recorte para o caminho elíptico.  
  
-   Preenche um retângulo grande com um pincel preto sólido.  
  
 O resultado é uma elipse preenchida, preta.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#154](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#154)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#154](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#154)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#154](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#154)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Graphics g);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(class System.Drawing.Graphics g) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Graphics)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetClip (g As Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Graphics ^ g);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Graphics -&gt; unit" Usage="graphics.SetClip g" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="g" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="g"><see cref="T:System.Drawing.Graphics" /> do qual capturar a nova região de recorte.</param>
        <summary>Define a área de recorte desse <see cref="T:System.Drawing.Graphics" /> para a propriedade <see langword="Clip" /> do <see cref="T:System.Drawing.Graphics" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro da <xref:System.Windows.Forms.Control.Paint> manipulador de eventos, bem como `thisForm`, o <xref:System.Windows.Forms.Form> para o exemplo. O código executa as seguintes ações:  
  
-   Cria um temporário <xref:System.Drawing.Graphics> do `thisForm` <xref:System.Windows.Forms.Form> do exemplo.  
  
-   Define a região de recorte de temporárias <xref:System.Drawing.Graphics> para um pequeno quadrado.  
  
-   Atualiza a região de recorte do objeto de gráfico do formulário para que um temporárias <xref:System.Drawing.Graphics>.  
  
-   Preenche um retângulo grande com um pincel preto sólido.  
  
 O resultado é um quadrado pequeno, preenchido, preto.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#156](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#156)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#156](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#156)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#156](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#156)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetClip (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Rectangle -&gt; unit" Usage="graphics.SetClip rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">Estrutura <see cref="T:System.Drawing.Rectangle" /> que representa a nova região de recorte.</param>
        <summary>Define a área de recorte desse <see cref="T:System.Drawing.Graphics" /> para o retângulo especificado por uma estrutura <see cref="T:System.Drawing.Rectangle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um pequeno retângulo para a região de recorte.  
  
-   Define a região de recorte para o retângulo.  
  
-   Preenche um retângulo grande com um pincel preto sólido.  
  
 O resultado é um retângulo pequeno, preenchido, preto.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#158](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#158)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#158](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#158)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#158](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#158)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetClip (rect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.RectangleF -&gt; unit" Usage="graphics.SetClip rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">Estrutura <see cref="T:System.Drawing.RectangleF" /> que representa a nova região de recorte.</param>
        <summary>Define a área de recorte desse <see cref="T:System.Drawing.Graphics" /> para o retângulo especificado por uma estrutura <see cref="T:System.Drawing.RectangleF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um pequeno retângulo para a região de recorte.  
  
-   Define a região de recorte para o retângulo.  
  
-   Preenche um retângulo grande com um pincel preto sólido.  
  
 O resultado é um retângulo pequeno, preenchido, preto.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#160](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#160)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#160](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#160)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#160](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#160)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Drawing2D.GraphicsPath path, System.Drawing.Drawing2D.CombineMode combineMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(class System.Drawing.Drawing2D.GraphicsPath path, valuetype System.Drawing.Drawing2D.CombineMode combineMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Drawing2D.GraphicsPath,System.Drawing.Drawing2D.CombineMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Drawing2D::GraphicsPath ^ path, System::Drawing::Drawing2D::CombineMode combineMode);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Drawing2D.GraphicsPath * System.Drawing.Drawing2D.CombineMode -&gt; unit" Usage="graphics.SetClip (path, combineMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.Drawing.Drawing2D.GraphicsPath" />
        <Parameter Name="combineMode" Type="System.Drawing.Drawing2D.CombineMode" />
      </Parameters>
      <Docs>
        <param name="path"><see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> a ser combinado.</param>
        <param name="combineMode">Membro da enumeração <see cref="T:System.Drawing.Drawing2D.CombineMode" /> que especifica a operação de combinação a ser usada.</param>
        <summary>Define a área de recorte deste <see cref="T:System.Drawing.Graphics" /> como o resultado da operação especificada que combina a região de recorte e o <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o caminho de gráficos é representado pelo `path` parâmetro não for fechado, um segmento adicional é adicionado do último ponto até o primeiro ponto para fechar o caminho.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um caminho de gráficos e adiciona uma elipse ao caminho.  
  
-   Define a região de recorte para o caminho elíptico com o <xref:System.Drawing.Drawing2D.CombineMode.Replace> membro.  
  
-   Preenche um retângulo grande com um pincel preto sólido.  
  
 O resultado é uma elipse preenchida, preta.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#155](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#155)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#155](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#155)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#155](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#155)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Graphics g, System.Drawing.Drawing2D.CombineMode combineMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(class System.Drawing.Graphics g, valuetype System.Drawing.Drawing2D.CombineMode combineMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Graphics,System.Drawing.Drawing2D.CombineMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Graphics ^ g, System::Drawing::Drawing2D::CombineMode combineMode);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Graphics * System.Drawing.Drawing2D.CombineMode -&gt; unit" Usage="graphics.SetClip (g, combineMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="g" Type="System.Drawing.Graphics" />
        <Parameter Name="combineMode" Type="System.Drawing.Drawing2D.CombineMode" />
      </Parameters>
      <Docs>
        <param name="g"><see cref="T:System.Drawing.Graphics" /> que especifica a área de recorte a ser combinada.</param>
        <param name="combineMode">Membro da enumeração <see cref="T:System.Drawing.Drawing2D.CombineMode" /> que especifica a operação de combinação a ser usada.</param>
        <summary>Define a área de recorte deste <see cref="T:System.Drawing.Graphics" /> como o resultado da operação especificada de combinação da área de recorte e a propriedade <see cref="P:System.Drawing.Graphics.Clip" /> do <see cref="T:System.Drawing.Graphics" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro da <xref:System.Windows.Forms.Control.Paint> manipulador de eventos, bem como `thisForm`, o <xref:System.Windows.Forms.Form> para o exemplo. O código executa as seguintes ações:  
  
-   Cria um temporário <xref:System.Drawing.Graphics> do `thisForm` <xref:System.Windows.Forms.Form> do exemplo.  
  
-   Define a região de recorte de temporárias <xref:System.Drawing.Graphics> para um pequeno quadrado.  
  
-   Atualiza a região de recorte do objeto de gráfico do formulário para que o New <xref:System.Drawing.Graphics> com o <xref:System.Drawing.Drawing2D.CombineMode.Replace> membro.  
  
-   Preenche um retângulo grande com um pincel preto sólido.  
  
 O resultado é um quadrado pequeno, preenchido, preto.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#157](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#157)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#157](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#157)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#157](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#157)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Rectangle rect, System.Drawing.Drawing2D.CombineMode combineMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(valuetype System.Drawing.Rectangle rect, valuetype System.Drawing.Drawing2D.CombineMode combineMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Rectangle,System.Drawing.Drawing2D.CombineMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Rectangle rect, System::Drawing::Drawing2D::CombineMode combineMode);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Rectangle * System.Drawing.Drawing2D.CombineMode -&gt; unit" Usage="graphics.SetClip (rect, combineMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="combineMode" Type="System.Drawing.Drawing2D.CombineMode" />
      </Parameters>
      <Docs>
        <param name="rect">A estrutura <see cref="T:System.Drawing.Rectangle" /> a combinar.</param>
        <param name="combineMode">Membro da enumeração <see cref="T:System.Drawing.Drawing2D.CombineMode" /> que especifica a operação de combinação a ser usada.</param>
        <summary>Define a área de recorte deste <see cref="T:System.Drawing.Graphics" /> como o resultado da operação especificada que combina a região de recorte e o retângulo especificado por uma estrutura <see cref="T:System.Drawing.Rectangle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um pequeno retângulo para a região de recorte.  
  
-   Define a região de recorte para o retângulo com o <xref:System.Drawing.Drawing2D.CombineMode.Replace> membro.  
  
-   Preenche um retângulo grande com um pincel preto sólido.  
  
 O resultado é um retângulo pequeno, preenchido, preto.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#159](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#159)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#159](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#159)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#159](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#159)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.RectangleF rect, System.Drawing.Drawing2D.CombineMode combineMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(valuetype System.Drawing.RectangleF rect, valuetype System.Drawing.Drawing2D.CombineMode combineMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.RectangleF,System.Drawing.Drawing2D.CombineMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::RectangleF rect, System::Drawing::Drawing2D::CombineMode combineMode);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.RectangleF * System.Drawing.Drawing2D.CombineMode -&gt; unit" Usage="graphics.SetClip (rect, combineMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
        <Parameter Name="combineMode" Type="System.Drawing.Drawing2D.CombineMode" />
      </Parameters>
      <Docs>
        <param name="rect">A estrutura <see cref="T:System.Drawing.RectangleF" /> a combinar.</param>
        <param name="combineMode">Membro da enumeração <see cref="T:System.Drawing.Drawing2D.CombineMode" /> que especifica a operação de combinação a ser usada.</param>
        <summary>Define a área de recorte deste <see cref="T:System.Drawing.Graphics" /> como o resultado da operação especificada que combina a região de recorte e o retângulo especificado por uma estrutura <see cref="T:System.Drawing.RectangleF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um pequeno retângulo para a região de recorte.  
  
-   Define a região de recorte para o retângulo com o <xref:System.Drawing.Drawing2D.CombineMode.Replace> membro.  
  
-   Preenche um retângulo grande com um pincel preto sólido.  
  
 O resultado é um retângulo pequeno, preenchido, preto.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#161](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#161)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#161](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#161)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#161](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#161)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Region region, System.Drawing.Drawing2D.CombineMode combineMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(class System.Drawing.Region region, valuetype System.Drawing.Drawing2D.CombineMode combineMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Region,System.Drawing.Drawing2D.CombineMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Region ^ region, System::Drawing::Drawing2D::CombineMode combineMode);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Region * System.Drawing.Drawing2D.CombineMode -&gt; unit" Usage="graphics.SetClip (region, combineMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
        <Parameter Name="combineMode" Type="System.Drawing.Drawing2D.CombineMode" />
      </Parameters>
      <Docs>
        <param name="region"><see cref="T:System.Drawing.Region" /> a ser combinado.</param>
        <param name="combineMode">Membro da enumeração <see cref="T:System.Drawing.Drawing2D.CombineMode" /> que especifica a operação de combinação a ser usada.</param>
        <summary>Define a área de recorte deste <see cref="T:System.Drawing.Graphics" /> como o resultado da operação especificada que combina a região de recorte e o <see cref="T:System.Drawing.Region" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um pequeno retângulo para a região de recorte.  
  
-   Define a região de recorte para o retângulo com o <xref:System.Drawing.Drawing2D.CombineMode.Replace> membro.  
  
-   Preenche um retângulo grande com um pincel preto sólido.  
  
 O resultado é um retângulo pequeno, preenchido, preto.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#162](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#162)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#162](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#162)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#162](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#162)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SmoothingMode">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.SmoothingMode SmoothingMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.SmoothingMode SmoothingMode" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.SmoothingMode" />
      <MemberSignature Language="VB.NET" Value="Public Property SmoothingMode As SmoothingMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::SmoothingMode SmoothingMode { System::Drawing::Drawing2D::SmoothingMode get(); void set(System::Drawing::Drawing2D::SmoothingMode value); };" />
      <MemberSignature Language="F#" Value="member this.SmoothingMode : System.Drawing.Drawing2D.SmoothingMode with get, set" Usage="System.Drawing.Graphics.SmoothingMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.SmoothingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a qualidade de renderização para este <see cref="T:System.Drawing.Graphics" />.</summary>
        <value>Um dos valores de <see cref="T:System.Drawing.Drawing2D.SmoothingMode" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O modo de suavização Especifica se linhas, curvas e as bordas das áreas preenchidas usam suavização (também chamado de suavização). Uma exceção é que os pincéis de gradiente de caminho não obedecer o modo de suavização. Áreas preenchidas usando um <xref:System.Drawing.Drawing2D.PathGradientBrush> são renderizados da mesma forma (alias) independentemente do <xref:System.Drawing.Graphics.SmoothingMode%2A> propriedade.  
  
   
  
## Examples  
 O método a seguir demonstra os efeitos da configuração de <xref:System.Drawing.Pen.DashCap%2A>, <xref:System.Drawing.Pen.DashPattern%2A>, e <xref:System.Drawing.Graphics.SmoothingMode%2A> propriedades. A saída do exemplo é mostrada na ilustração a seguir.  
  
 ![Linhas com e sem suavização aplicada. ] (~/add/media/gdi-smoothingmode.png "Linhas com e sem suavização aplicada.")  
  
 Este exemplo é projetado para ser usado com o Windows Forms. Cole o código em um formulário e chame o `ShowPensAndSmoothingMode` método ao lidar com o formulário <xref:System.Windows.Forms.Control.Paint> evento, passando `e` como <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-cpp[System.Drawing.PensExample#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.PensExample/CPP/form1.cpp#3)]
 [!code-csharp[System.Drawing.PensExample#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.PensExample/CS/form1.cs#3)]
 [!code-vb[System.Drawing.PensExample#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.PensExample/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextContrast">
      <MemberSignature Language="C#" Value="public int TextContrast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TextContrast" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.TextContrast" />
      <MemberSignature Language="VB.NET" Value="Public Property TextContrast As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TextContrast { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.TextContrast : int with get, set" Usage="System.Drawing.Graphics.TextContrast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor de correção gama para renderizar texto.</summary>
        <value>O valor de correção gama usado para renderizar antialiasing e texto ClearType.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de correção gama deve estar entre 0 e 12. O valor padrão é 4.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Drawing.Graphics.TextRenderingHint%2A> e <xref:System.Drawing.Graphics.TextContrast%2A> propriedades.  
  
 Este exemplo é projetado para ser usado com o Windows Forms. Cole o código em um formulário e chame o `ChangeTextRenderingHintAndTextContrast` método ao lidar com o formulário <xref:System.Windows.Forms.Control.Paint> evento, passando `e` como <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-cpp[System.Drawing.GraphicsProperties#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CPP/form1.cpp#5)]
 [!code-csharp[System.Drawing.GraphicsProperties#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CS/form1.cs#5)]
 [!code-vb[System.Drawing.GraphicsProperties#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextRenderingHint">
      <MemberSignature Language="C#" Value="public System.Drawing.Text.TextRenderingHint TextRenderingHint { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Text.TextRenderingHint TextRenderingHint" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.TextRenderingHint" />
      <MemberSignature Language="VB.NET" Value="Public Property TextRenderingHint As TextRenderingHint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Text::TextRenderingHint TextRenderingHint { System::Drawing::Text::TextRenderingHint get(); void set(System::Drawing::Text::TextRenderingHint value); };" />
      <MemberSignature Language="F#" Value="member this.TextRenderingHint : System.Drawing.Text.TextRenderingHint with get, set" Usage="System.Drawing.Graphics.TextRenderingHint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Text.TextRenderingHint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o modo de renderização para o texto associado a este <see cref="T:System.Drawing.Graphics" />.</summary>
        <value>Um dos valores de <see cref="T:System.Drawing.Text.TextRenderingHint" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A dica de renderização de texto Especifica se o texto renderizado com suavização.  
  
> [!NOTE]
>  Você não deve usar um <xref:System.Drawing.Graphics.CompositingMode%2A> valor da propriedade de <xref:System.Drawing.Drawing2D.CompositingMode.SourceCopy> quando o <xref:System.Drawing.Graphics.TextRenderingHint%2A> estiver definida como <xref:System.Drawing.Text.TextRenderingHint.ClearTypeGridFit>. Uma exceção pode ocorrer ou a imagem pode não renderizar corretamente.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Drawing.Graphics.TextRenderingHint%2A> e <xref:System.Drawing.Graphics.TextContrast%2A> propriedades.  
  
 Este exemplo é projetado para ser usado com o Windows Forms. Cole o código em um formulário e chame o `ChangeTextRenderingHintAndTextContrast` método ao lidar com o formulário <xref:System.Windows.Forms.Control.Paint> evento, passando `e` como <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-cpp[System.Drawing.GraphicsProperties#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CPP/form1.cpp#5)]
 [!code-csharp[System.Drawing.GraphicsProperties#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CS/form1.cs#5)]
 [!code-vb[System.Drawing.GraphicsProperties#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.Matrix Transform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Drawing2D.Matrix Transform" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.Transform" />
      <MemberSignature Language="VB.NET" Value="Public Property Transform As Matrix" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::Matrix ^ Transform { System::Drawing::Drawing2D::Matrix ^ get(); void set(System::Drawing::Drawing2D::Matrix ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Transform : System.Drawing.Drawing2D.Matrix with get, set" Usage="System.Drawing.Graphics.Transform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.Matrix</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define uma cópia da transformação geométrica global deste <see cref="T:System.Drawing.Graphics" />.</summary>
        <value>Uma cópia da <see cref="T:System.Drawing.Drawing2D.Matrix" /> que representa a transformação geométrica global deste <see cref="T:System.Drawing.Graphics" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GDI+ usa três espaços de coordenadas: mundo, página e dispositivo. Coordenadas de mundo são as coordenadas usadas para modelar um mundo gráfico específico e são as coordenadas que você passa para métodos no .NET Framework. As coordenadas da página se referem ao sistema de coordenadas usado por uma superfície de desenho, como um formulário ou controle. Coordenadas do dispositivo são as coordenadas usadas pelo dispositivo físico que está sendo desenhado, como uma tela ou uma impressora. O <xref:System.Drawing.Graphics.Transform%2A> propriedade representa a transformação global, que mapeia coordenadas de mundo para coordenadas de página.  
  
 Porque a matriz retornada e pela <xref:System.Drawing.Graphics.Transform%2A> é uma cópia da transformação geométrica, você deve descartar a matriz quando você não precisa mais dela.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/c61ff50a-eb1d-4e6c-83cd-f7e9764cfa9f">Tipos de sistemas de coordenadas</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransformPoints">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Transforma uma matriz de pontos de um espaço de coordenadas para outro usando as transformações global e de página atuais deste <see cref="T:System.Drawing.Graphics" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransformPoints">
      <MemberSignature Language="C#" Value="public void TransformPoints (System.Drawing.Drawing2D.CoordinateSpace destSpace, System.Drawing.Drawing2D.CoordinateSpace srcSpace, System.Drawing.Point[] pts);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransformPoints(valuetype System.Drawing.Drawing2D.CoordinateSpace destSpace, valuetype System.Drawing.Drawing2D.CoordinateSpace srcSpace, valuetype System.Drawing.Point[] pts) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.TransformPoints(System.Drawing.Drawing2D.CoordinateSpace,System.Drawing.Drawing2D.CoordinateSpace,System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransformPoints (destSpace As CoordinateSpace, srcSpace As CoordinateSpace, pts As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransformPoints(System::Drawing::Drawing2D::CoordinateSpace destSpace, System::Drawing::Drawing2D::CoordinateSpace srcSpace, cli::array &lt;System::Drawing::Point&gt; ^ pts);" />
      <MemberSignature Language="F#" Value="member this.TransformPoints : System.Drawing.Drawing2D.CoordinateSpace * System.Drawing.Drawing2D.CoordinateSpace * System.Drawing.Point[] -&gt; unit" Usage="graphics.TransformPoints (destSpace, srcSpace, pts)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destSpace" Type="System.Drawing.Drawing2D.CoordinateSpace" />
        <Parameter Name="srcSpace" Type="System.Drawing.Drawing2D.CoordinateSpace" />
        <Parameter Name="pts" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="destSpace">Membro da enumeração de <see cref="T:System.Drawing.Drawing2D.CoordinateSpace" /> que especifica o espaço de coordenadas de destino.</param>
        <param name="srcSpace">Membro da enumeração de <see cref="T:System.Drawing.Drawing2D.CoordinateSpace" /> que especifica o espaço de coordenadas de origem.</param>
        <param name="pts">Matriz de estruturas <see cref="T:System.Drawing.Point" /> que representa os pontos para transformação.</param>
        <summary>Transforma uma matriz de pontos de um espaço de coordenadas para outro usando as transformações global e de página atuais deste <see cref="T:System.Drawing.Graphics" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria dois pontos e desenha uma linha azul entre eles.  
  
-   Define a transformação de mundo para traduzir pelas quantidades 40 na direção x e 30 na direção y.  
  
-   Transforma os pontos de coordenadas de mundo (<xref:System.Drawing.Drawing2D.CoordinateSpace.World>) para as coordenadas da página (<xref:System.Drawing.Drawing2D.CoordinateSpace.Page>).  
  
-   Redefine a transformação global para a identidade.  
  
-   Desenha uma linha vermelha entre os pontos transformados.  
  
 O resultado é uma linha azul e uma linha vermelha traduzida abaixo dele.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#163](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#163)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#163](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#163)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#163](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#163)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransformPoints">
      <MemberSignature Language="C#" Value="public void TransformPoints (System.Drawing.Drawing2D.CoordinateSpace destSpace, System.Drawing.Drawing2D.CoordinateSpace srcSpace, System.Drawing.PointF[] pts);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransformPoints(valuetype System.Drawing.Drawing2D.CoordinateSpace destSpace, valuetype System.Drawing.Drawing2D.CoordinateSpace srcSpace, valuetype System.Drawing.PointF[] pts) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.TransformPoints(System.Drawing.Drawing2D.CoordinateSpace,System.Drawing.Drawing2D.CoordinateSpace,System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransformPoints (destSpace As CoordinateSpace, srcSpace As CoordinateSpace, pts As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransformPoints(System::Drawing::Drawing2D::CoordinateSpace destSpace, System::Drawing::Drawing2D::CoordinateSpace srcSpace, cli::array &lt;System::Drawing::PointF&gt; ^ pts);" />
      <MemberSignature Language="F#" Value="member this.TransformPoints : System.Drawing.Drawing2D.CoordinateSpace * System.Drawing.Drawing2D.CoordinateSpace * System.Drawing.PointF[] -&gt; unit" Usage="graphics.TransformPoints (destSpace, srcSpace, pts)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destSpace" Type="System.Drawing.Drawing2D.CoordinateSpace" />
        <Parameter Name="srcSpace" Type="System.Drawing.Drawing2D.CoordinateSpace" />
        <Parameter Name="pts" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="destSpace">Membro da enumeração de <see cref="T:System.Drawing.Drawing2D.CoordinateSpace" /> que especifica o espaço de coordenadas de destino.</param>
        <param name="srcSpace">Membro da enumeração de <see cref="T:System.Drawing.Drawing2D.CoordinateSpace" /> que especifica o espaço de coordenadas de origem.</param>
        <param name="pts">Matriz de estruturas <see cref="T:System.Drawing.PointF" /> que representa os pontos a serem transformados.</param>
        <summary>Transforma uma matriz de pontos de um espaço de coordenadas para outro usando as transformações global e de página atuais deste <see cref="T:System.Drawing.Graphics" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria dois pontos e desenha uma linha azul entre eles.  
  
-   Define a transformação de mundo para traduzir pelas quantidades 40 na direção x e 30 na direção y.  
  
-   Transforma os pontos de coordenadas de mundo (<xref:System.Drawing.Drawing2D.CoordinateSpace.World>) para as coordenadas da página (<xref:System.Drawing.Drawing2D.CoordinateSpace.Page>).  
  
-   Redefine a transformação global para a identidade e desenha uma linha vermelha entre os pontos transformados.  
  
 O resultado é uma linha azul e uma linha vermelha traduzida abaixo dele.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#164](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#164)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#164](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#164)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#164](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#164)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TranslateClip">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte a área de recorte deste <see cref="T:System.Drawing.Graphics" /> pelos valores especificados nas orientações horizontal e vertical.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TranslateClip">
      <MemberSignature Language="C#" Value="public void TranslateClip (int dx, int dy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TranslateClip(int32 dx, int32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.TranslateClip(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TranslateClip (dx As Integer, dy As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TranslateClip(int dx, int dy);" />
      <MemberSignature Language="F#" Value="member this.TranslateClip : int * int -&gt; unit" Usage="graphics.TranslateClip (dx, dy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Int32" />
        <Parameter Name="dy" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dx">A coordenada X da tradução.</param>
        <param name="dy">A coordenada y da tradução.</param>
        <summary>Converte a área de recorte deste <see cref="T:System.Drawing.Graphics" /> pelos valores especificados nas orientações horizontal e vertical.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um retângulo para a região de recorte.  
  
-   Define a região de recorte para o retângulo.  
  
-   Converte a região de recorte por um vetor de (50, 50).  
  
-   Preenche um retângulo grande com um pincel preto sólido.  
  
 O resultado é um retângulo traduzido, pequeno, preto.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#165](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#165)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#165](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#165)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#165](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#165)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TranslateClip">
      <MemberSignature Language="C#" Value="public void TranslateClip (float dx, float dy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TranslateClip(float32 dx, float32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.TranslateClip(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TranslateClip (dx As Single, dy As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TranslateClip(float dx, float dy);" />
      <MemberSignature Language="F#" Value="member this.TranslateClip : single * single -&gt; unit" Usage="graphics.TranslateClip (dx, dy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="dx">A coordenada X da tradução.</param>
        <param name="dy">A coordenada y da tradução.</param>
        <summary>Converte a área de recorte deste <see cref="T:System.Drawing.Graphics" /> pelos valores especificados nas orientações horizontal e vertical.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Cria um retângulo para a região de recorte.  
  
-   Define a região de recorte para o retângulo.  
  
-   Converte a região de recorte por um vetor (50.0F, 50.0F).  
  
-   Preenche um retângulo grande com um pincel preto sólido.  
  
 O resultado é um retângulo traduzido, pequeno, preto.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#166](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#166)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#166](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#166)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#166](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#166)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TranslateTransform">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Altera a origem do sistema de coordenadas acrescentando a tradução especificada para a matriz de transformação desse <see cref="T:System.Drawing.Graphics" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TranslateTransform">
      <MemberSignature Language="C#" Value="public void TranslateTransform (float dx, float dy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TranslateTransform(float32 dx, float32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.TranslateTransform(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TranslateTransform (dx As Single, dy As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TranslateTransform(float dx, float dy);" />
      <MemberSignature Language="F#" Value="member this.TranslateTransform : single * single -&gt; unit" Usage="graphics.TranslateTransform (dx, dy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="dx">A coordenada X da tradução.</param>
        <param name="dy">A coordenada y da tradução.</param>
        <summary>Altera a origem do sistema de coordenadas acrescentando a tradução especificada para a matriz de transformação desse <see cref="T:System.Drawing.Graphics" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, a origem é o canto superior esquerdo da superfície de desenho.  Operação de conversão consiste em multiplicar a matriz de transformação por uma matriz cuja parte de translação é o `dx` e `dy` parâmetros. Esse método se aplica a translação acrescentando a matriz de translação para a matriz de transformação.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Gira a matriz de transformação global do formulário Windows 30.0F graus.  
  
-   Move a origem do objeto graphics chamando <xref:System.Drawing.Graphics.TranslateTransform%2A>, acrescentando a tradução para a matriz de transformação.  
  
-   Desenha uma elipse traduzida, girada com uma caneta azul.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#167](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#167)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#167](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#167)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#167](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#167)]  
  
 A ilustração a seguir mostra a saída da execução do exemplo de código anterior.  
  
 ![Traduzido e ellipse transformado](~/add/media/ndp-tranlatetransform.png "traduzido e transformados de elipse")  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/9fef7451-bddf-4c68-9350-400d1f1f25a3">Sistemas de coordenadas e transformações</related>
        <related type="Article" href="https://msdn.microsoft.com/library/1f8e18d3-d2f5-460e-a8e3-2da891c301de">Usando transformações no GDI+ gerenciado</related>
      </Docs>
    </Member>
    <Member MemberName="TranslateTransform">
      <MemberSignature Language="C#" Value="public void TranslateTransform (float dx, float dy, System.Drawing.Drawing2D.MatrixOrder order);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TranslateTransform(float32 dx, float32 dy, valuetype System.Drawing.Drawing2D.MatrixOrder order) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.TranslateTransform(System.Single,System.Single,System.Drawing.Drawing2D.MatrixOrder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TranslateTransform (dx As Single, dy As Single, order As MatrixOrder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TranslateTransform(float dx, float dy, System::Drawing::Drawing2D::MatrixOrder order);" />
      <MemberSignature Language="F#" Value="member this.TranslateTransform : single * single * System.Drawing.Drawing2D.MatrixOrder -&gt; unit" Usage="graphics.TranslateTransform (dx, dy, order)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
        <Parameter Name="order" Type="System.Drawing.Drawing2D.MatrixOrder" />
      </Parameters>
      <Docs>
        <param name="dx">A coordenada X da tradução.</param>
        <param name="dy">A coordenada y da tradução.</param>
        <param name="order">Membro da enumeração <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> que especifica se a translação precede ou é acrescentada à matriz de transformação.</param>
        <summary>Altera a origem do sistema de coordenadas aplicando a translação especificada à matriz de transformação desse <see cref="T:System.Drawing.Graphics" /> na ordem especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operação de conversão consiste em multiplicar a matriz de transformação por uma matriz cuja parte de translação é o `dx` e `dy` parâmetros. Esse método precede ou acrescenta a matriz de transformação a <xref:System.Drawing.Graphics> pela matriz de translação de acordo com o `order` parâmetro.  
  
   
  
## Examples  
 O exemplo de código a seguir foi projetado para uso com o Windows Forms e requer <xref:System.Windows.Forms.PaintEventArgs> `e`, que é um parâmetro do <xref:System.Windows.Forms.Control.Paint> manipulador de eventos. O código executa as seguintes ações:  
  
-   Gira a matriz de transformação global do formulário Windows 30.0F graus.  
  
-   Move a origem do objeto de elementos gráficos chamando <xref:System.Drawing.Graphics.TranslateTransform%2A>, acrescentando a tradução para a matriz de transformação de mundo.  
  
-   Desenha uma elipse girada, traduzida com uma caneta azul.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#168](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#168)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#168](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#168)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#168](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#168)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/9fef7451-bddf-4c68-9350-400d1f1f25a3">Sistemas de coordenadas e transformações</related>
        <related type="Article" href="https://msdn.microsoft.com/library/1f8e18d3-d2f5-460e-a8e3-2da891c301de">Usando transformações no GDI+ gerenciado</related>
      </Docs>
    </Member>
    <Member MemberName="VisibleClipBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF VisibleClipBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.RectangleF VisibleClipBounds" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.VisibleClipBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VisibleClipBounds As RectangleF" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::RectangleF VisibleClipBounds { System::Drawing::RectangleF get(); };" />
      <MemberSignature Language="F#" Value="member this.VisibleClipBounds : System.Drawing.RectangleF" Usage="System.Drawing.Graphics.VisibleClipBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o retângulo delimitador da área de recorte visível deste <see cref="T:System.Drawing.Graphics" />.</summary>
        <value>Uma estrutura <see cref="T:System.Drawing.RectangleF" /> que representa um retângulo delimitador para a área de recorte visível deste <see cref="T:System.Drawing.Graphics" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A unidade para o retângulo resultante é designada pelo <xref:System.Drawing.Graphics.PageUnit%2A> propriedade. A unidade padrão é pixels. Um <xref:System.Drawing.Graphics> é tipicamente associado um controle e serão a origem do retângulo em relação à área de cliente desse controle.  
  
 A região de recorte visível é a interseção da região de recorte deste <xref:System.Drawing.Graphics> e a região de recorte da janela.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>