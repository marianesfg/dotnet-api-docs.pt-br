<Type Name="Timer" FullName="System.Timers.Timer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f2483b13115f709c891ae64fffbeed30c28faf0e" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56405391" /></Metadata><TypeSignature Language="C#" Value="public class Timer : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Timer extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Timers.Timer" />
  <TypeSignature Language="VB.NET" Value="Public Class Timer&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class Timer : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type Timer = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-3.0">
      <AttributeName>System.ComponentModel.DefaultEvent("Elapsed")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-3.0">
      <AttributeName>System.ComponentModel.DefaultProperty("Interval")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Gera um evento após um intervalo definido, a opção de gerar eventos recorrentes.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Timers.Timer> componente é um timer com base em servidor que gera uma <xref:System.Timers.Timer.Elapsed> eventos em seu aplicativo após o número de milissegundos no <xref:System.Timers.Timer.Interval%2A> propriedade tiver decorrido. Você pode configurar o <xref:System.Timers.Timer> objeto para gerar o evento usando apenas uma vez ou repetidamente o <xref:System.Timers.Timer.AutoReset%2A> propriedade. Normalmente, um <xref:System.Timers.Timer> objeto for declarado no nível de classe para que ele permaneça no escopo desde que ela é necessária. Em seguida, você pode manipular seu <xref:System.Timers.Timer.Elapsed> eventos para fornecer processamento regular. Por exemplo, suponha que você tem um servidor crítico que deve ser mantido em execução 24 horas por dia, 7 dias por semana. Você pode criar um serviço que usa um <xref:System.Timers.Timer> objeto periodicamente, verifique o servidor e certifique-se de que o sistema está em execução. Se o sistema não estiver respondendo, o serviço pode tentar reiniciar o servidor ou notificar um administrador.  
  
> [!IMPORTANT]
> O <xref:System.Timers.Timer> classe não está disponível para todas as implementações do .NET e versões, como .NET Standard 1.6 e versões anteriores.
> Nesses casos, você pode usar o <xref:System.Threading.Timer?displayProperty=nameWithType> classe em vez disso.
  
 Esse tipo implementa o <xref:System.IDisposable> interface. Quando você terminar de usar o tipo, você deve descartá-lo diretamente ou indiretamente. Para descartar o tipo diretamente, chame seu <xref:System.IDisposable.Dispose%2A> método em um `try` / `catch` bloco. Para descartá-los indiretamente, usar uma construção de linguagem, como `using` (em c#) ou `Using` (no Visual Basic). Para obter mais informações, consulte a seção "Usando um objeto que implementa IDisposable" o <xref:System.IDisposable> tópico da interface.  
  
 O servidor com base em <xref:System.Timers.Timer?displayProperty=nameWithType> classe foi projetado para uso com threads de trabalho em um ambiente multithreaded. Temporizadores de servidor podem mover entre threads para lidar com a elevação <xref:System.Timers.Timer.Elapsed> evento, resultando em mais precisão do que os temporizadores do Windows em acionar o evento no tempo.  
  
 O <xref:System.Timers.Timer?displayProperty=nameWithType> componente gera a <xref:System.Timers.Timer.Elapsed> evento, com base no valor (em milissegundos) do <xref:System.Timers.Timer.Interval%2A> propriedade. Você pode manipular esse evento para executar o processamento que é necessário. Por exemplo, suponha que você tenha um aplicativo de vendas online que envia continuamente de ordens de venda para um banco de dados. O serviço que compila as instruções para o envio de opera em um lote de pedidos em vez de individualmente cada ordem de processamento. Você pode usar um <xref:System.Timers.Timer> para iniciar a cada 30 minutos de processamento em lotes.  
  
> [!IMPORTANT]
>  A classe de timers tem a mesma resolução do relógio do sistema. Isso significa que o <xref:System.Timers.Timer.Elapsed> evento será acionado em um intervalo definido pela resolução do relógio do sistema se o <xref:System.Timers.Timer.Interval%2A> propriedade é menor que a resolução do relógio do sistema. Para obter mais informações, consulte a propriedade <xref:System.Timers.Timer.Interval%2A>.  
  
 Quando <xref:System.Timers.Timer.AutoReset%2A> é definido como `false`, um <xref:System.Timers.Timer?displayProperty=nameWithType> objeto gera o <xref:System.Timers.Timer.Elapsed> evento apenas uma vez, após a primeira <xref:System.Timers.Timer.Interval%2A> tiver decorrido. Para manter de elevar a <xref:System.Timers.Timer.Elapsed> eventos regularmente no intervalo definido pela <xref:System.Timers.Timer.Interval%2A>, defina <xref:System.Timers.Timer.AutoReset%2A> para `true`, que é o valor padrão.  
  
 O <xref:System.Timers.Timer> componente de captura e suprime todas as exceções lançadas por manipuladores de eventos para o <xref:System.Timers.Timer.Elapsed> eventos. Esse comportamento está sujeita a alterações em versões futuras do .NET Framework. No entanto, observe que isso não é verdadeiro para manipuladores de eventos que são executadas de forma assíncrona e incluem o `await` operador (em c#) ou o `Await` operador (no Visual Basic). Exceções geradas nesses manipuladores de eventos são propagadas novamente para o thread de chamada, como mostra o exemplo a seguir. Para obter mais informações sobre as exceções geradas em métodos assíncronos, consulte [tratamento de exceções](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 [!code-csharp[System.Timers.Timer#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/AsyncHandlerEx1.cs#3)]
 [!code-vb[System.Timers.Timer#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/AsyncHandlerEx1.vb#3)]  
  
 Se o <xref:System.Timers.Timer.SynchronizingObject%2A> é de propriedade `null`, o <xref:System.Timers.Timer.Elapsed> evento é gerado em um <xref:System.Threading.ThreadPool> thread. Se o processamento das <xref:System.Timers.Timer.Elapsed> evento dura mais de <xref:System.Timers.Timer.Interval%2A>, o evento pode ser gerado novamente em outro <xref:System.Threading.ThreadPool> thread. Nessa situação, o manipulador de eventos deve ser reentrante.  
  
> [!NOTE]
>  O método de manipulação de eventos pode ser executado em um thread ao mesmo tempo que outro thread chama o <xref:System.Timers.Timer.Stop%2A> método ou define o <xref:System.Timers.Timer.Enabled%2A> propriedade para `false`. Isso pode resultar no <xref:System.Timers.Timer.Elapsed> evento sendo gerado depois que o temporizador será interrompido. O exemplo de código para o <xref:System.Timers.Timer.Stop%2A> método mostra uma maneira de evitar essa condição de corrida.  
  
 Mesmo se <xref:System.Timers.Timer.SynchronizingObject%2A> não é `null`, <xref:System.Timers.Timer.Elapsed> eventos podem ocorrer após a <xref:System.Timers.Timer.Dispose%2A> ou <xref:System.Timers.Timer.Stop%2A> método foi chamado ou depois o <xref:System.Timers.Timer.Enabled%2A> propriedade foi definida como `false`, pois o sinal para gerar o <xref:System.Timers.Timer.Elapsed> eventos sempre foi enfileirado para execução em um pool de threads. Uma maneira de resolver essa condição de corrida é definir um sinalizador que informa ao manipulador de eventos para o <xref:System.Timers.Timer.Elapsed> evento ignorar eventos subsequentes.  
  
 Se você usar o <xref:System.Timers.Timer?displayProperty=nameWithType> classe com um elemento de interface do usuário, como um formulário ou controle, sem colocar o temporizador sobre esse elemento de interface do usuário, atribua o formulário ou controle que contém o <xref:System.Timers.Timer> para o <xref:System.Timers.Timer.SynchronizingObject%2A> propriedade, para que o evento é o marshaling realizado para o thread da interface do usuário.  
  
 Para obter uma lista de valores de propriedade padrão para uma instância do <xref:System.Timers.Timer>, consulte o <xref:System.Timers.Timer.%23ctor%2A> construtor.  
  
> [!TIP]
>  Lembre-se de que o .NET inclui quatro classes chamadas `Timer`, cada do que oferece uma funcionalidade diferente:  
>   
> - <xref:System.Timers.Timer?displayProperty=nameWithType> (neste tópico): dispara um evento em intervalos regulares. A classe é destinada para uso como um servidor baseado em ou componente de serviço em um ambiente multithreaded; ele não tem nenhuma interface de usuário e não estiver visível no tempo de execução.  
> - <xref:System.Threading.Timer?displayProperty=nameWithType>: executa um método de retorno de chamada único em um pool de threads em intervalos regulares. O método de retorno de chamada é definido quando o temporizador é instanciado e não pode ser alterado. Como o <xref:System.Timers.Timer?displayProperty=nameWithType> classe, essa classe é destinada para uso como um componente baseado em servidor ou de serviço em um ambiente multithreaded; ele não tem nenhuma interface de usuário e não estiver visível no tempo de execução.  
> - <xref:System.Windows.Forms.Timer?displayProperty=nameWithType> (Apenas no .NET framework): um componente de Windows Forms que dispara um evento em intervalos regulares. O componente não tem nenhuma interface do usuário e é projetado para ser usado em um ambiente single-threaded.  
> - <xref:System.Web.UI.Timer?displayProperty=nameWithType> (Apenas no .NET framework): um componente do ASP.NET que executa postbacks de página da web assíncrona ou síncrona em intervalos regulares.  

## Examples  
 O exemplo a seguir instancia um `System.Timers.Timer` objeto que aciona seu <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> eventos a cada dois segundos (2.000 milissegundos), configura um manipulador de eventos para o evento e inicia o temporizador. O manipulador de eventos exibe o valor da <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propriedade cada vez que ele é acionado.  
  
 [!code-csharp[System.Timers.Timer#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer2a.cs#2)]
 [!code-vb[System.Timers.Timer#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer2a.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Qualquer público <see langword="static" /> desse tipo são thread-safe. Não há garantia de que qualquer membro de instância seja thread-safe.</threadsafe>
    <altmember cref="P:System.Timers.Timer.AutoReset" />
    <altmember cref="P:System.Timers.Timer.Interval" />
    <altmember cref="E:System.Timers.Timer.Elapsed" />
    <altmember cref="M:System.Timers.Timer.#ctor" />
    <altmember cref="T:System.Threading.Timer" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Timers.Timer" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Timers.Timer" /> e define todas as propriedades para seus valores iniciais.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir mostra os valores de propriedade inicial para uma instância do <xref:System.Timers.Timer>.  
  
|Propriedade|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Timers.Timer.AutoReset%2A>|`true`|  
|<xref:System.Timers.Timer.Enabled%2A>|`false`|  
|<xref:System.Timers.Timer.Interval%2A>|100 milissegundos|  
|<xref:System.Timers.Timer.SynchronizingObject%2A>|Uma referência nula (`Nothing` no Visual Basic).|  
  
   
  
## Examples  
 O exemplo a seguir instancia um <xref:System.Timers.Timer> objeto que aciona seu <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> eventos a cada dois segundos (2000 milissegundos), configura um manipulador de eventos para o evento e inicia o temporizador. O manipulador de eventos exibe o valor da <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propriedade cada vez que ele é acionado.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (double interval);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (interval As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(double interval);" />
      <MemberSignature Language="F#" Value="new System.Timers.Timer : double -&gt; System.Timers.Timer" Usage="new System.Timers.Timer interval" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="interval" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="interval">O tempo, em milissegundos, entre eventos. O valor deve ser maior que zero e menor ou igual a <see cref="F:System.Int32.MaxValue" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Timers.Timer" /> e define a propriedade <see cref="P:System.Timers.Timer.Interval" /> como o número especificado de milissegundos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor define o <xref:System.Timers.Timer.Interval%2A> propriedade da nova instância de temporizador, mas não habilita o temporizador.  
  
   
  
## Examples  
 O exemplo a seguir instancia um <xref:System.Timers.Timer> objeto que aciona seu <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> eventos a cada dois segundos (2000 milissegundos), configura um manipulador de eventos para o evento e inicia o temporizador. O manipulador de eventos exibe o valor da <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propriedade cada vez que ele é acionado.  
  
 [!code-csharp[System.Timers.Timer#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/AsyncHandlerEx1.cs#3)]
 [!code-vb[System.Timers.Timer#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/AsyncHandlerEx1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor do parâmetro <paramref name="interval" /> é menor ou igual a zero ou maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="AutoReset">
      <MemberSignature Language="C#" Value="public bool AutoReset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoReset" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.AutoReset" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoReset As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoReset { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoReset : bool with get, set" Usage="System.Timers.Timer.AutoReset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("Indicates whether the timer will be restarted when it is enabled.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Timers.TimersDescription("TimerAutoReset")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor booliano que indica se <see cref="T:System.Timers.Timer" /> deve acionar o evento <see cref="E:System.Timers.Timer.Elapsed" /> apenas uma vez (<see langword="false" />) ou repetidamente (<see langword="true" />).</summary>
        <value><see langword="true" /> para que o <see cref="T:System.Timers.Timer" /> acione o evento <see cref="E:System.Timers.Timer.Elapsed" /> cada vez que o intervalo expirar; <see langword="false" /> para que acione o evento <see cref="E:System.Timers.Timer.Elapsed" /> somente uma vez, após a primeira vez que o intervalo expirar. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o <xref:System.Timers.Timer> já está habilitado quando o <xref:System.Timers.Timer.Start%2A> método é chamado, o intervalo é redefinido. Se <xref:System.Timers.Timer.AutoReset%2A> está `false`, o <xref:System.Timers.Timer.Start%2A> método deve ser chamado para iniciar a contagem novamente.  
  
 Redefinir o intervalo afeta quando o <xref:System.Timers.Timer.Elapsed> é gerado. Por exemplo, se você definir o intervalo de 5 segundos e, em seguida, defina as <xref:System.Timers.Timer.Enabled%2A> propriedade para `true`, a contagem começa no momento <xref:System.Timers.Timer.Enabled%2A> está definido. Se você redefinir o intervalo de 10 segundos quando a contagem é 3 segundos, o <xref:System.Timers.Timer.Elapsed> é gerado pela primeira vez e 13 segundos após o <xref:System.Timers.Timer.Enabled%2A> propriedade foi definida como `true`.  
  
   
  
## Examples  
 O exemplo a seguir cria uma <xref:System.Timers.Timer> cujo <xref:System.Timers.Timer.Elapsed> evento aciona após 1,5 segundos. Seu manipulador de eventos, em seguida, exibe "Hello World!" no console.  
  
 [!code-cpp[Classic Timer.Timer1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Timer.Timer1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/CS/source.cs#1)]
 [!code-vb[Classic Timer.Timer1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="timer.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Começa a inicialização do tempo de execução de um <see cref="T:System.Timers.Timer" /> que é usado em um formulário ou por outro componente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] ambiente usa esse método para iniciar a inicialização de um componente que é usado em um formulário ou por outro componente de design. O <xref:System.Timers.Timer.EndInit%2A> método encerra a inicialização. Usando o <xref:System.Timers.Timer.BeginInit%2A> e <xref:System.Timers.Timer.EndInit%2A> métodos impede que o controle seja usado antes de ser totalmente inicializado.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.EndInit" />
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="timer.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera os recursos usados pelo <see cref="T:System.Timers.Timer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Timers.Timer.Close%2A> método por sua vez chama o `Dispose` método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="timer.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
        <summary>Libera todos os recursos usados pelo <see cref="T:System.Timers.Timer" /> atual.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Elapsed">
      <MemberSignature Language="C#" Value="public event System.Timers.ElapsedEventHandler Elapsed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Timers.ElapsedEventHandler Elapsed" />
      <MemberSignature Language="DocId" Value="E:System.Timers.Timer.Elapsed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Elapsed As ElapsedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Timers::ElapsedEventHandler ^ Elapsed;" />
      <MemberSignature Language="F#" Value="member this.Elapsed : System.Timers.ElapsedEventHandler " Usage="member this.Elapsed : System.Timers.ElapsedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("Occurs when the Interval has elapsed.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Timers.TimersDescription("TimerIntervalElapsed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Timers.ElapsedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o intervalo termina.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Timers.Timer.Elapsed> evento será acionado se o <xref:System.Timers.Timer.Enabled%2A> é de propriedade `true` e o intervalo de tempo (em milissegundos) definido pelo <xref:System.Timers.Timer.Interval%2A> ter decorrido de propriedade. Se o <xref:System.Timers.Timer.AutoReset%2A> é de propriedade `true`, o evento é acionado repetidamente em um intervalo definido pela <xref:System.Timers.Timer.Interval%2A> propriedade; caso contrário, o evento é gerado apenas uma vez, na primeira vez o <xref:System.Timers.Timer.Interval%2A> valor tiver decorrido.  
  
 Se <xref:System.Timers.Timer.Interval%2A> é definido após o <xref:System.Timers.Timer> tiver iniciado, a contagem é redefinida. Por exemplo, se você definir o intervalo de 5 segundos e, em seguida, defina <xref:System.Timers.Timer.Enabled%2A> à `true`, a contagem começa no momento <xref:System.Timers.Timer.Enabled%2A> está definido. Se você redefinir o intervalo de 10 segundos quando a contagem for 3 segundos, o <xref:System.Timers.Timer.Elapsed> é gerado pela primeira vez e 13 segundos após <xref:System.Timers.Timer.Enabled%2A> foi definida como `true`.  
  
 Se o <xref:System.Timers.Timer.SynchronizingObject%2A> é de propriedade `null`, o <xref:System.Timers.Timer.Elapsed> evento é gerado em um <xref:System.Threading.ThreadPool> thread. Se o processamento das <xref:System.Timers.Timer.Elapsed> evento dura mais de <xref:System.Timers.Timer.Interval%2A>, o evento pode ser gerado novamente em outro <xref:System.Threading.ThreadPool> thread. Nessa situação, o manipulador de eventos deve ser reentrante.  
  
> [!NOTE]
>  O método de manipulação de eventos pode ser executado em um thread ao mesmo tempo que outro thread chama o <xref:System.Timers.Timer.Stop%2A> método ou define o <xref:System.Timers.Timer.Enabled%2A> propriedade para `false`. Isso pode resultar no <xref:System.Timers.Timer.Elapsed> evento sendo gerado depois que o temporizador será interrompido. O exemplo de código para o <xref:System.Timers.Timer.Stop%2A> método mostra uma maneira de evitar essa condição de corrida.  
  
 Mesmo se <xref:System.Timers.Timer.SynchronizingObject%2A> não é `null`, <xref:System.Timers.Timer.Elapsed> eventos podem ocorrer após a <xref:System.Timers.Timer.Dispose%2A> ou <xref:System.Timers.Timer.Stop%2A> método foi chamado ou depois o <xref:System.Timers.Timer.Enabled%2A> propriedade foi definida como `false`, pois o sinal para gerar o <xref:System.Timers.Timer.Elapsed> eventos sempre foi enfileirado para execução em um pool de threads. Uma maneira de resolver essa condição de corrida é definir um sinalizador que informa ao manipulador de eventos para o <xref:System.Timers.Timer.Elapsed> evento ignorar eventos subsequentes.  
  
 O <xref:System.Timers.Timer> componente de captura e suprime todas as exceções lançadas por manipuladores de eventos para o <xref:System.Timers.Timer.Elapsed> eventos. Esse comportamento está sujeita a alterações em versões futuras do .NET Framework.  
  
   
  
## Examples  
 O exemplo a seguir instancia um <xref:System.Timers.Timer> objeto que aciona seu <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> eventos a cada dois segundos (2000 milissegundos), configura um manipulador de eventos para o evento e inicia o temporizador. O manipulador de eventos exibe o valor da <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propriedade cada vez que ele é acionado.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
        <altmember cref="T:System.Timers.ElapsedEventArgs" />
        <altmember cref="T:System.Timers.ElapsedEventHandler" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Timers.Timer.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("Indicates whether the timer is enabled to fire events at a defined interval.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Timers.TimersDescription("TimerEnabled")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o <see cref="T:System.Timers.Timer" /> deve acionar o evento <see cref="E:System.Timers.Timer.Elapsed" />.</summary>
        <value><see langword="true" /> caso o <see cref="T:System.Timers.Timer" /> deva acionar o evento <see cref="E:System.Timers.Timer.Elapsed" />; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definindo <xref:System.Timers.Timer.Enabled%2A> à `true` é o mesmo que chamar <xref:System.Timers.Timer.Start%2A>, enquanto a configuração <xref:System.Timers.Timer.Enabled%2A> para `false` é o mesmo que chamar <xref:System.Timers.Timer.Stop%2A>.  
  
> [!NOTE]
>  O sinal para gerar a <xref:System.Timers.Timer.Elapsed> eventos sempre foi enfileirado para execução em um <xref:System.Threading.ThreadPool> thread. Isso pode resultar no <xref:System.Timers.Timer.Elapsed> evento sendo gerado após o <xref:System.Timers.Timer.Enabled%2A> estiver definida como `false`. O exemplo de código para o <xref:System.Timers.Timer.Stop%2A> método mostra uma maneira de contornar essa condição de corrida.  
  
 Se <xref:System.Timers.Timer.Enabled%2A> é definido como `true` e <xref:System.Timers.Timer.AutoReset%2A> é definido como `false`, o <xref:System.Timers.Timer> aciona o <xref:System.Timers.Timer.Elapsed> eventos somente uma vez, na primeira vez que o intervalo tenha decorrido.  
  
 Se o intervalo é definido após o <xref:System.Timers.Timer> tiver iniciado, a contagem é redefinida. Por exemplo, se você definir o intervalo de 5 segundos e, em seguida, defina as <xref:System.Timers.Timer.Enabled%2A> propriedade para `true`, a contagem começa no momento <xref:System.Timers.Timer.Enabled%2A> está definido. Se você redefinir o intervalo de 10 segundos quando a contagem for 3 segundos, o <xref:System.Timers.Timer.Elapsed> é gerado pela primeira vez e 13 segundos após <xref:System.Timers.Timer.Enabled%2A> foi definida como `true`.  
  
> [!NOTE]
>  Alguns designers visuais, como aqueles no Microsoft Visual Studio, defina as <xref:System.Timers.Timer.Enabled%2A> propriedade para `true` ao inserir um novo <xref:System.Timers.Timer>.  
  
   
  
## Examples  
 O exemplo a seguir instancia um <xref:System.Timers.Timer> objeto que aciona seu <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> eventos a cada dois segundos (2000 milissegundos), configura um manipulador de eventos para o evento e inicia o temporizador. O manipulador de eventos exibe o valor da <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propriedade cada vez que ele é acionado.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Essa propriedade não pode ser definida porque o temporizador foi descartado.</exception>
        <exception cref="T:System.ArgumentException">A propriedade <see cref="P:System.Timers.Timer.Interval" /> foi definida como um valor maior que <see cref="F:System.Int32.MaxValue" /> antes de o temporizador ser habilitado.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="M:System.Timers.Timer.Stop" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="timer.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Termina a inicialização do tempo de execução de um <see cref="T:System.Timers.Timer" /> que é usado em um formulário ou por outro componente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] ambiente usa esse método para terminar a inicialização de um componente que é usado em um formulário ou por outro componente de design. O <xref:System.Timers.Timer.BeginInit%2A> método começa a inicialização. Usando o <xref:System.Timers.Timer.BeginInit%2A> e <xref:System.Timers.Timer.EndInit%2A> métodos impede que o controle seja usado antes de ser totalmente inicializado.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Timers.Timer.BeginInit" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="Interval">
      <MemberSignature Language="C#" Value="public double Interval { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Interval" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Interval" />
      <MemberSignature Language="VB.NET" Value="Public Property Interval As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Interval { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Interval : double with get, set" Usage="System.Timers.Timer.Interval" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(100)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("The number of milliseconds between timer events.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Timers.TimersDescription("TimerInterval")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o intervalo, expressado em milissegundos, no qual gerar o evento <see cref="E:System.Timers.Timer.Elapsed" />.</summary>
        <value>O tempo, em milissegundos, entre eventos <see cref="E:System.Timers.Timer.Elapsed" />. O valor deve ser maior que zero e menor ou igual a <see cref="F:System.Int32.MaxValue" />. O padrão é 100 milissegundos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você usa o <xref:System.Timers.Timer.Interval%2A> propriedade para determinar a frequência na qual o <xref:System.Timers.Timer.Elapsed> evento é disparado. Porque o <xref:System.Timers.Timer> classe depende do relógio do sistema, ele tem a mesma resolução do relógio do sistema. Isso significa que o <xref:System.Timers.Timer.Elapsed> evento será acionado em um intervalo definido pela resolução do relógio do sistema se o <xref:System.Timers.Timer.Interval%2A> propriedade é menor que a resolução do relógio do sistema. O exemplo a seguir define o <xref:System.Timers.Timer.Interval%2A> propriedade para 5 milissegundos. Quando executado em um [!INCLUDE[win7](~/includes/win7-md.md)] sistema cujo relógio do sistema tem uma resolução de aproximadamente 15 milissegundos, o evento é acionado, aproximadamente a cada 15 milissegundos, em vez da cada 5 milissegundos.  
  
 [!code-csharp[System.Timers.Timer.Interval#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer.interval/cs/interval2.cs#1)]
 [!code-vb[System.Timers.Timer.Interval#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer.interval/vb/interval2.vb#1)]  
  
 Você pode usar o código a seguir para determinar a resolução do relógio do sistema no sistema atual:  
  
 [!code-csharp[System.Timers.Timer.Interval#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer.interval/cs/resolution1.cs#2)]
 [!code-vb[System.Timers.Timer.Interval#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer.interval/vb/resolution1.vb#2)]  
  
 Se seu aplicativo requer uma resolução maior do que o oferecido pelos <xref:System.Timers.Timer> classe ou o relógio do sistema, use os timers de multimídia de alta resolução, consulte [como: Usar o Timer de alta resolução](https://msdn.microsoft.com/library/aa964692.aspx).  
  
 Se o intervalo é definido após o <xref:System.Timers.Timer> tiver iniciado, a contagem é redefinida. Por exemplo, se você definir o intervalo de 5 segundos e, em seguida, defina as <xref:System.Timers.Timer.Enabled%2A> propriedade para `true`, a contagem começa no momento <xref:System.Timers.Timer.Enabled%2A> está definido. Se você redefinir o intervalo de 10 segundos quando a contagem for 3 segundos, o <xref:System.Timers.Timer.Elapsed> é gerado pela primeira vez e 13 segundos após <xref:System.Timers.Timer.Enabled%2A> foi definida como `true`.  
  
 Se <xref:System.Timers.Timer.Enabled%2A> é definido como `true` e <xref:System.Timers.Timer.AutoReset%2A> é definido como `false`, o <xref:System.Timers.Timer> aciona o <xref:System.Timers.Timer.Elapsed> eventos somente uma vez, na primeira vez que o intervalo tenha decorrido. <xref:System.Timers.Timer.Enabled%2A> em seguida, é definido como `false`.  
  
> [!NOTE]
>  Se <xref:System.Timers.Timer.Enabled%2A> e <xref:System.Timers.Timer.AutoReset%2A> são definidos como `false`, e o temporizador anteriormente tiver sido habilitado, definindo o <xref:System.Timers.Timer.Interval%2A> faz com que a propriedade a <xref:System.Timers.Timer.Elapsed> evento seja acionado uma vez, como se o <xref:System.Timers.Timer.Enabled%2A> propriedade tivesse sido definida como `true`. Para definir o intervalo sem acionar o evento, você pode definir temporariamente a <xref:System.Timers.Timer.Enabled%2A> propriedade para `true`, defina as <xref:System.Timers.Timer.Interval%2A> propriedade para o intervalo de tempo desejado e, em seguida, defina imediatamente o <xref:System.Timers.Timer.Enabled%2A> propriedade de volta para `false`.  
  
   
  
## Examples  
 O exemplo a seguir instancia um <xref:System.Timers.Timer> objeto que aciona seu <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> eventos a cada dois segundos (2000 milissegundos), configura um manipulador de eventos para o evento e inicia o temporizador. O manipulador de eventos exibe o valor da <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propriedade cada vez que ele é acionado.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O intervalo é menor ou igual a zero.  
  
- ou - 
O intervalo é maior que <see cref="F:System.Int32.MaxValue" /> e o timer está habilitado no momento. (Se o timer não estiver habilitado no momento, nenhuma exceção será lançada até que ele seja habilitado.)</exception>
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Timers.Timer.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o site que associa o <see cref="T:System.Timers.Timer" /> ao respectivo contêiner no modo de design.</summary>
        <value>Uma interface <see cref="T:System.ComponentModel.ISite" /> que representa o site que associa o objeto <see cref="T:System.Timers.Timer" /> ao respectivo contêiner.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sites de associar uma <xref:System.ComponentModel.Component> para um <xref:System.ComponentModel.Container> e habilitar a comunicação entre eles, bem como fornecendo uma maneira para o contêiner gerenciar seus componentes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="timer.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Começa a acionar o evento <see cref="E:System.Timers.Timer.Elapsed" /> definindo <see cref="P:System.Timers.Timer.Enabled" /> como <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se <xref:System.Timers.Timer.Start%2A> é chamado e <xref:System.Timers.Timer.AutoReset%2A> é definido como `false`, o <xref:System.Timers.Timer> aciona o <xref:System.Timers.Timer.Elapsed> eventos somente uma vez, na primeira vez que o intervalo tenha decorrido. Se <xref:System.Timers.Timer.Start%2A> é chamado e <xref:System.Timers.Timer.AutoReset%2A> é `true`, o <xref:System.Timers.Timer> aciona o <xref:System.Timers.Timer.Elapsed> hora do evento primeiro o intervalo decorre e continua a gerar o evento no intervalo especificado.  
  
 Você também pode iniciar a medição de tempo, definindo <xref:System.Timers.Timer.Enabled%2A> para `true`.  
  
> [!NOTE]
>  Se <xref:System.Timers.Timer.AutoReset%2A> está `false`, o <xref:System.Timers.Timer.Start%2A> método deve ser chamado para iniciar a contagem novamente.  
  
 Uma chamada para o <xref:System.Timers.Timer.Start%2A> método quando o temporizador estiver habilitado não tem nenhum efeito.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O <see cref="T:System.Timers.Timer" /> é criado com um intervalo maior ou igual a <see cref="F:System.Int32.MaxValue" /> + 1 ou definido como um intervalo menor que zero.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Stop" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="timer.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Para de acionar o evento <see cref="E:System.Timers.Timer.Elapsed" /> definindo <see cref="P:System.Timers.Timer.Enabled" /> como <see langword="false" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você também pode interromper a medição de tempo, definindo <xref:System.Timers.Timer.Enabled%2A> para `false`.  
  
> [!NOTE]
>  O sinal para gerar a <xref:System.Timers.Timer.Elapsed> eventos sempre foi enfileirado para execução em um <xref:System.Threading.ThreadPool> thread, portanto o método de manipulação de eventos pode ser executado em um thread ao mesmo tempo que uma chamada para o <xref:System.Timers.Timer.Stop%2A> método é executado em outro thread. Isso pode resultar no <xref:System.Timers.Timer.Elapsed> evento sendo gerado após o <xref:System.Timers.Timer.Stop%2A> método é chamado. O exemplo de código na próxima seção mostra uma maneira de contornar essa condição de corrida.  
  
   
  
## Examples  
 O exemplo a seguir instancia um `System.Timers.Timer` objeto que aciona seu <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> eventos a cada dois segundos (2.000 milissegundos), configura um manipulador de eventos para o evento e inicia o temporizador. O manipulador de eventos exibe o valor da <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propriedade cada vez que ele é acionado. Quando o usuário pressiona a tecla Enter, o aplicativo chama o <xref:System.Timers.Timer.Stop%2A> método antes de encerrar o aplicativo.  
  
 [!code-csharp[System.Timers.Timer#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer2a.cs#2)]
 [!code-vb[System.Timers.Timer#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer2a.vb#2)]  
  
 O exemplo de código a seguir mostra uma maneira de impedir que o thread que chama o <xref:System.Timers.Timer.Stop%2A> método de continuar até que uma atualmente em execução <xref:System.Timers.Timer.Elapsed> evento termina e também para evitar que dois <xref:System.Timers.Timer.Elapsed> eventos de executar o manipulador de eventos ao mesmo tempo tempo (também conhecido como reentrância).  
  
 O exemplo executa 100 execuções de teste. Cada vez que o teste é executado, o temporizador é iniciado com um intervalo de 150 milissegundos. O manipulador de eventos usa o <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método para simular uma tarefa que aleatoriamente varia em comprimento de 50 a 200 milissegundos. O método de teste também inicia um thread de controle que aguarda por um segundo e, em seguida, interrompe o temporizador. Se um evento está sendo tratado quando o thread de controle para o temporizador, o thread de controle deve aguardar até que o evento seja concluído antes de continuar.  
  
 O <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> sobrecarga do método é usada para evitar a reentrância e para impedir que o thread de controle continuando até que um evento em execução termina. O manipulador de eventos usa o <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> método para definir um controle de variável como 1, mas somente se o valor no momento é zero. Esta é uma operação atômica. Se o valor de retorno for zero, a variável de controle tiver sido definida como 1 e o manipulador de eventos continua. Se o valor retornado é diferente de zero, o evento será simplesmente descartado para evitar a reentrância. (Se fosse necessário executar todos os eventos, o <xref:System.Threading.Monitor> classe seria uma maneira melhor para sincronizar os eventos.) Quando termina o manipulador de eventos, ele reverte a variável de controle como zero. O exemplo registra o número total de eventos que executadas, que foram descartados devido à reentrância, e que ocorreu após o <xref:System.Timers.Timer.Stop%2A> método foi chamado.  
  
 O thread de controle usa o <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> método para definir o controle de variável como -1 (menos um), mas somente se o valor no momento é zero. Se a operação atômica retorna não zero, um evento está atualmente em execução. O thread de controle aguarda e tenta novamente. O exemplo registra o número de vezes que o thread de controle tinha que aguardar um evento concluir.  
  
 [!code-csharp[Timer.Stop#1](~/samples/snippets/csharp/VS_Snippets_CLR/Timer.Stop/CS/source.cs#1)]
 [!code-vb[Timer.Stop#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Timer.Stop/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Timers.Timer.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("The object used to marshal the event handler calls issued when an interval has elapsed.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Timers.TimersDescription("TimerSynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o objeto usado para realizar marshaling das chamadas do manipulador de eventos emitidas ao término de um intervalo.</summary>
        <value>O <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> que representa o objeto usado para realizar marshaling das chamadas do manipulador de eventos emitidas ao término de um intervalo. O padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Timers.Timer.SynchronizingObject%2A> está `null`, o método que manipula o <xref:System.Timers.Timer.Elapsed> evento é chamado em um thread do pool de threads do sistema. Para obter mais informações sobre pools de threads do sistema, consulte <xref:System.Threading.ThreadPool>.  
  
 Quando o <xref:System.Timers.Timer.Elapsed> evento é manipulado por um componente de Windows Forms visual, como um botão, acessando o componente através do pool de thread do sistema pode resultado em uma exceção ou simplesmente pode não funcionar. Evitar esse efeito definindo <xref:System.Timers.Timer.SynchronizingObject%2A> a um componente de Windows Forms, que faz com que o método que manipula o <xref:System.Timers.Timer.Elapsed> evento a ser chamado no mesmo thread que o componente foi criado.  
  
> [!NOTE]
>  Mesmo se o <xref:System.Timers.Timer.SynchronizingObject%2A> propriedade não é `null`, <xref:System.Timers.Timer.Elapsed> eventos podem ocorrer após a <xref:System.Timers.Timer.Dispose%2A> ou <xref:System.Timers.Timer.Stop%2A> método foi chamado ou depois o <xref:System.Timers.Timer.Enabled%2A> propriedade foi definida como `false`, pois o sinal para gerar o <xref:System.Timers.Timer.Elapsed> eventos sempre foi enfileirado para execução em um pool de threads. Uma maneira de resolver essa condição de corrida é definir um sinalizador que informa ao manipulador de eventos para o <xref:System.Timers.Timer.Elapsed> evento ignorar eventos subsequentes.  
  
 Se o <xref:System.Timers.Timer> é usado dentro do Visual Studio em um designer de formulários do Windows <xref:System.Timers.Timer.SynchronizingObject%2A> é definida automaticamente como o controle que contém o <xref:System.Timers.Timer>. Por exemplo, se você colocar uma <xref:System.Timers.Timer> em um designer para `Form1` (que herda do <xref:System.Windows.Forms.Form>), o <xref:System.Timers.Timer.SynchronizingObject%2A> propriedade de <xref:System.Timers.Timer> é definido como a instância do `Form1`.  
  
   
  
## Examples  
 O exemplo a seguir é um aplicativo de formulários do Windows que serve como um editor de arquivo de texto muito simples. Quando o texto na caixa de texto não tiver sido salvo, o aplicativo pede ao usuário em intervalos de um minuto se ele quer salvar o conteúdo da caixa de texto.  Para fazer isso, o <xref:System.Timers.Timer.Interval%2A> estiver definida como um minuto (60.000 milissegundos) e o <xref:System.Timers.Timer.SynchronizingObject%2A> estiver definida como o <xref:System.Windows.Forms.Form> objeto.  
  
 [!code-csharp[System.Timers.Timer.SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Timers.Timer.SynchronizingObject/cs/Form1.cs#1)]
 [!code-vb[System.Timers.Timer.SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Timers.Timer.SynchronizingObject/vb/Form1.vb#1)]  
  
 O exemplo requer que você adicione os seguintes controles ao formulário:  
  
-   Um <xref:System.Windows.Forms.TextBox> controle chamado `TextBox1` (seu nome padrão).  
  
-   Um <xref:System.Windows.Forms.Button> controle chamado `Button1` (seu nome padrão).  
  
-   Um <xref:System.Windows.Forms.SaveFileDialog> controle chamado `SaveSaveFileDialog1` (seu nome padrão).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Form" />
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
        <altmember cref="T:System.Threading.ThreadPool" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
  </Members>
</Type>