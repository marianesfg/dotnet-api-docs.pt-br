<Type Name="Expression" FullName="System.Linq.Expressions.Expression">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bfa7ae83c61b273e7c1b0bbd7bfaff643a4eeb76" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39913514" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Expression" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Expression extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Expressions.Expression" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Expression" />
  <TypeSignature Language="C++ CLI" Value="public ref class Expression abstract" />
  <TypeSignature Language="F#" Value="type Expression = class" />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="ed4d0-101">Fornece a classe base da qual são derivadas as classes que representam nós de árvore de expressão.</span>
      <span class="sxs-lookup">
        <span data-stu-id="ed4d0-101">Provides the base class from which the classes that represent expression tree nodes are derived.</span>
      </span>
      <span data-ttu-id="ed4d0-102">Também contém métodos de fábrica <see langword="static" /> (<see langword="Shared" /> no Visual Basic) para criar os diferentes tipos de nós.</span>
      <span class="sxs-lookup">
        <span data-stu-id="ed4d0-102">It also contains <see langword="static" /> (<see langword="Shared" /> in Visual Basic) factory methods to create the various node types.</span>
      </span>
      <span data-ttu-id="ed4d0-103">Esta é uma classe <see langword="abstract" />.</span>
      <span class="sxs-lookup">
        <span data-stu-id="ed4d0-103">This is an <see langword="abstract" /> class.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ed4d0-104">O exemplo de código a seguir mostra como criar uma expressão de bloco.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-104">The following code example shows how to create a block expression.</span></span> <span data-ttu-id="ed4d0-105">A expressão de bloco consiste em dois <xref:System.Linq.Expressions.MethodCallExpression> objetos e um <xref:System.Linq.Expressions.ConstantExpression> objeto.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-105">The block expression consists of two <xref:System.Linq.Expressions.MethodCallExpression> objects and one <xref:System.Linq.Expressions.ConstantExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-106">Constrói uma nova instância de <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-106">Constructs a new instance of <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Expression();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-107">Constrói uma nova instância de <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-107">Constructs a new instance of <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression (System.Linq.Expressions.ExpressionType nodeType, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.Linq.Expressions.ExpressionType nodeType, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor(System.Linq.Expressions.ExpressionType,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Expression(System::Linq::Expressions::ExpressionType nodeType, Type ^ type);" />
      <MemberSignature Language="F#" Value="new System.Linq.Expressions.Expression : System.Linq.Expressions.ExpressionType * Type -&gt; System.Linq.Expressions.Expression" Usage="new System.Linq.Expressions.Expression (nodeType, type)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("use a different constructor that does not take ExpressionType. Then override NodeType and Type properties to provide the values that would be specified to this constructor.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="nodeType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="nodeType">
          <span data-ttu-id="ed4d0-108">O <see cref="T:System.Linq.Expressions.ExpressionType" /> para definir como tipo de nó.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-108">The <see cref="T:System.Linq.Expressions.ExpressionType" /> to set as the node type.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="ed4d0-109">O <see cref="P:System.Linq.Expressions.Expression.Type" /> desse <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-109">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of this <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-110">Inicializa uma nova instância da classe <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-110">Initializes a new instance of the <see cref="T:System.Linq.Expressions.Expression" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-111">Este construtor é chamado de construtores em classes derivadas.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-111">This constructor is called from constructors in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="protected internal virtual System.Linq.Expressions.Expression Accept (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression Accept(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function Accept (visitor As ExpressionVisitor) As Expression" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Linq::Expressions::Expression ^ Accept(System::Linq::Expressions::ExpressionVisitor ^ visitor);" />
      <MemberSignature Language="F#" Value="abstract member Accept : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression&#xA;override this.Accept : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression" Usage="expression.Accept visitor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" />
      </Parameters>
      <Docs>
        <param name="visitor">
          <span data-ttu-id="ed4d0-112">O visitante com o qual visitar esse nó.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-112">The visitor to visit this node with.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-113">Expede o método específico de visita para esse tipo de nó.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-113">Dispatches to the specific visit method for this node type.</span>
          </span>
          <span data-ttu-id="ed4d0-114">Por exemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chama o <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-114">For example, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> calls the <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-115">O resultado de visitar esse nó.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-115">The result of visiting this node.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-116">Essa implementação padrão para <xref:System.Linq.Expressions.ExpressionType.Extension> chamadas nós <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-116">This default implementation for <xref:System.Linq.Expressions.ExpressionType.Extension> nodes calls <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.</span></span> <span data-ttu-id="ed4d0-117">Substitua este método para chamar um método mais específico em uma classe derivada de visitante do <xref:System.Linq.Expressions.ExpressionVisitor> classe.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-117">Override this method to call into a more specific method on a derived visitor class of the <xref:System.Linq.Expressions.ExpressionVisitor> class.</span></span> <span data-ttu-id="ed4d0-118">No entanto, ele ainda deve suportar visitantes desconhecidos chamando <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-118">However, it should still support unknown visitors by calling <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-119">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de adição que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-119">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that does not have overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Add(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-120">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-120">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-121">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-121">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-122">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de adição que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-122">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-123">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-123">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-124">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-124">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-125">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-125">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-126">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-126">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-127">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-127">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-128">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-128">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-129">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-129">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-130">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-130">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-131">As seguintes regras de determinam o método de implementação selecionado para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-131">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-132">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de adição, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-132">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-133">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-133">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-134">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-134">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-135">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-135">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-136">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-136">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-137">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-137">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-138">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-138">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-139">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-139">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-140">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-140">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-141">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-141">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-142">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-142">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-143">O tipo do nó é o tipo de resultado do operador de adição predefinidos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-143">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="ed4d0-144">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-144">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-145">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de adição predefinidos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-145">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-146">O exemplo de código a seguir mostra como criar uma expressão que adiciona dois números inteiros.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-146">The following code example shows how to create an expression that adds two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#1)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-147">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-147">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-148">O operador de adição não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-148">The addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Add(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Add : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Add (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-149">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-149">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-150">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-150">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-151">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-151">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-152">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de adição que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-152">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that does not have overflow checking.</span>
          </span>
          <span data-ttu-id="ed4d0-153">O método de implementação pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-153">The implementing method can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-154">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-154">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-155">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-155">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-156">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-156">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-157">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-157">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-158">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-158">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-159">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-159">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-160">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-160">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-161">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-161">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-162">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-162">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-163">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-163">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="ed4d0-164">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de adição, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-164">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-165">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-165">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-166">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-166">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-167">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-167">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-168">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-168">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-169">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-169">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-170">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-170">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-171">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-171">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-172">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-172">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-173">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-173">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-174">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-174">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-175">O tipo do nó é o tipo de resultado do operador de adição predefinidos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-175">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="ed4d0-176">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-176">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-177">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de adição predefinidos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-177">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-178">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-178">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-179">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-179">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-180">
            <paramref name="method" /> é <see langword="null" /> e o operador de adição não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-180">
              <paramref name="method" /> is <see langword="null" /> and the addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-181">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição que não tem a verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-181">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AddAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-182">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-182">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-183">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-183">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-184">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição que não tem a verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-184">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-185">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-185">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ed4d0-186">O exemplo de código a seguir mostra como criar uma expressão que adiciona um valor para uma variável de inteiro e, em seguida, atribui o resultado da operação para a variável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-186">The following code example shows how to create an expression that adds a value to an integer variable and then assigns the result of the operation to the variable.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#18)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AddAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-187">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-187">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-188">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-188">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-189">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-189">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-190">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição que não tem a verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-190">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-191">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-191">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member AddAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-192">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-192">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-193">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-193">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-194">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-194">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="ed4d0-195">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-195">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-196">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição que não tem a verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-196">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-197">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-197">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-198">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-198">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AddAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssignChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-199">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-199">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-200">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-200">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-201">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-201">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-202">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-202">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AddAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssignChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-203">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-203">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-204">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-204">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-205">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-205">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-206">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-206">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-207">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-207">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member AddAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssignChecked (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-208">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-208">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-209">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-209">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-210">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-210">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="ed4d0-211">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-211">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-212">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-212">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-213">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-213">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-214">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de adição que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-214">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that has overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AddChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-215">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-215">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-216">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-216">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-217">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de adição que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-217">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-218">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-218">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-219">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-219">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-220">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-220">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-221">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-221">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-222">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-222">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-223">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-223">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-224">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-224">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-225">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-225">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-226">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-226">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-227">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de adição, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-227">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-228">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-228">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-229">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-229">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-230">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-230">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-231">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-231">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-232">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-232">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-233">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-233">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-234">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-234">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-235">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-235">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-236">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-236">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-237">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-237">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-238">O tipo do nó é o tipo de resultado do operador de adição predefinidos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-238">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="ed4d0-239">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-239">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-240">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de adição predefinidos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-240">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-241">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-241">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-242">O operador de adição não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-242">The addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AddChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-243">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-243">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-244">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-244">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-245">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-245">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-246">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de adição que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-246">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that has overflow checking.</span>
          </span>
          <span data-ttu-id="ed4d0-247">O método de implementação pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-247">The implementing method can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-248">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-248">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-249">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-249">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-250">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-250">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-251">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-251">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-252">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-252">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-253">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-253">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-254">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-254">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-255">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-255">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-256">O método de implementação para a operação é escolhido com base nas seguintes regras:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-256">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="ed4d0-257">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-257">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="ed4d0-258">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de adição, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-258">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-259">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-259">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-260">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-260">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-261">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-261">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-262">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-262">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-263">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-263">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-264">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-264">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-265">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-265">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-266">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-266">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-267">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-267">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-268">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-268">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-269">O tipo do nó é o tipo de resultado do operador de adição predefinidos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-269">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="ed4d0-270">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-270">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-271">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de adição predefinidos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-271">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-272">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-272">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-273">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-273">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-274">
            <paramref name="method" /> é <see langword="null" /> e o operador de adição não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-274">
              <paramref name="method" /> is <see langword="null" /> and the addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="And">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-275">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="AND" /> bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-275">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="AND" /> operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ And(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member And : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.And (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-276">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-276">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-277">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-277">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-278">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="AND" /> bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-278">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="AND" /> operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-279">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.And" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-279">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.And" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-280">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-280">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-281">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-281">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-282">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-282">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-283">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-283">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-284">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-284">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-285">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-285">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-286">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-286">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-287">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-287">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-288">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o bit a bit `AND` operador, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-288">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-289">Caso contrário, se `left`. Tipo e `right`. Tipo são tipos de inteiros ou boolianos, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-289">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-290">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-290">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-291">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-291">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-292">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-292">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-293">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-293">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-294">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-294">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-295">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-295">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-296">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-296">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-297">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-297">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-298">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-298">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-299">O tipo do nó é o tipo de resultado de predefinida bit a bit `AND` operador.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-299">The type of the node is the result type of the predefined bitwise `AND` operator.</span></span>  
  
-   <span data-ttu-id="ed4d0-300">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-300">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-301">O tipo do nó é o tipo que permite valor nulo que corresponde ao tipo de resultado de predefinida bit a bit `AND` operador.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-301">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `AND` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-302">O exemplo de código a seguir mostra como criar uma expressão que representa uma operação AND lógica em dois valores Boolean.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-302">The following code example shows how to create an expression that represents a logical AND operation on two Boolean values.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#2)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-303">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-303">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-304">O operador <see langword="AND" /> bit a bit não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-304">The bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ And(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member And : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.And (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-305">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-305">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-306">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-306">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-307">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-307">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-308">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="AND" /> bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-308">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="AND" /> operation.</span>
          </span>
          <span data-ttu-id="ed4d0-309">O método de implementação pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-309">The implementing method can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-310">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.And" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-310">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.And" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-311">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-311">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-312">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-312">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-313">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-313">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-314">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-314">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-315">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-315">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-316">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-316">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-317">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-317">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-318">O método de implementação para a operação é escolhido com base nas seguintes regras:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-318">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="ed4d0-319">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-319">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="ed4d0-320">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o bit a bit `AND` operador, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-320">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-321">Caso contrário, se `left`. Tipo e `right`. Tipo são tipos de inteiros ou boolianos, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-321">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-322">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-322">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-323">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-323">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-324">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-324">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-325">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-325">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-326">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-326">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-327">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-327">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-328">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-328">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-329">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-329">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-330">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-330">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-331">O tipo do nó é o tipo de resultado de predefinida bit a bit `AND` operador.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-331">The type of the node is the result type of the predefined bitwise `AND` operator.</span></span>  
  
-   <span data-ttu-id="ed4d0-332">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-332">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-333">O tipo do nó é o tipo que permite valor nulo que corresponde ao tipo de resultado de predefinida bit a bit `AND` operador.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-333">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `AND` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-334">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-334">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-335">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-335">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-336">
            <paramref name="method" /> é <see langword="null" /> e o operador <see langword="AND" /> bit a bit não é definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-336">
              <paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AndAlso">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-337">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="AND" /> condicional que avalia o segundo operando somente se o primeiro operando é avaliado como <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-337">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="AND" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="true" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAlso (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAlso(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AndAlso : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAlso (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-338">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-338">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-339">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-339">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-340">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="AND" /> condicional que avalia o segundo operando somente se o primeiro operando é avaliado como <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-340">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="AND" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="true" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-341">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-341">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-342">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-342">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-343">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-343">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-344">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-344">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-345">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-345">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-346">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-346">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-347">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-347">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-348">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-348">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-349">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-349">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-350">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o bit a bit `AND` operador, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-350">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="ed4d0-351">A condicional `AND` operador não pode ser sobrecarregado em c# ou Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-351">The conditional `AND` operator cannot be overloaded in C# or Visual Basic.</span></span> <span data-ttu-id="ed4d0-352">No entanto, a condicional `AND` operador é avaliado usando o bit a bit `AND` operador.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-352">However, the conditional `AND` operator is evaluated by using the bitwise `AND` operator.</span></span> <span data-ttu-id="ed4d0-353">Portanto, uma sobrecarga definido pelo usuário de bit a bit `AND` operador pode ser o método de implementação para esse tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-353">Thus, a user-defined overload of the bitwise `AND` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="ed4d0-354">Caso contrário, se `left`. Tipo e `right`. Tipo são tipos boolianos, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-354">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-355">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-355">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-356">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-356">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-357">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-357">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-358">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-358">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-359">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-359">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-360">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável, e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-360">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-361">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-361">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-362">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-362">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-363">`left`. Tipo e `right`. Tipo são do mesmo tipo booliano.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-363">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="ed4d0-364">Se `left`. Tipo e `right`. Tipo não anulável, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-364">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-365">O tipo do nó é o tipo de resultado da condicional predefinido `AND` operador.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-365">The type of the node is the result type of the predefined conditional `AND` operator.</span></span>  
  
-   <span data-ttu-id="ed4d0-366">Se `left`. Tipo e `right`. Tipo que permite valor nulo, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-366">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-367">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado da condicional predefinido `AND` operador.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-367">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `AND` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-368">O exemplo de código a seguir mostra como para criar uma expressão que executa uma operação lógica e operação em apenas-se seus dois operandos o primeiro operando é avaliado para `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-368">The following code example shows how to create an expression that performs a logical AND operation on its two operands only if the first operand evaluates to `true`.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#19)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-369">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-369">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-370">O operador <see langword="AND" /> bit a bit não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-370">The bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
          <span data-ttu-id="ed4d0-371">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-371">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-372">
            <paramref name="left" />.Type e <paramref name="right" />.Type não são do mesmo tipo booliano.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-372">
              <paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAlso (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAlso(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AndAlso : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAlso (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-373">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-373">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-374">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-374">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-375">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-375">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-376">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="AND" /> condicional que avalia o segundo operando somente se o primeiro operando é resolvido para verdadeiro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-376">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="AND" /> operation that evaluates the second operand only if the first operand is resolved to true.</span>
          </span>
          <span data-ttu-id="ed4d0-377">O método de implementação pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-377">The implementing method can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-378">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-378">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-379">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-379">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-380">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-380">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-381">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-381">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-382">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-382">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-383">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-383">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-384">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-384">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-385">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-385">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-386">O método de implementação para a operação é escolhido com base nas seguintes regras:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-386">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="ed4d0-387">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-387">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="ed4d0-388">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o bit a bit `AND` operador, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-388">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="ed4d0-389">A condicional `AND` operador não pode ser sobrecarregado em c# ou Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-389">The conditional `AND` operator cannot be overloaded in C# or Visual Basic.</span></span> <span data-ttu-id="ed4d0-390">No entanto, a condicional `AND` operador é avaliado usando o bit a bit `AND` operador.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-390">However, the conditional `AND` operator is evaluated by using the bitwise `AND` operator.</span></span> <span data-ttu-id="ed4d0-391">Portanto, uma sobrecarga definido pelo usuário de bit a bit `AND` operador pode ser o método de implementação para esse tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-391">Thus, a user-defined overload of the bitwise `AND` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="ed4d0-392">Caso contrário, se `left`. Tipo e `right`. Tipo são tipos boolianos, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-392">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-393">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-393">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-394">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-394">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-395">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-395">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-396">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-396">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-397">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-397">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-398">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável, e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-398">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-399">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-399">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-400">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-400">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-401">`left`. Tipo e `right`. Tipo são do mesmo tipo booliano.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-401">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="ed4d0-402">Se `left`. Tipo e `right`. Tipo não anulável, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-402">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-403">O tipo do nó é o tipo de resultado da condicional predefinido `AND` operador.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-403">The type of the node is the result type of the predefined conditional `AND` operator.</span></span>  
  
-   <span data-ttu-id="ed4d0-404">Se `left`. Tipo e `right`. Tipo que permite valor nulo, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-404">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-405">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado da condicional predefinido `AND` operador.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-405">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `AND` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-406">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-406">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-407">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-407">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-408">
            <paramref name="method" /> é <see langword="null" /> e o operador <see langword="AND" /> bit a bit não é definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-408">
              <paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
          <span data-ttu-id="ed4d0-409">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-409">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-410">
            <paramref name="method" /> é <see langword="null" /> e Type.<paramref name="left" /> e Type.<paramref name="right" /> não são do mesmo tipo booliano.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-410">
              <paramref name="method" /> is <see langword="null" /> and <paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AndAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-411">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição AND bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-411">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AndAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-412">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-412">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-413">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-413">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-414">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição AND bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-414">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-415">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-415">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AndAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-416">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-416">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-417">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-417">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-418">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-418">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-419">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição AND bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-419">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-420">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-420">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member AndAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-421">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-421">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-422">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-422">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-423">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-423">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="ed4d0-424">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-424">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-425">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição AND bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-425">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-426">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-426">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ArrayAccess">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-427">Cria uma <see cref="T:System.Linq.Expressions.IndexExpression" /> para acessar uma matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-427">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> to access an array.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayAccess (array As Expression, indexes As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ ArrayAccess(System::Linq::Expressions::Expression ^ array, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayAccess : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.ArrayAccess (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="ed4d0-428">Uma expressão que representa a matriz multidimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-428">An expression that represents the multidimensional array.</span>
          </span>
        </param>
        <param name="indexes">
          <span data-ttu-id="ed4d0-429">Uma <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém as expressões usadas para indexar a matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-429">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> containing expressions used to index the array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-430">Cria uma <see cref="T:System.Linq.Expressions.IndexExpression" /> para acessar uma matriz multidimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-430">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> to access a multidimensional array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-431">O <see cref="T:System.Linq.Expressions.IndexExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-431">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-432">A expressão que representa a matriz pode ser obtida usando o <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> método, ou através dos <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> ou <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-432">The expression that represents the array can be obtained by using the <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> method, or through <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> or <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-433">O exemplo de código a seguir mostra como alterar o valor de um elemento em uma matriz multidimensional usando o `ArrayAccess` método.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-433">The following code example shows how to change the value of an element in a multidimensional array by using the `ArrayAccess` method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#21)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayAccess (array As Expression, ParamArray indexes As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ ArrayAccess(System::Linq::Expressions::Expression ^ array, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayAccess : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.ArrayAccess (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="ed4d0-434">Uma expressão que representa a matriz a ser indexada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-434">An expression representing the array to index.</span>
          </span>
        </param>
        <param name="indexes">
          <span data-ttu-id="ed4d0-435">Uma matriz que contém as expressões usadas para indexar a matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-435">An array that contains expressions used to index the array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-436">Cria uma <see cref="T:System.Linq.Expressions.IndexExpression" /> para acessar uma matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-436">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> to access an array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-437">O <see cref="T:System.Linq.Expressions.IndexExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-437">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-438">A expressão que representa a matriz pode ser obtida usando o <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> método, ou através dos <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> ou <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-438">The expression that represents the array can be obtained by using the <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> method, or through <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> or <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.</span></span>  
  
 <span data-ttu-id="ed4d0-439">Para matrizes multidimensionais, use o <xref:System.Linq.Expressions.Expression.ArrayAccess%2A> método.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-439">For multidimensional arrays, use the <xref:System.Linq.Expressions.Expression.ArrayAccess%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-440">O exemplo de código a seguir mostra como alterar um valor de um elemento de matriz usando o `ArrayAccess` método.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-440">The following code example shows how to change a value of an array element by using the `ArrayAccess` method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#20)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ArrayIndex">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-441">Cria uma <see cref="T:System.Linq.Expressions.Expression" /> que representa a aplicação de um operador de índice.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-441">Creates an <see cref="T:System.Linq.Expressions.Expression" /> that represents applying an array index operator.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, indexes As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayIndex : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.ArrayIndex (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="ed4d0-442">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-442">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> property equal to.</span>
          </span>
        </param>
        <param name="indexes">
          <span data-ttu-id="ed4d0-443">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-443">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-444">Cria uma <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa a aplicação de um operador de índice de matriz a uma matriz de classificação superior a um.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-444">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents applying an array index operator to an array of rank more than one.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-445">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-445">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-446">Cada elemento da `indexes` deve ter <xref:System.Linq.Expressions.Expression.Type%2A> igual a <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-446">Each element of `indexes` must have <xref:System.Linq.Expressions.Expression.Type%2A> equal to <xref:System.Int32>.</span></span> <span data-ttu-id="ed4d0-447">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de `array` deve representar um tipo de matriz cuja posição corresponde ao número de elementos em `indexes`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-447">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `array` must represent an array type whose rank matches the number of elements in `indexes`.</span></span>  
  
 <span data-ttu-id="ed4d0-448">Se a classificação de `array`. Tipo é 1, esse método retorna um <xref:System.Linq.Expressions.BinaryExpression>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-448">If the rank of `array`.Type is 1, this method returns a <xref:System.Linq.Expressions.BinaryExpression>.</span></span> <span data-ttu-id="ed4d0-449">O <xref:System.Linq.Expressions.BinaryExpression.Left%2A> estiver definida como `array` e o <xref:System.Linq.Expressions.BinaryExpression.Right%2A> estiver definida como o único elemento de `indexes`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-449">The <xref:System.Linq.Expressions.BinaryExpression.Left%2A> property is set to `array` and the <xref:System.Linq.Expressions.BinaryExpression.Right%2A> property is set to the single element of `indexes`.</span></span> <span data-ttu-id="ed4d0-450">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do <xref:System.Linq.Expressions.BinaryExpression> representa o tipo de elemento de `array`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-450">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the <xref:System.Linq.Expressions.BinaryExpression> represents the element type of `array`.Type.</span></span>  
  
 <span data-ttu-id="ed4d0-451">Se a classificação de `array`. Tipo é a mais de um, esse método retorna um <xref:System.Linq.Expressions.MethodCallExpression>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-451">If the rank of `array`.Type is more than one, this method returns a <xref:System.Linq.Expressions.MethodCallExpression>.</span></span> <span data-ttu-id="ed4d0-452">O <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> estiver definida como o <xref:System.Reflection.MethodInfo> que descreve o método de instância pública `Get` no tipo representado pela <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `array`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-452">The <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> property is set to the <xref:System.Reflection.MethodInfo> that describes the public instance method `Get` on the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-453">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> método para criar um <xref:System.Linq.Expressions.MethodCallExpression> que representa a indexação em uma matriz bidimensional.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-453">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create a <xref:System.Linq.Expressions.MethodCallExpression> that represents indexing into a two-dimensional array.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-454">
            <paramref name="array" /> ou <paramref name="indexes" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-454">
              <paramref name="array" /> or <paramref name="indexes" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-455">
            <paramref name="array" />.Type não representa um tipo de matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-455">
              <paramref name="array" />.Type does not represent an array type.</span>
          </span>
          <span data-ttu-id="ed4d0-456">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-456">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-457">A classificação de <paramref name="array" />.Type não corresponde ao número de elementos em <paramref name="indexes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-457">The rank of <paramref name="array" />.Type does not match the number of elements in <paramref name="indexes" />.</span>
          </span>
          <span data-ttu-id="ed4d0-458">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-458">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-459">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um ou mais elementos de <paramref name="indexes" /> não representa o tipo <see cref="T:System.Int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-459">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="indexes" /> does not represent the <see cref="T:System.Int32" /> type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Linq.Expressions.Expression index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, index As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, System::Linq::Expressions::Expression ^ index);" />
      <MemberSignature Language="F#" Value="static member ArrayIndex : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ArrayIndex (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="index" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="ed4d0-460">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-460">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="ed4d0-461">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-461">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-462">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa a aplicação de um operador de índice de matriz a uma matriz de classificação um.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-462">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents applying an array index operator to an array of rank one.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-463">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-463">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-464">`index` deve representar um índice do tipo <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-464">`index` must represent an index of type <xref:System.Int32>.</span></span>  
  
 <span data-ttu-id="ed4d0-465">O <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.BinaryExpression> é `null`e ambos <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> são definidos como `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-465">The <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is `null`, and both <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span> <span data-ttu-id="ed4d0-466">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é igual ao tipo de elemento de `array`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-466">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to the element type of `array`.Type.</span></span> <span data-ttu-id="ed4d0-467">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-467">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-468">
            <paramref name="array" /> ou <paramref name="index" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-468">
              <paramref name="array" /> or <paramref name="index" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-469">
            <paramref name="array" />.Type não representa um tipo de matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-469">
              <paramref name="array" />.Type does not represent an array type.</span>
          </span>
          <span data-ttu-id="ed4d0-470">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-470">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-471">
            <paramref name="array" />.Type representa um tipo de matriz cuja classificação não é 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-471">
              <paramref name="array" />.Type represents an array type whose rank is not 1.</span>
          </span>
          <span data-ttu-id="ed4d0-472">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-472">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-473">
            <paramref name="index" />.Type não representa o tipo <see cref="T:System.Int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-473">
              <paramref name="index" />.Type does not represent the <see cref="T:System.Int32" /> type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, ParamArray indexes As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayIndex : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.ArrayIndex (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="ed4d0-474">Uma matriz de instâncias <see cref="T:System.Linq.Expressions.Expression" />/índices para a operação de índice da matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-474">An array of <see cref="T:System.Linq.Expressions.Expression" /> instances - indexes for the array index operation.</span>
          </span>
        </param>
        <param name="indexes">
          <span data-ttu-id="ed4d0-475">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-475">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-476">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa a aplicação de um operador de índice de matriz a uma matriz multidimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-476">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents applying an array index operator to a multidimensional array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-477">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-477">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-478">Cada elemento da `indexes` deve ter <xref:System.Linq.Expressions.Expression.Type%2A> igual a <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-478">Each element of `indexes` must have <xref:System.Linq.Expressions.Expression.Type%2A> equal to <xref:System.Int32>.</span></span> <span data-ttu-id="ed4d0-479">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de `array` deve representar um tipo de matriz cuja posição corresponde ao número de elementos em `indexes`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-479">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `array` must represent an array type whose rank matches the number of elements in `indexes`.</span></span>  
  
 <span data-ttu-id="ed4d0-480">Se a classificação de `array`. Tipo é 1, esse método retorna um <xref:System.Linq.Expressions.BinaryExpression>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-480">If the rank of `array`.Type is 1, this method returns a <xref:System.Linq.Expressions.BinaryExpression>.</span></span> <span data-ttu-id="ed4d0-481">O <xref:System.Linq.Expressions.BinaryExpression.Left%2A> estiver definida como `array` e o <xref:System.Linq.Expressions.BinaryExpression.Right%2A> estiver definida como o único elemento de `indexes`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-481">The <xref:System.Linq.Expressions.BinaryExpression.Left%2A> property is set to `array` and the <xref:System.Linq.Expressions.BinaryExpression.Right%2A> property is set to the single element of `indexes`.</span></span> <span data-ttu-id="ed4d0-482">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do <xref:System.Linq.Expressions.BinaryExpression> representa o tipo de elemento de `array`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-482">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the <xref:System.Linq.Expressions.BinaryExpression> represents the element type of `array`.Type.</span></span>  
  
 <span data-ttu-id="ed4d0-483">Se a classificação de `array`. Tipo é a mais de um, esse método retorna um <xref:System.Linq.Expressions.MethodCallExpression>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-483">If the rank of `array`.Type is more than one, this method returns a <xref:System.Linq.Expressions.MethodCallExpression>.</span></span> <span data-ttu-id="ed4d0-484">O <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> estiver definida como o <xref:System.Reflection.MethodInfo> que descreve o método de instância pública `Get` no tipo representado pela <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `array`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-484">The <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> property is set to the <xref:System.Reflection.MethodInfo> that describes the public instance method `Get` on the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-485">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> método para criar um <xref:System.Linq.Expressions.MethodCallExpression> que representa a indexação em uma matriz bidimensional.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-485">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create a <xref:System.Linq.Expressions.MethodCallExpression> that represents indexing into a two-dimensional array.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-486">
            <paramref name="array" /> ou <paramref name="indexes" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-486">
              <paramref name="array" /> or <paramref name="indexes" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-487">
            <paramref name="array" />.Type não representa um tipo de matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-487">
              <paramref name="array" />.Type does not represent an array type.</span>
          </span>
          <span data-ttu-id="ed4d0-488">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-488">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-489">A classificação de <paramref name="array" />.Type não corresponde ao número de elementos em <paramref name="indexes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-489">The rank of <paramref name="array" />.Type does not match the number of elements in <paramref name="indexes" />.</span>
          </span>
          <span data-ttu-id="ed4d0-490">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-490">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-491">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um ou mais elementos de <paramref name="indexes" /> não representa o tipo <see cref="T:System.Int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-491">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="indexes" /> does not represent the <see cref="T:System.Int32" /> type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayLength">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ArrayLength (System.Linq.Expressions.Expression array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ArrayLength(class System.Linq.Expressions.Expression array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayLength (array As Expression) As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ArrayLength(System::Linq::Expressions::Expression ^ array);" />
      <MemberSignature Language="F#" Value="static member ArrayLength : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.ArrayLength array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="ed4d0-492">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-492">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-493">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma expressão para obter o comprimento de uma matriz unidimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-493">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an expression for obtaining the length of a one-dimensional array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-494">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> e a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a <paramref name="array" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-494">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to <paramref name="array" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-495">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de `array` deve representar um tipo de matriz.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-495">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `array` must represent an array type.</span></span>  
  
 <span data-ttu-id="ed4d0-496">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> é igual a <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-496">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is equal to <xref:System.Int32>.</span></span> <span data-ttu-id="ed4d0-497">O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> é de propriedade `null`e ambos <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> são definidos como `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-497">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property is `null`, and both <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-498">
            <paramref name="array" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-498">
              <paramref name="array" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-499">
            <paramref name="array" />.Type não representa um tipo de matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-499">
              <paramref name="array" />.Type does not represent an array type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Assign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Assign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Assign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Assign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Assign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Assign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Assign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-500">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-500">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-501">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-501">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-502">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-502">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-503">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-503">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-504">O `Assign` expressão copia um valor para tipos de valor e, em seguida, copia uma referência para tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-504">The `Assign` expression copies a value for value types, and it copies a reference for reference types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-505">O exemplo de código a seguir mostra como criar uma expressão que representa uma operação de atribuição.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-505">The following code example shows how to create an expression that represents an assignment operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#12)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Bind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-506">Cria uma <see cref="T:System.Linq.Expressions.MemberAssignment" /> que representa a inicialização de um membro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-506">Creates a <see cref="T:System.Linq.Expressions.MemberAssignment" /> that represents the initialization of a member.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MemberInfo member, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberAssignment ^ Bind(System::Reflection::MemberInfo ^ member, System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Bind : System.Reflection.MemberInfo * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MemberAssignment" Usage="System.Linq.Expressions.Expression.Bind (member, expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="member">
          <span data-ttu-id="ed4d0-507">Um <see cref="T:System.Reflection.MemberInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-507">A <see cref="T:System.Reflection.MemberInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span>
          </span>
        </param>
        <param name="expression">
          <span data-ttu-id="ed4d0-508">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-508">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-509">Cria um <see cref="T:System.Linq.Expressions.MemberAssignment" /> que representa a inicialização de um campo ou propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-509">Creates a <see cref="T:System.Linq.Expressions.MemberAssignment" /> that represents the initialization of a field or property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-510">Um <see cref="T:System.Linq.Expressions.MemberAssignment" /> que tem <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-510">A <see cref="T:System.Linq.Expressions.MemberAssignment" /> that has <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> equal to <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-511">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de `expression` deve ser atribuível ao tipo representado pela <xref:System.Reflection.FieldInfo.FieldType%2A> ou <xref:System.Reflection.PropertyInfo.PropertyType%2A> propriedade do `member`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-511">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `expression` must be assignable to the type represented by the <xref:System.Reflection.FieldInfo.FieldType%2A> or <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of `member`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-512">
            <paramref name="member" /> ou <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-512">
              <paramref name="member" /> or <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-513">
            <paramref name="member" /> não representa um campo ou propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-513">
              <paramref name="member" /> does not represent a field or property.</span>
          </span>
          <span data-ttu-id="ed4d0-514">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-514">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-515">A propriedade representada por <paramref name="member" /> não tem um acessador <see langword="set" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-515">The property represented by <paramref name="member" /> does not have a <see langword="set" /> accessor.</span>
          </span>
          <span data-ttu-id="ed4d0-516">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-516">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-517">
            <paramref name="expression" />.Type não é atribuível ao tipo de campo ou à propriedade que <paramref name="member" /> representa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-517">
              <paramref name="expression" />.Type is not assignable to the type of the field or property that <paramref name="member" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MethodInfo propertyAccessor, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberAssignment ^ Bind(System::Reflection::MethodInfo ^ propertyAccessor, System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Bind : System.Reflection.MethodInfo * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MemberAssignment" Usage="System.Linq.Expressions.Expression.Bind (propertyAccessor, expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor">
          <span data-ttu-id="ed4d0-518">Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-518">A <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span>
          </span>
        </param>
        <param name="expression">
          <span data-ttu-id="ed4d0-519">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-519">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-520">Cria uma <see cref="T:System.Linq.Expressions.MemberAssignment" /> que representa a inicialização de um membro usando um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-520">Creates a <see cref="T:System.Linq.Expressions.MemberAssignment" /> that represents the initialization of a member by using a property accessor method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-521">Um <see cref="T:System.Linq.Expressions.MemberAssignment" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> definida para o <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade acessada em <paramref name="propertyAccessor" /> e a propriedade <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> definida para <paramref name="expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-521">A <see cref="T:System.Linq.Expressions.MemberAssignment" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and the <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> property set to <paramref name="expression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-522">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de `expression` deve ser atribuível ao tipo representado pela <xref:System.Reflection.PropertyInfo.PropertyType%2A> propriedade da propriedade acessada em `propertyAccessor`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-522">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `expression` must be assignable to the type represented by the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of the property accessed in `propertyAccessor`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-523">
            <paramref name="propertyAccessor" /> ou <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-523">
              <paramref name="propertyAccessor" /> or <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-524">
            <paramref name="propertyAccessor" /> não representa um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-524">
              <paramref name="propertyAccessor" /> does not represent a property accessor method.</span>
          </span>
          <span data-ttu-id="ed4d0-525">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-525">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-526">A propriedade acessada por <paramref name="propertyAccessor" /> não tem um acessador <see langword="set" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-526">The property accessed by <paramref name="propertyAccessor" /> does not have a <see langword="set" /> accessor.</span>
          </span>
          <span data-ttu-id="ed4d0-527">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-527">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-528">
            <paramref name="expression" />.Type não é atribuível ao tipo de campo ou à propriedade que <paramref name="member" /> representa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-528">
              <paramref name="expression" />.Type is not assignable to the type of the field or property that <paramref name="member" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Block">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-529">Cria um <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-529">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (expressions As IEnumerable(Of Expression)) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block expressions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="expressions">
          <span data-ttu-id="ed4d0-530">As expressões no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-530">The expressions in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-531">Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões determinadas e não tem variáveis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-531">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions and has no variables.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-532">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-532">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-533">Quando a expressão de bloco é executada, ele retorna o valor da última expressão no bloco.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-533">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (ParamArray expressions As Expression()) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block expressions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expressions">
          <span data-ttu-id="ed4d0-534">As expressões no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-534">The expressions in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-535">Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões determinadas e não tem variáveis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-535">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions and has no variables.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-536">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-536">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-537">Quando a expressão de bloco é executada, ele retorna o valor da última expressão no bloco.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-537">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-538">O exemplo de código a seguir mostra como criar uma expressão de bloco.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-538">The following code example shows how to create a block expression.</span></span> <span data-ttu-id="ed4d0-539">A expressão de bloco consiste em dois <xref:System.Linq.Expressions.MethodCallExpression> objetos e um <xref:System.Linq.Expressions.ConstantExpression> objeto.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-539">The block expression consists of two <xref:System.Linq.Expressions.MethodCallExpression> objects and one <xref:System.Linq.Expressions.ConstantExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (variables As IEnumerable(Of ParameterExpression), expressions As IEnumerable(Of Expression)) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : seq&lt;System.Linq.Expressions.ParameterExpression&gt; * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="variables">
          <span data-ttu-id="ed4d0-540">As variáveis no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-540">The variables in the block.</span>
          </span>
        </param>
        <param name="expressions">
          <span data-ttu-id="ed4d0-541">As expressões no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-541">The expressions in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-542">Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões e variáveis determinadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-542">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-543">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-543">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-544">Quando a expressão de bloco é executada, ele retorna o valor da última expressão no bloco.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-544">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-545">O exemplo de código a seguir mostra como passar um parâmetro para uma expressão de bloco e processa este parâmetro dentro de um bloco.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-545">The following code example shows how to pass a parameter to a block expression and process this parameter within a block.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#14)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (variables As IEnumerable(Of ParameterExpression), ParamArray expressions As Expression()) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : seq&lt;System.Linq.Expressions.ParameterExpression&gt; * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables">
          <span data-ttu-id="ed4d0-546">As variáveis no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-546">The variables in the block.</span>
          </span>
        </param>
        <param name="expressions">
          <span data-ttu-id="ed4d0-547">As expressões no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-547">The expressions in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-548">Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões e variáveis determinadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-548">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-549">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-549">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-550">Quando a expressão de bloco é executada, ele retorna o valor da última expressão no bloco.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-550">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">
          <span data-ttu-id="ed4d0-551">A primeira expressão no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-551">The first expression in the block.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="ed4d0-552">A segunda expressão no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-552">The second expression in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-553">Cria uma <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém duas expressões e não tem variáveis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-553">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains two expressions and has no variables.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-554">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-554">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-555">Quando a expressão de bloco é executada, ele retorna o valor da última expressão no bloco.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-555">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ed4d0-556">O tipo de resultado do bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-556">The result type of the block.</span>
          </span>
        </param>
        <param name="expressions">
          <span data-ttu-id="ed4d0-557">As expressões no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-557">The expressions in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-558">Cria uma <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões fornecidas, não tem variáveis e tem um tipo de resultado específico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-558">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions, has no variables and has specific result type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-559">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-559">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ed4d0-560">O tipo de resultado do bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-560">The result type of the block.</span>
          </span>
        </param>
        <param name="expressions">
          <span data-ttu-id="ed4d0-561">As expressões no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-561">The expressions in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-562">Cria uma <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões fornecidas, não tem variáveis e tem um tipo de resultado específico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-562">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions, has no variables and has specific result type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-563">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-563">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">
          <span data-ttu-id="ed4d0-564">A primeira expressão no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-564">The first expression in the block.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="ed4d0-565">A segunda expressão no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-565">The second expression in the block.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="ed4d0-566">A terceira expressão no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-566">The third expression in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-567">Cria uma <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém três expressões e não tem variáveis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-567">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains three expressions and has no variables.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-568">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-568">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-569">Quando a expressão de bloco é executada, ele retorna o valor da última expressão no bloco.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-569">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * seq&lt;System.Linq.Expressions.ParameterExpression&gt; * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ed4d0-570">O tipo de resultado do bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-570">The result type of the block.</span>
          </span>
        </param>
        <param name="variables">
          <span data-ttu-id="ed4d0-571">As variáveis no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-571">The variables in the block.</span>
          </span>
        </param>
        <param name="expressions">
          <span data-ttu-id="ed4d0-572">As expressões no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-572">The expressions in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-573">Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões e variáveis determinadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-573">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-574">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-574">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * seq&lt;System.Linq.Expressions.ParameterExpression&gt; * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ed4d0-575">O tipo de resultado do bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-575">The result type of the block.</span>
          </span>
        </param>
        <param name="variables">
          <span data-ttu-id="ed4d0-576">As variáveis no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-576">The variables in the block.</span>
          </span>
        </param>
        <param name="expressions">
          <span data-ttu-id="ed4d0-577">As expressões no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-577">The expressions in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-578">Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões e variáveis determinadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-578">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-579">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-579">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">
          <span data-ttu-id="ed4d0-580">A primeira expressão no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-580">The first expression in the block.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="ed4d0-581">A segunda expressão no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-581">The second expression in the block.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="ed4d0-582">A terceira expressão no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-582">The third expression in the block.</span>
          </span>
        </param>
        <param name="arg3">
          <span data-ttu-id="ed4d0-583">A quarta expressão no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-583">The fourth expression in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-584">Cria uma <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém quatro expressões e não tem variáveis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-584">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains four expressions and has no variables.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-585">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-585">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-586">Quando a expressão de bloco é executada, ele retorna o valor da última expressão no bloco.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-586">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression, arg4 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3, System::Linq::Expressions::Expression ^ arg4);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1, arg2, arg3, arg4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">
          <span data-ttu-id="ed4d0-587">A primeira expressão no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-587">The first expression in the block.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="ed4d0-588">A segunda expressão no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-588">The second expression in the block.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="ed4d0-589">A terceira expressão no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-589">The third expression in the block.</span>
          </span>
        </param>
        <param name="arg3">
          <span data-ttu-id="ed4d0-590">A quarta expressão no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-590">The fourth expression in the block.</span>
          </span>
        </param>
        <param name="arg4">
          <span data-ttu-id="ed4d0-591">A quinta expressão no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-591">The fifth expression in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-592">Cria uma <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém cinco expressões e não tem variáveis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-592">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains five expressions and has no variables.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-593">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-593">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-594">Quando a expressão de bloco é executada, ele retorna o valor da última expressão no bloco.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-594">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Break">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-595">Cria uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução break.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-595">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Break (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="ed4d0-596">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-596">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-597">Cria uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução break.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-597">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-598">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" /> e um valor nulo a ser passado para o rótulo de destino ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-598">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and a null value to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ed4d0-599">O exemplo a seguir demonstra como criar uma expressão que contém um <xref:System.Linq.Expressions.LoopExpression> objeto que usa o <xref:System.Linq.Expressions.Expression.Break%2A> método.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-599">The following example demonstrates how to create an expression that contains a <xref:System.Linq.Expressions.LoopExpression> object that uses the <xref:System.Linq.Expressions.Expression.Break%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Break (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="ed4d0-600">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-600">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="ed4d0-601">O valor que será passado para o rótulo associado ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-601">The value that will be passed to the associated label upon jumping.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-602">Cria uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução break.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-602">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement.</span>
          </span>
          <span data-ttu-id="ed4d0-603">O valor passado para o rótulo no salto pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-603">The value passed to the label upon jumping can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-604">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" /> e <paramref name="value" /> a ser passado para o rótulo de destino ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-604">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="ed4d0-605">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-605">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="ed4d0-606">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-606">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-607">Cria uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução break com o tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-607">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement with the specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-608">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" /> e a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-608">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break (target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="ed4d0-609">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-609">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="ed4d0-610">O valor que será passado para o rótulo associado ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-610">The value that will be passed to the associated label upon jumping.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="ed4d0-611">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-611">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-612">Cria uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução break com o tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-612">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement with the specified type.</span>
          </span>
          <span data-ttu-id="ed4d0-613">O valor passado para o rótulo no salto pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-613">The value passed to the label upon jumping can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-614">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" />, a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" /> e <paramref name="value" /> a serem passados para o rótulo de destino após saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-614">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Call">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-615">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-615">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="instance">
          <span data-ttu-id="ed4d0-616">Um <see cref="T:System.Linq.Expressions.Expression" /> que especifica a instância de uma chamada de método de instância (passa <see langword="null" /> para um método <see langword="static" /> (<see langword="Shared" /> no Visual Basic)).</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-616">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance method call (pass <see langword="null" /> for a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method).</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-617">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-617">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-618">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método que não aceita argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-618">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes no arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-619">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-619">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-620">Para representar uma chamada para um `static` (`Shared` no Visual Basic) método, passe `null` para o `instance` parâmetro ao chamar esse método.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-620">To represent a call to a `static` (`Shared` in Visual Basic) method, pass in `null` for the `instance` parameter when you call this method.</span></span>  
  
 <span data-ttu-id="ed4d0-621">Se `method` representa um método de instância, o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de `instance` deve ser atribuível ao tipo de declaração do método representado por `method`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-621">If `method` represents an instance method, the <xref:System.Linq.Expressions.Expression.Type%2A> property of `instance` must be assignable to the declaring type of the method represented by `method`.</span></span>  
  
 <span data-ttu-id="ed4d0-622">O <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> propriedade resultantes <xref:System.Linq.Expressions.MethodCallExpression> está vazio.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-622">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty.</span></span> <span data-ttu-id="ed4d0-623">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é igual ao tipo de retorno do método representado por `method`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-623">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to the return type of the method represented by `method`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-624">O exemplo de código a seguir mostra como criar uma expressão que chama um método sem argumentos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-624">The following code example shows how to create an expression that calls a method without arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#15)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-625">
            <paramref name="method" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-625">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ed4d0-626">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-626">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-627">
            <paramref name="instance" /> é <see langword="null" /> e <paramref name="method" /> representa um método de instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-627">
              <paramref name="instance" /> is <see langword="null" /> and <paramref name="method" /> represents an instance method.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-628">
            <paramref name="instance" />. O tipo não é atribuível ao tipo de declaração de método representada pelo <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-628">
              <paramref name="instance" />.Type is not assignable to the declaring type of the method represented by <paramref name="method" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arguments As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="method">
          <span data-ttu-id="ed4d0-629">O <see cref="T:System.Reflection.MethodInfo" /> que representa o método de destino.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-629">The <see cref="T:System.Reflection.MethodInfo" /> that represents the target method.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="ed4d0-630">Uma coleção de <see cref="T:System.Linq.Expressions.Expression" /> que representa os argumentos de chamada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-630">A collection of <see cref="T:System.Linq.Expressions.Expression" /> that represents the call arguments.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-631">Cria uma <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método estático (compartilhado no Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-631">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static (Shared in Visual Basic) method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-632">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-632">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">
          <span data-ttu-id="ed4d0-633">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-633">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="ed4d0-634">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-634">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-635">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método <see langword="static" /> (<see langword="Shared" /> no Visual Basic) que aceita um argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-635">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method that takes one argument.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-636">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-636">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ed4d0-637">O exemplo a seguir demonstra como criar uma expressão que chama um `static` (`Shared` no Visual Basic) método que aceita um argumento.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-637">The following example demonstrates how to create an expression that calls a `static` (`Shared` in Visual Basic) method that takes one argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#16)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-638">
            <paramref name="method" /> é nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-638">
              <paramref name="method" /> is null.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">
          <span data-ttu-id="ed4d0-639">Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método <see langword="static" /> (<see langword="Shared" /> no Visual Basic) igual ao qual definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-639">A <see cref="T:System.Reflection.MethodInfo" /> that represents a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="ed4d0-640">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-640">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-641">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método <see langword="static" /> (<see langword="Shared" /> no Visual Basic) que tem argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-641">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method that has arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-642">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-642">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-643">Se `arguments` não é `null`, ele deve ter o mesmo número de elementos que o número de parâmetros para o método representado por `method`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-643">If `arguments` is not `null`, it must have the same number of elements as the number of parameters for the method represented by `method`.</span></span> <span data-ttu-id="ed4d0-644">Cada elemento na `arguments` não deve ser `null` e deve ser atribuível ao parâmetro correspondente do `method`, possivelmente após *citando*.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-644">Each element in `arguments` must not be `null` and must be assignable to the corresponding parameter of `method`, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ed4d0-645">Um elemento será ser colocado entre aspas somente se o parâmetro do método correspondente é do tipo <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-645">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="ed4d0-646">Delimitação significa que o elemento é encapsulado em um <xref:System.Linq.Expressions.ExpressionType.Quote> nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-646">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="ed4d0-647">O nó resultante é um <xref:System.Linq.Expressions.UnaryExpression> cujos <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriedade é o elemento de `arguments`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-647">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
 <span data-ttu-id="ed4d0-648">O <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> propriedade resultantes <xref:System.Linq.Expressions.MethodCallExpression> está vazia se `arguments` é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-648">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="ed4d0-649">Caso contrário, ele contém os mesmos elementos que `arguments`, algumas das quais podem ser colocado entre aspas.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-649">Otherwise, it contains the same elements as `arguments`, some of which may be quoted.</span></span>  
  
 <span data-ttu-id="ed4d0-650">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.MethodCallExpression> é igual ao tipo de retorno do método representado por `method`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-650">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method represented by `method`.</span></span> <span data-ttu-id="ed4d0-651">A propriedade <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-651">The <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> property is `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-652">
            <paramref name="method" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-652">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-653">O número de elementos em <paramref name="arguments" /> não é igual ao número de parâmetros para o método representado por <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-653">The number of elements in <paramref name="arguments" /> does not equal the number of parameters for the method represented by <paramref name="method" />.</span>
          </span>
          <span data-ttu-id="ed4d0-654">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-654">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-655">Um ou mais dos elementos de <paramref name="arguments" /> não é atribuível ao parâmetro correspondente para o método representado por <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-655">One or more of the elements of <paramref name="arguments" /> is not assignable to the corresponding parameter for the method represented by <paramref name="method" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arguments As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance">
          <span data-ttu-id="ed4d0-656">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> igual a (passar <see langword="null" /> para um método <see langword="static" /> [<see langword="Shared" /> no Visual Basic]).</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-656">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> property equal to (pass <see langword="null" /> for a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method).</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-657">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-657">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="ed4d0-658">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-658">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-659">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método que aceita argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-659">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-660">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-660">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />, and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-661">Para representar uma chamada para um `static` (`Shared` no Visual Basic) método, passe `null` para o `instance` parâmetro ao chamar esse método, ou chamar <xref:System.Linq.Expressions.Expression.Call%2A> em vez disso.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-661">To represent a call to a `static` (`Shared` in Visual Basic) method, pass in `null` for the `instance` parameter when you call this method, or call <xref:System.Linq.Expressions.Expression.Call%2A> instead.</span></span>  
  
 <span data-ttu-id="ed4d0-662">Se `method` representa um método de instância, o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de `instance` deve ser atribuível ao tipo de declaração do método representado por `method`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-662">If `method` represents an instance method, the <xref:System.Linq.Expressions.Expression.Type%2A> property of `instance` must be assignable to the declaring type of the method represented by `method`.</span></span>  
  
 <span data-ttu-id="ed4d0-663">Se `arguments` não é `null`, ele deve ter o mesmo número de elementos que o número de parâmetros para o método representado por `method`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-663">If `arguments` is not `null`, it must have the same number of elements as the number of parameters for the method represented by `method`.</span></span> <span data-ttu-id="ed4d0-664">Cada elemento na `arguments` não deve ser `null` e deve ser atribuível ao parâmetro correspondente do `method`, possivelmente após *citando*.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-664">Each element in `arguments` must not be `null` and must be assignable to the corresponding parameter of `method`, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ed4d0-665">Um elemento será ser colocado entre aspas somente se o parâmetro do método correspondente é do tipo <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-665">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="ed4d0-666">Delimitação significa que o elemento é encapsulado em um <xref:System.Linq.Expressions.ExpressionType.Quote> nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-666">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="ed4d0-667">O nó resultante é um <xref:System.Linq.Expressions.UnaryExpression> cujos <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriedade é o elemento de `arguments`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-667">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
 <span data-ttu-id="ed4d0-668">O <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> propriedade resultantes <xref:System.Linq.Expressions.MethodCallExpression> está vazia se `arguments` é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-668">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="ed4d0-669">Caso contrário, ele contém os mesmos elementos que `arguments`, algumas das quais podem ser colocado entre aspas.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-669">Otherwise, it contains the same elements as `arguments`, some of which may be quoted.</span></span>  
  
 <span data-ttu-id="ed4d0-670">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.MethodCallExpression> é igual ao tipo de retorno do método representado por `method`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-670">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method represented by `method`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-671">
            <paramref name="method" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-671">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ed4d0-672">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-672">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-673">
            <paramref name="instance" /> é <see langword="null" /> e <paramref name="method" /> representa um método de instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-673">
              <paramref name="instance" /> is <see langword="null" /> and <paramref name="method" /> represents an instance method.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-674">
            <paramref name="instance" />. O tipo não é atribuível ao tipo de declaração de método representada pelo <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-674">
              <paramref name="instance" />.Type is not assignable to the declaring type of the method represented by <paramref name="method" />.</span>
          </span>
          <span data-ttu-id="ed4d0-675">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-675">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-676">O número de elementos em <paramref name="arguments" /> não é igual ao número de parâmetros para o método representado por <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-676">The number of elements in <paramref name="arguments" /> does not equal the number of parameters for the method represented by <paramref name="method" />.</span>
          </span>
          <span data-ttu-id="ed4d0-677">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-677">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-678">Um ou mais dos elementos de <paramref name="arguments" /> não é atribuível ao parâmetro correspondente para o método representado por <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-678">One or more of the elements of <paramref name="arguments" /> is not assignable to the corresponding parameter for the method represented by <paramref name="method" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">
          <span data-ttu-id="ed4d0-679">Um <see cref="T:System.Linq.Expressions.Expression" /> que especifica a instância de uma chamada de método de instância (passa <see langword="null" /> para um método <see langword="static" /> (<see langword="Shared" /> no Visual Basic)).</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-679">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance method call (pass <see langword="null" /> for a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method).</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-680">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-680">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="ed4d0-681">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-681">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-682">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método que aceita argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-682">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-683">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-683">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />, and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-684">Para representar uma chamada para um `static` (`Shared` no Visual Basic) método, passe `null` para o `instance` parâmetro ao chamar esse método, ou chamar <xref:System.Linq.Expressions.Expression.Call%2A> em vez disso.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-684">To represent a call to a `static` (`Shared` in Visual Basic) method, pass in `null` for the `instance` parameter when you call this method, or call <xref:System.Linq.Expressions.Expression.Call%2A> instead.</span></span>  
  
 <span data-ttu-id="ed4d0-685">Se `method` representa um método de instância, o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de `instance` deve ser atribuível ao tipo de declaração do método representado por `method`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-685">If `method` represents an instance method, the <xref:System.Linq.Expressions.Expression.Type%2A> property of `instance` must be assignable to the declaring type of the method represented by `method`.</span></span>  
  
 <span data-ttu-id="ed4d0-686">Se `arguments` não é `null`, ele deve ter o mesmo número de elementos que o número de parâmetros para o método representado por `method`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-686">If `arguments` is not `null`, it must have the same number of elements as the number of parameters for the method represented by `method`.</span></span> <span data-ttu-id="ed4d0-687">Cada elemento na `arguments` não deve ser `null` e deve ser atribuível ao parâmetro correspondente do `method`, possivelmente após *citando*.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-687">Each element in `arguments` must not be `null` and must be assignable to the corresponding parameter of `method`, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ed4d0-688">Um elemento será ser colocado entre aspas somente se o parâmetro do método correspondente é do tipo <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-688">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="ed4d0-689">Delimitação significa que o elemento é encapsulado em um <xref:System.Linq.Expressions.ExpressionType.Quote> nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-689">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="ed4d0-690">O nó resultante é um <xref:System.Linq.Expressions.UnaryExpression> cujos <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriedade é o elemento de `arguments`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-690">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
 <span data-ttu-id="ed4d0-691">O <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> propriedade resultantes <xref:System.Linq.Expressions.MethodCallExpression> está vazia se `arguments` é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-691">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="ed4d0-692">Caso contrário, ele contém os mesmos elementos que `arguments`, algumas das quais podem ser colocado entre aspas.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-692">Otherwise, it contains the same elements as `arguments`, some of which may be quoted.</span></span>  
  
 <span data-ttu-id="ed4d0-693">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.MethodCallExpression> é igual ao tipo de retorno do método representado por `method`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-693">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method represented by `method`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-694">
            <paramref name="method" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-694">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ed4d0-695">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-695">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-696">
            <paramref name="instance" /> é <see langword="null" /> e <paramref name="method" /> representa um método de instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-696">
              <paramref name="instance" /> is <see langword="null" /> and <paramref name="method" /> represents an instance method.</span>
          </span>
          <span data-ttu-id="ed4d0-697">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-697">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-698">
            <paramref name="arguments" /> não é <see langword="null" /> e um ou mais dos seus elementos é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-698">
              <paramref name="arguments" /> is not <see langword="null" /> and one or more of its elements is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-699">
            <paramref name="instance" />. O tipo não é atribuível ao tipo de declaração de método representada pelo <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-699">
              <paramref name="instance" />.Type is not assignable to the declaring type of the method represented by <paramref name="method" />.</span>
          </span>
          <span data-ttu-id="ed4d0-700">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-700">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-701">O número de elementos em <paramref name="arguments" /> não é igual ao número de parâmetros para o método representado por <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-701">The number of elements in <paramref name="arguments" /> does not equal the number of parameters for the method represented by <paramref name="method" />.</span>
          </span>
          <span data-ttu-id="ed4d0-702">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-702">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-703">Um ou mais dos elementos de <paramref name="arguments" /> não é atribuível ao parâmetro correspondente para o método representado por <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-703">One or more of the elements of <paramref name="arguments" /> is not assignable to the corresponding parameter for the method represented by <paramref name="method" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">
          <span data-ttu-id="ed4d0-704">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-704">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="ed4d0-705">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-705">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="ed4d0-706">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o segundo argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-706">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-707">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método estático que aceita dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-707">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes two arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-708">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-708">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-709">
            <paramref name="method" /> é nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-709">
              <paramref name="method" /> is null.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arg0 As Expression, arg1 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="instance">
          <span data-ttu-id="ed4d0-710">Um <see cref="T:System.Linq.Expressions.Expression" /> que especifica a instância de uma chamada de instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-710">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance call.</span>
          </span>
          <span data-ttu-id="ed4d0-711">(passar nulo para um método estático [compartilhado no Visual Basic]).</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-711">(pass null for a static (Shared in Visual Basic) method).</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-712">O <see cref="T:System.Reflection.MethodInfo" /> que representa o método de destino.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-712">The <see cref="T:System.Reflection.MethodInfo" /> that represents the target method.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="ed4d0-713">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-713">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="ed4d0-714">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o segundo argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-714">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-715">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método que aceita dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-715">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes two arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-716">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-716">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ed4d0-717">O exemplo de código a seguir mostra como criar uma expressão que chama um método de instância que tem dois argumentos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-717">The following code example shows how to create an expression that calls an instance method that has two arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#17)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, methodName As String, typeArguments As Type(), ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::String ^ methodName, cli::array &lt;Type ^&gt; ^ typeArguments, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * string * Type[] * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, methodName, typeArguments, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">
          <span data-ttu-id="ed4d0-718">Um <see cref="T:System.Linq.Expressions.Expression" /> cujo valor da propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> será pesquisado quanto a um método específico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-718">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> property value will be searched for a specific method.</span>
          </span>
        </param>
        <param name="methodName">
          <span data-ttu-id="ed4d0-719">O nome do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-719">The name of the method.</span>
          </span>
        </param>
        <param name="typeArguments">
          <span data-ttu-id="ed4d0-720">Uma matriz de objetos <see cref="T:System.Type" /> que especificam os parâmetros de tipo do método genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-720">An array of <see cref="T:System.Type" /> objects that specify the type parameters of the generic method.</span>
          </span>
          <span data-ttu-id="ed4d0-721">Esse argumento deve ser nulo quando methodName especifica um método não genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-721">This argument should be null when methodName specifies a non-generic method.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="ed4d0-722">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representa os argumentos para o método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-722">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that represents the arguments to the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-723">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método chamando o método de fábrica apropriado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-723">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method by calling the appropriate factory method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-724">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> igual a <paramref name="instance" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definido como o <see cref="T:System.Reflection.MethodInfo" /> que representa o método de instância especificado e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definido como os argumentos especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-724">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> property equal to <paramref name="instance" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> set to the <see cref="T:System.Reflection.MethodInfo" /> that represents the specified instance method, and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> set to the specified arguments.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-725">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.MethodCallExpression> é igual ao tipo de retorno do método indicado pelo `methodName`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-725">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method denoted by `methodName`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-726">
            <paramref name="instance" /> ou <paramref name="methodName" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-726">
              <paramref name="instance" /> or <paramref name="methodName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-727">Nenhum método cujo nome é <paramref name="methodName" />, cujos parâmetros de tipo correspondem a <paramref name="typeArguments" /> e cujos tipos de parâmetro correspondem a <paramref name="arguments" /> foi encontrado em <paramref name="instance" />.Type ou em seus tipos base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-727">No method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="instance" />.Type or its base types.</span>
          </span>
          <span data-ttu-id="ed4d0-728">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-728">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-729">Mais de um método cujo nome é <paramref name="methodName" />, cujos parâmetros de tipo correspondem a <paramref name="typeArguments" /> e cujos tipos de parâmetro correspondem a <paramref name="arguments" /> foi encontrado em <paramref name="instance" />.Type ou em seus tipos base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-729">More than one method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="instance" />.Type or its base types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">
          <span data-ttu-id="ed4d0-730">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-730">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="ed4d0-731">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-731">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="ed4d0-732">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o segundo argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-732">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="ed4d0-733">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o terceiro argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-733">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-734">Cria uma <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método estático que usa três argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-734">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes three arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-735">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-735">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-736">
            <paramref name="method" /> é nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-736">
              <paramref name="method" /> is null.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (Type type, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Type type, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(Type ^ type, System::String ^ methodName, cli::array &lt;Type ^&gt; ^ typeArguments, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : Type * string * Type[] * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (type, methodName, typeArguments, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ed4d0-737">O <see cref="T:System.Type" /> que especifica o tipo que contém o método <see langword="static" /> especificado (<see langword="Shared" /> no Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-737">The <see cref="T:System.Type" /> that specifies the type that contains the specified <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method.</span>
          </span>
        </param>
        <param name="methodName">
          <span data-ttu-id="ed4d0-738">O nome do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-738">The name of the method.</span>
          </span>
        </param>
        <param name="typeArguments">
          <span data-ttu-id="ed4d0-739">Uma matriz de objetos <see cref="T:System.Type" /> que especificam os parâmetros de tipo do método genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-739">An array of <see cref="T:System.Type" /> objects that specify the type parameters of the generic method.</span>
          </span>
          <span data-ttu-id="ed4d0-740">Esse argumento deve ser nulo quando methodName especifica um método não genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-740">This argument should be null when methodName specifies a non-generic method.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="ed4d0-741">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representam os argumentos para o método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-741">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that represent the arguments to the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-742">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método <see langword="static" /> (<see langword="Shared" /> no Visual Basic) chamando o método de fábrica apropriado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-742">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method by calling the appropriate factory method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-743">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definida como o <see cref="T:System.Reflection.MethodInfo" /> que representa o método <see langword="static" /> especificado (<see langword="Shared" /> no Visual Basic) e a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definida como os argumentos especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-743">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property set to the <see cref="T:System.Reflection.MethodInfo" /> that represents the specified <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method, and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> property set to the specified arguments.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-744">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.MethodCallExpression> é igual ao tipo de retorno do método indicado pelo `methodName`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-744">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method denoted by `methodName`.</span></span> <span data-ttu-id="ed4d0-745">A propriedade <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-745">The <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> property is `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-746">
            <paramref name="type" /> ou <paramref name="methodName" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-746">
              <paramref name="type" /> or <paramref name="methodName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-747">Nenhum método cujo nome é <paramref name="methodName" />, cujos parâmetros de tipo correspondem a <paramref name="typeArguments" /> e cujos tipos de parâmetro correspondem a <paramref name="arguments" /> foi encontrado em <paramref name="type" /> ou em seus tipos base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-747">No method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="type" /> or its base types.</span>
          </span>
          <span data-ttu-id="ed4d0-748">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-748">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-749">Mais de um método cujo nome é <paramref name="methodName" />, cujos parâmetros de tipo correspondem a <paramref name="typeArguments" /> e cujos tipos de parâmetro correspondem a <paramref name="arguments" /> foi encontrado em <paramref name="type" /> ou em seus tipos base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-749">More than one method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="type" /> or its base types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="instance">
          <span data-ttu-id="ed4d0-750">Um <see cref="T:System.Linq.Expressions.Expression" /> que especifica a instância de uma chamada de instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-750">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance call.</span>
          </span>
          <span data-ttu-id="ed4d0-751">(passar nulo para um método estático [compartilhado no Visual Basic]).</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-751">(pass null for a static (Shared in Visual Basic) method).</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-752">O <see cref="T:System.Reflection.MethodInfo" /> que representa o método de destino.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-752">The <see cref="T:System.Reflection.MethodInfo" /> that represents the target method.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="ed4d0-753">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-753">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="ed4d0-754">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o segundo argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-754">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="ed4d0-755">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o terceiro argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-755">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-756">Cria uma <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método que usa três argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-756">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes three arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-757">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-757">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">
          <span data-ttu-id="ed4d0-758">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-758">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="ed4d0-759">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-759">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="ed4d0-760">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o segundo argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-760">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="ed4d0-761">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o terceiro argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-761">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span>
          </span>
        </param>
        <param name="arg3">
          <span data-ttu-id="ed4d0-762">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o quarto argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-762">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the fourth argument.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-763">Cria uma <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método estático que aceita quatro argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-763">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes four arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-764">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-764">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-765">
            <paramref name="method" /> é nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-765">
              <paramref name="method" /> is null.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression, arg4 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3, System::Linq::Expressions::Expression ^ arg4);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1, arg2, arg3, arg4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">
          <span data-ttu-id="ed4d0-766">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-766">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="ed4d0-767">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-767">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="ed4d0-768">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o segundo argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-768">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="ed4d0-769">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o terceiro argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-769">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span>
          </span>
        </param>
        <param name="arg3">
          <span data-ttu-id="ed4d0-770">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o quarto argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-770">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the fourth argument.</span>
          </span>
        </param>
        <param name="arg4">
          <span data-ttu-id="ed4d0-771">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o quinto argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-771">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the fifth argument.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-772">Cria uma <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método estático que aceita cinco argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-772">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes five arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-773">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-773">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-774">
            <paramref name="method" /> é nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-774">
              <paramref name="method" /> is null.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CanReduce">
      <MemberSignature Language="C#" Value="public virtual bool CanReduce { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReduce" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.CanReduce" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReduce As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReduce { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReduce : bool" Usage="System.Linq.Expressions.Expression.CanReduce" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-775">Indica que o nó pode ser reduzido a um nó mais simples.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-775">Indicates that the node can be reduced to a simpler node.</span>
          </span>
          <span data-ttu-id="ed4d0-776">Se isso retornar verdadeiro, Reduce() poderá ser chamado para produzir a forma reduzida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-776">If this returns true, Reduce() can be called to produce the reduced form.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ed4d0-777">True se o nó puder ser reduzido; caso contrário, false.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-777">True if the node can be reduced, otherwise false.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Catch">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-778">Cria uma <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa uma instrução catch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-778">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Catch (variable As ParameterExpression, body As Expression) As CatchBlock" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body);" />
      <MemberSignature Language="F#" Value="static member Catch : System.Linq.Expressions.ParameterExpression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (variable, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="variable">
          <span data-ttu-id="ed4d0-779">Uma <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa uma referência para o objeto <see cref="T:System.Exception" /> capturado por este manipulador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-779">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> representing a reference to the <see cref="T:System.Exception" /> object caught by this handler.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="ed4d0-780">O corpo da instrução catch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-780">The body of the catch statement.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-781">Cria uma <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa uma instrução catch com uma referência para o objeto <see cref="T:System.Exception" /> capturado para uso no corpo do manipulador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-781">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with a reference to the caught <see cref="T:System.Exception" /> object for use in the handler body.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-782">O <see cref="T:System.Linq.Expressions.CatchBlock" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-782">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(Type ^ type, System::Linq::Expressions::Expression ^ body);" />
      <MemberSignature Language="F#" Value="static member Catch : Type * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (type, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ed4d0-783">O <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que esse <see cref="T:System.Linq.Expressions.CatchBlock" /> tratará.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-783">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of <see cref="T:System.Exception" /> this <see cref="T:System.Linq.Expressions.CatchBlock" /> will handle.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="ed4d0-784">O corpo da instrução catch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-784">The body of the catch statement.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-785">Cria uma <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa uma instrução catch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-785">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-786">O <see cref="T:System.Linq.Expressions.CatchBlock" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-786">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-787">O <xref:System.Linq.Expressions.Expression.Type%2A> de <xref:System.Exception> ser capturada pode ser especificada, mas nenhuma referência para o <xref:System.Exception> objeto estará disponível para uso no <xref:System.Linq.Expressions.CatchBlock>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-787">The <xref:System.Linq.Expressions.Expression.Type%2A> of <xref:System.Exception> to be caught can be specified but no reference to the <xref:System.Exception> object will be available for use in the <xref:System.Linq.Expressions.CatchBlock>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Catch (variable As ParameterExpression, body As Expression, filter As Expression) As CatchBlock" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberSignature Language="F#" Value="static member Catch : System.Linq.Expressions.ParameterExpression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (variable, body, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="variable">
          <span data-ttu-id="ed4d0-788">Uma <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa uma referência para o objeto <see cref="T:System.Exception" /> capturado por este manipulador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-788">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> representing a reference to the <see cref="T:System.Exception" /> object caught by this handler.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="ed4d0-789">O corpo da instrução catch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-789">The body of the catch statement.</span>
          </span>
        </param>
        <param name="filter">
          <span data-ttu-id="ed4d0-790">O corpo do filtro <see cref="T:System.Exception" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-790">The body of the <see cref="T:System.Exception" /> filter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-791">Cria uma <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa uma instrução catch com um filtro <see cref="T:System.Exception" /> e uma referência para o objeto <see cref="T:System.Exception" /> capturado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-791">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with an <see cref="T:System.Exception" /> filter and a reference to the caught <see cref="T:System.Exception" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-792">O <see cref="T:System.Linq.Expressions.CatchBlock" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-792">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(Type ^ type, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberSignature Language="F#" Value="static member Catch : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (type, body, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ed4d0-793">O <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que esse <see cref="T:System.Linq.Expressions.CatchBlock" /> tratará.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-793">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of <see cref="T:System.Exception" /> this <see cref="T:System.Linq.Expressions.CatchBlock" /> will handle.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="ed4d0-794">O corpo da instrução catch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-794">The body of the catch statement.</span>
          </span>
        </param>
        <param name="filter">
          <span data-ttu-id="ed4d0-795">O corpo do filtro <see cref="T:System.Exception" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-795">The body of the <see cref="T:System.Exception" /> filter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-796">Cria uma <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa uma instrução catch com um filtro <see cref="T:System.Exception" />, mas nenhuma referência ao objeto <see cref="T:System.Exception" /> capturado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-796">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with an <see cref="T:System.Exception" /> filter but no reference to the caught <see cref="T:System.Exception" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-797">O <see cref="T:System.Linq.Expressions.CatchBlock" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-797">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearDebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression ClearDebugInfo (System.Linq.Expressions.SymbolDocumentInfo document);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression ClearDebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ClearDebugInfo (document As SymbolDocumentInfo) As DebugInfoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DebugInfoExpression ^ ClearDebugInfo(System::Linq::Expressions::SymbolDocumentInfo ^ document);" />
      <MemberSignature Language="F#" Value="static member ClearDebugInfo : System.Linq.Expressions.SymbolDocumentInfo -&gt; System.Linq.Expressions.DebugInfoExpression" Usage="System.Linq.Expressions.Expression.ClearDebugInfo document" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" />
      </Parameters>
      <Docs>
        <param name="document">
          <span data-ttu-id="ed4d0-798">O <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa o arquivo de origem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-798">The <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that represents the source file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-799">Cria uma <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> para limpar um ponto de sequência.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-799">Creates a <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> for clearing a sequence point.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-800">Uma instância de <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> para limpar um ponto de sequência.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-800">An instance of <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> for clearning a sequence point.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Coalesce">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-801">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de união.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-801">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a coalescing operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Coalesce (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Coalesce(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Coalesce : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Coalesce (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-802">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-802">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-803">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-803">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-804">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de união.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-804">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a coalescing operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-805">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-805">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-806">O <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.BinaryExpression> é `null` e ambas <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> são definidos como `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-806">The <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is `null` and both <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span> <span data-ttu-id="ed4d0-807">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é igual ao tipo de resultado da operação de união.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-807">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to the result type of the coalescing operation.</span></span> <span data-ttu-id="ed4d0-808">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-808">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
#### <a name="result-type"></a><span data-ttu-id="ed4d0-809">Tipo de resultado</span><span class="sxs-lookup"><span data-stu-id="ed4d0-809">Result Type</span></span>  
 <span data-ttu-id="ed4d0-810">As regras a seguir determinam o tipo de resultado:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-810">The following rules determine the result type:</span></span>  
  
-   <span data-ttu-id="ed4d0-811">Se `left`. Tipo representa um tipo anulável e `right`. Tipo é implicitamente conversível para o tipo não anulável correspondente, o tipo de resultado é o equivalente não anulável de `left`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-811">If `left`.Type represents a nullable type and `right`.Type is implicitly convertible to the corresponding non-nullable type, the result type is the non-nullable equivalent of `left`.Type.</span></span>  
  
-   <span data-ttu-id="ed4d0-812">Caso contrário, se `right`. Tipo é implicitamente conversível para `left`. Tipo, o tipo de resultado é `left`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-812">Otherwise, if `right`.Type is implicitly convertible to `left`.Type, the result type is `left`.Type.</span></span>  
  
-   <span data-ttu-id="ed4d0-813">Caso contrário, se o equivalente não anulável de `left`. Tipo é implicitamente conversível para `right`. Tipo, o tipo de resultado é `right`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-813">Otherwise, if the non-nullable equivalent of `left`.Type is implicitly convertible to `right`.Type, the result type is `right`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-814">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-814">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-815">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> do <paramref name="left" /> não representa um tipo de referência nem um tipo de valor que permite um valor null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-815">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="left" /> does not represent a reference type or a nullable value type.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-816">
            <paramref name="left" />.Type e <paramref name="right" />.Type não são conversíveis entre si.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-816">
              <paramref name="left" />.Type and <paramref name="right" />.Type are not convertible to each other.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Coalesce (left As Expression, right As Expression, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Coalesce(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member Coalesce : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Coalesce (left, right, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-817">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-817">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-818">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-818">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="ed4d0-819">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-819">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-820">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de união, dada uma função de conversão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-820">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a coalescing operation, given a conversion function.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-821">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-821">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-822">O <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.BinaryExpression> é `null` e ambas <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> são definidos como `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-822">The <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is `null` and both <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span>  
  
 <span data-ttu-id="ed4d0-823">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.BinaryExpression> é igual ao tipo de resultado da operação de união.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-823">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is equal to the result type of the coalescing operation.</span></span>  
  
 <span data-ttu-id="ed4d0-824">As regras a seguir determinam o tipo de resultado:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-824">The following rules determine the result type:</span></span>  
  
-   <span data-ttu-id="ed4d0-825">Se `left`. Tipo representa um tipo anulável e `right`. Tipo é implicitamente conversível para o tipo não anulável correspondente, o tipo de resultado é o equivalente não anulável de `left`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-825">If `left`.Type represents a nullable type and `right`.Type is implicitly convertible to the corresponding non-nullable type, the result type is the non-nullable equivalent of `left`.Type.</span></span>  
  
-   <span data-ttu-id="ed4d0-826">Caso contrário, se `right`. Tipo é implicitamente conversível para `left`. Tipo, o tipo de resultado é `left`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-826">Otherwise, if `right`.Type is implicitly convertible to `left`.Type, the result type is `left`.Type.</span></span>  
  
-   <span data-ttu-id="ed4d0-827">Caso contrário, se o equivalente não anulável de `left`. Tipo é implicitamente conversível para `right`. Tipo, o tipo de resultado é `right`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-827">Otherwise, if the non-nullable equivalent of `left`.Type is implicitly convertible to `right`.Type, the result type is `right`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-828">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-828">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-829">
            <paramref name="left" />.Type e <paramref name="right" />.Type não são conversíveis entre si.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-829">
              <paramref name="left" />.Type and <paramref name="right" />.Type are not convertible to each other.</span>
          </span>
          <span data-ttu-id="ed4d0-830">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-830">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-831">
            <paramref name="conversion" /> não é <see langword="null" /> e <paramref name="conversion" />. O tipo é um tipo delegado que não aceita exatamente um argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-831">
              <paramref name="conversion" /> is not <see langword="null" /> and <paramref name="conversion" />.Type is a delegate type that does not take exactly one argument.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-832">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> do <paramref name="left" /> não representa um tipo de referência nem um tipo de valor que permite um valor null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-832">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="left" /> does not represent a reference type or a nullable value type.</span>
          </span>
          <span data-ttu-id="ed4d0-833">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-833">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-834">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> representa um tipo que não é atribuível ao tipo de parâmetro do tipo delegado <paramref name="conversion" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-834">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="left" /> represents a type that is not assignable to the parameter type of the delegate type <paramref name="conversion" />.Type.</span>
          </span>
          <span data-ttu-id="ed4d0-835">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-835">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-836">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="right" /> não é igual ao tipo de retorno do tipo delegado <paramref name="conversion" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-836">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="right" /> is not equal to the return type of the delegate type <paramref name="conversion" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Condition">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-837">Cria um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa uma instrução condicional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-837">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional statement.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Condition (test As Expression, ifTrue As Expression, ifFalse As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ Condition(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse);" />
      <MemberSignature Language="F#" Value="static member Condition : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.Condition (test, ifTrue, ifFalse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test">
          <span data-ttu-id="ed4d0-838">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-838">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span>
          </span>
        </param>
        <param name="ifTrue">
          <span data-ttu-id="ed4d0-839">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-839">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span>
          </span>
        </param>
        <param name="ifFalse">
          <span data-ttu-id="ed4d0-840">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-840">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-841">Cria um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa uma instrução condicional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-841">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional statement.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-842">Um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e as propriedades <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> e <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-842">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, and <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-843">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.ConditionalExpression> é igual ao <xref:System.Linq.Expressions.Expression.Type%2A> propriedade `ifTrue`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-843">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ConditionalExpression> is equal to the <xref:System.Linq.Expressions.Expression.Type%2A> property of `ifTrue`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-844">O exemplo de código a seguir mostra como criar uma expressão que representa uma instrução condicional.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-844">The following code example shows how to create an expression that represents a conditional statement.</span></span> <span data-ttu-id="ed4d0-845">Se o primeiro argumento é avaliado como `true`, o segundo argumento é executado; caso contrário, o terceiro argumento é executado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-845">If the first argument evaluates to `true`, the second argument is executed; otherwise, the third argument is executed.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#3)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-846">
            <paramref name="test" />, <paramref name="ifTrue" /> ou <paramref name="ifFalse" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-846">
              <paramref name="test" /> or <paramref name="ifTrue" /> or <paramref name="ifFalse" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-847">
            <paramref name="test" />.Type não é <see cref="T:System.Boolean" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-847">
              <paramref name="test" />.Type is not <see cref="T:System.Boolean" />.</span>
          </span>
          <span data-ttu-id="ed4d0-848">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-848">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-849">
            <paramref name="ifTrue" />.Type não é igual a <paramref name="ifFalse" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-849">
              <paramref name="ifTrue" />.Type is not equal to <paramref name="ifFalse" />.Type.</span>
          </span>
        </exception>
        <altmember cref="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
        <altmember cref="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      </Docs>
    </Member>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ Condition(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Condition : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.Condition (test, ifTrue, ifFalse, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="test">
          <span data-ttu-id="ed4d0-850">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-850">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span>
          </span>
        </param>
        <param name="ifTrue">
          <span data-ttu-id="ed4d0-851">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-851">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span>
          </span>
        </param>
        <param name="ifFalse">
          <span data-ttu-id="ed4d0-852">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-852">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property equal to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="ed4d0-853">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-853">A <see cref="P:System.Linq.Expressions.Expression.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-854">Cria um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa uma instrução condicional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-854">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional statement.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-855">Um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e as propriedades <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> e <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-855">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, and <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-856">Esse método permite unificando explicitamente o tipo de resultado da expressão condicional em casos em que os tipos de `ifTrue` e `ifFalse` expressões não são iguais.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-856">This method allows explicitly unifying the result type of the conditional expression in cases where the types of `ifTrue` and `ifFalse` expressions are not equal.</span></span> <span data-ttu-id="ed4d0-857">Tipos de ambos `ifTrue` e `ifFalse` deve ser implicitamente referência atribuível ao tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-857">Types of both `ifTrue` and `ifFalse` must be implicitly reference assignable to the result type.</span></span> <span data-ttu-id="ed4d0-858">O `type` tem permissão para ser <xref:System.Void>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-858">The `type` is allowed to be <xref:System.Void>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Constant">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-859">Cria um <see cref="T:System.Linq.Expressions.ConstantExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-859">Creates a <see cref="T:System.Linq.Expressions.ConstantExpression" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Constant (value As Object) As ConstantExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConstantExpression ^ Constant(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Constant : obj -&gt; System.Linq.Expressions.ConstantExpression" Usage="System.Linq.Expressions.Expression.Constant value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="ed4d0-860">Um <see cref="T:System.Object" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-860">An <see cref="T:System.Object" /> to set the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-861">Cria uma <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-861">Creates a <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property set to the specified value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-862">Uma <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> e a propriedade <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-862">A <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> and the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-863">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.ConstantExpression> é igual ao tipo de `value`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-863">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ConstantExpression> is equal to the type of `value`.</span></span> <span data-ttu-id="ed4d0-864">Se `value` está `null`, <xref:System.Linq.Expressions.Expression.Type%2A> é igual a <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-864">If `value` is `null`, <xref:System.Linq.Expressions.Expression.Type%2A> is equal to <xref:System.Object>.</span></span>  
  
 <span data-ttu-id="ed4d0-865">Para representar `null`, você também pode usar o <xref:System.Linq.Expressions.Expression.Constant%28System.Object%2CSystem.Type%29> método, com a qual você pode especificar explicitamente o tipo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-865">To represent `null`, you can also use the <xref:System.Linq.Expressions.Expression.Constant%28System.Object%2CSystem.Type%29> method, with which you can explicitly specify the type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-866">O exemplo de código a seguir mostra como criar uma expressão que representa um valor constante.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-866">The following code example shows how to create an expression that represents a constant value.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#4)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConstantExpression ^ Constant(System::Object ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Constant : obj * Type -&gt; System.Linq.Expressions.ConstantExpression" Usage="System.Linq.Expressions.Expression.Constant (value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="ed4d0-867">Um <see cref="T:System.Object" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-867">An <see cref="T:System.Object" /> to set the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property equal to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="ed4d0-868">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-868">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-869">Cria uma <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tem as propriedades <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-869">Creates a <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-870">Um <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> e as propriedades <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-870">A <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> and the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-871">Esse método pode ser útil para representar valores de tipos que permitem valor nulos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-871">This method can be useful for representing values of nullable types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-872">O exemplo de código a seguir mostra como criar uma expressão que representa uma constante do tipo que permite valor nulo e defina seu valor como `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-872">The following code example shows how to create an expression that represents a constant of the nullable type and set its value to `null`.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#22)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-873">
            <paramref name="type" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-873">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-874">
            <paramref name="value" /> não é <see langword="null" /> e <paramref name="type" /> não pode ser atribuído do tipo dinâmico de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-874">
              <paramref name="value" /> is not <see langword="null" /> and <paramref name="type" /> is not assignable from the dynamic type of <paramref name="value" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Continue">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-875">Cria uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução continue.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-875">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a continue statement.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Continue (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Continue(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Continue : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Continue target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="ed4d0-876">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-876">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-877">Cria uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução continue.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-877">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a continue statement.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-878">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" /> e um valor nulo a ser passado para o rótulo de destino ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-878">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and a null value to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ed4d0-879">O exemplo a seguir demonstra como criar uma expressão de loop que usa o <xref:System.Linq.Expressions.Expression.Continue%2A> método.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-879">The following example demonstrates how to create a loop expression that uses the <xref:System.Linq.Expressions.Expression.Continue%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#46)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#46)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Continue(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Continue : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Continue (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="ed4d0-880">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-880">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="ed4d0-881">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-881">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-882">Cria uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução continue com o tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-882">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a continue statement with the specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-883">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" />, a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" /> e um valor nulo a ser passado para o rótulo de destino ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-883">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and a null value to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-884">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de conversão de tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-884">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a type conversion operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Convert(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Convert (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-885">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-885">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="ed4d0-886">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-886">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-887">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de conversão de tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-887">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a type conversion operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-888">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-888">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-889">O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-889">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="ed4d0-890">A propriedade <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> é `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-890">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="ed4d0-891">Se o nó é eliminado, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> é `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-891">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="ed4d0-892">Caso contrário, será `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-892">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-893">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-893">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-894">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-894">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-895">Se qualquer um dos `expression`. Tipo ou `type` é um tipo definido pelo usuário que define um operador de conversão implícita ou explícita, o <xref:System.Reflection.MethodInfo> que representa que o método de implementação do operador é.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-895">If either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-896">Caso contrário:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-896">Otherwise:</span></span>  
  
    -   <span data-ttu-id="ed4d0-897">Se ambos os `expression`. Tipo e `type` representam os tipos numéricos ou booleanos ou tipos de enumeração que permite valor nulo ou não anulável, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-897">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="ed4d0-898">Se qualquer um dos `expression`. Tipo ou `type` é um tipo de referência e uma conversão boxing explícita, conversão unboxing ou conversão de referência existe de `expression`. Digite para `type`, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-898">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-899">Com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-899">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-900">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-900">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-901">Se `expression`. O tipo é atribuível ao tipo de argumento do método de implementação e o tipo de retorno do método de implementação é atribuível ao `type`, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-901">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="ed4d0-902">Se uma ou ambas as de `expression`. Tipo ou `type` é um tipo de valor anulável e os tipos de valor não anulável correspondentes são iguais para o tipo de argumento e o tipo de retorno do método de implementação, respectivamente, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-902">If one or both of `expression`.Type or `type` is a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="ed4d0-903">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-903">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-904">Se ambos os `expression`. Tipo e `type` são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-904">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="ed4d0-905">Caso contrário, o nó é eliminado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-905">Otherwise the node is lifted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-906">O exemplo de código a seguir mostra como criar uma expressão que representa uma operação de conversão de tipo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-906">The following code example shows how to create an expression that represents a type convertion operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#23)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-907">
            <paramref name="expression" /> ou <paramref name="type" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-907">
              <paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-908">Não há nenhum operador de conversão definido entre <paramref name="expression" />.Type e <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-908">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Convert(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Linq.Expressions.Expression * Type * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Convert (expression, type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-909">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-909">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="ed4d0-910">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-910">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-911">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-911">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-912">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de conversão para a qual o método de implementação é especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-912">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation for which the implementing method is specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-913">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-913">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" />, and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-914">O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-914">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="ed4d0-915">A propriedade <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> é `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-915">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="ed4d0-916">Se o nó é eliminado, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> é `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-916">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="ed4d0-917">Caso contrário, será `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-917">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-918">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-918">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-919">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-919">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-920">Se o método não é `null`, é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-920">If method is not `null`, it is the implementing method.</span></span> <span data-ttu-id="ed4d0-921">Ele deve representar um não-nulo, `static` (`Shared` no Visual Basic) método que aceita um argumento.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-921">It must represent a non-void, `static` (`Shared` in Visual Basic) method that takes one argument.</span></span>  
  
-   <span data-ttu-id="ed4d0-922">Caso contrário, se qualquer um dos `expression`. Tipo ou `type` é um tipo definido pelo usuário que define um operador de conversão implícita ou explícita, o <xref:System.Reflection.MethodInfo> que representa que o método de implementação do operador é.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-922">Otherwise, if either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-923">Caso contrário:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-923">Otherwise:</span></span>  
  
    -   <span data-ttu-id="ed4d0-924">Se ambos os `expression`. Tipo e `type` representam os tipos numéricos ou booleanos ou tipos de enumeração que permite valor nulo ou não anulável, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-924">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="ed4d0-925">Se qualquer um dos `expression`. Tipo ou `type` é um tipo de referência e uma conversão boxing explícita, conversão unboxing ou conversão de referência existe de `expression`. Digite para `type`, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-925">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-926">Com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-926">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-927">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-927">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-928">Se `expression`. O tipo é atribuível ao tipo de argumento do método de implementação e o tipo de retorno do método de implementação é atribuível ao `type`, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-928">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="ed4d0-929">Se um ou ambos os de `expression`. Tipo ou `type` são um tipo de valor anulável e os tipos de valor não anulável correspondentes são iguais para o tipo de argumento e o tipo de retorno do método de implementação, respectivamente, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-929">If either or both of `expression`.Type or `type` are a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="ed4d0-930">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-930">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-931">Se ambos os `expression`. Tipo e `type` são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-931">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="ed4d0-932">Caso contrário, o nó é eliminado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-932">Otherwise the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-933">
            <paramref name="expression" /> ou <paramref name="type" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-933">
              <paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-934">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente um argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-934">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-935">Não há nenhum operador de conversão definido entre <paramref name="expression" />.Type e <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-935">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span>
          </span>
          <span data-ttu-id="ed4d0-936">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-936">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-937">
            <paramref name="expression" />.Type não é atribuível ao tipo de argumento do método representado pelo <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-937">
              <paramref name="expression" />.Type is not assignable to the argument type of the method represented by <paramref name="method" />.</span>
          </span>
          <span data-ttu-id="ed4d0-938">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-938">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-939">O tipo de retorno do método representado por <paramref name="method" /> não é atribuível ao <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-939">The return type of the method represented by <paramref name="method" /> is not assignable to <paramref name="type" />.</span>
          </span>
          <span data-ttu-id="ed4d0-940">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-940">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-941">
            <paramref name="expression" />.Type ou <paramref name="type" /> é um tipo de valor que permite valor nulo e o tipo de valor que não permite valor nulo correspondente não é igual ao tipo de argumento ou ao tipo de retorno, respectivamente, do método representado por <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-941">
              <paramref name="expression" />.Type or <paramref name="type" /> is a nullable value type and the corresponding non-nullable value type does not equal the argument type or the return type, respectively, of the method represented by <paramref name="method" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="ed4d0-942">Foi encontrado mais de um método que corresponde à descrição de <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-942">More than one method that matches the <paramref name="method" /> description was found.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConvertChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-943">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de conversão que lança uma exceção se o tipo de destino está estourado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-943">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation that throws an exception if the target type is overflowed.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ConvertChecked(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member ConvertChecked : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.ConvertChecked (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-944">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-944">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="ed4d0-945">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-945">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-946">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de conversão que lança uma exceção se o tipo de destino está estourado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-946">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation that throws an exception if the target type is overflowed.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-947">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-947">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-948">O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-948">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="ed4d0-949">A propriedade <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> é `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-949">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="ed4d0-950">Se o nó é eliminado, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> é `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-950">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="ed4d0-951">Caso contrário, será `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-951">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-952">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-952">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-953">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-953">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-954">Se qualquer um dos `expression`. Tipo ou `type` é um tipo definido pelo usuário que define um operador de conversão implícita ou explícita, o <xref:System.Reflection.MethodInfo> que representa que o método de implementação do operador é.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-954">If either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-955">Caso contrário:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-955">Otherwise:</span></span>  
  
    -   <span data-ttu-id="ed4d0-956">Se ambos os `expression`. Tipo e `type` representam os tipos numéricos ou booleanos ou tipos de enumeração que permite valor nulo ou não anulável, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-956">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="ed4d0-957">Se qualquer um dos `expression`. Tipo ou `type` é um tipo de referência e uma conversão boxing explícita, conversão unboxing ou conversão de referência existe de `expression`. Digite para `type`, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-957">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-958">Com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-958">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-959">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-959">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-960">Se `expression`. O tipo é atribuível ao tipo de argumento do método de implementação e o tipo de retorno do método de implementação é atribuível ao `type`, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-960">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="ed4d0-961">Se um ou ambos os de `expression`. Tipo ou `type` são um tipo de valor anulável e os tipos de valor não anulável correspondentes são iguais para o tipo de argumento e o tipo de retorno do método de implementação, respectivamente, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-961">If either or both of `expression`.Type or `type` are a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="ed4d0-962">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-962">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-963">Se ambos os `expression`. Tipo e `type` são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-963">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="ed4d0-964">Caso contrário, o nó é eliminado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-964">Otherwise the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-965">
            <paramref name="expression" /> ou <paramref name="type" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-965">
              <paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-966">Não há nenhum operador de conversão definido entre <paramref name="expression" />.Type e <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-966">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ConvertChecked(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ConvertChecked : System.Linq.Expressions.Expression * Type * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.ConvertChecked (expression, type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-967">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-967">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="ed4d0-968">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-968">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-969">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-969">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-970">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de conversão que lança uma exceção se o tipo de destino está estourado e para o qual o método de implementação é especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-970">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation that throws an exception if the target type is overflowed and for which the implementing method is specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-971">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-971">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" />, and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-972">O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-972">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="ed4d0-973">A propriedade <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> é `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-973">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="ed4d0-974">Se o nó é eliminado, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> é `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-974">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="ed4d0-975">Caso contrário, será `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-975">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-976">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-976">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-977">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-977">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-978">Se o método não é `null`, é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-978">If method is not `null`, it is the implementing method.</span></span> <span data-ttu-id="ed4d0-979">Ele deve representar um não-nulo, `static` (`Shared` no Visual Basic) método que aceita um argumento.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-979">It must represent a non-void, `static` (`Shared` in Visual Basic) method that takes one argument.</span></span>  
  
-   <span data-ttu-id="ed4d0-980">Caso contrário, se qualquer um dos `expression`. Tipo ou `type` é um tipo definido pelo usuário que define um operador de conversão implícita ou explícita, o <xref:System.Reflection.MethodInfo> que representa que o método de implementação do operador é.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-980">Otherwise, if either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-981">Caso contrário:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-981">Otherwise:</span></span>  
  
    -   <span data-ttu-id="ed4d0-982">Se ambos os `expression`. Tipo e `type` representam os tipos numéricos ou booleanos ou tipos de enumeração que permite valor nulo ou não anulável, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-982">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="ed4d0-983">Se qualquer um dos `expression`. Tipo ou `type` é um tipo de referência e uma conversão boxing explícita, conversão unboxing ou conversão de referência existe de `expression`. Digite para `type`, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-983">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-984">Com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-984">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-985">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-985">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-986">Se `expression`. O tipo é atribuível ao tipo de argumento do método de implementação e o tipo de retorno do método de implementação é atribuível ao `type`, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-986">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="ed4d0-987">Se um ou ambos os de `expression`. Tipo ou `type` são um tipo de valor anulável e os tipos de valor não anulável correspondentes são iguais para o tipo de argumento e o tipo de retorno do método de implementação, respectivamente, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-987">If either or both of `expression`.Type or `type` are a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="ed4d0-988">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-988">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-989">Se ambos os `expression`. Tipo e `type` são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-989">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="ed4d0-990">Caso contrário, o nó é eliminado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-990">Otherwise the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-991">
            <paramref name="expression" /> ou <paramref name="type" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-991">
              <paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-992">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente um argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-992">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-993">Não há nenhum operador de conversão definido entre <paramref name="expression" />.Type e <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-993">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span>
          </span>
          <span data-ttu-id="ed4d0-994">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-994">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-995">
            <paramref name="expression" />.Type não é atribuível ao tipo de argumento do método representado pelo <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-995">
              <paramref name="expression" />.Type is not assignable to the argument type of the method represented by <paramref name="method" />.</span>
          </span>
          <span data-ttu-id="ed4d0-996">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-996">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-997">O tipo de retorno do método representado por <paramref name="method" /> não é atribuível ao <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-997">The return type of the method represented by <paramref name="method" /> is not assignable to <paramref name="type" />.</span>
          </span>
          <span data-ttu-id="ed4d0-998">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-998">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-999">
            <paramref name="expression" />.Type ou <paramref name="type" /> é um tipo de valor que permite valor nulo e o tipo de valor que não permite valor nulo correspondente não é igual ao tipo de argumento ou ao tipo de retorno, respectivamente, do método representado por <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-999">
              <paramref name="expression" />.Type or <paramref name="type" /> is a nullable value type and the corresponding non-nullable value type does not equal the argument type or the return type, respectively, of the method represented by <paramref name="method" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="ed4d0-1000">Foi encontrado mais de um método que corresponde à descrição de <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1000">More than one method that matches the <paramref name="method" /> description was found.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression DebugInfo (System.Linq.Expressions.SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression DebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document, int32 startLine, int32 startColumn, int32 endLine, int32 endColumn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DebugInfo (document As SymbolDocumentInfo, startLine As Integer, startColumn As Integer, endLine As Integer, endColumn As Integer) As DebugInfoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DebugInfoExpression ^ DebugInfo(System::Linq::Expressions::SymbolDocumentInfo ^ document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="F#" Value="static member DebugInfo : System.Linq.Expressions.SymbolDocumentInfo * int * int * int * int -&gt; System.Linq.Expressions.DebugInfoExpression" Usage="System.Linq.Expressions.Expression.DebugInfo (document, startLine, startColumn, endLine, endColumn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" />
        <Parameter Name="startLine" Type="System.Int32" />
        <Parameter Name="startColumn" Type="System.Int32" />
        <Parameter Name="endLine" Type="System.Int32" />
        <Parameter Name="endColumn" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="document">
          <span data-ttu-id="ed4d0-1001">O <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa o arquivo de origem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1001">The <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that represents the source file.</span>
          </span>
        </param>
        <param name="startLine">
          <span data-ttu-id="ed4d0-1002">A linha inicial deste <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1002">The start line of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span>
          </span>
          <span data-ttu-id="ed4d0-1003">Deve ser maior que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1003">Must be greater than 0.</span>
          </span>
        </param>
        <param name="startColumn">
          <span data-ttu-id="ed4d0-1004">A coluna inicial deste <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1004">The start column of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span>
          </span>
          <span data-ttu-id="ed4d0-1005">Deve ser maior que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1005">Must be greater than 0.</span>
          </span>
        </param>
        <param name="endLine">
          <span data-ttu-id="ed4d0-1006">A linha final deste <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1006">The end line of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span>
          </span>
          <span data-ttu-id="ed4d0-1007">Deve ser maior ou igual à linha inicial.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1007">Must be greater or equal than the start line.</span>
          </span>
        </param>
        <param name="endColumn">
          <span data-ttu-id="ed4d0-1008">A coluna final deste <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1008">The end column of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span>
          </span>
          <span data-ttu-id="ed4d0-1009">Se a linha final é a mesma que a linha inicial, ela deve ser maior ou igual à coluna inicial.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1009">If the end line is the same as the start line, it must be greater or equal than the start column.</span>
          </span>
          <span data-ttu-id="ed4d0-1010">Em qualquer caso, ela deve ser maior que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1010">In any case, must be greater than 0.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1011">Cria uma <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> com o intervalo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1011">Creates a <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> with the specified span.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1012">Uma instância de <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1012">An instance of <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Decrement">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-1013">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa o decremento da expressão em 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1013">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decrementing of the expression by 1.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Decrement(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Decrement : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Decrement expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-1014">Um <see cref="T:System.Linq.Expressions.Expression" /> para diminuir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1014">An <see cref="T:System.Linq.Expressions.Expression" /> to decrement.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1015">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa o decremento da expressão em 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1015">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decrementing of the expression by 1.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1016">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão decrementada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1016">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decremented expression.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1017">Esta expressão é funcional e não altera o valor do objeto passado a ele.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1017">This expression is functional and does not change the value of the object passed to it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-1018">O exemplo de código a seguir mostra como criar uma expressão que substracts 1 de um determinado valor.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1018">The following code example shows how to create an expression that substracts 1 from a given value.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#5)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Decrement(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Decrement : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Decrement (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-1019">Um <see cref="T:System.Linq.Expressions.Expression" /> para diminuir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1019">An <see cref="T:System.Linq.Expressions.Expression" /> to decrement.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-1020">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1020">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1021">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa o decremento da expressão em 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1021">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decrementing of the expression by 1.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1022">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão decrementada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1022">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decremented expression.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1023">Esta expressão é funcional e não altera o valor do objeto passado a ele.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1023">This expression is functional and does not change the value of the object passed to it.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Default (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Default(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Default(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DefaultExpression ^ Default(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Default : Type -&gt; System.Linq.Expressions.DefaultExpression" Usage="System.Linq.Expressions.Expression.Default type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ed4d0-1024">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1024">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1025">Cria um <see cref="T:System.Linq.Expressions.DefaultExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para o tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1025">Creates a <see cref="T:System.Linq.Expressions.DefaultExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to the specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1026">Um <see cref="T:System.Linq.Expressions.DefaultExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> e a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para o tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1026">A <see cref="T:System.Linq.Expressions.DefaultExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> and the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to the specified type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ed4d0-1027">O exemplo de código a seguir mostra como criar uma expressão que representa um valor padrão para um determinado tipo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1027">The following code example shows how to create an expression that represents a default vaule for a given type.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#6)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Divide">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-1028">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de divisão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1028">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic division operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Divide(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Divide (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-1029">Um <see cref="T:System.Linq.Expressions.Expression" /> para o qual definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1029">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-1030">Um <see cref="T:System.Linq.Expressions.Expression" /> para o qual definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1030">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1031">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de divisão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1031">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic division operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1032">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1032">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1033">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1033">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-1034">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1034">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-1035">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1035">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-1036">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1036">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-1037">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1037">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-1038">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1038">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-1039">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1039">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-1040">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1040">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-1041">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de divisão, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1041">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the division operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1042">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1042">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-1043">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1043">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-1044">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1044">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1045">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1045">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1046">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1046">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1047">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1047">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-1048">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1048">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-1049">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1049">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-1050">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1050">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1051">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1051">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1052">O tipo do nó é o tipo de resultado do operador de divisão predefinidos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1052">The type of the node is the result type of the predefined division operator.</span></span>  
  
-   <span data-ttu-id="ed4d0-1053">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1053">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-1054">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de divisão predefinidos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1054">The type of the node is the nullable type that corresponds to the result type of the predefined division operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-1055">O exemplo de código a seguir mostra como criar uma expressão que divide divide seu primeiro argumento pelo seu segundo argumento.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1055">The following code example shows how to create an expression that divides divides its first argument by its second argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#7)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-1056">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1056">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-1057">O operador de divisão não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1057">The division operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Divide(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Divide (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-1058">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1058">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-1059">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1059">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-1060">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1060">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1061">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de divisão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1061">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic division operation.</span>
          </span>
          <span data-ttu-id="ed4d0-1062">O método de implementação pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1062">The implementing method can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1063">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1063">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1064">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1064">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-1065">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1065">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-1066">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1066">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-1067">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1067">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-1068">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1068">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-1069">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1069">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-1070">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1070">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-1071">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1071">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-1072">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1072">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="ed4d0-1073">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de divisão, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1073">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the division operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1074">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1074">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-1075">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1075">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-1076">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1076">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1077">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1077">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1078">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1078">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1079">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1079">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-1080">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1080">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-1081">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1081">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-1082">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1082">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1083">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1083">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1084">O tipo do nó é o tipo de resultado do operador de divisão predefinidos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1084">The type of the node is the result type of the predefined division operator.</span></span>  
  
-   <span data-ttu-id="ed4d0-1085">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1085">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-1086">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de divisão predefinidos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1086">The type of the node is the nullable type that corresponds to the result type of the predefined division operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-1087">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1087">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-1088">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1088">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-1089">
            <paramref name="method" /> é <see langword="null" /> e o operador de divisão não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1089">
              <paramref name="method" /> is <see langword="null" /> and the division operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DivideAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-1090">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de divisão de adição que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1090">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member DivideAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.DivideAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-1091">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1091">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-1092">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1092">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1093">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de divisão de adição que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1093">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1094">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1094">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member DivideAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.DivideAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-1095">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1095">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-1096">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1096">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-1097">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1097">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1098">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de divisão de adição que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1098">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1099">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1099">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member DivideAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.DivideAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-1100">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1100">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-1101">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1101">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-1102">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1102">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="ed4d0-1103">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1103">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1104">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de divisão de adição que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1104">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1105">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1105">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dynamic">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-1106">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1106">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arguments As IEnumerable(Of Expression)) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="binder">
          <span data-ttu-id="ed4d0-1107">O associador de tempo de execução para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1107">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="ed4d0-1108">O tipo de resultado da expressão dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1108">The result type of the dynamic expression.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="ed4d0-1109">Os argumentos para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1109">The arguments to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1110">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1110">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1111">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem a <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1111">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1112">O <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propriedade do resultado será inferida dos tipos dos argumentos e o tipo de retorno especificado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1112">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">
          <span data-ttu-id="ed4d0-1113">O associador de tempo de execução para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1113">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="ed4d0-1114">O tipo de resultado da expressão dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1114">The result type of the dynamic expression.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="ed4d0-1115">O primeiro argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1115">The first argument to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1116">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1116">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1117">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem a <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1117">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1118">O <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propriedade do resultado será inferida dos tipos dos argumentos e o tipo de retorno especificado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1118">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, ParamArray arguments As Expression()) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="binder">
          <span data-ttu-id="ed4d0-1119">O associador de tempo de execução para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1119">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="ed4d0-1120">O tipo de resultado da expressão dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1120">The result type of the dynamic expression.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="ed4d0-1121">Os argumentos para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1121">The arguments to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1122">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1122">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1123">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem a <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1123">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1124">O <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propriedade do resultado será inferida dos tipos dos argumentos e o tipo de retorno especificado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1124">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">
          <span data-ttu-id="ed4d0-1125">O associador de tempo de execução para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1125">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="ed4d0-1126">O tipo de resultado da expressão dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1126">The result type of the dynamic expression.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="ed4d0-1127">O primeiro argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1127">The first argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="ed4d0-1128">O segundo argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1128">The second argument to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1129">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1129">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1130">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem a <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1130">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1131">O <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propriedade do resultado será inferida dos tipos dos argumentos e o tipo de retorno especificado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1131">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression, arg2 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">
          <span data-ttu-id="ed4d0-1132">O associador de tempo de execução para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1132">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="ed4d0-1133">O tipo de resultado da expressão dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1133">The result type of the dynamic expression.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="ed4d0-1134">O primeiro argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1134">The first argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="ed4d0-1135">O segundo argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1135">The second argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="ed4d0-1136">O terceiro argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1136">The third argument to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1137">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1137">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1138">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem a <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1138">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1139">O <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propriedade do resultado será inferida dos tipos dos argumentos e o tipo de retorno especificado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1139">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">
          <span data-ttu-id="ed4d0-1140">O associador de tempo de execução para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1140">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="ed4d0-1141">O tipo de resultado da expressão dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1141">The result type of the dynamic expression.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="ed4d0-1142">O primeiro argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1142">The first argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="ed4d0-1143">O segundo argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1143">The second argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="ed4d0-1144">O terceiro argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1144">The third argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg3">
          <span data-ttu-id="ed4d0-1145">O quarto argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1145">The fourth argument to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1146">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1146">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1147">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem a <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1147">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1148">O <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propriedade do resultado será inferida dos tipos dos argumentos e o tipo de retorno especificado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1148">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ElementInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-1149">Cria um <see cref="T:System.Linq.Expressions.ElementInit" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1149">Creates an <see cref="T:System.Linq.Expressions.ElementInit" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ElementInit (addMethod As MethodInfo, arguments As IEnumerable(Of Expression)) As ElementInit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ElementInit ^ ElementInit(System::Reflection::MethodInfo ^ addMethod, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member ElementInit : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.ElementInit" Usage="System.Linq.Expressions.Expression.ElementInit (addMethod, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="addMethod">
          <span data-ttu-id="ed4d0-1150">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1150">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> property equal to.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="ed4d0-1151">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> igual aos quais definir a propriedade <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1151">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to set the <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1152">Cria uma <see cref="T:System.Linq.Expressions.ElementInit" />, dado um <see cref="T:System.Collections.Generic.IEnumerable`1" /> como o segundo argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1152">Creates an <see cref="T:System.Linq.Expressions.ElementInit" />, given an <see cref="T:System.Collections.Generic.IEnumerable`1" /> as the second argument.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1153">Um <see cref="T:System.Linq.Expressions.ElementInit" /> que tem as propriedades <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> e <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1153">An <see cref="T:System.Linq.Expressions.ElementInit" /> that has the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> and <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1154">O `addMethod` parâmetro deve representar um método de instância nomeado "Add" (diferencia maiusculas de minúsculas).</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1154">The `addMethod` parameter must represent an instance method named "Add" (case insensitive).</span></span> <span data-ttu-id="ed4d0-1155">O método add deve ter o mesmo número de parâmetros que o número de elementos em `arguments`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1155">The add method must have the same number of parameters as the number of elements in `arguments`.</span></span> <span data-ttu-id="ed4d0-1156">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de cada elemento na `arguments` deve ser atribuível ao tipo do parâmetro correspondente do método add, possivelmente após *citando*.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1156">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element in `arguments` must be assignable to the type of the corresponding parameter of the add method, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ed4d0-1157">Um elemento será ser colocado entre aspas somente se o parâmetro do método correspondente é do tipo <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1157">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="ed4d0-1158">Delimitação significa que o elemento é encapsulado em um <xref:System.Linq.Expressions.ExpressionType.Quote> nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1158">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="ed4d0-1159">O nó resultante é um <xref:System.Linq.Expressions.UnaryExpression> cujos <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriedade é o elemento de `arguments`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1159">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-1160">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> método para criar um <xref:System.Linq.Expressions.ElementInit> que representa a chamada a <xref:System.Collections.Generic.Dictionary%602.Add%2A> método para inicializar um elemento de uma coleção de dicionário.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1160">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.ElementInit> that represents calling the <xref:System.Collections.Generic.Dictionary%602.Add%2A> method to initialize an element of a dictionary collection.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-1161">
            <paramref name="addMethod" /> ou <paramref name="arguments" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1161">
              <paramref name="addMethod" /> or <paramref name="arguments" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-1162">O método representado por <paramref name="addMethod" /> não é nomeado "Add" (não diferencia maiúsculas de minúsculas).</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1162">The method that <paramref name="addMethod" /> represents is not named "Add" (case insensitive).</span>
          </span>
          <span data-ttu-id="ed4d0-1163">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1163">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-1164">O método representado por <paramref name="addMethod" /> não é um método de instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1164">The method that <paramref name="addMethod" /> represents is not an instance method.</span>
          </span>
          <span data-ttu-id="ed4d0-1165">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1165">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-1166">
            <paramref name="arguments" /> não contém o mesmo número de elementos que o número de parâmetros para o método representado por <paramref name="addMethod" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1166">
              <paramref name="arguments" /> does not contain the same number of elements as the number of parameters for the method that <paramref name="addMethod" /> represents.</span>
          </span>
          <span data-ttu-id="ed4d0-1167">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1167">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-1168">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um ou mais elementos de <paramref name="arguments" /> não pode ser atribuída ao tipo do parâmetro correspondente do método representado por <paramref name="addMethod" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1168">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the method that <paramref name="addMethod" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ElementInit (addMethod As MethodInfo, ParamArray arguments As Expression()) As ElementInit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ElementInit ^ ElementInit(System::Reflection::MethodInfo ^ addMethod, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member ElementInit : System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.ElementInit" Usage="System.Linq.Expressions.Expression.ElementInit (addMethod, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="addMethod">
          <span data-ttu-id="ed4d0-1169">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1169">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> property equal to.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="ed4d0-1170">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> igual aos quais definir a propriedade <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1170">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to set the <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1171">Cria uma <see cref="T:System.Linq.Expressions.ElementInit" />, dada uma matriz de valores como o segundo argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1171">Creates an <see cref="T:System.Linq.Expressions.ElementInit" />, given an array of values as the second argument.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1172">Um <see cref="T:System.Linq.Expressions.ElementInit" /> que tem as propriedades <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> e <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1172">An <see cref="T:System.Linq.Expressions.ElementInit" /> that has the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> and <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1173">O `addMethod` parâmetro deve representar um método de instância nomeado "Add" (diferencia maiusculas de minúsculas).</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1173">The `addMethod` parameter must represent an instance method named "Add" (case insensitive).</span></span> <span data-ttu-id="ed4d0-1174">O método add deve ter o mesmo número de parâmetros que o número de elementos em `arguments`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1174">The add method must have the same number of parameters as the number of elements in `arguments`.</span></span> <span data-ttu-id="ed4d0-1175">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de cada elemento na `arguments` deve ser atribuível ao tipo do parâmetro correspondente do método add, possivelmente após *citando*.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1175">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element in `arguments` must be assignable to the type of the corresponding parameter of the add method, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ed4d0-1176">Um elemento será ser colocado entre aspas somente se o parâmetro do método correspondente é do tipo <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1176">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="ed4d0-1177">Delimitação significa que o elemento é encapsulado em um <xref:System.Linq.Expressions.ExpressionType.Quote> nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1177">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="ed4d0-1178">O nó resultante é um <xref:System.Linq.Expressions.UnaryExpression> cujos <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriedade é o elemento de `arguments`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1178">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-1179">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> método para criar um <xref:System.Linq.Expressions.ElementInit> que representa a chamada a <xref:System.Collections.Generic.Dictionary%602.Add%2A> método para inicializar um elemento de uma coleção de dicionário.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1179">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.ElementInit> that represents calling the <xref:System.Collections.Generic.Dictionary%602.Add%2A> method to initialize an element of a dictionary collection.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-1180">
            <paramref name="addMethod" /> ou <paramref name="arguments" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1180">
              <paramref name="addMethod" /> or <paramref name="arguments" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-1181">O método representado por addMethod não é nomeado "Add" (não diferencia maiúsculas de minúsculas).</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1181">The method that addMethod represents is not named "Add" (case insensitive).</span>
          </span>
          <span data-ttu-id="ed4d0-1182">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1182">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-1183">O método representado por addMethod não é um método de instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1183">The method that addMethod represents is not an instance method.</span>
          </span>
          <span data-ttu-id="ed4d0-1184">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1184">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-1185">arguments não contém o mesmo número de elementos que o número de parâmetros para o método representado por addMethod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1185">arguments does not contain the same number of elements as the number of parameters for the method that addMethod represents.</span>
          </span>
          <span data-ttu-id="ed4d0-1186">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1186">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-1187">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um ou mais elementos de <paramref name="arguments" /> não pode ser atribuída ao tipo do parâmetro correspondente do método representado por <paramref name="addMethod" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1187">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the method that <paramref name="addMethod" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Empty ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Empty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty () As DefaultExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DefaultExpression ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; System.Linq.Expressions.DefaultExpression" Usage="System.Linq.Expressions.Expression.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-1188">Cria uma expressão vazia com o tipo <see cref="T:System.Void" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1188">Creates an empty expression that has <see cref="T:System.Void" /> type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1189">O <see cref="T:System.Linq.Expressions.DefaultExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> e a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida como <see cref="T:System.Void" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1189">A <see cref="T:System.Linq.Expressions.DefaultExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> and the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <see cref="T:System.Void" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1190">Uma expressão vazia pode ser usada onde uma expressão é esperada, mas nenhuma ação é desejada.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1190">An empty expression can be used where an expression is expected but no action is desired.</span></span> <span data-ttu-id="ed4d0-1191">Por exemplo, você pode usar uma expressão vazia como a última expressão em uma expressão de bloco.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1191">For example, you can use an empty expression as the last expression in a block expression.</span></span> <span data-ttu-id="ed4d0-1192">Nesse caso, o valor de retorno da expressão no bloco é nulo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1192">In this case, the block expression's return value is void.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-1193">O exemplo de código a seguir mostra como criar uma expressão vazia e adicioná-lo a uma expressão de bloco.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1193">The following code example shows how to create an empty expression and add it to a block expression.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#31)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equal">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-1194">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de igualdade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1194">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an equality comparison.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equal (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Equal(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Equal : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Equal (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-1195">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1195">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-1196">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1196">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1197">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de igualdade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1197">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an equality comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1198">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1198">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1199">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1199">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-1200">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1200">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-1201">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1201">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="ed4d0-1202">Caso contrário, será `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1202">Otherwise, it is `false`.</span></span> <span data-ttu-id="ed4d0-1203">A propriedade <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> sempre é `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1203">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="ed4d0-1204">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1204">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-1205">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1205">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-1206">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1206">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-1207">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de igualdade, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1207">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the equality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1208">Caso contrário, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1208">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-1209">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1209">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-1210">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1210">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1211">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1211">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1212">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1212">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1213">Se as duas seguintes condições forem atendidas, o nó é elevado e o tipo de nó é <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1213">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="ed4d0-1214">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1214">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-1215">O tipo de retorno do método de implementação é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1215">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="ed4d0-1216">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1216">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1217">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1217">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1218">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1218">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="ed4d0-1219">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1219">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-1220">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1220">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-1221">O exemplo de código a seguir mostra como criar uma expressão que verifica se os valores dos dois argumentos forem iguais.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1221">The following code example shows how to create an expression that checks whether the values of its two arguments are equal.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#8)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-1222">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1222">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-1223">O operador de igualdade não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1223">The equality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equal (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Equal(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Equal : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Equal (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-1224">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1224">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-1225">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1225">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="liftToNull">
          <span data-ttu-id="ed4d0-1226">
            <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1226">
              <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-1227">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1227">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1228">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de igualdade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1228">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an equality comparison.</span>
          </span>
          <span data-ttu-id="ed4d0-1229">O método de implementação pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1229">The implementing method can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1230">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1230">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1231">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1231">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-1232">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1232">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-1233">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true` e o <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedade é igual a `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1233">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="ed4d0-1234">Caso contrário, eles são ambos `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1234">Otherwise, they are both `false`.</span></span> <span data-ttu-id="ed4d0-1235">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1235">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-1236">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1236">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-1237">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1237">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-1238">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1238">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1239">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de igualdade, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1239">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the equality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1240">Caso contrário, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1240">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-1241">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1241">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-1242">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1242">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1243">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1243">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1244">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1244">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1245">Se as duas seguintes condições forem atendidas, o nó é eliminado; Além disso, o tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1245">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="ed4d0-1246">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1246">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-1247">O tipo de retorno do método de implementação é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1247">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="ed4d0-1248">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1248">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1249">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1249">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1250">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1250">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="ed4d0-1251">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1251">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-1252">O tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1252">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-1253">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1253">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-1254">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1254">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-1255">
            <paramref name="method" /> é <see langword="null" /> e o operador de igualdade não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1255">
              <paramref name="method" /> is <see langword="null" /> and the equality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExclusiveOr">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-1256">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="XOR" /> bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1256">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="XOR" /> operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOr (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOr(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOr : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOr (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-1257">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1257">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-1258">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1258">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1259">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="XOR" /> bit a bit, usando <c>op_ExclusiveOr</c> para tipos definidos pelo usuário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1259">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="XOR" /> operation, using <c>op_ExclusiveOr</c> for user-defined types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1260">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1260">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1261">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1261">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-1262">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1262">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-1263">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1263">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-1264">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1264">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-1265">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1265">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-1266">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1266">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-1267">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1267">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-1268">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1268">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-1269">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o `XOR` operador, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1269">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the `XOR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1270">Caso contrário, se `left`. Tipo e `right`. Tipo são tipos de inteiros ou boolianos, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1270">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-1271">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1271">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-1272">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1272">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1273">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1273">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1274">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1274">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1275">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1275">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-1276">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1276">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-1277">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1277">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-1278">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1278">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1279">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1279">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1280">O tipo de nó é o tipo de resultado de predefinido `XOR` operador.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1280">The type of the node is the result type of the predefined `XOR` operator.</span></span>  
  
-   <span data-ttu-id="ed4d0-1281">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1281">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-1282">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado de predefinido `XOR` operador.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1282">The type of the node is the nullable type that corresponds to the result type of the predefined `XOR` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-1283">O exemplo de código a seguir mostra como criar uma expressão que representa a operação XOR lógica.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1283">The following code example shows how to create an expression that represents the logical XOR operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#9)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-1284">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1284">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-1285">O operador <see langword="XOR" /> não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1285">The <see langword="XOR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOr (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOr(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOr : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOr (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-1286">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1286">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-1287">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1287">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-1288">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1288">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1289">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="XOR" /> bit a bit, usando <c>op_ExclusiveOr</c> para tipos definidos pelo usuário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1289">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="XOR" /> operation, using <c>op_ExclusiveOr</c> for user-defined types.</span>
          </span>
          <span data-ttu-id="ed4d0-1290">O método de implementação pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1290">The implementing method can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1291">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1291">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1292">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1292">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-1293">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1293">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-1294">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1294">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-1295">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1295">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-1296">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1296">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-1297">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1297">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-1298">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1298">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-1299">As regras a seguir determinam o escolhido a implementação de método para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1299">The following rules determine the chosen implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-1300">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1300">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1301">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o `XOR` operador, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1301">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the `XOR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1302">Caso contrário, se `left`. Tipo e `right`. Tipo são tipos de inteiros ou boolianos, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1302">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-1303">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1303">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-1304">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1304">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1305">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1305">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1306">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1306">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1307">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1307">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-1308">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1308">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-1309">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1309">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-1310">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1310">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1311">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1311">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1312">O tipo de nó é o tipo de resultado de predefinido `XOR` operador.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1312">The type of the node is the result type of the predefined `XOR` operator.</span></span>  
  
-   <span data-ttu-id="ed4d0-1313">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1313">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-1314">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado de predefinido `XOR` operador.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1314">The type of the node is the nullable type that corresponds to the result type of the predefined `XOR` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-1315">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1315">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-1316">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1316">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-1317">
            <paramref name="method" /> é <see langword="null" /> e o operador <see langword="XOR" /> não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1317">
              <paramref name="method" /> is <see langword="null" /> and the <see langword="XOR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExclusiveOrAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-1318">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição XOR bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1318">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOrAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-1319">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1319">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-1320">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1320">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1321">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição XOR bit a bit, usando <c>op_ExclusiveOr</c> para tipos definidos pelo usuário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1321">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation, using <c>op_ExclusiveOr</c> for user-defined types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1322">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1322">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOrAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-1323">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1323">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-1324">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1324">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-1325">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1325">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1326">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição XOR bit a bit, usando <c>op_ExclusiveOr</c> para tipos definidos pelo usuário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1326">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation, using <c>op_ExclusiveOr</c> for user-defined types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1327">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1327">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOrAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-1328">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1328">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-1329">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1329">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-1330">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1330">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="ed4d0-1331">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1331">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1332">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição XOR bit a bit, usando <c>op_ExclusiveOr</c> para tipos definidos pelo usuário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1332">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation, using <c>op_ExclusiveOr</c> for user-defined types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1333">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1333">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Field">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-1334">Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a um campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1334">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, System::Reflection::FieldInfo ^ field);" />
      <MemberSignature Language="F#" Value="static member Field : System.Linq.Expressions.Expression * System.Reflection.FieldInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Field (expression, field)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-1335">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1335">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property equal to.</span>
          </span>
          <span data-ttu-id="ed4d0-1336">Para <see langword="static" /> (<see langword="Shared" /> no Visual Basic), <c>expression</c> deve ser <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1336">For <see langword="static" /> (<see langword="Shared" /> in Visual Basic), <c>expression</c> must be <see langword="null" />.</span>
          </span>
        </param>
        <param name="field">
          <span data-ttu-id="ed4d0-1337">O <see cref="T:System.Reflection.FieldInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> propriedade será definida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1337">The <see cref="T:System.Reflection.FieldInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1338">Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a um campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1338">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1339">Um <see cref="T:System.Linq.Expressions.MemberExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> e <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1339">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> and the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> and <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1340">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.MemberExpression> é igual ao <xref:System.Reflection.FieldInfo.FieldType%2A> propriedade `field`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1340">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.FieldInfo.FieldType%2A> property of `field`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-1341">
            <paramref name="field" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1341">
              <paramref name="field" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ed4d0-1342">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1342">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-1343">O campo representado por <paramref name="field" /> não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) e <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1343">The field represented by <paramref name="field" /> is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic) and <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-1344">
            <paramref name="expression" />.Type não pode ser atribuído ao tipo declarativo do campo representado por <paramref name="field" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1344">
              <paramref name="expression" />.Type is not assignable to the declaring type of the field represented by <paramref name="field" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, System::String ^ fieldName);" />
      <MemberSignature Language="F#" Value="static member Field : System.Linq.Expressions.Expression * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Field (expression, fieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-1345">Um <see cref="T:System.Linq.Expressions.Expression" /> cujo <see cref="P:System.Linq.Expressions.Expression.Type" /> contém um campo chamado <c>fieldName</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1345">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> contains a field named <c>fieldName</c>.</span>
          </span>
          <span data-ttu-id="ed4d0-1346">Pode ser nulo para campos estáticos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1346">This can be null for static fields.</span>
          </span>
        </param>
        <param name="fieldName">
          <span data-ttu-id="ed4d0-1347">O nome de um campo a ser acessado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1347">The name of a field to be accessed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1348">Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a um campo dado o nome do campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1348">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field given the name of the field.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1349">Um <see cref="T:System.Linq.Expressions.MemberExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> definida como <paramref name="expression" /> e a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> definida como o <see cref="T:System.Reflection.FieldInfo" /> que representa o campo indicado por <paramref name="fieldName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1349">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" />, and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.FieldInfo" /> that represents the field denoted by <paramref name="fieldName" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1350">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.MemberExpression> é igual ao <xref:System.Reflection.FieldInfo.FieldType%2A> propriedade o <xref:System.Reflection.FieldInfo> que representa o campo indicado por `fieldName`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1350">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.FieldInfo.FieldType%2A> property of the <xref:System.Reflection.FieldInfo> that represents the field denoted by `fieldName`.</span></span>  
  
 <span data-ttu-id="ed4d0-1351">Este método pesquisa `expression`. Tipo e seus tipos base para um campo que tem o nome `fieldName`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1351">This method searches `expression`.Type and its base types for a field that has the name `fieldName`.</span></span> <span data-ttu-id="ed4d0-1352">Campos públicos terá preferência em relação aos campos não públicos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1352">Public fields are given preference over non-public fields.</span></span> <span data-ttu-id="ed4d0-1353">Se um campo correspondente for encontrado, esse método passa `expression` e o <xref:System.Reflection.FieldInfo> que representa o campo para <xref:System.Linq.Expressions.Expression.Field%2A>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1353">If a matching field is found, this method passes `expression` and the <xref:System.Reflection.FieldInfo> that represents that field to <xref:System.Linq.Expressions.Expression.Field%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-1354">O exemplo de código a seguir mostra como criar uma expressão que representa o acesso a um campo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1354">The following code example shows how to create an expression that represents accessing a field.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#37)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#37)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-1355">
            <paramref name="expression" /> ou <paramref name="fieldName" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1355">
              <paramref name="expression" /> or <paramref name="fieldName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-1356">Nenhum campo nomeado <paramref name="fieldName" /> é definido no tipo <paramref name="expression" /> ou em seus tipos base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1356">No field named <paramref name="fieldName" /> is defined in <paramref name="expression" />.Type or its base types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, Type type, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Type type, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::String ^ fieldName);" />
      <MemberSignature Language="F#" Value="static member Field : System.Linq.Expressions.Expression * Type * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Field (expression, type, fieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-1357">O objeto recipiente do campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1357">The containing object of the field.</span>
          </span>
          <span data-ttu-id="ed4d0-1358">Pode ser nulo para campos estáticos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1358">This can be null for static fields.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="ed4d0-1359">O <see cref="P:System.Linq.Expressions.Expression.Type" /> que contém o campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1359">The <see cref="P:System.Linq.Expressions.Expression.Type" /> that contains the field.</span>
          </span>
        </param>
        <param name="fieldName">
          <span data-ttu-id="ed4d0-1360">O campo a ser acessado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1360">The field to be accessed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1361">Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a um campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1361">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1362">O <see cref="T:System.Linq.Expressions.MemberExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1362">The created <see cref="T:System.Linq.Expressions.MemberExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetActionType">
      <MemberSignature Language="C#" Value="public static Type GetActionType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetActionType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetActionType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetActionType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberSignature Language="F#" Value="static member GetActionType : Type[] -&gt; Type" Usage="System.Linq.Expressions.Expression.GetActionType typeArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs">
          <span data-ttu-id="ed4d0-1363">Uma matriz de um a dezesseis objetos <see cref="T:System.Type" /> que especifica os argumentos de tipo para o tipo de delegado <see langword="System.Action" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1363">An array of up to sixteen <see cref="T:System.Type" /> objects that specify the type arguments for the <see langword="System.Action" /> delegate type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1364">Cria um objeto <see cref="T:System.Type" /> que representa um tipo de delegado genérico <c>System.Action</c> que tem argumentos de tipo específicos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1364">Creates a <see cref="T:System.Type" /> object that represents a generic <c>System.Action</c> delegate type that has specific type arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1365">O tipo de um delegado <c>System.Action</c> que tem os argumentos de tipo especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1365">The type of a <c>System.Action</c> delegate that has the specified type arguments.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1366">Por exemplo, se os elementos de `typeArgs` representam os tipos `T1…Tn`, resultante <xref:System.Type> objeto representa o tipo de delegado construído `System.Action<T1,…,Tn>` em c# ou `System.Action(Of T1,…,Tn)` no Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1366">As an example, if the elements of `typeArgs` represent the types `T1…Tn`, the resulting <xref:System.Type> object represents the constructed delegate type `System.Action<T1,…,Tn>` in C# or `System.Action(Of T1,…,Tn)` in Visual Basic.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-1367">
            <paramref name="typeArgs" /> contém mais de dezesseis elementos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1367">
              <paramref name="typeArgs" /> contains more than sixteen elements.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-1368">
            <paramref name="typeArgs" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1368">
              <paramref name="typeArgs" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetDelegateType">
      <MemberSignature Language="C#" Value="public static Type GetDelegateType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetDelegateType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDelegateType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetDelegateType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberSignature Language="F#" Value="static member GetDelegateType : Type[] -&gt; Type" Usage="System.Linq.Expressions.Expression.GetDelegateType typeArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs">
          <span data-ttu-id="ed4d0-1369">Os argumentos de tipo do delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1369">The type arguments of the delegate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1370">Obtém um objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa um tipo de delegado genérico <c>System.Func</c> ou <c>System.Action</c> que tem argumentos de tipo específicos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1370">Gets a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic <c>System.Func</c> or <c>System.Action</c> delegate type that has specific type arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1371">O tipo de delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1371">The delegate type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1372">O último argumento de tipo determina o tipo de retorno do delegado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1372">The last type argument determines the return type of the delegate.</span></span> <span data-ttu-id="ed4d0-1373">Se nenhuma ação ou Func é grande o suficiente, ele irá gerar um tipo de delegado personalizado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1373">If no Func or Action is large enough, it will generate a custom delegate type.</span></span>  
  
 <span data-ttu-id="ed4d0-1374">Assim como Func, o último argumento é o tipo de retorno.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1374">As with Func, the last argument is the return type.</span></span> <span data-ttu-id="ed4d0-1375">Ele pode ser definido como System. void para produzir uma ação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1375">It can be set to System.Void to produce an Action.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFuncType">
      <MemberSignature Language="C#" Value="public static Type GetFuncType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetFuncType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFuncType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetFuncType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberSignature Language="F#" Value="static member GetFuncType : Type[] -&gt; Type" Usage="System.Linq.Expressions.Expression.GetFuncType typeArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs">
          <span data-ttu-id="ed4d0-1376">Uma matriz de um a dezessete objetos <see cref="T:System.Type" /> que especifica os argumentos de tipo para o tipo de delegado <see langword="System.Func" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1376">An array of one to seventeen <see cref="T:System.Type" /> objects that specify the type arguments for the <see langword="System.Func" /> delegate type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1377">Cria um objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa um tipo de delegado genérico <c>System.Func</c>, que tem argumentos de tipo específicos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1377">Creates a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic <c>System.Func</c> delegate type that has specific type arguments.</span>
          </span>
          <span data-ttu-id="ed4d0-1378">O último argumento de tipo especifica o tipo de retorno do delegado criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1378">The last type argument specifies the return type of the created delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1379">O tipo de um delegado <c>System.Func</c> que tem os argumentos de tipo especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1379">The type of a <c>System.Func</c> delegate that has the specified type arguments.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1380">`typeArgs` deve conter pelo menos um e no máximo dezessete elementos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1380">`typeArgs` must contain at least one and at most seventeen elements.</span></span>  
  
 <span data-ttu-id="ed4d0-1381">Por exemplo, se os elementos de `typeArgs` representam os tipos `T1…Tn`, resultante <xref:System.Type> objeto representa o tipo de delegado construído `System.Func<T1,…,Tn>` em c# ou `System.Func(Of T1,…,Tn)` no Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1381">As an example, if the elements of `typeArgs` represent the types `T1…Tn`, the resulting <xref:System.Type> object represents the constructed delegate type `System.Func<T1,…,Tn>` in C# or `System.Func(Of T1,…,Tn)` in Visual Basic.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-1382">
            <paramref name="typeArgs" /> contém menos de um ou mais de dezessete elementos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1382">
              <paramref name="typeArgs" /> contains fewer than one or more than seventeen elements.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-1383">
            <paramref name="typeArgs" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1383">
              <paramref name="typeArgs" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Goto">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-1384">Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução "go to".</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1384">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Goto (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="ed4d0-1385">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1385">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1386">Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução "go to".</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1386">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1387">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para o valor especificado e um valor nulo a ser passado para o rótulo de destino após saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1387">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to the specified value, and a null value to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ed4d0-1388">O exemplo a seguir demonstra como criar uma expressão que contém um <xref:System.Linq.Expressions.GotoExpression> objeto.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1388">The following example demonstrates how to create an expression that contains a <xref:System.Linq.Expressions.GotoExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#45)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#45)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Goto (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="ed4d0-1389">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1389">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="ed4d0-1390">O valor que será passado para o rótulo associado ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1390">The value that will be passed to the associated label upon jumping.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1391">Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução "go to".</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1391">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement.</span>
          </span>
          <span data-ttu-id="ed4d0-1392">O valor passado para o rótulo no salto pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1392">The value passed to the label upon jumping can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1393">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" /> e <paramref name="value" /> a ser passado para o rótulo de destino ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1393">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="ed4d0-1394">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1394">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="ed4d0-1395">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1395">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1396">Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução "go to" com o tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1396">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement with the specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1397">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para o valor especificado, a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" /> e um valor nulo a serem passados para o rótulo de destino após saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1397">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to the specified value, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and a null value to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto (target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="ed4d0-1398">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1398">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="ed4d0-1399">O valor que será passado para o rótulo associado ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1399">The value that will be passed to the associated label upon jumping.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="ed4d0-1400">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1400">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1401">Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução "go to" com o tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1401">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement with the specified type.</span>
          </span>
          <span data-ttu-id="ed4d0-1402">O valor passado para o rótulo no salto pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1402">The value passed to the label upon jumping can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1403">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" />, a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" /> e <paramref name="value" /> a ser passado para o rótulo de destino ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1403">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-1404">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "maior que".</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1404">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than" numeric comparison.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member GreaterThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThan (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-1405">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1405">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-1406">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1406">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1407">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "maior que".</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1407">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than" numeric comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1408">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1408">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1409">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1409">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-1410">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1410">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-1411">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1411">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="ed4d0-1412">Caso contrário, será `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1412">Otherwise, it is `false`.</span></span> <span data-ttu-id="ed4d0-1413">A propriedade <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> sempre é `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1413">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="ed4d0-1414">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1414">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-1415">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1415">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-1416">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1416">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-1417">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1417">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-1418">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador "maior que", o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1418">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1419">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1419">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-1420">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1420">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-1421">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1421">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1422">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1422">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1423">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1423">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1424">Se as duas seguintes condições forem atendidas, o nó é elevado e o tipo de nó é <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1424">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="ed4d0-1425">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1425">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-1426">O tipo de retorno do método de implementação é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1426">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="ed4d0-1427">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1427">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1428">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1428">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1429">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1429">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="ed4d0-1430">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1430">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-1431">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1431">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-1432">O exemplo de código a seguir mostra como criar uma expressão que compara dois inteiros.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1432">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#10)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-1433">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1433">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-1434">O operador “maior que” não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1434">The "greater than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member GreaterThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThan (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-1435">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1435">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-1436">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1436">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="liftToNull">
          <span data-ttu-id="ed4d0-1437">
            <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1437">
              <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-1438">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1438">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1439">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "maior que".</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1439">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than" numeric comparison.</span>
          </span>
          <span data-ttu-id="ed4d0-1440">O método de implementação pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1440">The implementing method can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1441">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1441">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1442">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1442">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-1443">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1443">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-1444">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true` e o <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedade é igual a `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1444">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="ed4d0-1445">Caso contrário, eles são ambos `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1445">Otherwise, they are both `false`.</span></span> <span data-ttu-id="ed4d0-1446">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1446">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-1447">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1447">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-1448">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1448">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-1449">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1449">The following rules determine the implementing method for the operation :</span></span>  
  
-   <span data-ttu-id="ed4d0-1450">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1450">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1451">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador "maior que", o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1451">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1452">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1452">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-1453">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1453">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-1454">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1454">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1455">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1455">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1456">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1456">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1457">Se as duas seguintes condições forem atendidas, o nó é eliminado; Além disso, o tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1457">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="ed4d0-1458">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1458">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-1459">O tipo de retorno do método de implementação é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1459">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="ed4d0-1460">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1460">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1461">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1461">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1462">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1462">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="ed4d0-1463">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1463">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-1464">O tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1464">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-1465">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1465">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-1466">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1466">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-1467">
            <paramref name="method" /> é <see langword="null" /> e o operador "maior que" não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1467">
              <paramref name="method" /> is <see langword="null" /> and the "greater than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-1468">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "maior ou igual a".</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1468">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than or equal" numeric comparison.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThanOrEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-1469">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1469">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-1470">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1470">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1471">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "maior ou igual a".</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1471">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than or equal" numeric comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1472">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1472">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1473">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1473">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-1474">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1474">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-1475">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1475">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="ed4d0-1476">Caso contrário, será `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1476">Otherwise, it is `false`.</span></span> <span data-ttu-id="ed4d0-1477">A propriedade <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> sempre é `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1477">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="ed4d0-1478">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1478">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-1479">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1479">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-1480">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1480">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-1481">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1481">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-1482">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador "maior que ou igual", o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1482">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1483">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1483">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-1484">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1484">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-1485">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1485">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1486">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1486">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1487">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1487">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1488">Se as duas seguintes condições forem atendidas, o nó é elevado e o tipo de nó é <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1488">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="ed4d0-1489">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1489">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-1490">O tipo de retorno do método de implementação é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1490">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="ed4d0-1491">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1491">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1492">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1492">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1493">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1493">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="ed4d0-1494">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1494">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-1495">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1495">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-1496">O exemplo de código a seguir mostra como criar uma expressão que compara dois inteiros.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1496">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#11)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-1497">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1497">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-1498">O operador “maior ou igual a” não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1498">The "greater than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThanOrEqual (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-1499">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1499">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-1500">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1500">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="liftToNull">
          <span data-ttu-id="ed4d0-1501">
            <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1501">
              <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-1502">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1502">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1503">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "maior ou igual a".</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1503">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than or equal" numeric comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1504">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1504">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1505">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1505">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-1506">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1506">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-1507">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true` e o <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedade é igual a `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1507">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="ed4d0-1508">Caso contrário, eles são ambos `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1508">Otherwise, they are both `false`.</span></span> <span data-ttu-id="ed4d0-1509">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1509">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-1510">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1510">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-1511">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1511">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-1512">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1512">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-1513">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1513">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1514">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador "maior que ou igual", o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1514">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1515">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1515">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-1516">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1516">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-1517">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1517">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1518">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1518">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1519">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1519">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1520">Se as duas seguintes condições forem atendidas, o nó é eliminado; Além disso, o tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1520">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="ed4d0-1521">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1521">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-1522">O tipo de retorno do método de implementação é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1522">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="ed4d0-1523">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1523">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1524">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1524">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1525">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1525">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="ed4d0-1526">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1526">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-1527">O tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1527">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-1528">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1528">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-1529">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1529">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-1530">
            <paramref name="method" /> é <see langword="null" /> e o operador "maior ou igual a" não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1530">
              <paramref name="method" /> is <see langword="null" /> and the "greater than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IfThen">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThen (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThen(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IfThen (test As Expression, ifTrue As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ IfThen(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue);" />
      <MemberSignature Language="F#" Value="static member IfThen : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.IfThen (test, ifTrue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test">
          <span data-ttu-id="ed4d0-1531">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1531">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span>
          </span>
        </param>
        <param name="ifTrue">
          <span data-ttu-id="ed4d0-1532">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1532">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1533">Cria um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa um bloco condicional com uma instrução <see langword="if" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1533">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional block with an <see langword="if" /> statement.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1534">Um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e as propriedades <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> e <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> definidas como os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1534">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, properties set to the specified values.</span>
          </span>
          <span data-ttu-id="ed4d0-1535">A propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> foi definida como a expressão padrão e o tipo do <see cref="T:System.Linq.Expressions.ConditionalExpression" /> resultante retornado por esse método é <see cref="T:System.Void" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1535">The <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property is set to default expression and the type of the resulting <see cref="T:System.Linq.Expressions.ConditionalExpression" /> returned by this method is <see cref="T:System.Void" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ed4d0-1536">O exemplo de código a seguir mostra como criar uma expressão que representa um bloco condicional.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1536">The following code example shows how to create an expression that represents a conditional block.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#32)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IfThenElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThenElse (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThenElse(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IfThenElse (test As Expression, ifTrue As Expression, ifFalse As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ IfThenElse(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse);" />
      <MemberSignature Language="F#" Value="static member IfThenElse : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.IfThenElse (test, ifTrue, ifFalse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test">
          <span data-ttu-id="ed4d0-1537">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1537">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span>
          </span>
        </param>
        <param name="ifTrue">
          <span data-ttu-id="ed4d0-1538">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1538">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span>
          </span>
        </param>
        <param name="ifFalse">
          <span data-ttu-id="ed4d0-1539">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1539">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1540">Cria um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa um bloco condicional com as instruções <see langword="if" /> e <see langword="else" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1540">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional block with <see langword="if" /> and <see langword="else" /> statements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1541">Um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e as propriedades <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> e <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1541">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, and <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> properties set to the specified values.</span>
          </span>
          <span data-ttu-id="ed4d0-1542">O tipo de <see cref="T:System.Linq.Expressions.ConditionalExpression" /> resultante retornado por esse método é <see cref="T:System.Void" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1542">The type of the resulting <see cref="T:System.Linq.Expressions.ConditionalExpression" /> returned by this method is <see cref="T:System.Void" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ed4d0-1543">O exemplo de código a seguir mostra como criar uma expressão que representa um bloco condicional.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1543">The following code example shows how to create an expression that represents a conditional block.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#33)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Increment">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-1544">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa o incremento do valor da expressão em 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1544">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incrementing of the expression value by 1.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Increment(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Increment : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Increment expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-1545">Um <see cref="T:System.Linq.Expressions.Expression" /> a ser incrementado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1545">An <see cref="T:System.Linq.Expressions.Expression" /> to increment.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1546">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa o incremento do valor da expressão em 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1546">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incrementing of the expression value by 1.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1547">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão incrementada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1547">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incremented expression.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1548">Esta expressão é funcional e não altera o valor do objeto que é passado para ele.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1548">This expression is functional and does not change the value of the object that is passed to it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-1549">O exemplo de código a seguir mostra como criar uma expressão que representa uma operação de incremento.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1549">The following code example shows how to create an expression that represents an increment operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#24)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Increment(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Increment : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Increment (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-1550">Um <see cref="T:System.Linq.Expressions.Expression" /> a ser incrementado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1550">An <see cref="T:System.Linq.Expressions.Expression" /> to increment.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-1551">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1551">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1552">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa o incremento da expressão em 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1552">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incrementing of the expression by 1.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1553">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão incrementada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1553">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incremented expression.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1554">Esta expressão é funcional e não altera o valor do objeto que é passado para ele.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1554">This expression is functional and does not change the value of the object that is passed to it.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-1555">Cria um <see cref="T:System.Linq.Expressions.InvocationExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1555">Creates an <see cref="T:System.Linq.Expressions.InvocationExpression" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::InvocationExpression ^ Invoke(System::Linq::Expressions::Expression ^ expression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.InvocationExpression" Usage="System.Linq.Expressions.Expression.Invoke (expression, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-1556">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa a expressão de delegado ou lambda à qual aplicar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1556">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the delegate or lambda expression to be applied to.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="ed4d0-1557">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> que representam os argumentos aos quais a expressão de delegado ou lambda é aplicada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1557">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects that represent the arguments that the delegate or lambda expression is applied to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1558">Cria um <see cref="T:System.Linq.Expressions.InvocationExpression" /> que se aplica a uma expressão de delegado ou lambda para uma lista de expressões de argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1558">Creates an <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies a delegate or lambda expression to a list of argument expressions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1559">Um <see cref="T:System.Linq.Expressions.InvocationExpression" /> que se aplica à expressão de delegado ou lambda especificada para os argumentos fornecidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1559">An <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies the specified delegate or lambda expression to the provided arguments.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1560">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.InvocationExpression> representa o tipo de retorno do delegado que é representado pela `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1560">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> represents the return type of the delegate that is represented by `expression`.Type.</span></span>  
  
 <span data-ttu-id="ed4d0-1561">O <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> propriedade resultantes <xref:System.Linq.Expressions.InvocationExpression> está vazia se `arguments` é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1561">The <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="ed4d0-1562">Caso contrário, ele contém os mesmos elementos `arguments` , exceto que alguns deles <xref:System.Linq.Expressions.Expression> objetos podem estar *entre aspas*.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1562">Otherwise, it contains the same elements as `arguments` except that some of these <xref:System.Linq.Expressions.Expression> objects may be *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ed4d0-1563">Um elemento será ser colocado entre aspas somente se o parâmetro correspondente ao delegado representado por `expression` é do tipo <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1563">An element will be quoted only if the corresponding parameter of the delegate represented by `expression` is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="ed4d0-1564">Delimitação significa que o elemento é encapsulado em um <xref:System.Linq.Expressions.ExpressionType.Quote> nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1564">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="ed4d0-1565">O nó resultante é um <xref:System.Linq.Expressions.UnaryExpression> cujos <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriedade é o elemento de `arguments`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1565">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-1566">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> método para criar um <xref:System.Linq.Expressions.InvocationExpression> que representa a invocação de uma expressão lambda com argumentos especificados.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1566">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.InvocationExpression> that represents the invocation of a lambda expression with specified arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-1567">
            <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1567">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-1568">
            <paramref name="expression" />.Type não representa um tipo de delegado nem um <see cref="T:System.Linq.Expressions.Expression`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1568">
              <paramref name="expression" />.Type does not represent a delegate type or an <see cref="T:System.Linq.Expressions.Expression`1" />.</span>
          </span>
          <span data-ttu-id="ed4d0-1569">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1569">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-1570">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="arguments" /> não é atribuível ao tipo de parâmetro correspondente ao delegado representado por <paramref name="expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1570">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the delegate represented by <paramref name="expression" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-1571">
            <paramref name="arguments" /> não contém o mesmo número de elementos da lista de parâmetros para o delegado representado por <paramref name="expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1571">
              <paramref name="arguments" /> does not contain the same number of elements as the list of parameters for the delegate represented by <paramref name="expression" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::InvocationExpression ^ Invoke(System::Linq::Expressions::Expression ^ expression, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.InvocationExpression" Usage="System.Linq.Expressions.Expression.Invoke (expression, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-1572">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa a expressão de delegado ou lambda a ser aplicada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1572">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the delegate or lambda expression to be applied.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="ed4d0-1573">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representam os argumentos aos quais que a expressão de delegado ou lambda são aplicados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1573">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that represent the arguments that the delegate or lambda expression is applied to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1574">Cria um <see cref="T:System.Linq.Expressions.InvocationExpression" /> que se aplica a uma expressão de delegado ou lambda para uma lista de expressões de argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1574">Creates an <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies a delegate or lambda expression to a list of argument expressions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1575">Um <see cref="T:System.Linq.Expressions.InvocationExpression" /> que se aplica à expressão de delegado ou lambda especificada para os argumentos fornecidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1575">An <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies the specified delegate or lambda expression to the provided arguments.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1576">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.InvocationExpression> representa o tipo de retorno do delegado que é representado pela `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1576">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> represents the return type of the delegate that is represented by `expression`.Type.</span></span>  
  
 <span data-ttu-id="ed4d0-1577">O <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> propriedade resultantes <xref:System.Linq.Expressions.InvocationExpression> está vazia se `arguments` é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1577">The <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="ed4d0-1578">Caso contrário, ele contém os mesmos elementos `arguments` , exceto que alguns deles <xref:System.Linq.Expressions.Expression> objetos podem estar *entre aspas*.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1578">Otherwise, it contains the same elements as `arguments` except that some of these <xref:System.Linq.Expressions.Expression> objects may be *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ed4d0-1579">Um elemento será ser colocado entre aspas somente se o parâmetro correspondente ao delegado representado por `expression` é do tipo <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1579">An element will be quoted only if the corresponding parameter of the delegate represented by `expression` is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="ed4d0-1580">Delimitação significa que o elemento é encapsulado em um <xref:System.Linq.Expressions.ExpressionType.Quote> nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1580">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="ed4d0-1581">O nó resultante é um <xref:System.Linq.Expressions.UnaryExpression> cujos <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriedade é o elemento de `arguments`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1581">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-1582">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> método para criar um <xref:System.Linq.Expressions.InvocationExpression> que representa a invocação de uma expressão lambda com argumentos especificados.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1582">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.InvocationExpression> that represents the invocation of a lambda expression with specified arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-1583">
            <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1583">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-1584">
            <paramref name="expression" />.Type não representa um tipo de delegado nem um <see cref="T:System.Linq.Expressions.Expression`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1584">
              <paramref name="expression" />.Type does not represent a delegate type or an <see cref="T:System.Linq.Expressions.Expression`1" />.</span>
          </span>
          <span data-ttu-id="ed4d0-1585">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1585">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-1586">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="arguments" /> não é atribuível ao tipo de parâmetro correspondente ao delegado representado por <paramref name="expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1586">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the delegate represented by <paramref name="expression" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-1587">
            <paramref name="arguments" /> não contém o mesmo número de elementos da lista de parâmetros para o delegado representado por <paramref name="expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1587">
              <paramref name="arguments" /> does not contain the same number of elements as the list of parameters for the delegate represented by <paramref name="expression" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsFalse">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-1588">Retorna se a expressão é avaliada como false.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1588">Returns whether the expression evaluates to false.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsFalse(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member IsFalse : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsFalse expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-1589">Um <see cref="T:System.Linq.Expressions.Expression" /> a ser avaliado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1589">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1590">Retorna se a expressão é avaliada como false.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1590">Returns whether the expression evaluates to false.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1591">Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1591">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsFalse(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member IsFalse : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsFalse (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-1592">Um <see cref="T:System.Linq.Expressions.Expression" /> a ser avaliado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1592">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-1593">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1593">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1594">Retorna se a expressão é avaliada como false.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1594">Returns whether the expression evaluates to false.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1595">Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1595">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsTrue">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-1596">Retorna se a expressão é avaliada como true.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1596">Returns whether the expression evaluates to true.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsTrue(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member IsTrue : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsTrue expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-1597">Um <see cref="T:System.Linq.Expressions.Expression" /> a ser avaliado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1597">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1598">Retorna se a expressão é avaliada como true.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1598">Returns whether the expression evaluates to true.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1599">Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1599">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsTrue(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member IsTrue : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsTrue (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-1600">Um <see cref="T:System.Linq.Expressions.Expression" /> a ser avaliado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1600">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-1601">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1601">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1602">Retorna se a expressão é avaliada como true.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1602">Returns whether the expression evaluates to true.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1603">Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1603">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Label">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-1604">Cria um <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa um demonstrativo de retorno.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1604">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label () As LabelTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label();" />
      <MemberSignature Language="F#" Value="static member Label : unit -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-1605">Cria um <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa um rótulo com um tipo void e sem nenhum nome.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1605">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with void type and no name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1606">O novo <see cref="T:System.Linq.Expressions.LabelTarget" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1606">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ed4d0-1607">O exemplo a seguir demonstra como criar uma expressão que contém um <xref:System.Linq.Expressions.LabelTarget> objeto.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1607">The following example demonstrates how to create an expression that contains a <xref:System.Linq.Expressions.LabelTarget> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (target As LabelTarget) As LabelExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelExpression ^ Label(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Label : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.LabelExpression" Usage="System.Linq.Expressions.Expression.Label target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="ed4d0-1608">O <see cref="T:System.Linq.Expressions.LabelTarget" /> ao qual esse <see cref="T:System.Linq.Expressions.LabelExpression" /> será associado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1608">The <see cref="T:System.Linq.Expressions.LabelTarget" /> which this <see cref="T:System.Linq.Expressions.LabelExpression" /> will be associated with.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1609">Cria um <see cref="T:System.Linq.Expressions.LabelExpression" /> que representa um rótulo com um valor padrão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1609">Creates a <see cref="T:System.Linq.Expressions.LabelExpression" /> representing a label without a default value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1610">Um <see cref="T:System.Linq.Expressions.LabelExpression" /> sem um valor padrão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1610">A <see cref="T:System.Linq.Expressions.LabelExpression" /> without a default value.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (name As String) As LabelTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Label : string -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="ed4d0-1611">O nome do rótulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1611">The name of the label.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1612">Cria um <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa um rótulo com um tipo void e o nome fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1612">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with void type and the given name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1613">O novo <see cref="T:System.Linq.Expressions.LabelTarget" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1613">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Label : Type -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ed4d0-1614">O tipo de valor que é passado ao saltar para o rótulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1614">The type of value that is passed when jumping to the label.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1615">Cria um <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa um rótulo com o tipo fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1615">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with the given type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1616">O novo <see cref="T:System.Linq.Expressions.LabelTarget" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1616">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ed4d0-1617">O exemplo a seguir demonstra como usar um <xref:System.Linq.Expressions.LabelTarget> objeto em uma expressão de loop.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1617">The following example demonstrates how to use a <xref:System.Linq.Expressions.LabelTarget> object in a loop expression.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (target As LabelTarget, defaultValue As Expression) As LabelExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelExpression ^ Label(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ defaultValue);" />
      <MemberSignature Language="F#" Value="static member Label : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.LabelExpression" Usage="System.Linq.Expressions.Expression.Label (target, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="defaultValue" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="ed4d0-1618">O <see cref="T:System.Linq.Expressions.LabelTarget" /> ao qual esse <see cref="T:System.Linq.Expressions.LabelExpression" /> será associado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1618">The <see cref="T:System.Linq.Expressions.LabelTarget" /> which this <see cref="T:System.Linq.Expressions.LabelExpression" /> will be associated with.</span>
          </span>
        </param>
        <param name="defaultValue">
          <span data-ttu-id="ed4d0-1619">O valor desse <see cref="T:System.Linq.Expressions.LabelExpression" /> quando o rótulo é acessado por meio de fluxo de controle normal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1619">The value of this <see cref="T:System.Linq.Expressions.LabelExpression" /> when the label is reached through regular control flow.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1620">Cria um <see cref="T:System.Linq.Expressions.LabelExpression" /> que representa um rótulo com o valor padrão fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1620">Creates a <see cref="T:System.Linq.Expressions.LabelExpression" /> representing a label with the given default value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1621">Um <see cref="T:System.Linq.Expressions.LabelExpression" /> com o valor padrão fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1621">A <see cref="T:System.Linq.Expressions.LabelExpression" /> with the given default value.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Label : Type * string -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ed4d0-1622">O tipo de valor que é passado ao saltar para o rótulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1622">The type of value that is passed when jumping to the label.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="ed4d0-1623">O nome do rótulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1623">The name of the label.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1624">Cria um <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa um rótulo com o tipo e nome fornecidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1624">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with the given type and name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1625">O novo <see cref="T:System.Linq.Expressions.LabelTarget" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1625">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Lambda">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-1626">Uma árvore de expressão que representa uma expressão lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1626">Creates an expression tree that represents a lambda expression.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="ed4d0-1627">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1627">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="ed4d0-1628">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1628">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1629">Cria uma LambdaExpression criando primeiro um tipo delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1629">Creates a LambdaExpression by first constructing a delegate type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1630">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1630">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="ed4d0-1631">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1631">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="ed4d0-1632">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1632">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1633">Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> criando primeiro um tipo delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1633">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> by first constructing a delegate type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1634">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1634">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1635">O `parameters` parâmetro não deve ter mais de dezesseis elementos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1635">The `parameters` parameter must not have more than sixteen elements.</span></span>  
  
 <span data-ttu-id="ed4d0-1636">Os elementos de `parameters` deve ser igual às expressões de parâmetro na referência `body`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1636">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="ed4d0-1637">Este método constrói um tipo de delegado apropriado de uma da `System.Func` delegados genéricos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1637">This method constructs an appropriate delegate type from one of the `System.Func` generic delegates.</span></span> <span data-ttu-id="ed4d0-1638">Ele passa o tipo de delegado para um dos <xref:System.Linq.Expressions.ExpressionType.Lambda> métodos de fábrica para criar um <xref:System.Linq.Expressions.LambdaExpression>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1638">It then passes the delegate type to one of the <xref:System.Linq.Expressions.ExpressionType.Lambda> factory methods to create a <xref:System.Linq.Expressions.LambdaExpression>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-1639">
            <paramref name="body" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1639">
              <paramref name="body" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ed4d0-1640">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1640">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-1641">Um ou mais elementos de <paramref name="parameters" /> são <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1641">One or more elements of <paramref name="parameters" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-1642">
            <paramref name="parameters" /> contém mais de dezesseis elementos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1642">
              <paramref name="parameters" /> contains more than sixteen elements.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="ed4d0-1643">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1643">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="tailCall">
          <span data-ttu-id="ed4d0-1644">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1644">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="ed4d0-1645">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1645">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1646">Cria uma LambdaExpression criando primeiro um tipo delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1646">Creates a LambdaExpression by first constructing a delegate type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1647">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1647">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="ed4d0-1648">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1648">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="tailCall">
          <span data-ttu-id="ed4d0-1649">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1649">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="ed4d0-1650">Uma matriz que contém os objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1650">An array that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1651">Cria uma LambdaExpression criando primeiro um tipo delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1651">Creates a LambdaExpression by first constructing a delegate type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1652">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1652">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, name, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="ed4d0-1653">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1653">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="ed4d0-1654">O nome para o lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1654">The name for the lambda.</span>
          </span>
          <span data-ttu-id="ed4d0-1655">Usada para emitir informações de depuração.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1655">Used for emitting debug information.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="ed4d0-1656">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1656">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1657">Cria uma LambdaExpression criando primeiro um tipo delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1657">Creates a LambdaExpression by first constructing a delegate type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1658">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1658">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="ed4d0-1659">Um <see cref="T:System.Type" /> que representa uma assinatura de delegado para lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1659">A <see cref="T:System.Type" /> that represents a delegate signature for the lambda.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="ed4d0-1660">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1660">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="ed4d0-1661">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1661">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1662">Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> criando primeiro um tipo delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1662">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> by first constructing a delegate type.</span>
          </span>
          <span data-ttu-id="ed4d0-1663">Ele pode ser usado quando o tipo de delegado não é conhecido em tempo de compilação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1663">It can be used when the delegate type is not known at compile time.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1664">Um objeto que representa uma expressão lambda que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1664">An object that represents a lambda expression which has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1665">O objeto que é retornado por essa função é do tipo <xref:System.Linq.Expressions.Expression%601>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1665">The object that is returned from this function is of type <xref:System.Linq.Expressions.Expression%601>.</span></span> <span data-ttu-id="ed4d0-1666">O <xref:System.Linq.Expressions.LambdaExpression> tipo é usado para representar o objeto retornado porque o tipo concreto da expressão lambda não é conhecido em tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1666">The <xref:System.Linq.Expressions.LambdaExpression> type is used to represent the returned object because the concrete type of the lambda expression is not known at compile time.</span></span>  
  
 <span data-ttu-id="ed4d0-1667">O número de parâmetros para o tipo de delegado representado por`delegateType` deve igual ao comprimento da `parameters`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1667">The number of parameters for the delegate type represented by`delegateType` must equal the length of `parameters`.</span></span>  
  
 <span data-ttu-id="ed4d0-1668">Os elementos de `parameters` deve ser igual às expressões de parâmetro na referência `body`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1668">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="ed4d0-1669">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do objeto resultante é igual a `delegateType`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1669">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object is equal to `delegateType`.</span></span> <span data-ttu-id="ed4d0-1670">Se `parameters` está `null`, o <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> propriedade do objeto resultante é uma coleção vazia.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1670">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-1671">O exemplo a seguir demonstra como criar uma expressão que representa uma expressão lambda que adiciona 1 para o argumento passado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1671">The following example demonstrates how to create an expression that represents a lambda expression that adds 1 to the passed argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#42)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-1672">
            <paramref name="delegateType" /> ou <paramref name="body" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1672">
              <paramref name="delegateType" /> or <paramref name="body" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ed4d0-1673">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1673">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-1674">Um ou mais elementos em <paramref name="parameters" /> são <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1674">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-1675">
            <paramref name="delegateType" /> não representa um tipo de delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1675">
              <paramref name="delegateType" /> does not represent a delegate type.</span>
          </span>
          <span data-ttu-id="ed4d0-1676">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1676">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-1677">
            <paramref name="body" />.Type representa um tipo que não é atribuível ao tipo de retorno do tipo de delegado representado por <paramref name="delegateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1677">
              <paramref name="body" />.Type represents a type that is not assignable to the return type of the delegate type represented by <paramref name="delegateType" />.</span>
          </span>
          <span data-ttu-id="ed4d0-1678">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1678">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-1679">
            <paramref name="parameters" /> não contém o mesmo número de elementos da lista de parâmetros para o tipo de delegado representado por <paramref name="delegateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1679">
              <paramref name="parameters" /> does not contain the same number of elements as the list of parameters for the delegate type represented by <paramref name="delegateType" />.</span>
          </span>
          <span data-ttu-id="ed4d0-1680">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1680">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-1681">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="parameters" /> não é atribuível do tipo de parâmetro correspondente do tipo de delegado representado por <paramref name="delegateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1681">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of the delegate type represented by <paramref name="delegateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="ed4d0-1682">Um <see cref="T:System.Type" /> que representa uma assinatura de delegado para lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1682">A <see cref="T:System.Type" /> that represents a delegate signature for the lambda.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="ed4d0-1683">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1683">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="ed4d0-1684">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1684">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1685">Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> criando primeiro um tipo delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1685">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> by first constructing a delegate type.</span>
          </span>
          <span data-ttu-id="ed4d0-1686">Ele pode ser usado quando o tipo de delegado não é conhecido em tempo de compilação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1686">It can be used when the delegate type is not known at compile time.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1687">Um objeto que representa uma expressão lambda que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1687">An object that represents a lambda expression which has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1688">O objeto que é retornado por essa função é do tipo <xref:System.Linq.Expressions.Expression%601>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1688">The object that is returned from this function is of type <xref:System.Linq.Expressions.Expression%601>.</span></span> <span data-ttu-id="ed4d0-1689">O <xref:System.Linq.Expressions.LambdaExpression> tipo é usado para representar o objeto retornado porque o tipo concreto da expressão lambda não é conhecido em tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1689">The <xref:System.Linq.Expressions.LambdaExpression> type is used to represent the returned object because the concrete type of the lambda expression is not known at compile time.</span></span>  
  
 <span data-ttu-id="ed4d0-1690">O número de parâmetros para o tipo de delegado representado por `delegateType` deve igual ao comprimento da `parameters`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1690">The number of parameters for the delegate type represented by `delegateType` must equal the length of `parameters`.</span></span>  
  
 <span data-ttu-id="ed4d0-1691">Os elementos de `parameters` deve ser igual às expressões de parâmetro na referência `body`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1691">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="ed4d0-1692">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do objeto resultante é igual a `delegateType`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1692">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object is equal to `delegateType`.</span></span> <span data-ttu-id="ed4d0-1693">Se `parameters` está `null`, o <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> propriedade do objeto resultante é uma coleção vazia.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1693">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-1694">
            <paramref name="delegateType" /> ou <paramref name="body" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1694">
              <paramref name="delegateType" /> or <paramref name="body" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ed4d0-1695">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1695">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-1696">Um ou mais elementos em <paramref name="parameters" /> são <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1696">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-1697">
            <paramref name="delegateType" /> não representa um tipo de delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1697">
              <paramref name="delegateType" /> does not represent a delegate type.</span>
          </span>
          <span data-ttu-id="ed4d0-1698">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1698">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-1699">
            <paramref name="body" />.Type representa um tipo que não é atribuível ao tipo de retorno do tipo de delegado representado por <paramref name="delegateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1699">
              <paramref name="body" />.Type represents a type that is not assignable to the return type of the delegate type represented by <paramref name="delegateType" />.</span>
          </span>
          <span data-ttu-id="ed4d0-1700">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1700">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-1701">
            <paramref name="parameters" /> não contém o mesmo número de elementos da lista de parâmetros para o tipo de delegado representado por <paramref name="delegateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1701">
              <paramref name="parameters" /> does not contain the same number of elements as the list of parameters for the delegate type represented by <paramref name="delegateType" />.</span>
          </span>
          <span data-ttu-id="ed4d0-1702">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1702">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-1703">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="parameters" /> não é atribuível do tipo de parâmetro correspondente do tipo de delegado representado por <paramref name="delegateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1703">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of the delegate type represented by <paramref name="delegateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, name, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="ed4d0-1704">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1704">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="ed4d0-1705">O nome para o lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1705">The name for the lambda.</span>
          </span>
          <span data-ttu-id="ed4d0-1706">Usada para emitir informações de depuração.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1706">Used for emitting debug information.</span>
          </span>
        </param>
        <param name="tailCall">
          <span data-ttu-id="ed4d0-1707">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1707">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="ed4d0-1708">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1708">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1709">Cria uma LambdaExpression criando primeiro um tipo delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1709">Creates a LambdaExpression by first constructing a delegate type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1710">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1710">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="ed4d0-1711">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa a assinatura de delegado para o lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1711">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="ed4d0-1712">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1712">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="tailCall">
          <span data-ttu-id="ed4d0-1713">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1713">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="ed4d0-1714">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1714">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1715">Cria uma LambdaExpression criando primeiro um tipo delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1715">Creates a LambdaExpression by first constructing a delegate type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1716">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1716">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * bool * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="ed4d0-1717">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa a assinatura de delegado para o lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1717">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="ed4d0-1718">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1718">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="tailCall">
          <span data-ttu-id="ed4d0-1719">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1719">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="ed4d0-1720">Uma matriz que contém os objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1720">An array that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1721">Cria uma LambdaExpression criando primeiro um tipo delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1721">Creates a LambdaExpression by first constructing a delegate type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1722">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1722">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * string * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, name, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="ed4d0-1723">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa a assinatura de delegado para o lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1723">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="ed4d0-1724">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1724">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="ed4d0-1725">O nome para o lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1725">The name for the lambda.</span>
          </span>
          <span data-ttu-id="ed4d0-1726">Usada para emitir informações de depuração.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1726">Used for emitting debug information.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="ed4d0-1727">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1727">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1728">Cria uma LambdaExpression criando primeiro um tipo delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1728">Creates a LambdaExpression by first constructing a delegate type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1729">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1729">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * string * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, name, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="ed4d0-1730">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa a assinatura de delegado para o lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1730">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="ed4d0-1731">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1731">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="ed4d0-1732">O nome para o lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1732">The name for the lambda.</span>
          </span>
          <span data-ttu-id="ed4d0-1733">Usada para emitir informações de depuração.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1733">Used for emitting debug information.</span>
          </span>
        </param>
        <param name="tailCall">
          <span data-ttu-id="ed4d0-1734">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1734">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="ed4d0-1735">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1735">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1736">Cria uma LambdaExpression criando primeiro um tipo delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1736">Creates a LambdaExpression by first constructing a delegate type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1737">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1737">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">
          <span data-ttu-id="ed4d0-1738">Um tipo de delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1738">A delegate type.</span>
          </span>
        </typeparam>
        <param name="body">
          <span data-ttu-id="ed4d0-1739">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1739">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="ed4d0-1740">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1740">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1741">Cria um <see cref="T:System.Linq.Expressions.Expression`1" /> no qual o tipo de delegado é conhecido em tempo de compilação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1741">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1742">Um <see cref="T:System.Linq.Expressions.Expression`1" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1742">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1743">O número de parâmetros para o tipo de delegado `TDelegate` deve ser igual ao número de elementos em `parameters`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1743">The number of parameters for the delegate type `TDelegate` must equal the number of elements in `parameters`.</span></span>  
  
 <span data-ttu-id="ed4d0-1744">Os elementos de `parameters` deve ser igual às expressões de parâmetro na referência `body`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1744">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="ed4d0-1745">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do objeto resultante representa o tipo `TDelegate`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1745">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object represents the type `TDelegate`.</span></span> <span data-ttu-id="ed4d0-1746">Se `parameters` está `null`, o <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> propriedade do objeto resultante é uma coleção vazia.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1746">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-1747">
            <paramref name="body" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1747">
              <paramref name="body" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ed4d0-1748">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1748">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-1749">Um ou mais elementos em <paramref name="parameters" /> são <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1749">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-1750">
            <paramref name="TDelegate" /> não é um tipo de delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1750">
              <paramref name="TDelegate" /> is not a delegate type.</span>
          </span>
          <span data-ttu-id="ed4d0-1751">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1751">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-1752">
            <paramref name="body" />.Type representa um tipo que não pode ser atribuído ao tipo de retorno de <paramref name="TDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1752">
              <paramref name="body" />.Type represents a type that is not assignable to the return type of <paramref name="TDelegate" />.</span>
          </span>
          <span data-ttu-id="ed4d0-1753">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1753">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-1754">
            <paramref name="parameters" /> não contém o mesmo número de elementos que a lista de parâmetros de <paramref name="TDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1754">
              <paramref name="parameters" /> does not contain the same number of elements as the list of parameters for <paramref name="TDelegate" />.</span>
          </span>
          <span data-ttu-id="ed4d0-1755">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1755">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-1756">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="parameters" /> não pode ser atribuída do tipo de parâmetro correspondente de <paramref name="TDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1756">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of <paramref name="TDelegate" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, ParamArray parameters As ParameterExpression()) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">
          <span data-ttu-id="ed4d0-1757">Um tipo de delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1757">A delegate type.</span>
          </span>
        </typeparam>
        <param name="body">
          <span data-ttu-id="ed4d0-1758">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1758">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="ed4d0-1759">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1759">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1760">Cria um <see cref="T:System.Linq.Expressions.Expression`1" /> no qual o tipo de delegado é conhecido em tempo de compilação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1760">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1761">Um <see cref="T:System.Linq.Expressions.Expression`1" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1761">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1762">O número de parâmetros para o tipo de delegado `TDelegate` deve ser igual ao número de elementos em `parameters`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1762">The number of parameters for the delegate type `TDelegate` must equal the number of elements in `parameters`.</span></span>  
  
 <span data-ttu-id="ed4d0-1763">Os elementos de `parameters` deve ser igual às expressões de parâmetro na referência`body`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1763">The elements of `parameters` must be reference equal to the parameter expressions in`body`.</span></span>  
  
 <span data-ttu-id="ed4d0-1764">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do objeto resultante representa o tipo `TDelegate`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1764">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object represents the type `TDelegate`.</span></span> <span data-ttu-id="ed4d0-1765">Se `parameters` está `null`, o <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> propriedade do objeto resultante é uma coleção vazia.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1765">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-1766">
            <paramref name="body" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1766">
              <paramref name="body" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ed4d0-1767">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1767">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-1768">Um ou mais elementos em <paramref name="parameters" /> são <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1768">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-1769">
            <paramref name="TDelegate" /> não é um tipo de delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1769">
              <paramref name="TDelegate" /> is not a delegate type.</span>
          </span>
          <span data-ttu-id="ed4d0-1770">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1770">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-1771">
            <paramref name="body" />.Type representa um tipo que não pode ser atribuído ao tipo de retorno de <paramref name="TDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1771">
              <paramref name="body" />.Type represents a type that is not assignable to the return type of <paramref name="TDelegate" />.</span>
          </span>
          <span data-ttu-id="ed4d0-1772">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1772">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-1773">
            <paramref name="parameters" /> não contém o mesmo número de elementos que a lista de parâmetros de <paramref name="TDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1773">
              <paramref name="parameters" /> does not contain the same number of elements as the list of parameters for <paramref name="TDelegate" />.</span>
          </span>
          <span data-ttu-id="ed4d0-1774">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1774">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-1775">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="parameters" /> não pode ser atribuída do tipo de parâmetro correspondente de <paramref name="TDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1775">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of <paramref name="TDelegate" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">
          <span data-ttu-id="ed4d0-1776">O tipo de delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1776">The delegate type.</span>
          </span>
        </typeparam>
        <param name="body">
          <span data-ttu-id="ed4d0-1777">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1777">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="tailCall">
          <span data-ttu-id="ed4d0-1778">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1778">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="ed4d0-1779">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1779">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1780">Cria um <see cref="T:System.Linq.Expressions.Expression`1" /> no qual o tipo de delegado é conhecido em tempo de compilação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1780">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1781">Um <see cref="T:System.Linq.Expressions.Expression`1" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1781">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">
          <span data-ttu-id="ed4d0-1782">O tipo de delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1782">The delegate type.</span>
          </span>
        </typeparam>
        <param name="body">
          <span data-ttu-id="ed4d0-1783">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1783">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="tailCall">
          <span data-ttu-id="ed4d0-1784">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1784">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="ed4d0-1785">Uma matriz que contém os objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1785">An array that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1786">Cria um <see cref="T:System.Linq.Expressions.Expression`1" /> no qual o tipo de delegado é conhecido em tempo de compilação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1786">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1787">Um <see cref="T:System.Linq.Expressions.Expression`1" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1787">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, name, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">
          <span data-ttu-id="ed4d0-1788">O tipo de delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1788">The delegate type.</span>
          </span>
        </typeparam>
        <param name="body">
          <span data-ttu-id="ed4d0-1789">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1789">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="ed4d0-1790">O nome do lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1790">The name of the lambda.</span>
          </span>
          <span data-ttu-id="ed4d0-1791">Usado para gerar informações de depuração.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1791">Used for generating debugging information.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="ed4d0-1792">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1792">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1793">Cria um <see cref="T:System.Linq.Expressions.Expression`1" /> no qual o tipo de delegado é conhecido em tempo de compilação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1793">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1794">Um <see cref="T:System.Linq.Expressions.Expression`1" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1794">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, name, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">
          <span data-ttu-id="ed4d0-1795">O tipo de delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1795">The delegate type.</span>
          </span>
        </typeparam>
        <param name="body">
          <span data-ttu-id="ed4d0-1796">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1796">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="ed4d0-1797">O nome do lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1797">The name of the lambda.</span>
          </span>
          <span data-ttu-id="ed4d0-1798">Usado para gerar informações de depuração.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1798">Used for generating debugging info.</span>
          </span>
        </param>
        <param name="tailCall">
          <span data-ttu-id="ed4d0-1799">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1799">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="ed4d0-1800">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1800">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1801">Cria um <see cref="T:System.Linq.Expressions.Expression`1" /> no qual o tipo de delegado é conhecido em tempo de compilação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1801">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1802">Um <see cref="T:System.Linq.Expressions.Expression`1" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1802">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LeftShift">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-1803">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de deslocamento à esquerda bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1803">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShift (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LeftShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShift (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-1804">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1804">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-1805">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1805">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1806">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de deslocamento à esquerda bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1806">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1807">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1807">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1808">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1808">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-1809">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1809">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-1810">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1810">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-1811">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1811">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-1812">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1812">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-1813">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1813">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-1814">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1814">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-1815">As seguintes regras de determinam o método de implementação selecionado para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1815">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-1816">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de deslocamento à esquerda, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1816">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the left-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1817">Caso contrário, se `left`. Tipo é um tipo integral (um dos <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, ou os tipos que permitem valor nulos correspondentes) e `right`. É do tipo <xref:System.Int32>, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1817">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-1818">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1818">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-1819">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1819">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1820">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1820">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1821">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1821">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1822">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1822">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-1823">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1823">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-1824">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1824">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-1825">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1825">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1826">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1826">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1827">O tipo do nó é o tipo de resultado do operador de deslocamento à esquerda predefinido.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1827">The type of the node is the result type of the predefined left-shift operator.</span></span>  
  
-   <span data-ttu-id="ed4d0-1828">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1828">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-1829">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de deslocamento à esquerda predefinido.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1829">The type of the node is the nullable type that corresponds to the result type of the predefined left-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-1830">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1830">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-1831">O operador de deslocamento à esquerda não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1831">The left-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShift (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LeftShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShift (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-1832">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1832">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-1833">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1833">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-1834">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1834">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1835">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de deslocamento à esquerda bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1835">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1836">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1836">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1837">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1837">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-1838">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1838">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-1839">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1839">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-1840">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1840">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-1841">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1841">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-1842">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1842">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-1843">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1843">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-1844">As seguintes regras de determinam o método de implementação selecionado para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1844">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-1845">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1845">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="ed4d0-1846">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de deslocamento à esquerda, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1846">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the left-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1847">Caso contrário, se `left`. Tipo é um tipo integral (um dos <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, ou os tipos que permitem valor nulos correspondentes) e `right`. É do tipo <xref:System.Int32>, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1847">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-1848">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1848">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-1849">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1849">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1850">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1850">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1851">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1851">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1852">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1852">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-1853">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1853">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-1854">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1854">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-1855">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1855">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1856">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1856">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1857">O tipo do nó é o tipo de resultado do operador de deslocamento à esquerda predefinido.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1857">The type of the node is the result type of the predefined left-shift operator.</span></span>  
  
-   <span data-ttu-id="ed4d0-1858">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1858">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-1859">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de deslocamento à esquerda predefinido.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1859">The type of the node is the nullable type that corresponds to the result type of the predefined left-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-1860">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1860">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-1861">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1861">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-1862">
            <paramref name="method" /> é <see langword="null" /> e o operador de deslocamento à esquerda não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1862">
              <paramref name="method" /> is <see langword="null" /> and the left-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LeftShiftAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-1863">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de deslocamento à esquerda bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1863">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LeftShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShiftAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-1864">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1864">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-1865">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1865">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1866">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de deslocamento à esquerda bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1866">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1867">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1867">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LeftShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShiftAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-1868">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1868">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-1869">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1869">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-1870">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1870">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1871">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de deslocamento à esquerda bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1871">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1872">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1872">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member LeftShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShiftAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-1873">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1873">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-1874">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1874">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-1875">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1875">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="ed4d0-1876">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1876">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1877">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de deslocamento à esquerda bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1877">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1878">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1878">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-1879">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "menor que".</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1879">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than" numeric comparison.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LessThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThan (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-1880">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1880">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-1881">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1881">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1882">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "menor que".</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1882">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than" numeric comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1883">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1883">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1884">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1884">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-1885">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1885">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-1886">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1886">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="ed4d0-1887">Caso contrário, será `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1887">Otherwise, it is `false`.</span></span> <span data-ttu-id="ed4d0-1888">A propriedade <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> sempre é `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1888">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="ed4d0-1889">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1889">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-1890">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1890">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-1891">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1891">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-1892">O método de implementação para a operação é escolhido com base nas seguintes regras:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1892">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="ed4d0-1893">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador "menor que" o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1893">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1894">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1894">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-1895">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1895">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-1896">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1896">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1897">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1897">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1898">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1898">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1899">Se as duas seguintes condições forem atendidas, o nó é elevado e o tipo de nó é <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1899">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="ed4d0-1900">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1900">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-1901">O tipo de retorno do método de implementação é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1901">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="ed4d0-1902">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1902">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1903">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1903">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1904">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1904">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="ed4d0-1905">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1905">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-1906">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1906">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-1907">O exemplo de código a seguir mostra como criar uma expressão que compara dois inteiros.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1907">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#25)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-1908">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1908">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-1909">O operador “menor que” não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1909">The "less than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LessThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThan (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-1910">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1910">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-1911">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1911">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="liftToNull">
          <span data-ttu-id="ed4d0-1912">
            <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1912">
              <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-1913">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1913">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1914">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "menor que".</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1914">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than" numeric comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1915">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1915">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1916">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1916">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-1917">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1917">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-1918">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true` e o <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedade é igual a `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1918">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="ed4d0-1919">Caso contrário, eles são ambos `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1919">Otherwise, they are both `false`.</span></span> <span data-ttu-id="ed4d0-1920">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1920">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-1921">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1921">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-1922">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1922">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-1923">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1923">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-1924">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1924">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1925">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador "menor que" o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1925">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1926">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1926">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-1927">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1927">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-1928">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1928">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1929">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1929">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1930">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1930">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1931">Se as duas seguintes condições forem atendidas, o nó é eliminado; Além disso, o tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1931">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="ed4d0-1932">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1932">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-1933">O tipo de retorno do método de implementação é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1933">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="ed4d0-1934">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1934">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1935">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1935">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1936">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1936">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="ed4d0-1937">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1937">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-1938">O tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1938">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-1939">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1939">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-1940">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1940">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-1941">
            <paramref name="method" /> é <see langword="null" /> e o operador "menor que" não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1941">
              <paramref name="method" /> is <see langword="null" /> and the "less than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-1942">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "menor ou igual a".</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1942">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a " less than or equal" numeric comparison.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThanOrEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-1943">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1943">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-1944">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1944">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1945">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "menor ou igual a".</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1945">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a " less than or equal" numeric comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1946">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1946">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1947">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1947">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-1948">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1948">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-1949">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1949">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="ed4d0-1950">Caso contrário, será `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1950">Otherwise, it is `false`.</span></span> <span data-ttu-id="ed4d0-1951">A propriedade <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> sempre é `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1951">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="ed4d0-1952">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1952">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-1953">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1953">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-1954">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1954">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-1955">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1955">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-1956">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador "menor ou igual", o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1956">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1957">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1957">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-1958">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1958">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-1959">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1959">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1960">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1960">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1961">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1961">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1962">Se as duas seguintes condições forem atendidas, o nó é elevado e o tipo de nó é <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1962">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="ed4d0-1963">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1963">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-1964">O tipo de retorno do método de implementação é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1964">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="ed4d0-1965">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1965">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1966">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1966">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1967">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1967">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="ed4d0-1968">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1968">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-1969">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1969">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-1970">O exemplo de código a seguir mostra como criar uma expressão que compara dois inteiros.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1970">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#26)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-1971">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1971">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-1972">O operador "menor ou igual a" não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1972">The "less than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThanOrEqual (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-1973">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1973">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-1974">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1974">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="liftToNull">
          <span data-ttu-id="ed4d0-1975">
            <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1975">
              <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-1976">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1976">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-1977">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "menor ou igual a".</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1977">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than or equal" numeric comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-1978">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-1978">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-1979">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1979">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-1980">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1980">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-1981">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true` e o <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedade é igual a `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1981">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="ed4d0-1982">Caso contrário, eles são ambos `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1982">Otherwise, they are both `false`.</span></span> <span data-ttu-id="ed4d0-1983">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1983">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-1984">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1984">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-1985">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1985">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-1986">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1986">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-1987">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1987">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1988">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador "menor ou igual", o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1988">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1989">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1989">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-1990">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1990">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-1991">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1991">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1992">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1992">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1993">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1993">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-1994">Se as duas seguintes condições forem atendidas, o nó é eliminado; Além disso, o tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1994">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="ed4d0-1995">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1995">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-1996">O tipo de retorno do método de implementação é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1996">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="ed4d0-1997">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1997">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-1998">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1998">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-1999">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-1999">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="ed4d0-2000">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2000">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-2001">O tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2001">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2002">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2002">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2003">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2003">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-2004">
            <paramref name="method" /> é <see langword="null" /> e o operador "menor ou igual a" não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2004">
              <paramref name="method" /> is <see langword="null" /> and the "less than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ListBind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-2005">Cria um objeto <see cref="T:System.Linq.Expressions.MemberListBinding" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2005">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (member As MemberInfo, initializers As IEnumerable(Of ElementInit)) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MemberInfo ^ member, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MemberInfo * seq&lt;System.Linq.Expressions.ElementInit&gt; -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (member, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="member">
          <span data-ttu-id="ed4d0-2006">Um <see cref="T:System.Reflection.MemberInfo" /> que representa um campo ou propriedade igual à qual definir a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2006">A <see cref="T:System.Reflection.MemberInfo" /> that represents a field or property to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="ed4d0-2007">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ElementInit" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2007">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2008">Cria um <see cref="T:System.Linq.Expressions.MemberListBinding" /> em que o membro é um campo ou propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2008">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> where the member is a field or property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2009">Um <see cref="T:System.Linq.Expressions.MemberListBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2009">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2010">
            <paramref name="member" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2010">
              <paramref name="member" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ed4d0-2011">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2011">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2012">Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2012">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2013">
            <paramref name="member" /> não representa um campo ou propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2013">
              <paramref name="member" /> does not represent a field or property.</span>
          </span>
          <span data-ttu-id="ed4d0-2014">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2014">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2015">O <see cref="P:System.Reflection.FieldInfo.FieldType" /> ou <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> do campo ou propriedade representada por <paramref name="member" /> não implementa <see cref="T:System.Collections.IEnumerable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2015">The <see cref="P:System.Reflection.FieldInfo.FieldType" /> or <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the field or property that <paramref name="member" /> represents does not implement <see cref="T:System.Collections.IEnumerable" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (member As MemberInfo, ParamArray initializers As ElementInit()) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MemberInfo ^ member, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MemberInfo * System.Linq.Expressions.ElementInit[] -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (member, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member">
          <span data-ttu-id="ed4d0-2016">Um <see cref="T:System.Reflection.MemberInfo" /> que representa um campo ou propriedade igual à qual definir a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2016">A <see cref="T:System.Reflection.MemberInfo" /> that represents a field or property to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="ed4d0-2017">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2017">An array of <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2018">Cria um <see cref="T:System.Linq.Expressions.MemberListBinding" /> em que o membro é um campo ou propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2018">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> where the member is a field or property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2019">Um <see cref="T:System.Linq.Expressions.MemberListBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2019">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2020">
            <paramref name="member" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2020">
              <paramref name="member" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ed4d0-2021">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2021">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2022">Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2022">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2023">
            <paramref name="member" /> não representa um campo ou propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2023">
              <paramref name="member" /> does not represent a field or property.</span>
          </span>
          <span data-ttu-id="ed4d0-2024">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2024">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2025">O <see cref="P:System.Reflection.FieldInfo.FieldType" /> ou <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> do campo ou propriedade representada por <paramref name="member" /> não implementa <see cref="T:System.Collections.IEnumerable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2025">The <see cref="P:System.Reflection.FieldInfo.FieldType" /> or <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the field or property that <paramref name="member" /> represents does not implement <see cref="T:System.Collections.IEnumerable" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (propertyAccessor As MethodInfo, initializers As IEnumerable(Of ElementInit)) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MethodInfo ^ propertyAccessor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.ElementInit&gt; -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (propertyAccessor, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor">
          <span data-ttu-id="ed4d0-2026">Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2026">A <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="ed4d0-2027">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ElementInit" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2027">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2028">Cria um <see cref="T:System.Linq.Expressions.MemberListBinding" /> com base em um método de acessador de propriedade especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2028">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> based on a specified property accessor method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2029">Um <see cref="T:System.Linq.Expressions.MemberListBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> definida para o <see cref="T:System.Reflection.MemberInfo" /> que representa a propriedade acessada em <paramref name="propertyAccessor" /> e <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> populada com os elementos de <paramref name="initializers" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2029">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.MemberInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> populated with the elements of <paramref name="initializers" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2030">
            <paramref name="propertyAccessor" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2030">
              <paramref name="propertyAccessor" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ed4d0-2031">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2031">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2032">Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2032">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2033">
            <paramref name="propertyAccessor" /> não representa um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2033">
              <paramref name="propertyAccessor" /> does not represent a property accessor method.</span>
          </span>
          <span data-ttu-id="ed4d0-2034">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2034">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2035">O <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> da propriedade acessada pelo método representado por <paramref name="propertyAccessor" /> não implementa <see cref="T:System.Collections.IEnumerable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2035">The <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the property that the method represented by <paramref name="propertyAccessor" /> accesses does not implement <see cref="T:System.Collections.IEnumerable" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (propertyAccessor As MethodInfo, ParamArray initializers As ElementInit()) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MethodInfo ^ propertyAccessor, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MethodInfo * System.Linq.Expressions.ElementInit[] -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (propertyAccessor, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor">
          <span data-ttu-id="ed4d0-2036">Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2036">A <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="ed4d0-2037">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2037">An array of <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2038">Cria um objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> com base em um método de acessador de propriedade especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2038">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> object based on a specified property accessor method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2039">Um <see cref="T:System.Linq.Expressions.MemberListBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> definida para o <see cref="T:System.Reflection.MemberInfo" /> que representa a propriedade acessada em <paramref name="propertyAccessor" /> e <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> populada com os elementos de <paramref name="initializers" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2039">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.MemberInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> populated with the elements of <paramref name="initializers" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2040">
            <paramref name="propertyAccessor" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2040">
              <paramref name="propertyAccessor" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ed4d0-2041">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2041">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2042">Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2042">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2043">
            <paramref name="propertyAccessor" /> não representa um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2043">
              <paramref name="propertyAccessor" /> does not represent a property accessor method.</span>
          </span>
          <span data-ttu-id="ed4d0-2044">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2044">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2045">O <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> da propriedade acessada pelo método representado por <paramref name="propertyAccessor" /> não implementa <see cref="T:System.Collections.IEnumerable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2045">The <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the property that the method represented by <paramref name="propertyAccessor" /> accesses does not implement <see cref="T:System.Collections.IEnumerable" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ListInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-2046">Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2046">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * seq&lt;System.Linq.Expressions.ElementInit&gt; -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">
          <span data-ttu-id="ed4d0-2047">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2047">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="ed4d0-2048">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ElementInit" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2048">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2049">Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa objetos <see cref="T:System.Linq.Expressions.ElementInit" /> especificados para inicializar uma coleção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2049">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses specified <see cref="T:System.Linq.Expressions.ElementInit" /> objects to initialize a collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2050">Um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e as propriedades <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2050">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2051">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de `newExpression` deve representar um tipo que implementa <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2051">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="ed4d0-2052">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.ListInitExpression> é igual a `newExpression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2052">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-2053">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> método para criar um <xref:System.Linq.Expressions.ListInitExpression> que representa a inicialização de uma nova instância de dicionário com dois pares de chave-valor.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2053">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> method to create a <xref:System.Linq.Expressions.ListInitExpression> that represents the initialization of a new dictionary instance with two key-value pairs.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2054">
            <paramref name="newExpression" /> ou <paramref name="initializers" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2054">
              <paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ed4d0-2055">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2055">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2056">Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2056">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2057">
            <paramref name="newExpression" />.Type não implementa <see cref="T:System.Collections.IEnumerable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2057">
              <paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">
          <span data-ttu-id="ed4d0-2058">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2058">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="ed4d0-2059">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2059">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2060">Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa um método chamado "Add" para adicionar elementos a uma coleção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2060">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a method named "Add" to add elements to a collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2061">Uma <see cref="T:System.Linq.Expressions.ListInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2061">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2062">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de `newExpression` deve representar um tipo que implementa <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2062">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="ed4d0-2063">Para usar essa sobrecarga de <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Collections.Generic.IEnumerable%7BSystem.Linq.Expressions.Expression%7D%29>, `newExpression`. Tipo ou seu tipo base deve declarar um único método nomeado "Add" (diferencia maiusculas de minúsculas) que aceita exatamente um argumento.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2063">In order to use this overload of <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Collections.Generic.IEnumerable%7BSystem.Linq.Expressions.Expression%7D%29>, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="ed4d0-2064">O tipo do argumento deve ser atribuível do tipo representado pela <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do primeiro elemento de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2064">The type of the argument must be assignable from the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of the first element of `initializers`.</span></span>  
  
 <span data-ttu-id="ed4d0-2065">O <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> propriedade retornada <xref:System.Linq.Expressions.ListInitExpression> contém um elemento do tipo <xref:System.Linq.Expressions.ElementInit> para cada elemento da `initializers`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2065">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="ed4d0-2066">O <xref:System.Linq.Expressions.ElementInit.Arguments%2A> propriedade de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> é uma coleção de singleton que contém o elemento correspondente de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2066">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="ed4d0-2067">O <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> propriedade de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> representa o método add que foi descoberto no `newExpression`. Tipo ou seu tipo base.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2067">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> represents the add method that was discovered on `newExpression`.Type or its base type.</span></span>  
  
 <span data-ttu-id="ed4d0-2068">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.ListInitExpression> é igual a `newExpression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2068">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2069">
            <paramref name="newExpression" /> ou <paramref name="initializers" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2069">
              <paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ed4d0-2070">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2070">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2071">Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2071">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2072">
            <paramref name="newExpression" />.Type não implementa <see cref="T:System.Collections.IEnumerable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2072">
              <paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-2073">Não há nenhum método de instância nomeado "Add" (não diferencia maiúsculas de minúsculas) declarado em <paramref name="newExpression" />.Type ou no tipo base dele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2073">There is no instance method named "Add" (case insensitive) declared in <paramref name="newExpression" />.Type or its base type.</span>
          </span>
          <span data-ttu-id="ed4d0-2074">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2074">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2075">O método add no <paramref name="newExpression" />.Type ou no tipo base dele não aceita exatamente um argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2075">The add method on <paramref name="newExpression" />.Type or its base type does not take exactly one argument.</span>
          </span>
          <span data-ttu-id="ed4d0-2076">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2076">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2077">O tipo representado pela propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> do primeiro elemento de <paramref name="initializers" /> não é atribuível ao tipo de argumento do método add em <paramref name="newExpression" />.Type ou no tipo base dele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2077">The type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of the first element of <paramref name="initializers" /> is not assignable to the argument type of the add method on <paramref name="newExpression" />.Type or its base type.</span>
          </span>
          <span data-ttu-id="ed4d0-2078">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2078">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2079">Existe mais de um método compatível com o argumento nomeado "Add" (não diferencia maiúsculas de minúsculas) em <paramref name="newExpression" />.Type e/ou o tipo base dele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2079">More than one argument-compatible method named "Add" (case-insensitive) exists on <paramref name="newExpression" />.Type and/or its base type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Linq.Expressions.ElementInit[] -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">
          <span data-ttu-id="ed4d0-2080">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2080">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="ed4d0-2081">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2081">An array of <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2082">Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa objetos <see cref="T:System.Linq.Expressions.ElementInit" /> especificados para inicializar uma coleção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2082">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses specified <see cref="T:System.Linq.Expressions.ElementInit" /> objects to initialize a collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2083">Um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e as propriedades <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2083">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2084">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de `newExpression` deve representar um tipo que implementa <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2084">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="ed4d0-2085">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.ListInitExpression> é igual a `newExpression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2085">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-2086">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> método para criar um <xref:System.Linq.Expressions.ListInitExpression> que representa a inicialização de uma nova instância de dicionário com dois pares de chave-valor.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2086">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> method to create a <xref:System.Linq.Expressions.ListInitExpression> that represents the initialization of a new dictionary instance with two key-value pairs.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2087">
            <paramref name="newExpression" /> ou <paramref name="initializers" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2087">
              <paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ed4d0-2088">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2088">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2089">Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2089">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2090">
            <paramref name="newExpression" />.Type não implementa <see cref="T:System.Collections.IEnumerable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2090">
              <paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">
          <span data-ttu-id="ed4d0-2091">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2091">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="ed4d0-2092">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2092">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2093">Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa um método chamado "Add" para adicionar elementos a uma coleção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2093">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a method named "Add" to add elements to a collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2094">Uma <see cref="T:System.Linq.Expressions.ListInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2094">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2095">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de `newExpression` deve representar um tipo que implementa <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2095">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="ed4d0-2096">Para usar essa sobrecarga de <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.Expression%5B%5D%29>, `newExpression`. Tipo ou seu tipo base deve declarar um único método nomeado "Add" (diferencia maiusculas de minúsculas) que aceita exatamente um argumento.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2096">In order to use this overload of <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.Expression%5B%5D%29>, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="ed4d0-2097">O tipo do argumento deve ser atribuível do tipo representado pela <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do primeiro elemento de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2097">The type of the argument must be assignable from the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of the first element of `initializers`.</span></span>  
  
 <span data-ttu-id="ed4d0-2098">O <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> propriedade retornada <xref:System.Linq.Expressions.ListInitExpression> contém um elemento do tipo <xref:System.Linq.Expressions.ElementInit> para cada elemento da `initializers`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2098">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="ed4d0-2099">O <xref:System.Linq.Expressions.ElementInit.Arguments%2A> propriedade de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> é uma coleção de singleton que contém o elemento correspondente de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2099">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="ed4d0-2100">O <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> propriedade de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> representa o método add que foi descoberto no `newExpression`. Tipo ou seu tipo base.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2100">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> represents the add method that was discovered on `newExpression`.Type or its base type.</span></span>  
  
 <span data-ttu-id="ed4d0-2101">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.ListInitExpression> é igual a `newExpression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2101">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2102">
            <paramref name="newExpression" /> ou <paramref name="initializers" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2102">
              <paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ed4d0-2103">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2103">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2104">Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2104">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2105">
            <paramref name="newExpression" />.Type não implementa <see cref="T:System.Collections.IEnumerable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2105">
              <paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-2106">Não há nenhum método de instância nomeado "Add" (não diferencia maiúsculas de minúsculas) declarado em <paramref name="newExpression" />.Type ou no tipo base dele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2106">There is no instance method named "Add" (case insensitive) declared in <paramref name="newExpression" />.Type or its base type.</span>
          </span>
          <span data-ttu-id="ed4d0-2107">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2107">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2108">O método add no <paramref name="newExpression" />.Type ou no tipo base dele não aceita exatamente um argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2108">The add method on <paramref name="newExpression" />.Type or its base type does not take exactly one argument.</span>
          </span>
          <span data-ttu-id="ed4d0-2109">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2109">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2110">O tipo representado pela propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> do primeiro elemento de <paramref name="initializers" /> não é atribuível ao tipo de argumento do método add em <paramref name="newExpression" />.Type ou no tipo base dele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2110">The type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of the first element of <paramref name="initializers" /> is not assignable to the argument type of the add method on <paramref name="newExpression" />.Type or its base type.</span>
          </span>
          <span data-ttu-id="ed4d0-2111">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2111">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2112">Existe mais de um método compatível com o argumento nomeado "Add" (não diferencia maiúsculas de minúsculas) em <paramref name="newExpression" />.Type e/ou o tipo base dele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2112">More than one argument-compatible method named "Add" (case-insensitive) exists on <paramref name="newExpression" />.Type and/or its base type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Reflection::MethodInfo ^ addMethod, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, addMethod, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">
          <span data-ttu-id="ed4d0-2113">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2113">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span>
          </span>
        </param>
        <param name="addMethod">
          <span data-ttu-id="ed4d0-2114">Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método de instância nomeado "Add" (não diferencia maiúsculas de minúsculas), que adiciona um elemento a uma coleção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2114">A <see cref="T:System.Reflection.MethodInfo" /> that represents an instance method named "Add" (case insensitive), that adds an element to a collection.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="ed4d0-2115">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2115">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2116">Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa um método especificado para adicionar elementos a uma coleção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2116">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a specified method to add elements to a collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2117">Uma <see cref="T:System.Linq.Expressions.ListInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2117">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2118">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de `newExpression` deve representar um tipo que implementa <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2118">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="ed4d0-2119">Se `addMethod` está `null`, `newExpression`. Tipo ou seu tipo base deve declarar um único método nomeado "Add" (diferencia maiusculas de minúsculas) que aceita exatamente um argumento.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2119">If `addMethod` is `null`, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="ed4d0-2120">Se `addMethod` não é `null`, ele deve representar um método de instância nomeado "Add" (diferencia maiusculas de minúsculas) e que tenha exatamente um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2120">If `addMethod` is not `null`, it must represent an instance method named "Add" (case insensitive) that has exactly one parameter.</span></span> <span data-ttu-id="ed4d0-2121">O tipo representado pela <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de cada elemento da `initializers` deve ser atribuível ao tipo de argumento do método add.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2121">The type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must be assignable to the argument type of the add method.</span></span>  
  
 <span data-ttu-id="ed4d0-2122">O <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> propriedade retornada <xref:System.Linq.Expressions.ListInitExpression> contém um elemento do tipo <xref:System.Linq.Expressions.ElementInit> para cada elemento da `initializers`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2122">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="ed4d0-2123">O <xref:System.Linq.Expressions.ElementInit.Arguments%2A> propriedade de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> é uma coleção de singleton que contém o elemento correspondente de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2123">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="ed4d0-2124">O <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> propriedade de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> é igual a `addMethod`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2124">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is equal to `addMethod`.</span></span>  
  
 <span data-ttu-id="ed4d0-2125">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.ListInitExpression> é igual a `newExpression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2125">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2126">
            <paramref name="newExpression" /> ou <paramref name="initializers" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2126">
              <paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ed4d0-2127">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2127">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2128">Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2128">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2129">
            <paramref name="newExpression" />.Type não implementa <see cref="T:System.Collections.IEnumerable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2129">
              <paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span>
          </span>
          <span data-ttu-id="ed4d0-2130">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2130">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2131">
            <paramref name="addMethod" /> não é <see langword="null" /> e não representa um método de instância nomeado "Add" (não diferencia maiúsculas de minúsculas) que aceita exatamente um argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2131">
              <paramref name="addMethod" /> is not <see langword="null" /> and it does not represent an instance method named "Add" (case insensitive) that takes exactly one argument.</span>
          </span>
          <span data-ttu-id="ed4d0-2132">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2132">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2133">
            <paramref name="addMethod" /> não é <see langword="null" /> e o tipo representado pela propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um ou mais elementos de <paramref name="initializers" /> não pode ser atribuída ao tipo de argumento do método representado por <paramref name="addMethod" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2133">
              <paramref name="addMethod" /> is not <see langword="null" /> and the type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="initializers" /> is not assignable to the argument type of the method that <paramref name="addMethod" /> represents.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-2134">
            <paramref name="addMethod" /> é <see langword="null" /> e nenhum método de instância nomeado "Add" que aceita um argumento de tipo compatível existe no <paramref name="newExpression" />.Type ou no tipo base dele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2134">
              <paramref name="addMethod" /> is <see langword="null" /> and no instance method named "Add" that takes one type-compatible argument exists on <paramref name="newExpression" />.Type or its base type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Reflection::MethodInfo ^ addMethod, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, addMethod, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">
          <span data-ttu-id="ed4d0-2135">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2135">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span>
          </span>
        </param>
        <param name="addMethod">
          <span data-ttu-id="ed4d0-2136">Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método de instância que aceita um argumento, que adiciona um elemento a uma coleção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2136">A <see cref="T:System.Reflection.MethodInfo" /> that represents an instance method that takes one argument, that adds an element to a collection.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="ed4d0-2137">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2137">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2138">Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa um método especificado para adicionar elementos a uma coleção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2138">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a specified method to add elements to a collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2139">Uma <see cref="T:System.Linq.Expressions.ListInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2139">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2140">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de `newExpression` deve representar um tipo que implementa <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2140">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="ed4d0-2141">Se `addMethod` está `null`, `newExpression`. Tipo ou seu tipo base deve declarar um único método nomeado "Add" (diferencia maiusculas de minúsculas) que aceita exatamente um argumento.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2141">If `addMethod` is `null`, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="ed4d0-2142">Se `addMethod` não é `null`, ele deve representar um método de instância nomeado "Add" (diferencia maiusculas de minúsculas) e que tenha exatamente um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2142">If `addMethod` is not `null`, it must represent an instance method named "Add" (case insensitive) that has exactly one parameter.</span></span> <span data-ttu-id="ed4d0-2143">O tipo representado pela <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de cada elemento da `initializers` deve ser atribuível ao tipo de argumento do método add.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2143">The type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must be assignable to the argument type of the add method.</span></span>  
  
 <span data-ttu-id="ed4d0-2144">O <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> propriedade retornada <xref:System.Linq.Expressions.ListInitExpression> contém um elemento do tipo <xref:System.Linq.Expressions.ElementInit> para cada elemento da `initializers`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2144">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="ed4d0-2145">O <xref:System.Linq.Expressions.ElementInit.Arguments%2A> propriedade de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> é uma coleção de singleton que contém o elemento correspondente de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2145">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="ed4d0-2146">O <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> propriedade de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> é igual a `addMethod`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2146">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is equal to `addMethod`.</span></span>  
  
 <span data-ttu-id="ed4d0-2147">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.ListInitExpression> é igual a `newExpression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2147">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2148">
            <paramref name="newExpression" /> ou <paramref name="initializers" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2148">
              <paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ed4d0-2149">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2149">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2150">Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2150">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2151">
            <paramref name="newExpression" />.Type não implementa <see cref="T:System.Collections.IEnumerable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2151">
              <paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span>
          </span>
          <span data-ttu-id="ed4d0-2152">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2152">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2153">
            <paramref name="addMethod" /> não é <see langword="null" /> e não representa um método de instância nomeado "Add" (não diferencia maiúsculas de minúsculas) que aceita exatamente um argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2153">
              <paramref name="addMethod" /> is not <see langword="null" /> and it does not represent an instance method named "Add" (case insensitive) that takes exactly one argument.</span>
          </span>
          <span data-ttu-id="ed4d0-2154">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2154">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2155">
            <paramref name="addMethod" /> não é <see langword="null" /> e o tipo representado pela propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um ou mais elementos de <paramref name="initializers" /> não pode ser atribuída ao tipo de argumento do método representado por <paramref name="addMethod" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2155">
              <paramref name="addMethod" /> is not <see langword="null" /> and the type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="initializers" /> is not assignable to the argument type of the method that <paramref name="addMethod" /> represents.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-2156">
            <paramref name="addMethod" /> é <see langword="null" /> e nenhum método de instância nomeado "Add" que aceita um argumento de tipo compatível existe no <paramref name="newExpression" />.Type ou no tipo base dele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2156">
              <paramref name="addMethod" /> is <see langword="null" /> and no instance method named "Add" that takes one type-compatible argument exists on <paramref name="newExpression" />.Type or its base type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Loop">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-2157">Cria um <see cref="T:System.Linq.Expressions.LoopExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2157">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body);" />
      <MemberSignature Language="F#" Value="static member Loop : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.LoopExpression" Usage="System.Linq.Expressions.Expression.Loop body" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="ed4d0-2158">O corpo do loop.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2158">The body of the loop.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2159">Cria um <see cref="T:System.Linq.Expressions.LoopExpression" /> com o corpo fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2159">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" /> with the given body.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2160">O <see cref="T:System.Linq.Expressions.LoopExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2160">The created <see cref="T:System.Linq.Expressions.LoopExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression, break As LabelTarget) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::LabelTarget ^ break);" />
      <MemberSignature Language="F#" Value="static member Loop : System.Linq.Expressions.Expression * System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.LoopExpression" Usage="System.Linq.Expressions.Expression.Loop (body, break)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="ed4d0-2161">O corpo do loop.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2161">The body of the loop.</span>
          </span>
        </param>
        <param name="break">
          <span data-ttu-id="ed4d0-2162">O destino de interrupção usado pelo corpo do loop.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2162">The break target used by the loop body.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2163">Cria um <see cref="T:System.Linq.Expressions.LoopExpression" /> com o destino corpo e interrupção determinado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2163">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" /> with the given body and break target.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2164">O <see cref="T:System.Linq.Expressions.LoopExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2164">The created <see cref="T:System.Linq.Expressions.LoopExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ed4d0-2165">O exemplo a seguir demonstra como criar uma expressão de bloco que contém um <xref:System.Linq.Expressions.LoopExpression> objeto.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2165">The following example demonstrates how to create a block expression that contains a <xref:System.Linq.Expressions.LoopExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break, System.Linq.Expressions.LabelTarget continue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break, class System.Linq.Expressions.LabelTarget continue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression, break As LabelTarget, continue As LabelTarget) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::LabelTarget ^ break, System::Linq::Expressions::LabelTarget ^ continue);" />
      <MemberSignature Language="F#" Value="static member Loop : System.Linq.Expressions.Expression * System.Linq.Expressions.LabelTarget * System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.LoopExpression" Usage="System.Linq.Expressions.Expression.Loop (body, break, continue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="continue" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="ed4d0-2166">O corpo do loop.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2166">The body of the loop.</span>
          </span>
        </param>
        <param name="break">
          <span data-ttu-id="ed4d0-2167">O destino de interrupção usado pelo corpo do loop.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2167">The break target used by the loop body.</span>
          </span>
        </param>
        <param name="continue">
          <span data-ttu-id="ed4d0-2168">O destino continue usado pelo corpo do loop.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2168">The continue target used by the loop body.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2169">Cria um <see cref="T:System.Linq.Expressions.LoopExpression" /> com o corpo fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2169">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" /> with the given body.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2170">O <see cref="T:System.Linq.Expressions.LoopExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2170">The created <see cref="T:System.Linq.Expressions.LoopExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeBinary">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-2171">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> chamando o método de fábrica apropriado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2171">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> by calling the appropriate factory method.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MakeBinary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MakeBinary (binaryType, left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binaryType">
          <span data-ttu-id="ed4d0-2172">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica o tipo de operação binária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2172">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of binary operation.</span>
          </span>
        </param>
        <param name="left">
          <span data-ttu-id="ed4d0-2173">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando esquerdo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2173">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the left operand.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-2174">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando direito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2174">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the right operand.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2175">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" />, considerando os operandos esquerdos e direito, chamando um método de fábrica apropriado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2175">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />, given the left and right operands, by calling an appropriate factory method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2176">O <see cref="T:System.Linq.Expressions.BinaryExpression" /> que resulta de chamar o método de fábrica apropriado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2176">The <see cref="T:System.Linq.Expressions.BinaryExpression" /> that results from calling the appropriate factory method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2177">O `binaryType` parâmetro determina quais <xref:System.Linq.Expressions.BinaryExpression> chama esse método de método de fábrica.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2177">The `binaryType` parameter determines which <xref:System.Linq.Expressions.BinaryExpression> factory method this method calls.</span></span> <span data-ttu-id="ed4d0-2178">Por exemplo, se `binaryType` está <xref:System.Linq.Expressions.ExpressionType.Subtract>, este método invoca <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2178">For example, if `binaryType` is <xref:System.Linq.Expressions.ExpressionType.Subtract>, this method invokes <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-2179">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.MakeBinary%28System.Linq.Expressions.ExpressionType%2CSystem.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%29> método para criar um <xref:System.Linq.Expressions.BinaryExpression> que representa a subtração de um número de outro.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2179">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.MakeBinary%28System.Linq.Expressions.ExpressionType%2CSystem.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%29> method to create a <xref:System.Linq.Expressions.BinaryExpression> that represents the subtraction of one number from another.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#8)]
 [!code-vb[System.Linq.Expressions.Expression#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2180">
            <paramref name="binaryType" /> não corresponde a um nó de expressão binária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2180">
              <paramref name="binaryType" /> does not correspond to a binary expression node.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2181">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2181">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MakeBinary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MakeBinary (binaryType, left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="binaryType">
          <span data-ttu-id="ed4d0-2182">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica o tipo de operação binária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2182">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of binary operation.</span>
          </span>
        </param>
        <param name="left">
          <span data-ttu-id="ed4d0-2183">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando esquerdo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2183">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the left operand.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-2184">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando direito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2184">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the right operand.</span>
          </span>
        </param>
        <param name="liftToNull">
          <span data-ttu-id="ed4d0-2185">
            <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2185">
              <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-2186">Um <see cref="T:System.Reflection.MethodInfo" /> que especifica o método de implementação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2186">A <see cref="T:System.Reflection.MethodInfo" /> that specifies the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2187">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" />, dado o operando esquerdo, o operando direito e o método de implementação, chamando o método de fábrica apropriado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2187">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />, given the left operand, right operand and implementing method, by calling the appropriate factory method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2188">O <see cref="T:System.Linq.Expressions.BinaryExpression" /> que resulta de chamar o método de fábrica apropriado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2188">The <see cref="T:System.Linq.Expressions.BinaryExpression" /> that results from calling the appropriate factory method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2189">O `binaryType` parâmetro determina quais <xref:System.Linq.Expressions.BinaryExpression> método de fábrica que esse método chamará.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2189">The `binaryType` parameter determines which <xref:System.Linq.Expressions.BinaryExpression> factory method this method will call.</span></span> <span data-ttu-id="ed4d0-2190">Por exemplo, se `binaryType` está <xref:System.Linq.Expressions.ExpressionType.Subtract>, este método invoca <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2190">For example, if `binaryType` is <xref:System.Linq.Expressions.ExpressionType.Subtract>, this method invokes <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span></span> <span data-ttu-id="ed4d0-2191">O `liftToNull` e `method` parâmetros serão ignorados se o método de fábrica apropriado não tem um parâmetro correspondente.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2191">The `liftToNull` and `method` parameters are ignored if the appropriate factory method does not have a corresponding parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2192">
            <paramref name="binaryType" /> não corresponde a um nó de expressão binária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2192">
              <paramref name="binaryType" /> does not correspond to a binary expression node.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2193">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2193">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member MakeBinary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MakeBinary (binaryType, left, right, liftToNull, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="binaryType">
          <span data-ttu-id="ed4d0-2194">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica o tipo de operação binária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2194">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of binary operation.</span>
          </span>
        </param>
        <param name="left">
          <span data-ttu-id="ed4d0-2195">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando esquerdo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2195">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the left operand.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-2196">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando direito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2196">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the right operand.</span>
          </span>
        </param>
        <param name="liftToNull">
          <span data-ttu-id="ed4d0-2197">
            <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2197">
              <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-2198">Um <see cref="T:System.Reflection.MethodInfo" /> que especifica o método de implementação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2198">A <see cref="T:System.Reflection.MethodInfo" /> that specifies the implementing method.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="ed4d0-2199">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que representa uma função de conversão de tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2199">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that represents a type conversion function.</span>
          </span>
          <span data-ttu-id="ed4d0-2200">Esse parâmetro é usado somente se <c>binaryType</c> é <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> ou uma atribuição composta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2200">This parameter is used only if <c>binaryType</c> is <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> or compound assignment..</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2201">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" />, dado o operando esquerdo, o operando direito, o método de implementação e a função de conversão de tipo, chamando o método de fábrica apropriado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2201">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />, given the left operand, right operand, implementing method and type conversion function, by calling the appropriate factory method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2202">O <see cref="T:System.Linq.Expressions.BinaryExpression" /> que resulta de chamar o método de fábrica apropriado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2202">The <see cref="T:System.Linq.Expressions.BinaryExpression" /> that results from calling the appropriate factory method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2203">O `binaryType` parâmetro determina quais <xref:System.Linq.Expressions.BinaryExpression> método de fábrica que esse método chamará.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2203">The `binaryType` parameter determines which <xref:System.Linq.Expressions.BinaryExpression> factory method this method will call.</span></span> <span data-ttu-id="ed4d0-2204">Por exemplo, se `binaryType` está <xref:System.Linq.Expressions.ExpressionType.Subtract>, este método invoca <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2204">For example, if `binaryType` is <xref:System.Linq.Expressions.ExpressionType.Subtract>, this method invokes <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span></span> <span data-ttu-id="ed4d0-2205">O `liftToNull`, `method` e `conversion` parâmetros serão ignorados se o método de fábrica apropriado não tem um parâmetro correspondente.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2205">The `liftToNull`, `method` and `conversion` parameters are ignored if the appropriate factory method does not have a corresponding parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2206">
            <paramref name="binaryType" /> não corresponde a um nó de expressão binária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2206">
              <paramref name="binaryType" /> does not correspond to a binary expression node.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2207">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2207">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MakeCatchBlock">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock MakeCatchBlock (Type type, System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock MakeCatchBlock(class System.Type type, class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ MakeCatchBlock(Type ^ type, System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberSignature Language="F#" Value="static member MakeCatchBlock : Type * System.Linq.Expressions.ParameterExpression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.MakeCatchBlock (type, variable, body, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ed4d0-2208">O <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que esse <see cref="T:System.Linq.Expressions.CatchBlock" /> tratará.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2208">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of <see cref="T:System.Exception" /> this <see cref="T:System.Linq.Expressions.CatchBlock" /> will handle.</span>
          </span>
        </param>
        <param name="variable">
          <span data-ttu-id="ed4d0-2209">Uma <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa uma referência para o objeto <see cref="T:System.Exception" /> capturado por este manipulador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2209">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> representing a reference to the <see cref="T:System.Exception" /> object caught by this handler.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="ed4d0-2210">O corpo da instrução catch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2210">The body of the catch statement.</span>
          </span>
        </param>
        <param name="filter">
          <span data-ttu-id="ed4d0-2211">O corpo do filtro <see cref="T:System.Exception" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2211">The body of the <see cref="T:System.Exception" /> filter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2212">Cria um <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa uma instrução catch com os elementos especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2212">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with the specified elements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2213">O <see cref="T:System.Linq.Expressions.CatchBlock" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2213">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2214">`type` deve ser não nulo e corresponder ao tipo de `variable` (se ele é fornecido).</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2214">`type` must be non-null and match the type of `variable` (if it is supplied).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeDynamic">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-2215">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2215">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arguments As IEnumerable(Of Expression)) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="ed4d0-2216">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2216">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="ed4d0-2217">O associador de tempo de execução para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2217">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="ed4d0-2218">Os argumentos para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2218">The arguments to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2219">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2219">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2220">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2220">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="ed4d0-2221">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2221">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="ed4d0-2222">O associador de tempo de execução para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2222">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="ed4d0-2223">O argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2223">The argument to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2224">Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido e um argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2224">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and one argument.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2225">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2225">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, ParamArray arguments As Expression()) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="ed4d0-2226">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2226">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="ed4d0-2227">O associador de tempo de execução para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2227">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="ed4d0-2228">Os argumentos para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2228">The arguments to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2229">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2229">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2230">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2230">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="ed4d0-2231">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2231">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="ed4d0-2232">O associador de tempo de execução para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2232">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="ed4d0-2233">O primeiro argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2233">The first argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="ed4d0-2234">O segundo argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2234">The second argument to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2235">Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido e dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2235">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and two arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2236">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2236">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression, arg2 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="ed4d0-2237">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2237">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="ed4d0-2238">O associador de tempo de execução para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2238">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="ed4d0-2239">O primeiro argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2239">The first argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="ed4d0-2240">O segundo argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2240">The second argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="ed4d0-2241">O terceiro argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2241">The third argument to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2242">Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido e três argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2242">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and three arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2243">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2243">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="ed4d0-2244">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2244">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="ed4d0-2245">O associador de tempo de execução para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2245">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="ed4d0-2246">O primeiro argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2246">The first argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="ed4d0-2247">O segundo argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2247">The second argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="ed4d0-2248">O terceiro argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2248">The third argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg3">
          <span data-ttu-id="ed4d0-2249">O quarto argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2249">The fourth argument to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2250">Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido e quatro argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2250">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and four arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2251">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2251">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGoto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression MakeGoto (System.Linq.Expressions.GotoExpressionKind kind, System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression MakeGoto(valuetype System.Linq.Expressions.GotoExpressionKind kind, class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ MakeGoto(System::Linq::Expressions::GotoExpressionKind kind, System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member MakeGoto : System.Linq.Expressions.GotoExpressionKind * System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.MakeGoto (kind, target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="kind" Type="System.Linq.Expressions.GotoExpressionKind" />
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="kind">
          <span data-ttu-id="ed4d0-2252">O <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> do <see cref="T:System.Linq.Expressions.GotoExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2252">The <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> of the <see cref="T:System.Linq.Expressions.GotoExpression" />.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="ed4d0-2253">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2253">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="ed4d0-2254">O valor que será passado para o rótulo associado ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2254">The value that will be passed to the associated label upon jumping.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="ed4d0-2255">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2255">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2256">Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa um link do <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2256">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a jump of the specified <see cref="T:System.Linq.Expressions.GotoExpressionKind" />.</span>
          </span>
          <span data-ttu-id="ed4d0-2257">O valor passado para o rótulo ao saltar também pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2257">The value passed to the label upon jumping can also be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2258">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a <paramref name="kind" />, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" />, a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" /> e <paramref name="value" /> a ser passado para o rótulo de destino ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2258">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to <paramref name="kind" />, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression MakeIndex (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression MakeIndex(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeIndex (instance As Expression, indexer As PropertyInfo, arguments As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ MakeIndex(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member MakeIndex : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.MakeIndex (instance, indexer, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance">
          <span data-ttu-id="ed4d0-2259">O objeto ao qual a propriedade pertence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2259">The object to which the property belongs.</span>
          </span>
          <span data-ttu-id="ed4d0-2260">Deve ser nulo se a propriedade for <see langword="static" /> (<see langword="shared" /> no Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2260">It should be null if the property is <see langword="static" /> (<see langword="shared" /> in Visual Basic).</span>
          </span>
        </param>
        <param name="indexer">
          <span data-ttu-id="ed4d0-2261">Um <see cref="T:System.Linq.Expressions.Expression" /> representando a propriedade a indexar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2261">An <see cref="T:System.Linq.Expressions.Expression" /> representing the property to index.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="ed4d0-2262">Um <c>IEnumerable&lt;Expression&gt;</c> (<c>IEnumerable (Of Expression)</c> no Visual Basic) que contém os argumentos que serão usados para indexar a propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2262">An <c>IEnumerable&lt;Expression&gt;</c> (<c>IEnumerable (Of Expression)</c> in Visual Basic) that contains the arguments that will be used to index the property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2263">Cria um <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa o acesso a uma propriedade indexada em um objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2263">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> that represents accessing an indexed property in an object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2264">O <see cref="T:System.Linq.Expressions.IndexExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2264">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeMemberAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression MakeMemberAccess (System.Linq.Expressions.Expression expression, System.Reflection.MemberInfo member);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression MakeMemberAccess(class System.Linq.Expressions.Expression expression, class System.Reflection.MemberInfo member) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ MakeMemberAccess(System::Linq::Expressions::Expression ^ expression, System::Reflection::MemberInfo ^ member);" />
      <MemberSignature Language="F#" Value="static member MakeMemberAccess : System.Linq.Expressions.Expression * System.Reflection.MemberInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.MakeMemberAccess (expression, member)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-2265">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o objeto ao qual o membro pertence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2265">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the object that the member belongs to.</span>
          </span>
          <span data-ttu-id="ed4d0-2266">Isso pode ser nulo para membros estáticos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2266">This can be null for static members.</span>
          </span>
        </param>
        <param name="member">
          <span data-ttu-id="ed4d0-2267">O <see cref="T:System.Reflection.MemberInfo" /> que descreve a propriedade ou o campo a ser acessado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2267">The <see cref="T:System.Reflection.MemberInfo" /> that describes the field or property to be accessed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2268">Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a um campo ou uma propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2268">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing either a field or a property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2269">O <see cref="T:System.Linq.Expressions.MemberExpression" /> que resulta de chamar o método de fábrica apropriado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2269">The <see cref="T:System.Linq.Expressions.MemberExpression" /> that results from calling the appropriate factory method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2270">Esse método pode ser usado para criar uma <xref:System.Linq.Expressions.MemberExpression> que representa o acesso a um campo ou uma propriedade, dependendo do tipo de `member`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2270">This method can be used to create a <xref:System.Linq.Expressions.MemberExpression> that represents accessing either a field or a property, depending on the type of `member`.</span></span> <span data-ttu-id="ed4d0-2271">Se `member` é do tipo <xref:System.Reflection.FieldInfo>, este método chama <xref:System.Linq.Expressions.Expression.Field%2A> para criar o <xref:System.Linq.Expressions.MemberExpression>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2271">If `member` is of type <xref:System.Reflection.FieldInfo>, this method calls <xref:System.Linq.Expressions.Expression.Field%2A> to create the <xref:System.Linq.Expressions.MemberExpression>.</span></span> <span data-ttu-id="ed4d0-2272">Se `member` é do tipo <xref:System.Reflection.PropertyInfo>, este método chama <xref:System.Linq.Expressions.Expression.Property%2A> para criar o <xref:System.Linq.Expressions.MemberExpression>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2272">If `member` is of type <xref:System.Reflection.PropertyInfo>, this method calls <xref:System.Linq.Expressions.Expression.Property%2A> to create the <xref:System.Linq.Expressions.MemberExpression>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2273">
            <paramref name="member" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2273">
              <paramref name="member" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2274">
            <paramref name="member" /> não representa um campo ou propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2274">
              <paramref name="member" /> does not represent a field or property.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MakeTry">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression MakeTry (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, System.Linq.Expressions.Expression fault, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt; handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression MakeTry(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.Expression fault, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.CatchBlock&gt; handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ MakeTry(Type ^ type, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally, System::Linq::Expressions::Expression ^ fault, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberSignature Language="F#" Value="static member MakeTry : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.CatchBlock&gt; -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.MakeTry (type, body, finally, fault, handlers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt;" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ed4d0-2275">O tipo de resultado da expressão try.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2275">The result type of the try expression.</span>
          </span>
          <span data-ttu-id="ed4d0-2276">Se for null, o corpo e todos os manipuladores devem ter tipo idêntico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2276">If null, bodh and all handlers must have identical type.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="ed4d0-2277">O corpo do bloco try.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2277">The body of the try block.</span>
          </span>
        </param>
        <param name="finally">
          <span data-ttu-id="ed4d0-2278">O corpo do bloco finally.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2278">The body of the finally block.</span>
          </span>
          <span data-ttu-id="ed4d0-2279">Passe null se o bloco try não tem bloco finally associado a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2279">Pass null if the try block has no finally block associated with it.</span>
          </span>
        </param>
        <param name="fault">
          <span data-ttu-id="ed4d0-2280">O corpo do bloco de falha.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2280">The body of the fault block.</span>
          </span>
          <span data-ttu-id="ed4d0-2281">Passe null se o bloco try não tem bloco fault associado a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2281">Pass null if the try block has no fault block associated with it.</span>
          </span>
        </param>
        <param name="handlers">
          <span data-ttu-id="ed4d0-2282">Uma coleção de <see cref="T:System.Linq.Expressions.CatchBlock" />s representando as instruções catch a serem associados com o bloco try.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2282">A collection of <see cref="T:System.Linq.Expressions.CatchBlock" />s representing the catch statements to be associated with the try block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2283">Cria um <see cref="T:System.Linq.Expressions.TryExpression" /> que representa um bloco try com os elementos especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2283">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with the specified elements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2284">O <see cref="T:System.Linq.Expressions.TryExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2284">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeUnary">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-2285">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> chamando o método de fábrica apropriado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2285">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> by calling the appropriate factory method.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ MakeUnary(System::Linq::Expressions::ExpressionType unaryType, System::Linq::Expressions::Expression ^ operand, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member MakeUnary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.MakeUnary (unaryType, operand, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="unaryType">
          <span data-ttu-id="ed4d0-2286">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica o tipo de operação unária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2286">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of unary operation.</span>
          </span>
        </param>
        <param name="operand">
          <span data-ttu-id="ed4d0-2287">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2287">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the operand.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="ed4d0-2288">O <see cref="T:System.Type" /> que especifica o tipo no qual converter (passe <see langword="null" /> se não for aplicável).</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2288">The <see cref="T:System.Type" /> that specifies the type to be converted to (pass <see langword="null" /> if not applicable).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2289">Dado um determinado operando, cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> chamando o método de fábrica apropriado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2289">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />, given an operand, by calling the appropriate factory method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2290">O <see cref="T:System.Linq.Expressions.UnaryExpression" /> que resulta de chamar o método de fábrica apropriado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2290">The <see cref="T:System.Linq.Expressions.UnaryExpression" /> that results from calling the appropriate factory method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2291">O `unaryType` parâmetro determina quais <xref:System.Linq.Expressions.UnaryExpression> chama esse método de método de fábrica.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2291">The `unaryType` parameter determines which <xref:System.Linq.Expressions.UnaryExpression> factory method this method calls.</span></span> <span data-ttu-id="ed4d0-2292">Por exemplo, se `unaryType` é igual a <xref:System.Linq.Expressions.ExpressionType.Convert>, este método invoca <xref:System.Linq.Expressions.Expression.Convert%2A>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2292">For example, if `unaryType` is equal to <xref:System.Linq.Expressions.ExpressionType.Convert>, this method invokes <xref:System.Linq.Expressions.Expression.Convert%2A>.</span></span> <span data-ttu-id="ed4d0-2293">O `type`parâmetro será ignorado se ele não se aplica ao método de fábrica que é chamado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2293">The `type`parameter is ignored if it does not apply to the factory method that is called.</span></span>  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2294">
            <paramref name="operand" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2294">
              <paramref name="operand" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2295">
            <paramref name="unaryType" /> não corresponde a um nó de expressão unária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2295">
              <paramref name="unaryType" /> does not correspond to a unary expression node.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ MakeUnary(System::Linq::Expressions::ExpressionType unaryType, System::Linq::Expressions::Expression ^ operand, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MakeUnary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * Type * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.MakeUnary (unaryType, operand, type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="unaryType">
          <span data-ttu-id="ed4d0-2296">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica o tipo de operação unária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2296">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of unary operation.</span>
          </span>
        </param>
        <param name="operand">
          <span data-ttu-id="ed4d0-2297">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2297">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the operand.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="ed4d0-2298">O <see cref="T:System.Type" /> que especifica o tipo no qual converter (passe <see langword="null" /> se não for aplicável).</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2298">The <see cref="T:System.Type" /> that specifies the type to be converted to (pass <see langword="null" /> if not applicable).</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-2299">O <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2299">The <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2300">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" />, dado um operando e um método de implementação, chamando o método de fábrica apropriado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2300">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />, given an operand and implementing method, by calling the appropriate factory method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2301">O <see cref="T:System.Linq.Expressions.UnaryExpression" /> que resulta de chamar o método de fábrica apropriado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2301">The <see cref="T:System.Linq.Expressions.UnaryExpression" /> that results from calling the appropriate factory method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2302">O `unaryType` parâmetro determina quais <xref:System.Linq.Expressions.UnaryExpression> chama esse método de método de fábrica.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2302">The `unaryType` parameter determines which <xref:System.Linq.Expressions.UnaryExpression> factory method this method calls.</span></span> <span data-ttu-id="ed4d0-2303">Por exemplo, se `unaryType` é igual a <xref:System.Linq.Expressions.ExpressionType.Convert>, este método invoca <xref:System.Linq.Expressions.Expression.Convert%2A>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2303">For example, if `unaryType` is equal to <xref:System.Linq.Expressions.ExpressionType.Convert>, this method invokes <xref:System.Linq.Expressions.Expression.Convert%2A>.</span></span> <span data-ttu-id="ed4d0-2304">O `type` e `method` parâmetros serão ignorados se eles não se aplicam para o método de fábrica é chamado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2304">The `type` and `method` parameters are ignored if they do not apply to the factory method that is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2305">
            <paramref name="operand" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2305">
              <paramref name="operand" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2306">
            <paramref name="unaryType" /> não corresponde a um nó de expressão unária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2306">
              <paramref name="unaryType" /> does not correspond to a unary expression node.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberBind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-2307">Cria uma <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa a inicialização recursiva de membros de um membro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2307">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a member.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (member As MemberInfo, bindings As IEnumerable(Of MemberBinding)) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MemberInfo ^ member, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MemberInfo * seq&lt;System.Linq.Expressions.MemberBinding&gt; -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (member, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="member">
          <span data-ttu-id="ed4d0-2308">O <see cref="T:System.Reflection.MemberInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propriedade será definida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2308">The <see cref="T:System.Reflection.MemberInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span>
          </span>
        </param>
        <param name="bindings">
          <span data-ttu-id="ed4d0-2309">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2309">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2310">Cria um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa a inicialização recursiva de membros de um campo ou propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2310">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a field or property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2311">Um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2311">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2312">O `member` parâmetro deve representar um campo ou propriedade.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2312">The `member` parameter must represent a field or property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2313">
            <paramref name="member" /> ou <paramref name="bindings" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2313">
              <paramref name="member" /> or <paramref name="bindings" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2314">
            <paramref name="member" /> não representa um campo ou propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2314">
              <paramref name="member" /> does not represent a field or property.</span>
          </span>
          <span data-ttu-id="ed4d0-2315">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2315">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2316">A propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de um elemento de <paramref name="bindings" /> não representa um membro do tipo do campo ou propriedade representada por <paramref name="member" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2316">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the field or property that <paramref name="member" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (member As MemberInfo, ParamArray bindings As MemberBinding()) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MemberInfo ^ member, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MemberInfo * System.Linq.Expressions.MemberBinding[] -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (member, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member">
          <span data-ttu-id="ed4d0-2317">O <see cref="T:System.Reflection.MemberInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propriedade será definida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2317">The <see cref="T:System.Reflection.MemberInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span>
          </span>
        </param>
        <param name="bindings">
          <span data-ttu-id="ed4d0-2318">Uma matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2318">An array of <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2319">Cria um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa a inicialização recursiva de membros de um campo ou propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2319">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a field or property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2320">Um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2320">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2321">O `member` parâmetro deve representar um campo ou propriedade.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2321">The `member` parameter must represent a field or property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2322">
            <paramref name="member" /> ou <paramref name="bindings" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2322">
              <paramref name="member" /> or <paramref name="bindings" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2323">
            <paramref name="member" /> não representa um campo ou propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2323">
              <paramref name="member" /> does not represent a field or property.</span>
          </span>
          <span data-ttu-id="ed4d0-2324">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2324">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2325">A propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de um elemento de <paramref name="bindings" /> não representa um membro do tipo do campo ou propriedade representada por <paramref name="member" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2325">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the field or property that <paramref name="member" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (propertyAccessor As MethodInfo, bindings As IEnumerable(Of MemberBinding)) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MethodInfo ^ propertyAccessor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.MemberBinding&gt; -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (propertyAccessor, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor">
          <span data-ttu-id="ed4d0-2326">O <see cref="T:System.Reflection.MethodInfo" /> que representa um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2326">The <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span>
          </span>
        </param>
        <param name="bindings">
          <span data-ttu-id="ed4d0-2327">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2327">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2328">Cria um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa a inicialização recursiva de membros de um membro que é acessado usando um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2328">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a member that is accessed by using a property accessor method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2329">Um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> definida para o <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade acessada em <paramref name="propertyAccessor" /> e propriedades <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2329">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2330">
            <paramref name="propertyAccessor" /> ou <paramref name="bindings" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2330">
              <paramref name="propertyAccessor" /> or <paramref name="bindings" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2331">
            <paramref name="propertyAccessor" /> não representa um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2331">
              <paramref name="propertyAccessor" /> does not represent a property accessor method.</span>
          </span>
          <span data-ttu-id="ed4d0-2332">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2332">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2333">A propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de um elemento de <paramref name="bindings" /> não representa um membro do tipo da propriedade acessada pelo método representado por <paramref name="propertyAccessor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2333">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the property accessed by the method that <paramref name="propertyAccessor" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (propertyAccessor As MethodInfo, ParamArray bindings As MemberBinding()) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MethodInfo ^ propertyAccessor, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MethodInfo * System.Linq.Expressions.MemberBinding[] -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (propertyAccessor, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor">
          <span data-ttu-id="ed4d0-2334">O <see cref="T:System.Reflection.MethodInfo" /> que representa um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2334">The <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span>
          </span>
        </param>
        <param name="bindings">
          <span data-ttu-id="ed4d0-2335">Uma matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2335">An array of <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2336">Cria um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa a inicialização recursiva de membros de um membro que é acessado usando um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2336">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a member that is accessed by using a property accessor method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2337">Um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> definida para o <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade acessada em <paramref name="propertyAccessor" /> e propriedades <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2337">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2338">
            <paramref name="propertyAccessor" /> ou <paramref name="bindings" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2338">
              <paramref name="propertyAccessor" /> or <paramref name="bindings" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2339">
            <paramref name="propertyAccessor" /> não representa um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2339">
              <paramref name="propertyAccessor" /> does not represent a property accessor method.</span>
          </span>
          <span data-ttu-id="ed4d0-2340">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2340">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2341">A propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de um elemento de <paramref name="bindings" /> não representa um membro do tipo da propriedade acessada pelo método representado por <paramref name="propertyAccessor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2341">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the property accessed by the method that <paramref name="propertyAccessor" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-2342">Representa uma expressão que cria um novo objeto e inicializa uma propriedade do objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2342">Represents an expression that creates a new object and initializes a property of the object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberInitExpression ^ MemberInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberInit : System.Linq.Expressions.NewExpression * seq&lt;System.Linq.Expressions.MemberBinding&gt; -&gt; System.Linq.Expressions.MemberInitExpression" Usage="System.Linq.Expressions.Expression.MemberInit (newExpression, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">
          <span data-ttu-id="ed4d0-2343">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2343">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> property equal to.</span>
          </span>
        </param>
        <param name="bindings">
          <span data-ttu-id="ed4d0-2344">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2344">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2345">Representa uma expressão que cria um novo objeto e inicializa uma propriedade do objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2345">Represents an expression that creates a new object and initializes a property of the object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2346">Um <see cref="T:System.Linq.Expressions.MemberInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2346">A <see cref="T:System.Linq.Expressions.MemberInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> and the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2347">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.MemberInitExpression> é igual ao <xref:System.Linq.Expressions.Expression.Type%2A> propriedade `newExpression`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2347">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberInitExpression> is equal to the <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-2348">O exemplo a seguir demonstra uma expressão que cria um novo objeto e inicializa uma propriedade do objeto.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2348">The following example demonstrates an expression that creates a new object and initializes a property of the object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#40)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2349">
            <paramref name="newExpression" /> ou <paramref name="bindings" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2349">
              <paramref name="newExpression" /> or <paramref name="bindings" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2350">A propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de um elemento de <paramref name="bindings" /> não representa um membro do tipo representado por <paramref name="newExpression" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2350">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type that <paramref name="newExpression" />.Type represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberInitExpression ^ MemberInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberInit : System.Linq.Expressions.NewExpression * System.Linq.Expressions.MemberBinding[] -&gt; System.Linq.Expressions.MemberInitExpression" Usage="System.Linq.Expressions.Expression.MemberInit (newExpression, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">
          <span data-ttu-id="ed4d0-2351">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2351">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> property equal to.</span>
          </span>
        </param>
        <param name="bindings">
          <span data-ttu-id="ed4d0-2352">Uma matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2352">An array of <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2353">Cria um <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2353">Creates a <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2354">Um <see cref="T:System.Linq.Expressions.MemberInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2354">A <see cref="T:System.Linq.Expressions.MemberInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> and the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2355">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.MemberInitExpression> é igual ao <xref:System.Linq.Expressions.Expression.Type%2A> propriedade `newExpression`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2355">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberInitExpression> is equal to the <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-2356">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.MemberInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.MemberBinding%5B%5D%29> método para criar um <xref:System.Linq.Expressions.MemberInitExpression> que representa a inicialização de dois membros de um novo objeto.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2356">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.MemberInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.MemberBinding%5B%5D%29> method to create a <xref:System.Linq.Expressions.MemberInitExpression> that represents the initialization of two members of a new object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#9)]
 [!code-vb[System.Linq.Expressions.Expression#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2357">
            <paramref name="newExpression" /> ou <paramref name="bindings" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2357">
              <paramref name="newExpression" /> or <paramref name="bindings" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2358">A propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de um elemento de <paramref name="bindings" /> não representa um membro do tipo representado por <paramref name="newExpression" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2358">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type that <paramref name="newExpression" />.Type represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Modulo">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-2359">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação restante aritmética.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2359">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic remainder operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Modulo (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Modulo(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Modulo : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Modulo (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-2360">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2360">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-2361">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2361">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2362">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação restante aritmética.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2362">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic remainder operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2363">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2363">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2364">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2364">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-2365">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2365">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-2366">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2366">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-2367">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2367">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-2368">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2368">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-2369">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2369">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-2370">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2370">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-2371">As seguintes regras de determinam o método de implementação selecionado para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2371">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-2372">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de módulo, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2372">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the modulus operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-2373">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2373">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-2374">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2374">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-2375">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2375">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-2376">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2376">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-2377">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2377">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-2378">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2378">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-2379">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2379">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-2380">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2380">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-2381">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2381">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-2382">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2382">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-2383">O tipo do nó é o tipo de resultado do operador de módulo predefinido.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2383">The type of the node is the result type of the predefined modulus operator.</span></span>  
  
-   <span data-ttu-id="ed4d0-2384">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2384">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-2385">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de módulo predefinido.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2385">The type of the node is the nullable type that corresponds to the result type of the predefined modulus operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2386">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2386">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-2387">O operador modulus não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2387">The modulus operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Modulo (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Modulo(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Modulo : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Modulo (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-2388">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2388">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-2389">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2389">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-2390">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2390">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2391">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação restante aritmética.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2391">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic remainder operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2392">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2392">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2393">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2393">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-2394">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2394">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-2395">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2395">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-2396">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2396">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-2397">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2397">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-2398">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2398">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-2399">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2399">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-2400">O método de implementação para a operação é escolhido com base nas seguintes regras:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2400">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="ed4d0-2401">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2401">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="ed4d0-2402">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de módulo, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2402">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the modulus operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-2403">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2403">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-2404">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2404">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-2405">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2405">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-2406">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2406">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-2407">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2407">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-2408">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2408">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-2409">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2409">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-2410">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2410">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-2411">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2411">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-2412">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2412">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-2413">O tipo do nó é o tipo de resultado do operador de módulo predefinido.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2413">The type of the node is the result type of the predefined modulus operator.</span></span>  
  
-   <span data-ttu-id="ed4d0-2414">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2414">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-2415">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de módulo predefinido.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2415">The type of the node is the nullable type that corresponds to the result type of the predefined modulus operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2416">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2416">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2417">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2417">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-2418">
            <paramref name="method" /> é <see langword="null" /> e operador de módulo não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2418">
              <paramref name="method" /> is <see langword="null" /> and the modulus operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ModuloAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-2419">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição pendente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2419">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ModuloAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ModuloAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-2420">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2420">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-2421">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2421">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2422">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição pendente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2422">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2423">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2423">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ModuloAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ModuloAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-2424">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2424">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-2425">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2425">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-2426">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2426">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2427">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição pendente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2427">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2428">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2428">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member ModuloAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ModuloAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-2429">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2429">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-2430">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2430">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-2431">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2431">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="ed4d0-2432">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2432">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2433">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição pendente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2433">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2434">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2434">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Multiply">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-2435">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de multiplicação que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2435">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that does not have overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Multiply(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-2436">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2436">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-2437">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2437">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2438">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de multiplicação que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2438">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2439">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2439">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2440">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2440">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-2441">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2441">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-2442">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2442">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-2443">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2443">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-2444">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2444">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-2445">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2445">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-2446">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2446">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-2447">As seguintes regras de determinam o método de implementação selecionado para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2447">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-2448">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de multiplicação, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2448">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-2449">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2449">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-2450">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2450">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-2451">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2451">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-2452">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2452">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-2453">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2453">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-2454">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2454">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-2455">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2455">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-2456">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2456">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-2457">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2457">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-2458">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2458">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-2459">O tipo do nó é o tipo de resultado do operador de multiplicação predefinidos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2459">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="ed4d0-2460">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2460">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-2461">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de multiplicação predefinidos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2461">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-2462">O exemplo de código a seguir mostra como criar uma expressão que multiplica dois valores.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2462">The following code example shows how to create an expression that multiplies two values.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#27)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2463">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2463">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-2464">O operador de multiplicação não está definido como <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2464">The multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Multiply(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Multiply (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-2465">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2465">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-2466">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2466">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-2467">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2467">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2468">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de multiplicação que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2468">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2469">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2469">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2470">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2470">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-2471">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2471">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-2472">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2472">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-2473">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2473">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-2474">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2474">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-2475">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2475">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-2476">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2476">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-2477">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2477">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-2478">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2478">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="ed4d0-2479">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de multiplicação, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2479">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-2480">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2480">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-2481">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2481">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-2482">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2482">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-2483">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2483">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-2484">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2484">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-2485">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2485">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-2486">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2486">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-2487">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2487">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-2488">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2488">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-2489">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2489">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-2490">O tipo do nó é o tipo de resultado do operador de multiplicação predefinidos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2490">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="ed4d0-2491">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2491">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-2492">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de multiplicação predefinidos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2492">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2493">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2493">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2494">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2494">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-2495">
            <paramref name="method" /> é <see langword="null" /> e o operador de multiplicação não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2495">
              <paramref name="method" /> is <see langword="null" /> and the multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-2496">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2496">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-2497">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2497">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-2498">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2498">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2499">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2499">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2500">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2500">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-2501">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2501">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-2502">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2502">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-2503">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2503">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2504">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2504">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2505">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2505">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-2506">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2506">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-2507">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2507">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-2508">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2508">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="ed4d0-2509">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2509">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2510">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2510">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2511">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2511">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-2512">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2512">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssignChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-2513">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2513">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-2514">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2514">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2515">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2515">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2516">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2516">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssignChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-2517">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2517">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-2518">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2518">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-2519">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2519">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2520">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2520">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2521">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2521">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssignChecked (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-2522">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2522">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-2523">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2523">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-2524">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2524">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="ed4d0-2525">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2525">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2526">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2526">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2527">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2527">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-2528">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de multiplicação que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2528">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that has overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MultiplyChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-2529">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2529">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-2530">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2530">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2531">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de multiplicação que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2531">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2532">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2532">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2533">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2533">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-2534">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2534">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-2535">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2535">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-2536">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2536">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-2537">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2537">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-2538">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2538">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-2539">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2539">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-2540">As seguintes regras de determinam o método de implementação selecionado para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2540">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-2541">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de multiplicação, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2541">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-2542">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2542">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-2543">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2543">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-2544">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2544">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-2545">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2545">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-2546">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2546">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-2547">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2547">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-2548">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2548">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-2549">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2549">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-2550">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2550">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-2551">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2551">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-2552">O tipo do nó é o tipo de resultado do operador de multiplicação predefinidos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2552">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="ed4d0-2553">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2553">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-2554">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de multiplicação predefinidos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2554">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2555">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2555">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-2556">O operador de multiplicação não está definido como <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2556">The multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MultiplyChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-2557">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2557">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-2558">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2558">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-2559">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2559">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2560">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de multiplicação que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2560">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2561">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2561">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2562">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2562">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-2563">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2563">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-2564">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2564">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-2565">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2565">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-2566">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2566">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-2567">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2567">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-2568">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2568">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-2569">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2569">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-2570">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2570">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="ed4d0-2571">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de multiplicação, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2571">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-2572">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2572">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-2573">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2573">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-2574">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2574">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-2575">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2575">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-2576">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2576">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-2577">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2577">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-2578">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2578">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-2579">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2579">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-2580">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2580">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-2581">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2581">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-2582">O tipo do nó é o tipo de resultado do operador de multiplicação predefinidos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2582">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="ed4d0-2583">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2583">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-2584">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de multiplicação predefinidos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2584">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2585">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2585">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2586">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2586">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-2587">
            <paramref name="method" /> é <see langword="null" /> e o operador de multiplicação não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2587">
              <paramref name="method" /> is <see langword="null" /> and the multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Negate">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-2588">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação aritmética de negação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2588">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Negate(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Negate expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-2589">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2589">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2590">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação aritmética de negação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2590">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2591">Uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> e a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2591">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2592">O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2592">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="ed4d0-2593">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2593">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-2594">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2594">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-2595">Caso contrário, eles são falsos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2595">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-2596">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2596">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-2597">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2597">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-2598">Se `expression`. Tipo é um tipo definido pelo usuário que define o operador de subtração unário a <xref:System.Reflection.MethodInfo> que representa que o método de implementação do operador é.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2598">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-2599">Caso contrário, se `expression`. Tipo é um tipo numérico, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2599">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-2600">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2600">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-2601">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2601">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-2602">Se `expression`. O tipo é atribuível ao tipo de argumento do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2602">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-2603">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2603">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-2604">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2604">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-2605">`expression`. É um tipo de valor anulável e o tipo de valor não anulável correspondente é igual ao tipo de argumento do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2605">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-2606">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2606">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-2607">Se for o método de implementação `null`, o tipo de nó é `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2607">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="ed4d0-2608">Se `expression`. Tipo não anulável, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2608">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-2609">Caso contrário, o nó é eliminado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2609">Otherwise, the node is lifted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-2610">O exemplo a seguir demonstra como criar uma expressão que representa uma operação de negação aritmética.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2610">The following example demonstrates how to create an expression that represents an arithmetic negation operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#50)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2611">
            <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2611">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-2612">O operador de menos unário não está definido para <paramref name="expression" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2612">The unary minus operator is not defined for <paramref name="expression" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Negate(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Negate (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-2613">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2613">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-2614">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2614">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2615">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação aritmética de negação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2615">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2616">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2616">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2617">O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2617">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="ed4d0-2618">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2618">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-2619">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2619">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-2620">Caso contrário, eles são falsos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2620">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-2621">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2621">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-2622">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2622">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-2623">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que aceita um argumento, ele é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2623">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="ed4d0-2624">Se `expression`. Tipo é um tipo definido pelo usuário que define o operador de subtração unário a <xref:System.Reflection.MethodInfo> que representa que o método de implementação do operador é.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2624">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-2625">Caso contrário, se `expression`. Tipo é um tipo numérico, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2625">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-2626">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2626">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-2627">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2627">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-2628">Se `expression`. O tipo é atribuível ao tipo de argumento do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2628">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-2629">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2629">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-2630">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2630">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-2631">`expression`. É um tipo de valor anulável e o tipo de valor não anulável correspondente é igual ao tipo de argumento do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2631">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-2632">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2632">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-2633">Se for o método de implementação `null`, o tipo de nó é `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2633">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="ed4d0-2634">Se `expression`. Tipo não anulável, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2634">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-2635">Caso contrário, o nó é eliminado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2635">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2636">
            <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2636">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2637">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente um argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2637">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-2638">
            <paramref name="method" /> é <see langword="null" /> e o operador unário de menos não foi definido para <paramref name="expression" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2638">
              <paramref name="method" /> is <see langword="null" /> and the unary minus operator is not defined for <paramref name="expression" />.Type.</span>
          </span>
          <span data-ttu-id="ed4d0-2639">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2639">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2640">
            <paramref name="expression" />.Type (ou o respectivo tipo que não permite valor nulo correspondente se ele é um tipo que permite valor nulo) não é atribuível ao tipo de argumento do método representado por <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2640">
              <paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NegateChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-2641">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação aritmética de negação de adição que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2641">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation that has overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ NegateChecked(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member NegateChecked : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.NegateChecked expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-2642">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2642">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2643">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação aritmética de negação de adição que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2643">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2644">Uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> e a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2644">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2645">O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2645">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="ed4d0-2646">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2646">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-2647">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2647">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-2648">Caso contrário, eles são falsos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2648">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-2649">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2649">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-2650">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2650">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-2651">Se `expression`. Tipo é um tipo definido pelo usuário que define o operador de subtração unário a <xref:System.Reflection.MethodInfo> que representa que o método de implementação do operador é.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2651">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-2652">Caso contrário, se `expression`. Tipo é um tipo numérico, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2652">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-2653">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2653">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-2654">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2654">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-2655">Se `expression`. O tipo é atribuível ao tipo de argumento do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2655">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-2656">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2656">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-2657">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2657">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-2658">`expression`. É um tipo de valor anulável e o tipo de valor não anulável correspondente é igual ao tipo de argumento do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2658">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-2659">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2659">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-2660">Se for o método de implementação `null`, o tipo de nó é `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2660">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="ed4d0-2661">Se `expression`. Tipo não anulável, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2661">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-2662">Caso contrário, o nó é eliminado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2662">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2663">
            <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2663">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-2664">O operador de menos unário não está definido para <paramref name="expression" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2664">The unary minus operator is not defined for <paramref name="expression" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ NegateChecked(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member NegateChecked : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.NegateChecked (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-2665">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2665">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-2666">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2666">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2667">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação aritmética de negação de adição que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2667">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation that has overflow checking.</span>
          </span>
          <span data-ttu-id="ed4d0-2668">O método de implementação pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2668">The implementing method can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2669">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2669">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2670">O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2670">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="ed4d0-2671">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2671">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-2672">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2672">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-2673">Caso contrário, eles são falsos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2673">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-2674">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2674">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-2675">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2675">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-2676">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que aceita um argumento, ele é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2676">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="ed4d0-2677">Se `expression`. Tipo é um tipo definido pelo usuário que define o operador de subtração unário a <xref:System.Reflection.MethodInfo> que representa que o método de implementação do operador é.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2677">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-2678">Caso contrário, se `expression`. Tipo é um tipo numérico, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2678">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-2679">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2679">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-2680">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2680">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-2681">Se `expression`. O tipo é atribuível ao tipo de argumento do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2681">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-2682">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2682">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-2683">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2683">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-2684">`expression`. É um tipo de valor anulável e o tipo de valor não anulável correspondente é igual ao tipo de argumento do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2684">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-2685">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2685">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-2686">Se for o método de implementação `null`, o tipo de nó é `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2686">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="ed4d0-2687">Se `expression`. Tipo não anulável, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2687">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-2688">Caso contrário, o nó é eliminado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2688">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2689">
            <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2689">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2690">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente um argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2690">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-2691">
            <paramref name="method" /> é <see langword="null" /> e o operador unário de menos não foi definido para <paramref name="expression" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2691">
              <paramref name="method" /> is <see langword="null" /> and the unary minus operator is not defined for <paramref name="expression" />.Type.</span>
          </span>
          <span data-ttu-id="ed4d0-2692">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2692">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2693">
            <paramref name="expression" />.Type (ou o respectivo tipo que não permite valor nulo correspondente se ele é um tipo que permite valor nulo) não é atribuível ao tipo de argumento do método representado por <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2693">
              <paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="New">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-2694">Cria um <see cref="T:System.Linq.Expressions.NewExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2694">Creates a <see cref="T:System.Linq.Expressions.NewExpression" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New constructor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="constructor">
          <span data-ttu-id="ed4d0-2695">O <see cref="T:System.Reflection.ConstructorInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> propriedade será definida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2695">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2696">Cria um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa uma chamada ao construtor especificado que não aceita nenhum argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2696">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor that takes no arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2697">Uma <see cref="T:System.Linq.Expressions.NewExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e a propriedade <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2697">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2698">O <xref:System.Linq.Expressions.NewExpression.Arguments%2A> e <xref:System.Linq.Expressions.NewExpression.Members%2A> propriedades resultantes <xref:System.Linq.Expressions.NewExpression> são coleções vazias.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2698">The <xref:System.Linq.Expressions.NewExpression.Arguments%2A> and <xref:System.Linq.Expressions.NewExpression.Members%2A> properties of the resulting <xref:System.Linq.Expressions.NewExpression> are empty collections.</span></span> <span data-ttu-id="ed4d0-2699">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade representa o tipo de declaração do construtor representado por `constructor`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2699">The <xref:System.Linq.Expressions.Expression.Type%2A> property represents the declaring type of the constructor represented by `constructor`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2700">
            <paramref name="constructor" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2700">
              <paramref name="constructor" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2701">O construtor representado por <paramref name="constructor" /> tem pelo menos um parâmetro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2701">The constructor that <paramref name="constructor" /> represents has at least one parameter.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member New : Type -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ed4d0-2702">Um <see cref="T:System.Type" /> contém um construtor que não aceita argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2702">A <see cref="T:System.Type" /> that has a constructor that takes no arguments.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2703">Cria um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa uma chamada para o construtor sem parâmetro do tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2703">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the parameterless constructor of the specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2704">A <see cref="T:System.Linq.Expressions.NewExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e a propriedade <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> definida como o <see cref="T:System.Reflection.ConstructorInfo" /> que representa o construtor sem parâmetros para o tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2704">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property set to the <see cref="T:System.Reflection.ConstructorInfo" /> that represents the constructor without parameters for the specified type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2705">O `type` parâmetro deve representar um tipo que tem um construtor sem parâmetros.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2705">The `type` parameter must represent a type that has a constructor without parameters.</span></span>  
  
 <span data-ttu-id="ed4d0-2706">O <xref:System.Linq.Expressions.NewExpression.Arguments%2A> e <xref:System.Linq.Expressions.NewExpression.Members%2A> propriedades resultantes <xref:System.Linq.Expressions.NewExpression> são coleções vazias.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2706">The <xref:System.Linq.Expressions.NewExpression.Arguments%2A> and <xref:System.Linq.Expressions.NewExpression.Members%2A> properties of the resulting <xref:System.Linq.Expressions.NewExpression> are empty collections.</span></span> <span data-ttu-id="ed4d0-2707">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é igual a `type`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2707">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to `type`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-2708">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.New%28System.Type%29> método para criar um <xref:System.Linq.Expressions.NewExpression> que representa a construção de uma nova instância de um objeto dictionary, chamando o construtor sem parâmetros.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2708">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.New%28System.Type%29> method to create a <xref:System.Linq.Expressions.NewExpression> that represents constructing a new instance of a dictionary object by calling the constructor without parameters.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#10)]
 [!code-vb[System.Linq.Expressions.Expression#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2709">
            <paramref name="type" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2709">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2710">O tipo que <paramref name="type" /> representa não tem um construtor sem parâmetros.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2710">The type that <paramref name="type" /> represents does not have a constructor without parameters.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression)) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor">
          <span data-ttu-id="ed4d0-2711">O <see cref="T:System.Reflection.ConstructorInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> propriedade será definida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2711">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="ed4d0-2712">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2712">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2713">Cria um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa uma chamada ao construtor especificado com os argumentos especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2713">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2714">Um <see cref="T:System.Linq.Expressions.NewExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e as propriedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> e <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2714">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> and <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2715">O `arguments` parâmetro deve conter o mesmo número de elementos que o número de parâmetros do construtor representado por `constructor`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2715">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="ed4d0-2716">Se `arguments` está `null`, ele é considerado vazio e o <xref:System.Linq.Expressions.NewExpression.Arguments%2A> propriedade resultantes <xref:System.Linq.Expressions.NewExpression> é uma coleção vazia.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2716">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="ed4d0-2717">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.NewExpression> representa o tipo de declaração do construtor representado por `constructor`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2717">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="ed4d0-2718">O <xref:System.Linq.Expressions.NewExpression.Members%2A> propriedade é uma coleção vazia.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2718">The <xref:System.Linq.Expressions.NewExpression.Members%2A> property is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2719">
            <paramref name="constructor" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2719">
              <paramref name="constructor" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ed4d0-2720">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2720">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2721">Um elemento de <paramref name="arguments" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2721">An element of <paramref name="arguments" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2722">O parâmetro <paramref name="arguments" /> não contém o mesmo número de elementos que o número de parâmetros do construtor representado por <paramref name="constructor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2722">The <paramref name="arguments" /> parameter does not contain the same number of elements as the number of parameters for the constructor that <paramref name="constructor" /> represents.</span>
          </span>
          <span data-ttu-id="ed4d0-2723">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2723">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2724">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="arguments" /> não pode ser atribuída ao tipo do parâmetro correspondente do construtor representado por <paramref name="constructor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2724">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, ParamArray arguments As Expression()) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor">
          <span data-ttu-id="ed4d0-2725">O <see cref="T:System.Reflection.ConstructorInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> propriedade será definida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2725">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="ed4d0-2726">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2726">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2727">Cria um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa uma chamada ao construtor especificado com os argumentos especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2727">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2728">Um <see cref="T:System.Linq.Expressions.NewExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e as propriedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> e <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2728">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> and <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2729">O `arguments` parâmetro deve conter o mesmo número de elementos que o número de parâmetros do construtor representado por `constructor`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2729">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="ed4d0-2730">Se `arguments` está `null`, ele é considerado vazio e o <xref:System.Linq.Expressions.NewExpression.Arguments%2A> propriedade resultantes <xref:System.Linq.Expressions.NewExpression> é uma coleção vazia.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2730">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="ed4d0-2731">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.NewExpression> representa o tipo de declaração do construtor representado por `constructor`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2731">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="ed4d0-2732">O <xref:System.Linq.Expressions.NewExpression.Members%2A> propriedade é uma coleção vazia.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2732">The <xref:System.Linq.Expressions.NewExpression.Members%2A> property is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2733">
            <paramref name="constructor" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2733">
              <paramref name="constructor" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ed4d0-2734">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2734">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2735">Um elemento de <paramref name="arguments" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2735">An element of <paramref name="arguments" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2736">O tamanho de <paramref name="arguments" /> corresponde ao número de parâmetros do construtor representado por <paramref name="constructor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2736">The length of <paramref name="arguments" /> does match the number of parameters for the constructor that <paramref name="constructor" /> represents.</span>
          </span>
          <span data-ttu-id="ed4d0-2737">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2737">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2738">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="arguments" /> não pode ser atribuída ao tipo do parâmetro correspondente do construtor representado por <paramref name="constructor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2738">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt; members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.MemberInfo&gt; members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression), members As IEnumerable(Of MemberInfo)) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments, System::Collections::Generic::IEnumerable&lt;System::Reflection::MemberInfo ^&gt; ^ members);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * seq&lt;System.Linq.Expressions.Expression&gt; * seq&lt;System.Reflection.MemberInfo&gt; -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments, members)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor">
          <span data-ttu-id="ed4d0-2739">O <see cref="T:System.Reflection.ConstructorInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> propriedade será definida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2739">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="ed4d0-2740">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2740">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span>
          </span>
        </param>
        <param name="members">
          <span data-ttu-id="ed4d0-2741">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Reflection.MemberInfo" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2741">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Reflection.MemberInfo" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Members" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2742">Cria um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa uma chamada ao construtor especificado com os argumentos especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2742">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span>
          </span>
          <span data-ttu-id="ed4d0-2743">Os membros que acessam os campos inicializados pelo construtor são especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2743">The members that access the constructor initialized fields are specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2744">Um <see cref="T:System.Linq.Expressions.NewExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e as propriedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> e <see cref="P:System.Linq.Expressions.NewExpression.Members" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2744">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> and <see cref="P:System.Linq.Expressions.NewExpression.Members" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2745">O `arguments` parâmetro deve conter o mesmo número de elementos que o número de parâmetros do construtor representado por `constructor`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2745">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="ed4d0-2746">Se `arguments` está `null`, ele é considerado vazio e o <xref:System.Linq.Expressions.NewExpression.Arguments%2A> propriedade resultantes <xref:System.Linq.Expressions.NewExpression> é uma coleção vazia.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2746">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="ed4d0-2747">Se `members` está `null`, o <xref:System.Linq.Expressions.NewExpression.Members%2A> propriedade resultantes <xref:System.Linq.Expressions.NewExpression> é uma coleção vazia.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2747">If `members` is `null`, the <xref:System.Linq.Expressions.NewExpression.Members%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span> <span data-ttu-id="ed4d0-2748">Se `members` não é `null`, ele deve ter o mesmo número de elementos como `arguments` e cada elemento não deve ser `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2748">If `members` is not `null`, it must have the same number of elements as `arguments` and each element must not be `null`.</span></span> <span data-ttu-id="ed4d0-2749">Cada elemento da `members` deve ser um <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> ou <xref:System.Reflection.MethodInfo> que representa um membro de instância no tipo de declaração do construtor representado por `constructor`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2749">Each element of `members` must be a <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> or <xref:System.Reflection.MethodInfo> that represents an instance member on the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="ed4d0-2750">Se ele representa uma propriedade, a propriedade deve ter um `get` acessador.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2750">If it represents a property, the property must have a `get` accessor.</span></span> <span data-ttu-id="ed4d0-2751">O elemento correspondente de `arguments` para cada elemento de `members` deve ter uma <xref:System.Linq.Expressions.Expression.Type%2A> propriedade que representa um tipo que pode ser atribuído ao tipo do membro que o `members` elemento representa.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2751">The corresponding element of `arguments` for each element of `members` must have a <xref:System.Linq.Expressions.Expression.Type%2A> property that represents a type that is assignable to the type of the member that the `members` element represents.</span></span>  
  
 <span data-ttu-id="ed4d0-2752">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.NewExpression> representa o tipo de declaração do construtor que `constructor` representa.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2752">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor that `constructor` represents.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2753">
            <paramref name="constructor" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2753">
              <paramref name="constructor" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ed4d0-2754">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2754">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2755">Um elemento de <paramref name="arguments" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2755">An element of <paramref name="arguments" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ed4d0-2756">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2756">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2757">Um elemento de <paramref name="members" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2757">An element of <paramref name="members" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2758">O parâmetro <paramref name="arguments" /> não contém o mesmo número de elementos que o número de parâmetros do construtor representado por <paramref name="constructor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2758">The <paramref name="arguments" /> parameter does not contain the same number of elements as the number of parameters for the constructor that <paramref name="constructor" /> represents.</span>
          </span>
          <span data-ttu-id="ed4d0-2759">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2759">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2760">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="arguments" /> não pode ser atribuída ao tipo do parâmetro correspondente do construtor representado por <paramref name="constructor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2760">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span>
          </span>
          <span data-ttu-id="ed4d0-2761">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2761">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2762">O parâmetro <paramref name="members" /> não tem o mesmo número de elementos de <paramref name="arguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2762">The <paramref name="members" /> parameter does not have the same number of elements as <paramref name="arguments" />.</span>
          </span>
          <span data-ttu-id="ed4d0-2763">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2763">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2764">Um elemento de <paramref name="arguments" /> tem uma propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa um tipo que não é atribuível ao tipo do membro que é representado pelo elemento correspondente de <paramref name="members" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2764">An element of <paramref name="arguments" /> has a <see cref="P:System.Linq.Expressions.Expression.Type" /> property that represents a type that is not assignable to the type of the member that is represented by the corresponding element of <paramref name="members" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, params System.Reflection.MemberInfo[] members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Reflection.MemberInfo[] members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression), ParamArray members As MemberInfo()) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments, ... cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ members);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * seq&lt;System.Linq.Expressions.Expression&gt; * System.Reflection.MemberInfo[] -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments, members)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Reflection.MemberInfo[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor">
          <span data-ttu-id="ed4d0-2765">O <see cref="T:System.Reflection.ConstructorInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> propriedade será definida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2765">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="ed4d0-2766">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2766">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span>
          </span>
        </param>
        <param name="members">
          <span data-ttu-id="ed4d0-2767">Uma matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2767">An array of <see cref="T:System.Reflection.MemberInfo" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Members" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2768">Cria um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa uma chamada ao construtor especificado com os argumentos especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2768">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span>
          </span>
          <span data-ttu-id="ed4d0-2769">Os membros que acessam os campos inicializados pelo construtor são especificados como uma matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2769">The members that access the constructor initialized fields are specified as an array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2770">Um <see cref="T:System.Linq.Expressions.NewExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e as propriedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> e <see cref="P:System.Linq.Expressions.NewExpression.Members" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2770">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> and <see cref="P:System.Linq.Expressions.NewExpression.Members" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2771">O `arguments` parâmetro deve conter o mesmo número de elementos que o número de parâmetros do construtor representado por `constructor`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2771">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="ed4d0-2772">Se `arguments` está `null`, ele é considerado vazio e o <xref:System.Linq.Expressions.NewExpression.Arguments%2A> propriedade resultantes <xref:System.Linq.Expressions.NewExpression> é uma coleção vazia.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2772">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="ed4d0-2773">Se `members` está `null`, o <xref:System.Linq.Expressions.NewExpression.Members%2A> propriedade resultantes <xref:System.Linq.Expressions.NewExpression> é uma coleção vazia.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2773">If `members` is `null`, the <xref:System.Linq.Expressions.NewExpression.Members%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span> <span data-ttu-id="ed4d0-2774">Se `members` não é `null`, ele deve ter o mesmo número de elementos como `arguments` e cada elemento não deve ser `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2774">If `members` is not `null`, it must have the same number of elements as `arguments` and each element must not be `null`.</span></span> <span data-ttu-id="ed4d0-2775">Cada elemento da `members` deve ser um <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> ou <xref:System.Reflection.MethodInfo> que representa um membro de instância no tipo de declaração do construtor representado por `constructor`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2775">Each element of `members` must be a <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> or <xref:System.Reflection.MethodInfo> that represents an instance member on the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="ed4d0-2776">Se ele representa uma propriedade, a propriedade deve ser capaz de recuperar o valor do campo associado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2776">If it represents a property, the property must be able to retrieve the value of the associated field.</span></span> <span data-ttu-id="ed4d0-2777">O elemento correspondente de `arguments` para cada elemento de `members` deve ter uma <xref:System.Linq.Expressions.Expression.Type%2A> propriedade que representa um tipo que pode ser atribuído ao tipo do membro que o `members` elemento representa.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2777">The corresponding element of `arguments` for each element of `members` must have a <xref:System.Linq.Expressions.Expression.Type%2A> property that represents a type that is assignable to the type of the member that the `members` element represents.</span></span>  
  
 <span data-ttu-id="ed4d0-2778">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.NewExpression> representa o tipo de declaração do construtor que `constructor` representa.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2778">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor that `constructor` represents.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2779">
            <paramref name="constructor" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2779">
              <paramref name="constructor" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ed4d0-2780">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2780">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2781">Um elemento de <paramref name="arguments" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2781">An element of <paramref name="arguments" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ed4d0-2782">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2782">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2783">Um elemento de <paramref name="members" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2783">An element of <paramref name="members" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2784">O parâmetro <paramref name="arguments" /> não contém o mesmo número de elementos que o número de parâmetros do construtor representado por <paramref name="constructor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2784">The <paramref name="arguments" /> parameter does not contain the same number of elements as the number of parameters for the constructor that <paramref name="constructor" /> represents.</span>
          </span>
          <span data-ttu-id="ed4d0-2785">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2785">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2786">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="arguments" /> não pode ser atribuída ao tipo do parâmetro correspondente do construtor representado por <paramref name="constructor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2786">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span>
          </span>
          <span data-ttu-id="ed4d0-2787">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2787">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2788">O parâmetro <paramref name="members" /> não tem o mesmo número de elementos de <paramref name="arguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2788">The <paramref name="members" /> parameter does not have the same number of elements as <paramref name="arguments" />.</span>
          </span>
          <span data-ttu-id="ed4d0-2789">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2789">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2790">Um elemento de <paramref name="arguments" /> tem uma propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa um tipo que não é atribuível ao tipo do membro que é representado pelo elemento correspondente de <paramref name="members" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2790">An element of <paramref name="arguments" /> has a <see cref="P:System.Linq.Expressions.Expression.Type" /> property that represents a type that is not assignable to the type of the member that is represented by the corresponding element of <paramref name="members" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NewArrayBounds">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-2791">Cria uma <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa a criação de uma matriz que tem uma classificação especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2791">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating an array that has a specified rank.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayBounds(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ bounds);" />
      <MemberSignature Language="F#" Value="static member NewArrayBounds : Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayBounds (type, bounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ed4d0-2792">Um <see cref="T:System.Type" /> que representa o tipo de elemento da matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2792">A <see cref="T:System.Type" /> that represents the element type of the array.</span>
          </span>
        </param>
        <param name="bounds">
          <span data-ttu-id="ed4d0-2793">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2793">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2794">Cria uma <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa a criação de uma matriz que tem uma classificação especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2794">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating an array that has a specified rank.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2795">Uma <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> e a propriedade <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2795">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2796">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.NewArrayExpression> representa um tipo de matriz cuja classificação é igual ao comprimento de `bounds` e cujo tipo de elemento é `type`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2796">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is equal to the length of `bounds` and whose element type is `type`.</span></span>  
  
 <span data-ttu-id="ed4d0-2797">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de cada elemento da `bounds` deve representar um tipo integral.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2797">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `bounds` must represent an integral type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-2798">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> método para criar uma árvore de expressão que representa a criação de uma matriz de cadeia de caracteres que tem uma classificação de 2.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2798">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> method to create an expression tree that represents creating a string array that has a rank of 2.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2799">
            <paramref name="type" /> ou <paramref name="bounds" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2799">
              <paramref name="type" /> or <paramref name="bounds" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ed4d0-2800">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2800">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2801">Um elemento de <paramref name="bounds" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2801">An element of <paramref name="bounds" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2802">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="bounds" /> não representa um tipo integral.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2802">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="bounds" /> does not represent an integral type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, params System.Linq.Expressions.Expression[] bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Linq.Expressions.Expression[] bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayBounds(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ bounds);" />
      <MemberSignature Language="F#" Value="static member NewArrayBounds : Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayBounds (type, bounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ed4d0-2803">Um <see cref="T:System.Type" /> que representa o tipo de elemento da matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2803">A <see cref="T:System.Type" /> that represents the element type of the array.</span>
          </span>
        </param>
        <param name="bounds">
          <span data-ttu-id="ed4d0-2804">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2804">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2805">Cria uma <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa a criação de uma matriz que tem uma classificação especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2805">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating an array that has a specified rank.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2806">Uma <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> e a propriedade <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2806">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2807">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.NewArrayExpression> representa um tipo de matriz cuja classificação é igual ao comprimento de `bounds` e cujo tipo de elemento é `type`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2807">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is equal to the length of `bounds` and whose element type is `type`.</span></span>  
  
 <span data-ttu-id="ed4d0-2808">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de cada elemento da `bounds` deve representar um tipo integral.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2808">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `bounds` must represent an integral type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-2809">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> método para criar uma árvore de expressão que representa a criação de uma matriz de cadeia de caracteres que tem uma classificação de 2.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2809">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> method to create an expression tree that represents creating a string array that has a rank of 2.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2810">
            <paramref name="type" /> ou <paramref name="bounds" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2810">
              <paramref name="type" /> or <paramref name="bounds" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ed4d0-2811">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2811">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2812">Um elemento de <paramref name="bounds" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2812">An element of <paramref name="bounds" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2813">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="bounds" /> não representa um tipo integral.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2813">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="bounds" /> does not represent an integral type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NewArrayInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-2814">Cria um <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa a criação de uma matriz unidimensional e a inicialização dela de uma lista de elementos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2814">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating a one-dimensional array and initializing it from a list of elements.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayInit(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member NewArrayInit : Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayInit (type, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ed4d0-2815">Um <see cref="T:System.Type" /> que representa o tipo de elemento da matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2815">A <see cref="T:System.Type" /> that represents the element type of the array.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="ed4d0-2816">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2816">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2817">Cria um <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa a criação de uma matriz unidimensional e a inicialização dela de uma lista de elementos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2817">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating a one-dimensional array and initializing it from a list of elements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2818">Uma <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> e a propriedade <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2818">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2819">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de cada elemento de `initializers` deve representar um tipo que pode ser atribuído ao tipo representado pela `type`, possivelmente depois que estiver *entre aspas*.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2819">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must represent a type that is assignable to the type represented by `type`, possibly after it is *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ed4d0-2820">Um elemento será ser colocado entre aspas somente se `type` é <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2820">An element will be quoted only if `type` is <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="ed4d0-2821">Delimitação significa que o elemento é encapsulado em um <xref:System.Linq.Expressions.ExpressionType.Quote> nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2821">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="ed4d0-2822">O nó resultante é um <xref:System.Linq.Expressions.UnaryExpression> cujos <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriedade é o elemento de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2822">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `initializers`.</span></span>  
  
 <span data-ttu-id="ed4d0-2823">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.NewArrayExpression> representa uma matriz de tipo cuja posição é 1 e cujo tipo de elemento é `type`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2823">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is 1 and whose element type is `type`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-2824">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> método para criar uma árvore de expressão que representa a criação de uma matriz unidimensional de cadeia de caracteres que é inicializado com uma lista de expressões de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2824">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> method to create an expression tree that represents creating a one-dimensional string array that is initialized with a list of string expressions.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2825">
            <paramref name="type" /> ou <paramref name="initializers" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2825">
              <paramref name="type" /> or <paramref name="initializers" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ed4d0-2826">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2826">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2827">Um elemento de <paramref name="initializers" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2827">An element of <paramref name="initializers" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-2828">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento <paramref name="initializers" /> representa um tipo que não é atribuível ao tipo representado por <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2828">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="initializers" /> represents a type that is not assignable to the type that <paramref name="type" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayInit(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member NewArrayInit : Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayInit (type, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ed4d0-2829">Um <see cref="T:System.Type" /> que representa o tipo de elemento da matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2829">A <see cref="T:System.Type" /> that represents the element type of the array.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="ed4d0-2830">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2830">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2831">Cria um <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa a criação de uma matriz unidimensional e a inicialização dela de uma lista de elementos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2831">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating a one-dimensional array and initializing it from a list of elements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2832">Uma <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> e a propriedade <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2832">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2833">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de cada elemento de `initializers` deve representar um tipo que pode ser atribuído ao tipo representado pela `type`, possivelmente depois que estiver *entre aspas*.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2833">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must represent a type that is assignable to the type represented by `type`, possibly after it is *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ed4d0-2834">Um elemento será ser colocado entre aspas somente se `type` é <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2834">An element will be quoted only if `type` is <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="ed4d0-2835">Delimitação significa que o elemento é encapsulado em um <xref:System.Linq.Expressions.ExpressionType.Quote> nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2835">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="ed4d0-2836">O nó resultante é um <xref:System.Linq.Expressions.UnaryExpression> cujos <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriedade é o elemento de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2836">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `initializers`.</span></span>  
  
 <span data-ttu-id="ed4d0-2837">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.NewArrayExpression> representa uma matriz de tipo cuja posição é 1 e cujo tipo de elemento é `type`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2837">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is 1 and whose element type is `type`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-2838">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> método para criar uma árvore de expressão que representa a criação de uma matriz unidimensional de cadeia de caracteres que é inicializado com uma lista de expressões de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2838">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> method to create an expression tree that represents creating a one-dimensional string array that is initialized with a list of string expressions.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2839">
            <paramref name="type" /> ou <paramref name="initializers" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2839">
              <paramref name="type" /> or <paramref name="initializers" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ed4d0-2840">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2840">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2841">Um elemento de <paramref name="initializers" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2841">An element of <paramref name="initializers" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-2842">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="initializers" /> representa um tipo que não é atribuível ao tipo <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2842">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="initializers" /> represents a type that is not assignable to the type <paramref name="type" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.ExpressionType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Linq.Expressions.ExpressionType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NodeType As ExpressionType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Linq::Expressions::ExpressionType NodeType { System::Linq::Expressions::ExpressionType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Linq.Expressions.ExpressionType" Usage="System.Linq.Expressions.Expression.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ExpressionType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-2843">Obtém o tipo de nó deste <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2843">Gets the node type of this <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ed4d0-2844">Um dos valores de <see cref="T:System.Linq.Expressions.ExpressionType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2844">One of the <see cref="T:System.Linq.Expressions.ExpressionType" /> values.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2845">O <xref:System.Linq.Expressions.Expression.NodeType%2A> propriedade fornece uma descrição mais especializada de um <xref:System.Linq.Expressions.Expression> que apenas seu tipo derivado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2845">The <xref:System.Linq.Expressions.Expression.NodeType%2A> property provides a more specialized description of an <xref:System.Linq.Expressions.Expression> than just its derived type.</span></span> <span data-ttu-id="ed4d0-2846">Por exemplo, um <xref:System.Linq.Expressions.BinaryExpression> pode ser usado para representar muitos tipos diferentes de expressões binárias, como uma operação de divisão ou uma operação "maior que".</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2846">For example, a <xref:System.Linq.Expressions.BinaryExpression> can be used to represent many different kinds of binary expressions, such as a division operation or a "greater than" operation.</span></span> <span data-ttu-id="ed4d0-2847">O <xref:System.Linq.Expressions.Expression.NodeType%2A> propriedade descreveria essas expressões binárias, como <xref:System.Linq.Expressions.ExpressionType.Divide> e <xref:System.Linq.Expressions.ExpressionType.GreaterThan>, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2847">The <xref:System.Linq.Expressions.Expression.NodeType%2A> property would describe these binary expressions as <xref:System.Linq.Expressions.ExpressionType.Divide> and <xref:System.Linq.Expressions.ExpressionType.GreaterThan>, respectively.</span></span>  
  
 <span data-ttu-id="ed4d0-2848">O tipo CLR estático da expressão que o <xref:System.Linq.Expressions.Expression> representa de objeto é representado pelo <xref:System.Linq.Expressions.Expression.Type%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2848">The static CLR type of the expression that the <xref:System.Linq.Expressions.Expression> object represents is represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Not">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-2849">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de complemento bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2849">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a bitwise complement operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Not(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Not : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Not expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-2850">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2850">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2851">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de complemento bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2851">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a bitwise complement operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2852">Uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> e a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2852">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2853">O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2853">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="ed4d0-2854">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2854">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-2855">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2855">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-2856">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2856">Otherwise, they are `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-2857">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2857">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-2858">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2858">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-2859">Se `expression`. Tipo é um tipo definido pelo usuário que define o não operador unário de <xref:System.Reflection.MethodInfo> que representa que o método de implementação do operador é.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2859">If `expression`.Type is a user-defined type that defines the unary not operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-2860">Caso contrário, se `expression`. É um tipo numérico ou booliano, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2860">Otherwise, if `expression`.Type is a numeric or Boolean type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-2861">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2861">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-2862">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2862">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-2863">Se `expression`. O tipo é atribuível ao tipo de argumento do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2863">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-2864">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2864">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-2865">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2865">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-2866">`expression`. É um tipo de valor anulável e o tipo não anulável correspondente é igual ao tipo de argumento do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2866">`expression`.Type is a nullable value type and the corresponding non-nullable type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-2867">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2867">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-2868">Se for o método de implementação `null`, o tipo de nó é `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2868">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="ed4d0-2869">Se `expression`. Tipo não anulável, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2869">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-2870">Caso contrário, o nó é eliminado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2870">Otherwise, the node is lifted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-2871">O exemplo a seguir demonstra como criar uma expressão que representa uma operação lógica não a operação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2871">The following example demonstrates how to create an expression that represents a logical NOT operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#51)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#51)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2872">
            <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2872">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-2873">O não operador unário não é definido para <paramref name="expression" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2873">The unary not operator is not defined for <paramref name="expression" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Not(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Not : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Not (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-2874">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2874">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-2875">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2875">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2876">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de complemento bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2876">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a bitwise complement operation.</span>
          </span>
          <span data-ttu-id="ed4d0-2877">O método de implementação pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2877">The implementing method can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2878">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2878">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2879">O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2879">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="ed4d0-2880">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2880">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-2881">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2881">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-2882">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2882">Otherwise, they are `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-2883">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2883">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-2884">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2884">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-2885">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que aceita um argumento, ele é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2885">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="ed4d0-2886">Se `expression`. Tipo é um tipo definido pelo usuário que define o não operador unário de <xref:System.Reflection.MethodInfo> que representa que o método de implementação do operador é.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2886">If `expression`.Type is a user-defined type that defines the unary not operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-2887">Caso contrário, se `expression`. Tipo é um tipo numérico, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2887">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-2888">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2888">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-2889">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2889">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-2890">Se `expression`. O tipo é atribuível ao tipo de argumento do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2890">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-2891">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2891">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-2892">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2892">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-2893">`expression`. É um tipo de valor anulável e o tipo de valor não anulável correspondente é igual ao tipo de argumento do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2893">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-2894">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2894">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-2895">Se for o método de implementação `null`, o tipo de nó é `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2895">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="ed4d0-2896">Se `expression`. Tipo não anulável, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2896">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-2897">Caso contrário, o nó é eliminado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2897">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2898">
            <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2898">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2899">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente um argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2899">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-2900">
            <paramref name="method" /> é <see langword="null" /> e o operador não unário não foi definido para <paramref name="expression" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2900">
              <paramref name="method" /> is <see langword="null" /> and the unary not operator is not defined for <paramref name="expression" />.Type.</span>
          </span>
          <span data-ttu-id="ed4d0-2901">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2901">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-2902">
            <paramref name="expression" />.Type (ou o respectivo tipo que não permite valor nulo correspondente se ele é um tipo que permite valor nulo) não é atribuível ao tipo de argumento do método representado por <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2902">
              <paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NotEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-2903">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de desigualdade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2903">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an inequality comparison.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NotEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ NotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member NotEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.NotEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-2904">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2904">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-2905">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2905">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2906">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de desigualdade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2906">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an inequality comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2907">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2907">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2908">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2908">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-2909">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2909">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-2910">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2910">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="ed4d0-2911">Caso contrário, será `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2911">Otherwise, it is `false`.</span></span> <span data-ttu-id="ed4d0-2912">A propriedade <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> sempre é `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2912">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="ed4d0-2913">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2913">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-2914">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2914">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-2915">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2915">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-2916">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2916">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-2917">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de desigualdade, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2917">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the inequality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-2918">Caso contrário, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2918">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-2919">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2919">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-2920">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2920">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-2921">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2921">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-2922">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2922">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-2923">Se as duas seguintes condições forem atendidas, o nó é elevado e o tipo de nó é <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2923">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="ed4d0-2924">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2924">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-2925">O tipo de retorno do método de implementação é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2925">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="ed4d0-2926">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2926">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-2927">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2927">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-2928">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2928">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="ed4d0-2929">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2929">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-2930">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2930">The type of the node is <xref:System.Boolean>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2931">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2931">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-2932">O operador de desigualdade não está definido como <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2932">The inequality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NotEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ NotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member NotEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.NotEqual (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-2933">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2933">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-2934">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2934">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="liftToNull">
          <span data-ttu-id="ed4d0-2935">
            <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2935">
              <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-2936">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2936">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2937">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de desigualdade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2937">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an inequality comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2938">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2938">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2939">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2939">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-2940">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2940">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-2941">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true` e o <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedade é igual a `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2941">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="ed4d0-2942">Caso contrário, eles são ambos `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2942">Otherwise, they are both `false`.</span></span> <span data-ttu-id="ed4d0-2943">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2943">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-2944">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2944">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-2945">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2945">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-2946">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2946">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-2947">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2947">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-2948">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de desigualdade, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2948">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the inequality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-2949">Caso contrário, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2949">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-2950">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2950">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-2951">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2951">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-2952">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2952">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-2953">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2953">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-2954">Se as duas seguintes condições forem atendidas, o nó é eliminado; Além disso, o tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2954">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="ed4d0-2955">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2955">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-2956">O tipo de retorno do método de implementação é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2956">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="ed4d0-2957">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2957">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-2958">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2958">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-2959">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2959">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="ed4d0-2960">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2960">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-2961">O tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2961">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-2962">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2962">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-2963">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2963">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-2964">
            <paramref name="method" /> é <see langword="null" /> e o operador de desigualdade não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2964">
              <paramref name="method" /> is <see langword="null" /> and the inequality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OnesComplement">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-2965">Retorna a expressão que representa o complemento de um.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2965">Returns the expression representing the ones complement.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ OnesComplement(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member OnesComplement : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.OnesComplement expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-2966">Um <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2966">An <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2967">Retorna a expressão que representa o complemento de um.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2967">Returns the expression representing the ones complement.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2968">Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2968">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ OnesComplement(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member OnesComplement : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.OnesComplement (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-2969">Um <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2969">An <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-2970">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2970">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2971">Retorna a expressão que representa o complemento de um.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2971">Returns the expression representing the ones complement.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2972">Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2972">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Or">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-2973">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="OR" /> bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2973">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="OR" /> operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Or(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Or : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Or (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-2974">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2974">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-2975">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2975">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-2976">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="OR" /> bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2976">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="OR" /> operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-2977">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-2977">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-2978">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2978">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-2979">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2979">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-2980">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2980">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-2981">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2981">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-2982">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2982">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-2983">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2983">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-2984">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2984">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-2985">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2985">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-2986">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o bit a bit `OR` operador, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2986">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-2987">Caso contrário, se `left`. Tipo e `right`. Tipo são tipos de inteiros ou boolianos, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2987">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-2988">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2988">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-2989">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2989">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-2990">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2990">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-2991">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2991">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-2992">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2992">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-2993">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2993">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-2994">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2994">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-2995">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2995">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-2996">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2996">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-2997">O tipo do nó é o tipo de resultado de predefinida bit a bit `OR` operador.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2997">The type of the node is the result type of the predefined bitwise `OR` operator.</span></span>  
  
-   <span data-ttu-id="ed4d0-2998">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2998">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-2999">O tipo do nó é o tipo que permite valor nulo que corresponde ao tipo de resultado de predefinida bit a bit `OR` operador.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-2999">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `OR` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-3000">O exemplo de código a seguir mostra como criar uma expressão que representa uma operação OR lógica.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3000">The following code example shows how to create an expression that represents a logical OR operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#28)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-3001">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3001">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-3002">O operador <see langword="OR" /> bit a bit não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3002">The bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Or(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Or : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Or (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-3003">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3003">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-3004">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3004">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-3005">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3005">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3006">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="OR" /> bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3006">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="OR" /> operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3007">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3007">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-3008">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3008">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-3009">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3009">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-3010">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3010">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-3011">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3011">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-3012">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3012">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-3013">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3013">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-3014">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3014">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-3015">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3015">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-3016">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3016">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-3017">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o bit a bit `OR` operador, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3017">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-3018">Caso contrário, se `left`. Tipo e `right`. Tipo são tipos de inteiros ou boolianos, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3018">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-3019">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3019">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-3020">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3020">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-3021">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3021">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-3022">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3022">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-3023">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3023">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-3024">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3024">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-3025">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3025">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-3026">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3026">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-3027">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3027">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-3028">O tipo do nó é o tipo de resultado de predefinida bit a bit `OR` operador.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3028">The type of the node is the result type of the predefined bitwise `OR` operator.</span></span>  
  
-   <span data-ttu-id="ed4d0-3029">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3029">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-3030">O tipo do nó é o tipo que permite valor nulo que corresponde ao tipo de resultado de predefinida bit a bit `OR` operador.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3030">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `OR` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-3031">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3031">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-3032">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3032">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-3033">
            <paramref name="method" /> é <see langword="null" /> e o operador <see langword="OR" /> bit a bit não é definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3033">
              <paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-3034">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição OR bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3034">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member OrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-3035">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3035">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-3036">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3036">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3037">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição OR bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3037">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3038">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3038">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member OrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-3039">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3039">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-3040">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3040">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-3041">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3041">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3042">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição OR bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3042">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3043">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3043">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member OrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-3044">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3044">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-3045">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3045">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-3046">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3046">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="ed4d0-3047">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3047">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3048">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição OR bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3048">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3049">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3049">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrElse">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-3050">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação condicional <see langword="OR" /> que avalia o segundo operando somente se o primeiro operador é avaliado como <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3050">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="OR" /> operation that evaluates the second operand only if the first operator evaluates to <see langword="false" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrElse (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrElse(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member OrElse : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrElse (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-3051">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3051">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-3052">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3052">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3053">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="OR" /> condicional que avalia o segundo operando somente se o primeiro operando é avaliado como <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3053">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="OR" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="false" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3054">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3054">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-3055">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3055">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-3056">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3056">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-3057">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3057">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-3058">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3058">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-3059">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3059">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-3060">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3060">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-3061">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3061">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-3062">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3062">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-3063">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o bit a bit `OR` operador, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3063">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="ed4d0-3064">A condicional `OR` operador não pode ser sobrecarregado em c# ou Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3064">The conditional `OR` operator cannot be overloaded in C# or Visual Basic.</span></span> <span data-ttu-id="ed4d0-3065">No entanto, a condicional `OR` operador é avaliado usando o bit a bit `OR` operador.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3065">However, the conditional `OR` operator is evaluated by using the bitwise `OR` operator.</span></span> <span data-ttu-id="ed4d0-3066">Portanto, uma sobrecarga definido pelo usuário de bit a bit `OR` operador pode ser o método de implementação para esse tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3066">Thus, a user-defined overload of the bitwise `OR` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="ed4d0-3067">Caso contrário, se `left`. Tipo e `right`. Tipo são tipos boolianos, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3067">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-3068">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3068">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-3069">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3069">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-3070">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3070">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-3071">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3071">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-3072">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3072">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-3073">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável, e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3073">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-3074">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3074">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-3075">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3075">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-3076">`left`. Tipo e `right`. Tipo são do mesmo tipo booliano.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3076">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="ed4d0-3077">Se `left`. Tipo e `right`. Tipo não anulável, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3077">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-3078">O tipo do nó é o tipo de resultado da condicional predefinido `OR` operador.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3078">The type of the node is the result type of the predefined conditional `OR` operator.</span></span>  
  
-   <span data-ttu-id="ed4d0-3079">Se `left`. Tipo e `right`. Tipo que permite valor nulo, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3079">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-3080">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado da condicional predefinido `OR` operador.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3080">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `OR` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-3081">O exemplo de código a seguir mostra como criar uma expressão que representa uma operação lógica `OR` operação que avalia o segundo operando somente se o primeiro operando é avaliado para `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3081">The following code example shows how to create an expression that represents a logical `OR` operation that evaluates the second operand only if the first operand evaluates to `false`.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#29)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-3082">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3082">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-3083">O operador <see langword="OR" /> bit a bit não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3083">The bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
          <span data-ttu-id="ed4d0-3084">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3084">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-3085">
            <paramref name="left" />.Type e <paramref name="right" />.Type não são do mesmo tipo booliano.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3085">
              <paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrElse (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrElse(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member OrElse : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrElse (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-3086">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3086">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-3087">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3087">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-3088">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3088">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3089">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="OR" /> condicional que avalia o segundo operando somente se o primeiro operando é avaliado como <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3089">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="OR" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="false" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3090">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3090">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-3091">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3091">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-3092">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3092">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-3093">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3093">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-3094">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3094">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-3095">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3095">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-3096">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3096">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-3097">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3097">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-3098">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3098">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-3099">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3099">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="ed4d0-3100">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o bit a bit `OR` operador, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3100">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="ed4d0-3101">A condicional `OR` operador não pode ser sobrecarregado em c# ou Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3101">The conditional `OR` operator cannot be overloaded in C# or Visual Basic.</span></span> <span data-ttu-id="ed4d0-3102">No entanto, a condicional `OR` operador é avaliado usando o bit a bit `OR` operador.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3102">However, the conditional `OR` operator is evaluated by using the bitwise `OR` operator.</span></span> <span data-ttu-id="ed4d0-3103">Portanto, uma sobrecarga definido pelo usuário de bit a bit `OR` operador pode ser o método de implementação para esse tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3103">Thus, a user-defined overload of the bitwise `OR` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="ed4d0-3104">Caso contrário, se `left`. Tipo e `right`. Tipo são tipos boolianos, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3104">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-3105">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3105">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-3106">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3106">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-3107">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3107">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-3108">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3108">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-3109">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3109">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-3110">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável, e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3110">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-3111">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3111">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-3112">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3112">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-3113">`left`. Tipo e `right`. Tipo são do mesmo tipo booliano.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3113">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="ed4d0-3114">Se `left`. Tipo e `right`. Tipo não anulável, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3114">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-3115">O tipo do nó é o tipo de resultado da condicional predefinido `OR` operador.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3115">The type of the node is the result type of the predefined conditional `OR` operator.</span></span>  
  
-   <span data-ttu-id="ed4d0-3116">Se `left`. Tipo e `right`. Tipo que permite valor nulo, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3116">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-3117">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado da condicional predefinido `OR` operador.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3117">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `OR` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-3118">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3118">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-3119">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3119">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-3120">
            <paramref name="method" /> é <see langword="null" /> e o operador <see langword="OR" /> bit a bit não é definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3120">
              <paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
          <span data-ttu-id="ed4d0-3121">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3121">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-3122">
            <paramref name="method" /> é <see langword="null" /> e Type.<paramref name="left" /> e Type.<paramref name="right" /> não são do mesmo tipo booliano.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3122">
              <paramref name="method" /> is <see langword="null" /> and <paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parameter">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-3123">Cria um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que pode ser usado para identificar um parâmetro ou uma variável em uma árvore de expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3123">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Parameter(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Parameter : Type -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Parameter type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ed4d0-3124">O tipo do parâmetro ou da variável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3124">The type of the parameter or variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3125">Cria um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que pode ser usado para identificar um parâmetro ou uma variável em uma árvore de expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3125">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3126">Um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> com o nome e tipo especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3126">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> node with the specified name and type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ed4d0-3127">O exemplo a seguir demonstra como criar uma <xref:System.Linq.Expressions.MethodCallExpression> objeto que imprime o valor de um <xref:System.Linq.Expressions.ParameterExpression> objeto.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3127">The following example demonstrates how to create a <xref:System.Linq.Expressions.MethodCallExpression> object that prints the value of a <xref:System.Linq.Expressions.ParameterExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#49)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#49)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Parameter(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Parameter : Type * string -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Parameter (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ed4d0-3128">O tipo do parâmetro ou da variável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3128">The type of the parameter or variable.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="ed4d0-3129">O nome do parâmetro ou variável, usado para fins de depuração ou impressão apenas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3129">The name of the parameter or variable, used for debugging or printing purpose only.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3130">Cria um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que pode ser usado para identificar um parâmetro ou uma variável em uma árvore de expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3130">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3131">Um <see cref="T:System.Linq.Expressions.ParameterExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> e as propriedades <see cref="P:System.Linq.Expressions.Expression.Type" /> e <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3131">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> and the <see cref="P:System.Linq.Expressions.Expression.Type" /> and <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-3132">
            <paramref name="type" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3132">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="PostDecrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-3133">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a atribuição da expressão seguida de um decremento subsequente da expressão original em 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3133">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostDecrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PostDecrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostDecrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-3134">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3134">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3135">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a atribuição da expressão seguida de um decremento subsequente da expressão original em 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3135">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3136">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3136">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostDecrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PostDecrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostDecrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-3137">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3137">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-3138">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3138">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3139">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a atribuição da expressão seguida de um decremento subsequente da expressão original em 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3139">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3140">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3140">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PostIncrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-3141">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a atribuição da expressão seguida de um incremento de 1 à expressão original.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3141">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostIncrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PostIncrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostIncrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-3142">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3142">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3143">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a atribuição da expressão seguida de um incremento de 1 à expressão original.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3143">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3144">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3144">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostIncrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PostIncrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostIncrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-3145">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3145">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-3146">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3146">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3147">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a atribuição da expressão seguida de um incremento de 1 à expressão original.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3147">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3148">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3148">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Power">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-3149">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa a elevação de um número a uma potência.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3149">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising a number to a power.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Power (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Power(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Power : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Power (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-3150">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3150">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-3151">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3151">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3152">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa a elevação de um número a uma potência.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3152">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising a number to a power.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3153">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3153">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-3154">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3154">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-3155">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3155">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-3156">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3156">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-3157">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3157">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-3158">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3158">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-3159">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3159">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-3160">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3160">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-3161">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3161">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-3162">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de exponenciação, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3162">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the exponentiation operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-3163">Caso contrário, se `left`. Tipo e `right`. Tipo são ambos <xref:System.Double>, o método de implementação é <xref:System.Math.Pow%2A>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3163">Otherwise, if `left`.Type and `right`.Type are both <xref:System.Double>, the implementing method is <xref:System.Math.Pow%2A>.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-3164">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3164">Node Type and Lifted versus Non-Lifted</span></span>  
  
-   <span data-ttu-id="ed4d0-3165">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3165">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-3166">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3166">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-3167">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3167">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-3168">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3168">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-3169">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3169">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-3170">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3170">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-3171">O operador de exponenciação não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3171">The exponentiation operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
          <span data-ttu-id="ed4d0-3172">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3172">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-3173">
            <paramref name="left" />.Type e/ou <paramref name="right" />.Type não são <see cref="T:System.Double" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3173">
              <paramref name="left" />.Type and/or <paramref name="right" />.Type are not <see cref="T:System.Double" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Power (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Power(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Power : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Power (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-3174">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3174">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-3175">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3175">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-3176">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3176">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3177">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa a elevação de um número a uma potência.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3177">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising a number to a power.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3178">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3178">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-3179">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3179">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-3180">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3180">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-3181">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3181">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-3182">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3182">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-3183">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3183">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-3184">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3184">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-3185">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3185">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-3186">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3186">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-3187">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3187">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-3188">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de exponenciação, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3188">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the exponentiation operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-3189">Caso contrário, se `left`. Tipo e `right`. Tipo são ambos <xref:System.Double>, o método de implementação é <xref:System.Math.Pow%2A>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3189">Otherwise, if `left`.Type and `right`.Type are both <xref:System.Double>, the implementing method is <xref:System.Math.Pow%2A>.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-3190">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3190">Node Type and Lifted versus Non-Lifted</span></span>  
  
-   <span data-ttu-id="ed4d0-3191">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3191">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-3192">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3192">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-3193">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3193">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-3194">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3194">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-3195">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3195">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-3196">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3196">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-3197">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3197">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-3198">
            <paramref name="method" /> é <see langword="null" /> e o operador de exponenciação não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3198">
              <paramref name="method" /> is <see langword="null" /> and the exponentiation operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
          <span data-ttu-id="ed4d0-3199">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3199">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-3200">
            <paramref name="method" /> é <see langword="null" /> e <paramref name="left" />.Type e/ou <paramref name="right" />.Type não são <see cref="T:System.Double" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3200">
              <paramref name="method" /> is <see langword="null" /> and <paramref name="left" />.Type and/or <paramref name="right" />.Type are not <see cref="T:System.Double" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="PowerAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-3201">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa elevar uma expressão a uma potência e atribuir o resultado de volta à expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3201">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member PowerAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.PowerAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-3202">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3202">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-3203">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3203">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3204">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa elevar uma expressão a uma potência e atribuir o resultado de volta à expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3204">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3205">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3205">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PowerAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.PowerAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-3206">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3206">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-3207">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3207">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-3208">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3208">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3209">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa elevar uma expressão a uma potência e atribuir o resultado de volta à expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3209">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3210">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3210">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member PowerAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.PowerAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-3211">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3211">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-3212">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3212">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-3213">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3213">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="ed4d0-3214">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3214">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3215">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa elevar uma expressão a uma potência e atribuir o resultado de volta à expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3215">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3216">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3216">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PreDecrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-3217">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que decrementa a expressão por 1 e atribui o resultado de volta à expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3217">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that decrements the expression by 1 and assigns the result back to the expression.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreDecrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PreDecrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreDecrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-3218">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3218">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3219">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que decrementa a expressão por 1 e atribui o resultado de volta à expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3219">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that decrements the expression by 1 and assigns the result back to the expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3220">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3220">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreDecrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PreDecrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreDecrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-3221">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3221">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-3222">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3222">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3223">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que decrementa a expressão por 1 e atribui o resultado de volta à expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3223">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that decrements the expression by 1 and assigns the result back to the expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3224">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3224">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PreIncrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-3225">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que incrementa a expressão em 1 e atribui o resultado de volta à expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3225">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that increments the expression by 1 and assigns the result back to the expression.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreIncrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PreIncrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreIncrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-3226">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3226">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3227">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que incrementa a expressão em 1 e atribui o resultado de volta à expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3227">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that increments the expression by 1 and assigns the result back to the expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3228">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3228">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreIncrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PreIncrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreIncrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-3229">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3229">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-3230">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3230">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3231">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que incrementa a expressão em 1 e atribui o resultado de volta à expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3231">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that increments the expression by 1 and assigns the result back to the expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3232">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3232">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Property">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-3233">Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a uma propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3233">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo propertyAccessor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo propertyAccessor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ propertyAccessor);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, propertyAccessor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-3234">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3234">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property equal to.</span>
          </span>
          <span data-ttu-id="ed4d0-3235">Pode ser nulo para propriedades estáticas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3235">This can be null for static properties.</span>
          </span>
        </param>
        <param name="propertyAccessor">
          <span data-ttu-id="ed4d0-3236">O <see cref="T:System.Reflection.MethodInfo" /> que representa um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3236">The <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3237">Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a uma propriedade usando um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3237">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property by using a property accessor method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3238">Um <see cref="T:System.Linq.Expressions.MemberExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> definida como <paramref name="expression" /> e a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> definida como o <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade acessada em <paramref name="propertyAccessor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3238">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" /> and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-3239">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.MemberExpression> é igual ao <xref:System.Reflection.PropertyInfo.PropertyType%2A> propriedade <xref:System.Linq.Expressions.MemberExpression.Member%2A>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3239">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of <xref:System.Linq.Expressions.MemberExpression.Member%2A>.</span></span>  
  
 <span data-ttu-id="ed4d0-3240">Se o método representado por `propertyAccessor` está `static` (`Shared` no Visual Basic), `expression` pode ser `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3240">If the method represented by `propertyAccessor` is `static` (`Shared` in Visual Basic), `expression` can be `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-3241">
            <paramref name="propertyAccessor" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3241">
              <paramref name="propertyAccessor" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ed4d0-3242">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3242">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-3243">O método representado por <paramref name="propertyAccessor" /> não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) e <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3243">The method that <paramref name="propertyAccessor" /> represents is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic) and <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-3244">
            <paramref name="expression" />. O tipo não é atribuível ao tipo de declaração de método representada pelo <paramref name="propertyAccessor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3244">
              <paramref name="expression" />.Type is not assignable to the declaring type of the method represented by <paramref name="propertyAccessor" />.</span>
          </span>
          <span data-ttu-id="ed4d0-3245">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3245">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-3246">O método representado por <paramref name="propertyAccessor" /> não é um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3246">The method that <paramref name="propertyAccessor" /> represents is not a property accessor method.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.PropertyInfo property);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.PropertyInfo property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::Reflection::PropertyInfo ^ property);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="property" Type="System.Reflection.PropertyInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-3247">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3247">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property equal to.</span>
          </span>
          <span data-ttu-id="ed4d0-3248">Pode ser nulo para propriedades estáticas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3248">This can be null for static properties.</span>
          </span>
        </param>
        <param name="property">
          <span data-ttu-id="ed4d0-3249">O <see cref="T:System.Reflection.PropertyInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> propriedade será definida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3249">The <see cref="T:System.Reflection.PropertyInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3250">Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a uma propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3250">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3251">Um <see cref="T:System.Linq.Expressions.MemberExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> e <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3251">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> and the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> and <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-3252">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.MemberExpression> é igual ao <xref:System.Reflection.PropertyInfo.PropertyType%2A> propriedade <xref:System.Linq.Expressions.MemberExpression.Member%2A>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3252">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of <xref:System.Linq.Expressions.MemberExpression.Member%2A>.</span></span>  
  
 <span data-ttu-id="ed4d0-3253">Se a propriedade representada pelo `property` está `static` (`Shared` no Visual Basic), `expression` pode ser `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3253">If the property represented by `property` is `static` (`Shared` in Visual Basic), `expression` can be `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-3254">
            <paramref name="property" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3254">
              <paramref name="property" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ed4d0-3255">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3255">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-3256">A propriedade que o <paramref name="property" /> representa não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) e o <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3256">The property that <paramref name="property" /> represents is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic) and <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-3257">
            <paramref name="expression" />.Type não é atribuível ao tipo de declaração da propriedade que o <paramref name="property" /> representa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3257">
              <paramref name="expression" />.Type is not assignable to the declaring type of the property that <paramref name="property" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, propertyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-3258">Um <see cref="T:System.Linq.Expressions.Expression" /> cujo <see cref="P:System.Linq.Expressions.Expression.Type" /> contém uma propriedade chamada <c>propertyName</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3258">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> contains a property named <c>propertyName</c>.</span>
          </span>
          <span data-ttu-id="ed4d0-3259">Pode ser <see langword="null" /> para propriedades estáticas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3259">This can be <see langword="null" /> for static properties.</span>
          </span>
        </param>
        <param name="propertyName">
          <span data-ttu-id="ed4d0-3260">O nome de uma propriedade a ser acessada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3260">The name of a property to be accessed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3261">Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a uma propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3261">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3262">Um <see cref="T:System.Linq.Expressions.MemberExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> definida como <paramref name="expression" /> e a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> definida como o <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade indicada por <paramref name="propertyName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3262">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" />, and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property denoted by <paramref name="propertyName" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-3263">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.MemberExpression> é igual ao <xref:System.Reflection.PropertyInfo.PropertyType%2A> propriedade o <xref:System.Reflection.PropertyInfo> que representa a propriedade indicada por `propertyName`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3263">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of the <xref:System.Reflection.PropertyInfo> that represents the property denoted by `propertyName`.</span></span>  
  
 <span data-ttu-id="ed4d0-3264">Este método pesquisa `expression`. Tipo e seus tipos base para uma propriedade que tem o nome `propertyName`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3264">This method searches `expression`.Type and its base types for a property that has the name `propertyName`.</span></span> <span data-ttu-id="ed4d0-3265">Propriedades públicas terá preferência sobre propriedades não públicas.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3265">Public properties are given preference over non-public properties.</span></span> <span data-ttu-id="ed4d0-3266">Se uma propriedade correspondente for encontrada, esse método passa `expression` e o <xref:System.Reflection.PropertyInfo> que representa essa propriedade para <xref:System.Linq.Expressions.Expression.Property%2A>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3266">If a matching property is found, this method passes `expression` and the <xref:System.Reflection.PropertyInfo> that represents that property to <xref:System.Linq.Expressions.Expression.Property%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-3267">O exemplo a seguir mostra como criar uma expressão que representa o acesso a uma propriedade.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3267">The following example shows how to create an expression that represents accessing a property.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#38)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-3268">
            <paramref name="expression" /> ou <paramref name="propertyName" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3268">
              <paramref name="expression" /> or <paramref name="propertyName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-3269">Nenhuma propriedade nomeada <paramref name="propertyName" /> é definida no tipo <paramref name="expression" /> ou em seus tipos base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3269">No property named <paramref name="propertyName" /> is defined in <paramref name="expression" />.Type or its base types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, indexer As PropertyInfo, arguments As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.Property (instance, indexer, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance">
          <span data-ttu-id="ed4d0-3270">O objeto ao qual a propriedade pertence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3270">The object to which the property belongs.</span>
          </span>
          <span data-ttu-id="ed4d0-3271">Se a propriedade for estática/compartilhada, ela deverá ser nula.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3271">If the property is static/shared, it must be null.</span>
          </span>
        </param>
        <param name="indexer">
          <span data-ttu-id="ed4d0-3272">O <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade de índice.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3272">The <see cref="T:System.Reflection.PropertyInfo" /> that represents the property to index.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="ed4d0-3273">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> de objetos <see cref="T:System.Linq.Expressions.Expression" /> que são usados para indexar a propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3273">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Linq.Expressions.Expression" /> objects that are used to index the property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3274">Cria um <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa o acesso a uma propriedade indexada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3274">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> representing the access to an indexed property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3275">O <see cref="T:System.Linq.Expressions.IndexExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3275">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, indexer As PropertyInfo, ParamArray arguments As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.Property (instance, indexer, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">
          <span data-ttu-id="ed4d0-3276">O objeto ao qual a propriedade pertence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3276">The object to which the property belongs.</span>
          </span>
          <span data-ttu-id="ed4d0-3277">Se a propriedade for estática/compartilhada, ela deverá ser nula.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3277">If the property is static/shared, it must be null.</span>
          </span>
        </param>
        <param name="indexer">
          <span data-ttu-id="ed4d0-3278">O <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade de índice.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3278">The <see cref="T:System.Reflection.PropertyInfo" /> that represents the property to index.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="ed4d0-3279">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que são usados para a propriedade de índice.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3279">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that are used to index the property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3280">Cria um <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa o acesso a uma propriedade indexada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3280">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> representing the access to an indexed property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3281">O <see cref="T:System.Linq.Expressions.IndexExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3281">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, string propertyName, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, string propertyName, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, propertyName As String, ParamArray arguments As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::String ^ propertyName, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * string * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.Property (instance, propertyName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">
          <span data-ttu-id="ed4d0-3282">O objeto ao qual a propriedade pertence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3282">The object to which the property belongs.</span>
          </span>
          <span data-ttu-id="ed4d0-3283">Se a propriedade for estática/compartilhada, ela deverá ser nula.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3283">If the property is static/shared, it must be null.</span>
          </span>
        </param>
        <param name="propertyName">
          <span data-ttu-id="ed4d0-3284">O nome do indexador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3284">The name of the indexer.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="ed4d0-3285">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que são usados para a propriedade de índice.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3285">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that are used to index the property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3286">Cria um <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa o acesso a uma propriedade indexada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3286">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> representing the access to an indexed property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3287">O <see cref="T:System.Linq.Expressions.IndexExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3287">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, Type type, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Type type, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * Type * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, type, propertyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-3288">O objeto recipiente da propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3288">The containing object of the property.</span>
          </span>
          <span data-ttu-id="ed4d0-3289">Pode ser nulo para propriedades estáticas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3289">This can be null for static properties.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="ed4d0-3290">O <see cref="P:System.Linq.Expressions.Expression.Type" /> que contém a propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3290">The <see cref="P:System.Linq.Expressions.Expression.Type" /> that contains the property.</span>
          </span>
        </param>
        <param name="propertyName">
          <span data-ttu-id="ed4d0-3291">A propriedade a ser acessada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3291">The property to be accessed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3292">Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> acessando uma propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3292">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> accessing a property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3293">O <see cref="T:System.Linq.Expressions.MemberExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3293">The created <see cref="T:System.Linq.Expressions.MemberExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyOrField">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression PropertyOrField (System.Linq.Expressions.Expression expression, string propertyOrFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression PropertyOrField(class System.Linq.Expressions.Expression expression, string propertyOrFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ PropertyOrField(System::Linq::Expressions::Expression ^ expression, System::String ^ propertyOrFieldName);" />
      <MemberSignature Language="F#" Value="static member PropertyOrField : System.Linq.Expressions.Expression * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.PropertyOrField (expression, propertyOrFieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyOrFieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-3294">Um <see cref="T:System.Linq.Expressions.Expression" /> cujo <see cref="P:System.Linq.Expressions.Expression.Type" /> contém uma propriedade ou campo chamado <c>propertyOrFieldName</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3294">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> contains a property or field named <c>propertyOrFieldName</c>.</span>
          </span>
          <span data-ttu-id="ed4d0-3295">Isso pode ser nulo para membros estáticos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3295">This can be null for static members.</span>
          </span>
        </param>
        <param name="propertyOrFieldName">
          <span data-ttu-id="ed4d0-3296">O nome de uma propriedade ou campo a ser acessado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3296">The name of a property or field to be accessed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3297">Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a uma propriedade ou campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3297">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property or field.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3298">Um <see cref="T:System.Linq.Expressions.MemberExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> definida como <paramref name="expression" /> e a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> definida como o <see cref="T:System.Reflection.PropertyInfo" /> ou <see cref="T:System.Reflection.FieldInfo" /> que representa a propriedade indicada por <paramref name="propertyOrFieldName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3298">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" />, and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> or <see cref="T:System.Reflection.FieldInfo" /> that represents the property or field denoted by <paramref name="propertyOrFieldName" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-3299">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.MemberExpression> é igual ao <xref:System.Reflection.PropertyInfo.PropertyType%2A> ou <xref:System.Reflection.FieldInfo.FieldType%2A> propriedades do <xref:System.Reflection.PropertyInfo> ou <xref:System.Reflection.FieldInfo>, respectivamente, que representa a propriedade ou campo indicado por `propertyOrFieldName`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3299">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> or <xref:System.Reflection.FieldInfo.FieldType%2A> properties of the <xref:System.Reflection.PropertyInfo> or <xref:System.Reflection.FieldInfo>, respectively, that represents the property or field denoted by `propertyOrFieldName`.</span></span>  
  
 <span data-ttu-id="ed4d0-3300">Este método pesquisa `expression`. Tipo e seus tipos base para uma propriedade ou campo que tem o nome `propertyOrFieldName`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3300">This method searches `expression`.Type and its base types for a property or field that has the name `propertyOrFieldName`.</span></span> <span data-ttu-id="ed4d0-3301">Campos e propriedades públicas terá preferência sobre os campos e propriedades não públicas.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3301">Public properties and fields are given preference over non-public properties and fields.</span></span> <span data-ttu-id="ed4d0-3302">Além disso, as propriedades terá preferência em relação aos campos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3302">Also, properties are given preference over fields.</span></span> <span data-ttu-id="ed4d0-3303">Se uma propriedade ou campo de correspondência for encontrado, esse método passa `expression` e o <xref:System.Reflection.PropertyInfo> ou <xref:System.Reflection.FieldInfo> que representa essa propriedade ou campo para <xref:System.Linq.Expressions.Expression.Property%2A> ou <xref:System.Linq.Expressions.Expression.Field%2A>, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3303">If a matching property or field is found, this method passes `expression` and the <xref:System.Reflection.PropertyInfo> or <xref:System.Reflection.FieldInfo> that represents that property or field to <xref:System.Linq.Expressions.Expression.Property%2A> or <xref:System.Linq.Expressions.Expression.Field%2A>, respectively.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-3304">O exemplo a seguir mostra como criar uma expressão que representa o acesso a uma propriedade ou campo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3304">The following example shows how to create an expression that represents accessing a property or field.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#39)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#39)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-3305">
            <paramref name="expression" /> ou <paramref name="propertyOrFieldName" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3305">
              <paramref name="expression" /> or <paramref name="propertyOrFieldName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-3306">Nenhuma propriedade nomeado <paramref name="propertyOrFieldName" /> é definido em <paramref name="expression" />.Type ou em seus tipos base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3306">No property or field named <paramref name="propertyOrFieldName" /> is defined in <paramref name="expression" />.Type or its base types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Quote">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Quote (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Quote(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Quote(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Quote : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Quote expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-3307">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3307">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3308">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma expressão que tem um valor constante do tipo <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3308">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an expression that has a constant value of type <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3309">Uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> e a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3309">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-3310">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> representa o tipo construído <xref:System.Linq.Expressions.Expression%601>, em que o argumento de tipo é o tipo representado por `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3310">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> represents the constructed type <xref:System.Linq.Expressions.Expression%601>, where the type argument is the type represented by `expression`.Type.</span></span> <span data-ttu-id="ed4d0-3311">A propriedade <xref:System.Linq.Expressions.UnaryExpression.Method%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3311">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property is `null`.</span></span> <span data-ttu-id="ed4d0-3312">Ambos <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3312">Both <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> are `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-3313">
            <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3313">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Reduce">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.Expression Reduce ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Linq.Expressions.Expression Reduce() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Reduce" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Reduce () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Linq::Expressions::Expression ^ Reduce();" />
      <MemberSignature Language="F#" Value="abstract member Reduce : unit -&gt; System.Linq.Expressions.Expression&#xA;override this.Reduce : unit -&gt; System.Linq.Expressions.Expression" Usage="expression.Reduce " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-3314">Reduz esse nó a uma expressão mais simples.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3314">Reduces this node to a simpler expression.</span>
          </span>
          <span data-ttu-id="ed4d0-3315">Se CanReduce retornar true, ele deverá retornar uma expressão válida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3315">If CanReduce returns true, this should return a valid expression.</span>
          </span>
          <span data-ttu-id="ed4d0-3316">Esse método pode retornar outro nó que também precisa ser reduzido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3316">This method can return another node which itself must be reduced.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3317">A expressão reduzida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3317">The reduced expression.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceAndCheck">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceAndCheck ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceAndCheck() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceAndCheck" />
      <MemberSignature Language="VB.NET" Value="Public Function ReduceAndCheck () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Linq::Expressions::Expression ^ ReduceAndCheck();" />
      <MemberSignature Language="F#" Value="member this.ReduceAndCheck : unit -&gt; System.Linq.Expressions.Expression" Usage="expression.ReduceAndCheck " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-3318">Reduz esse nó a uma expressão mais simples.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3318">Reduces this node to a simpler expression.</span>
          </span>
          <span data-ttu-id="ed4d0-3319">Se CanReduce retornar true, ele deverá retornar uma expressão válida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3319">If CanReduce returns true, this should return a valid expression.</span>
          </span>
          <span data-ttu-id="ed4d0-3320">Esse método pode retornar outro nó que também precisa ser reduzido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3320">This method can return another node which itself must be reduced.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3321">A expressão reduzida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3321">The reduced expression.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-3322">Ao contrário de redução, esse método verifica que o nó reduzido atende a determinados invariáveis.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3322">Unlike Reduce, this method checks that the reduced node satisfies certain invariants.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceExtensions">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceExtensions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceExtensions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceExtensions" />
      <MemberSignature Language="VB.NET" Value="Public Function ReduceExtensions () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Linq::Expressions::Expression ^ ReduceExtensions();" />
      <MemberSignature Language="F#" Value="member this.ReduceExtensions : unit -&gt; System.Linq.Expressions.Expression" Usage="expression.ReduceExtensions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-3323">Reduz a expressão a um tipo de nó conhecido (que não é um nó de extensão) ou apenas retorna a expressão se ele já é um tipo conhecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3323">Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3324">A expressão reduzida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3324">The reduced expression.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ReferenceEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ReferenceEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ReferenceEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-3325">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3325">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-3326">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3326">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3327">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de igualdade de referência.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3327">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a reference equality comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3328">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3328">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceNotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceNotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceNotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceNotEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ReferenceNotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ReferenceNotEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ReferenceNotEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-3329">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3329">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-3330">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3330">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3331">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de desigualdade de referência.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3331">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a reference inequality comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3332">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3332">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Rethrow">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-3333">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa um relançamento de uma exceção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3333">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Rethrow () As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Rethrow();" />
      <MemberSignature Language="F#" Value="static member Rethrow : unit -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Rethrow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-3334">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa um relançamento de uma exceção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3334">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3335">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa um relançamento de uma exceção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3335">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Rethrow(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Rethrow : Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Rethrow type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ed4d0-3336">O novo <see cref="T:System.Type" /> da expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3336">The new <see cref="T:System.Type" /> of the expression.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3337">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa um relançamento de uma exceção com um determinado tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3337">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception with a given type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3338">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa um relançamento de uma exceção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3338">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Return">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-3339">Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa um demonstrativo de retorno.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3339">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Return (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="ed4d0-3340">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3340">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3341">Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa um demonstrativo de retorno.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3341">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3342">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Return, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" /> e um valor nulo a ser passado para o rótulo de destino ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3342">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Return, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and a null value to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Return (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="ed4d0-3343">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3343">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="ed4d0-3344">O valor que será passado para o rótulo associado ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3344">The value that will be passed to the associated label upon jumping.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3345">Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa um demonstrativo de retorno.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3345">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement.</span>
          </span>
          <span data-ttu-id="ed4d0-3346">O valor passado para o rótulo no salto pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3346">The value passed to the label upon jumping can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3347">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continuar, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida como <paramref name="target" /> e <paramref name="value" /> a ser passado para o rótulo de destino ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3347">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ed4d0-3348">O exemplo a seguir demonstra como criar uma expressão que contém o <xref:System.Linq.Expressions.Expression.Return%2A> método.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3348">The following example demonstrates how to create an expression that contains the <xref:System.Linq.Expressions.Expression.Return%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="ed4d0-3349">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3349">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="ed4d0-3350">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3350">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3351">Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução return com o tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3351">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement with the specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3352">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Return, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" />, a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" /> e um valor nulo a ser passado para o rótulo de destino ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3352">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Return, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and a null value to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return (target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="ed4d0-3353">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3353">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="ed4d0-3354">O valor que será passado para o rótulo associado ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3354">The value that will be passed to the associated label upon jumping.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="ed4d0-3355">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3355">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3356">Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução return com o tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3356">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement with the specified type.</span>
          </span>
          <span data-ttu-id="ed4d0-3357">O valor passado para o rótulo no salto pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3357">The value passed to the label upon jumping can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3358">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" />, a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" /> e <paramref name="value" /> a ser passado para o rótulo de destino ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3358">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RightShift">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-3359">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de deslocamento à direita bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3359">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShift (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member RightShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShift (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-3360">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3360">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-3361">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3361">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3362">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de deslocamento à direita bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3362">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3363">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3363">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-3364">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3364">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-3365">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3365">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-3366">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3366">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-3367">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3367">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-3368">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3368">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-3369">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3369">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-3370">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3370">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-3371">As seguintes regras de determinam o método de implementação selecionado para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3371">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-3372">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de deslocamento à direita, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3372">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the right-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-3373">Caso contrário, se `left`. Tipo é um tipo integral (um dos <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, ou os tipos que permitem valor nulos correspondentes) e `right`. É do tipo <xref:System.Int32>, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3373">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-3374">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3374">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-3375">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3375">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-3376">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3376">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-3377">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3377">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-3378">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3378">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-3379">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3379">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-3380">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3380">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-3381">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3381">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-3382">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3382">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-3383">O tipo do nó é o tipo de resultado do operador de deslocamento à direita predefinido.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3383">The type of the node is the result type of the predefined right-shift operator.</span></span>  
  
-   <span data-ttu-id="ed4d0-3384">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3384">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-3385">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de deslocamento à direita predefinido.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3385">The type of the node is the nullable type that corresponds to the result type of the predefined right-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-3386">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3386">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-3387">O operador de deslocamento à direita não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3387">The right-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShift (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member RightShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShift (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-3388">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3388">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-3389">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3389">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-3390">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3390">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3391">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de deslocamento à direita bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3391">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3392">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3392">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-3393">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3393">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-3394">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3394">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-3395">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3395">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-3396">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3396">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-3397">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3397">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-3398">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3398">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-3399">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3399">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-3400">As seguintes regras de determinam o método de implementação selecionado para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3400">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-3401">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3401">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="ed4d0-3402">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de deslocamento à direita, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3402">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the right-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-3403">Caso contrário, se `left`. Tipo é um tipo integral (um dos <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, ou os tipos que permitem valor nulos correspondentes) e `right`. É do tipo <xref:System.Int32>, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3403">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-3404">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3404">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-3405">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3405">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-3406">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3406">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-3407">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3407">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-3408">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3408">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-3409">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3409">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-3410">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3410">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-3411">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3411">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-3412">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3412">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-3413">O tipo do nó é o tipo de resultado do operador de deslocamento à direita predefinido.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3413">The type of the node is the result type of the predefined right-shift operator.</span></span>  
  
-   <span data-ttu-id="ed4d0-3414">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3414">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-3415">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de deslocamento à direita predefinido.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3415">The type of the node is the nullable type that corresponds to the result type of the predefined right-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-3416">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3416">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-3417">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3417">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-3418">
            <paramref name="method" /> é <see langword="null" /> e o operador de deslocamento à direita não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3418">
              <paramref name="method" /> is <see langword="null" /> and the right-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RightShiftAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-3419">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de deslocamento à direita bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3419">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member RightShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShiftAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-3420">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3420">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-3421">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3421">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3422">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de deslocamento à direita bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3422">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3423">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3423">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member RightShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShiftAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-3424">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3424">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-3425">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3425">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-3426">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3426">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3427">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de deslocamento à direita bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3427">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3428">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3428">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member RightShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShiftAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-3429">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3429">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-3430">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3430">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-3431">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3431">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="ed4d0-3432">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3432">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3433">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de deslocamento à direita bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3433">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3434">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3434">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RuntimeVariables">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-3435">Cria uma instância de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3435">Creates an instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RuntimeVariables (variables As IEnumerable(Of ParameterExpression)) As RuntimeVariablesExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::RuntimeVariablesExpression ^ RuntimeVariables(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables);" />
      <MemberSignature Language="F#" Value="static member RuntimeVariables : seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.RuntimeVariablesExpression" Usage="System.Linq.Expressions.Expression.RuntimeVariables variables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="variables">
          <span data-ttu-id="ed4d0-3436">Uma coleção de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3436">A collection of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3437">Cria uma instância de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3437">Creates an instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3438">Uma instância de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> e a propriedade <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3438">An instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> and the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (params System.Linq.Expressions.ParameterExpression[] variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Linq.Expressions.ParameterExpression[] variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RuntimeVariables (ParamArray variables As ParameterExpression()) As RuntimeVariablesExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::RuntimeVariablesExpression ^ RuntimeVariables(... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables);" />
      <MemberSignature Language="F#" Value="static member RuntimeVariables : System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.RuntimeVariablesExpression" Usage="System.Linq.Expressions.Expression.RuntimeVariables variables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables">
          <span data-ttu-id="ed4d0-3439">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3439">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3440">Cria uma instância de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3440">Creates an instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3441">Uma instância de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> e a propriedade <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3441">An instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> and the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Subtract">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-3442">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de subtração que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3442">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that does not have overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Subtract(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-3443">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3443">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-3444">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3444">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3445">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de subtração que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3445">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3446">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3446">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-3447">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3447">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-3448">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3448">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-3449">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3449">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-3450">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3450">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-3451">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3451">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-3452">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3452">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-3453">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3453">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-3454">As seguintes regras de determinam o método de implementação selecionado para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3454">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-3455">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de subtração, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3455">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-3456">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3456">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-3457">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3457">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-3458">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3458">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-3459">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3459">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-3460">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3460">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-3461">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3461">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-3462">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3462">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-3463">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3463">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-3464">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3464">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-3465">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3465">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-3466">O tipo do nó é o tipo de resultado do operador de subtração predefinidos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3466">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="ed4d0-3467">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3467">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-3468">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de subtração predefinidos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3468">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-3469">O exemplo de código a seguir mostra como criar uma expressão que subtrai o argumento do primeiro argumento.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3469">The following code example shows how to create an expression that subtracts the argument from the first argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#30)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-3470">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3470">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-3471">O operador de subtração não está definido como <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3471">The subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Subtract(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Subtract (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-3472">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3472">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-3473">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3473">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-3474">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3474">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3475">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de subtração que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3475">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3476">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3476">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-3477">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3477">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-3478">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3478">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-3479">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3479">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-3480">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3480">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-3481">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3481">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-3482">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3482">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-3483">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3483">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-3484">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3484">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-3485">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3485">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="ed4d0-3486">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de subtração, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3486">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-3487">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3487">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-3488">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3488">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-3489">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3489">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-3490">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3490">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-3491">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3491">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-3492">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3492">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-3493">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3493">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-3494">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3494">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-3495">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3495">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-3496">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3496">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-3497">O tipo do nó é o tipo de resultado do operador de subtração predefinidos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3497">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="ed4d0-3498">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3498">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-3499">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de subtração predefinidos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3499">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-3500">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3500">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-3501">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3501">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-3502">
            <paramref name="method" /> é <see langword="null" /> e o operador de subtração não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3502">
              <paramref name="method" /> is <see langword="null" /> and the subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-3503">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração que não tem a verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3503">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member SubtractAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-3504">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3504">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-3505">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3505">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3506">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração que não tem a verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3506">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3507">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3507">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member SubtractAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-3508">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3508">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-3509">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3509">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-3510">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3510">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3511">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração que não tem a verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3511">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3512">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3512">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member SubtractAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-3513">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3513">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-3514">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3514">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-3515">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3515">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="ed4d0-3516">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3516">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3517">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração que não tem a verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3517">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3518">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3518">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-3519">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3519">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member SubtractAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssignChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-3520">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3520">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-3521">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3521">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3522">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3522">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3523">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3523">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member SubtractAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssignChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-3524">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3524">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-3525">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3525">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-3526">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3526">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3527">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3527">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3528">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3528">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member SubtractAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssignChecked (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-3529">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3529">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-3530">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3530">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-3531">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3531">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="ed4d0-3532">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3532">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3533">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3533">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3534">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3534">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-3535">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de subtração que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3535">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that has overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member SubtractChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-3536">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3536">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-3537">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3537">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3538">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de subtração que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3538">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3539">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3539">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-3540">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3540">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-3541">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3541">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-3542">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3542">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-3543">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3543">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-3544">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3544">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-3545">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3545">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-3546">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3546">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-3547">As seguintes regras de determinam o método de implementação selecionado para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3547">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-3548">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de subtração, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3548">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-3549">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3549">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-3550">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3550">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-3551">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3551">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-3552">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3552">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-3553">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3553">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-3554">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3554">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-3555">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3555">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-3556">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3556">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-3557">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3557">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-3558">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3558">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-3559">O tipo do nó é o tipo de resultado do operador de subtração predefinidos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3559">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="ed4d0-3560">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3560">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-3561">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de subtração predefinidos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3561">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-3562">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3562">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-3563">O operador de subtração não está definido como <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3563">The subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member SubtractChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ed4d0-3564">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3564">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ed4d0-3565">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3565">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-3566">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3566">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3567">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de subtração que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3567">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3568">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3568">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-3569">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3569">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="ed4d0-3570">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3570">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-3571">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3571">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-3572">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3572">Otherwise, they are `false`.</span></span> <span data-ttu-id="ed4d0-3573">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3573">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="ed4d0-3574">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3574">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-3575">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3575">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-3576">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3576">The following rules determine the implementing method for the operation :</span></span>  
  
-   <span data-ttu-id="ed4d0-3577">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3577">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="ed4d0-3578">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de subtração, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3578">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-3579">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3579">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-3580">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3580">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-3581">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3581">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-3582">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3582">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-3583">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3583">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-3584">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3584">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-3585">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3585">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-3586">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3586">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-3587">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3587">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-3588">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3588">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-3589">O tipo do nó é o tipo de resultado do operador de subtração predefinidos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3589">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="ed4d0-3590">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3590">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="ed4d0-3591">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de subtração predefinidos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3591">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-3592">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3592">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-3593">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3593">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-3594">
            <paramref name="method" /> é <see langword="null" /> e o operador de subtração não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3594">
              <paramref name="method" /> is <see langword="null" /> and the subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Switch">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-3595">Cria uma <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa uma instrução <see langword="switch" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3595">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">
          <span data-ttu-id="ed4d0-3596">O valor a ser testado para cada caso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3596">The value to be tested against each case.</span>
          </span>
        </param>
        <param name="cases">
          <span data-ttu-id="ed4d0-3597">O conjunto de casos para esta expressão de comutador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3597">The set of cases for this switch expression.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3598">Cria uma <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa uma instrução <see langword="switch" /> sem um caso padrão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3598">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement without a default case.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3599">O <see cref="T:System.Linq.Expressions.SwitchExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3599">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-3600">Todos os <xref:System.Linq.Expressions.SwitchCase> objetos em um <xref:System.Linq.Expressions.SwitchExpression> objeto deve ter o mesmo tipo, a menos que o <xref:System.Linq.Expressions.SwitchExpression> tem o tipo `void`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3600">All <xref:System.Linq.Expressions.SwitchCase> objects in a <xref:System.Linq.Expressions.SwitchExpression> object must have the same type, unless the <xref:System.Linq.Expressions.SwitchExpression> has the type `void`.</span></span>  
  
 <span data-ttu-id="ed4d0-3601">Cada <xref:System.Linq.Expressions.SwitchCase> objeto tem implícito `break` instrução, o que significa que não há nenhum outono implícito por meio de um rótulo case para outro.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3601">Each <xref:System.Linq.Expressions.SwitchCase> object has an implicit `break` statement, which means that there is no implicit fall through from one case label to another.</span></span>  
  
 <span data-ttu-id="ed4d0-3602">Se `switchValue` não corresponde a nenhum dos casos, nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3602">If `switchValue` does not match any of the cases, no exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-3603">O exemplo a seguir demonstra como criar uma expressão que representa uma instrução de opção /Edit sem um caso padrão.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3603">The following example demonstrates how to create an expression that represents a swtich statement without a default case.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#34)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#34)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, defaultBody, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">
          <span data-ttu-id="ed4d0-3604">O valor a ser testado para cada caso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3604">The value to be tested against each case.</span>
          </span>
        </param>
        <param name="defaultBody">
          <span data-ttu-id="ed4d0-3605">O resultado da opção se <c>switchValue</c> não corresponde a nenhum dos casos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3605">The result of the switch if <c>switchValue</c> does not match any of the cases.</span>
          </span>
        </param>
        <param name="cases">
          <span data-ttu-id="ed4d0-3606">O conjunto de casos para esta expressão de comutador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3606">The set of cases for this switch expression.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3607">Cria um <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa uma instrução <see langword="switch" /> que tem um caso padrão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3607">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3608">O <see cref="T:System.Linq.Expressions.SwitchExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3608">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-3609">Todos os <xref:System.Linq.Expressions.SwitchCase> objetos em um <xref:System.Linq.Expressions.SwitchExpression> objeto deve ter o mesmo tipo, a menos que o <xref:System.Linq.Expressions.SwitchExpression> tem o tipo `void`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3609">All <xref:System.Linq.Expressions.SwitchCase> objects in a <xref:System.Linq.Expressions.SwitchExpression> object must have the same type, unless the <xref:System.Linq.Expressions.SwitchExpression> has the type `void`.</span></span>  
  
 <span data-ttu-id="ed4d0-3610">Cada <xref:System.Linq.Expressions.SwitchCase> objeto tem implícito `break` instrução, o que significa que não há nenhum outono implícito por meio de um rótulo case para outro.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3610">Each <xref:System.Linq.Expressions.SwitchCase> object has an implicit `break` statement, which means that there is no implicit fall through from one case label to another.</span></span>  
  
 <span data-ttu-id="ed4d0-3611">Se `switchValue` não corresponde a nenhum dos casos, o caso padrão representado por `defaultBody` é executado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3611">If `switchValue` does not match any of the cases, the default case represented by `defaultBody` is run.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-3612">O exemplo a seguir demonstra como criar uma expressão que representa uma instrução de opção /Edit que tem um caso padrão.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3612">The following example demonstrates how to create an expression that represents a swtich statement that has a default case.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, comparison As MethodInfo, cases As IEnumerable(Of SwitchCase)) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.SwitchCase&gt; -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" />
      </Parameters>
      <Docs>
        <param name="switchValue">
          <span data-ttu-id="ed4d0-3613">O valor a ser testado para cada caso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3613">The value to be tested against each case.</span>
          </span>
        </param>
        <param name="defaultBody">
          <span data-ttu-id="ed4d0-3614">O resultado da opção se <c>switchValue</c> não corresponde a nenhum dos casos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3614">The result of the switch if <c>switchValue</c> does not match any of the cases.</span>
          </span>
        </param>
        <param name="comparison">
          <span data-ttu-id="ed4d0-3615">O método de comparação de igualdade para usar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3615">The equality comparison method to use.</span>
          </span>
        </param>
        <param name="cases">
          <span data-ttu-id="ed4d0-3616">O conjunto de casos para esta expressão de comutador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3616">The set of cases for this switch expression.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3617">Cria um <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa uma instrução <see langword="switch" /> que tem um caso padrão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3617">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3618">O <see cref="T:System.Linq.Expressions.SwitchExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3618">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, comparison As MethodInfo, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">
          <span data-ttu-id="ed4d0-3619">O valor a ser testado para cada caso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3619">The value to be tested against each case.</span>
          </span>
        </param>
        <param name="defaultBody">
          <span data-ttu-id="ed4d0-3620">O resultado da opção se <c>switchValue</c> não corresponde a nenhum dos casos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3620">The result of the switch if <c>switchValue</c> does not match any of the cases.</span>
          </span>
        </param>
        <param name="comparison">
          <span data-ttu-id="ed4d0-3621">O método de comparação de igualdade para usar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3621">The equality comparison method to use.</span>
          </span>
        </param>
        <param name="cases">
          <span data-ttu-id="ed4d0-3622">O conjunto de casos para esta expressão de comutador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3622">The set of cases for this switch expression.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3623">Cria um <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa uma instrução <see langword="switch" /> que tem um caso padrão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3623">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3624">O <see cref="T:System.Linq.Expressions.SwitchExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3624">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(Type ^ type, System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.SwitchCase&gt; -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (type, switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ed4d0-3625">O tipo de resultado da opção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3625">The result type of the switch.</span>
          </span>
        </param>
        <param name="switchValue">
          <span data-ttu-id="ed4d0-3626">O valor a ser testado para cada caso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3626">The value to be tested against each case.</span>
          </span>
        </param>
        <param name="defaultBody">
          <span data-ttu-id="ed4d0-3627">O resultado da opção se <c>switchValue</c> não corresponde a nenhum dos casos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3627">The result of the switch if <c>switchValue</c> does not match any of the cases.</span>
          </span>
        </param>
        <param name="comparison">
          <span data-ttu-id="ed4d0-3628">O método de comparação de igualdade para usar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3628">The equality comparison method to use.</span>
          </span>
        </param>
        <param name="cases">
          <span data-ttu-id="ed4d0-3629">O conjunto de casos para esta expressão de comutador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3629">The set of cases for this switch expression.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3630">Cria um <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa uma instrução <see langword="switch" /> que tem um caso padrão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3630">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3631">O <see cref="T:System.Linq.Expressions.SwitchExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3631">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(Type ^ type, System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (type, switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ed4d0-3632">O tipo de resultado da opção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3632">The result type of the switch.</span>
          </span>
        </param>
        <param name="switchValue">
          <span data-ttu-id="ed4d0-3633">O valor a ser testado para cada caso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3633">The value to be tested against each case.</span>
          </span>
        </param>
        <param name="defaultBody">
          <span data-ttu-id="ed4d0-3634">O resultado da opção se <c>switchValue</c> não corresponde a nenhum dos casos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3634">The result of the switch if <c>switchValue</c> does not match any of the cases.</span>
          </span>
        </param>
        <param name="comparison">
          <span data-ttu-id="ed4d0-3635">O método de comparação de igualdade para usar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3635">The equality comparison method to use.</span>
          </span>
        </param>
        <param name="cases">
          <span data-ttu-id="ed4d0-3636">O conjunto de casos para esta expressão de comutador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3636">The set of cases for this switch expression.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3637">Cria um <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa uma instrução <see langword="switch" /> que tem um caso padrão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3637">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case..</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3638">O <see cref="T:System.Linq.Expressions.SwitchExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3638">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SwitchCase">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-3639">Cria um objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> a ser usado em um objeto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3639">Creates a <see cref="T:System.Linq.Expressions.SwitchCase" /> object to be used in a <see cref="T:System.Linq.Expressions.SwitchExpression" /> object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SwitchCase (body As Expression, testValues As IEnumerable(Of Expression)) As SwitchCase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchCase ^ SwitchCase(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ testValues);" />
      <MemberSignature Language="F#" Value="static member SwitchCase : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.SwitchCase" Usage="System.Linq.Expressions.Expression.SwitchCase (body, testValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="testValues" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="ed4d0-3640">O corpo do caso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3640">The body of the case.</span>
          </span>
        </param>
        <param name="testValues">
          <span data-ttu-id="ed4d0-3641">Os valores de teste do caso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3641">The test values of the case.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3642">Cria um objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> a ser usado em um objeto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3642">Creates a <see cref="T:System.Linq.Expressions.SwitchCase" /> object to be used in a <see cref="T:System.Linq.Expressions.SwitchExpression" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3643">O <see cref="T:System.Linq.Expressions.SwitchCase" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3643">The created <see cref="T:System.Linq.Expressions.SwitchCase" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-3644">Todos os <xref:System.Linq.Expressions.SwitchCase> objetos em um <xref:System.Linq.Expressions.SwitchExpression> objeto deve ter o mesmo tipo, a menos que o <xref:System.Linq.Expressions.SwitchExpression> tem o tipo `void`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3644">All <xref:System.Linq.Expressions.SwitchCase> objects in a <xref:System.Linq.Expressions.SwitchExpression> object must have the same type, unless the <xref:System.Linq.Expressions.SwitchExpression> has the type `void`.</span></span>  
  
 <span data-ttu-id="ed4d0-3645">Cada <xref:System.Linq.Expressions.SwitchCase> objeto tem implícito `break` instrução, o que significa que não há nenhum outono implícito por meio de um rótulo case para outro.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3645">Each <xref:System.Linq.Expressions.SwitchCase> object has an implicit `break` statement, which means that there is no implicit fall through from one case label to another.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-3646">O exemplo a seguir demonstra como criar uma expressão que representa uma instrução de opção /Edit que tem um caso padrão.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3646">The following example demonstrates how to create an expression that represents a swtich statement that has a default case.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, params System.Linq.Expressions.Expression[] testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression[] testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SwitchCase (body As Expression, ParamArray testValues As Expression()) As SwitchCase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchCase ^ SwitchCase(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ testValues);" />
      <MemberSignature Language="F#" Value="static member SwitchCase : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.SwitchCase" Usage="System.Linq.Expressions.Expression.SwitchCase (body, testValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="testValues" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="ed4d0-3647">O corpo do caso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3647">The body of the case.</span>
          </span>
        </param>
        <param name="testValues">
          <span data-ttu-id="ed4d0-3648">Os valores de teste do caso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3648">The test values of the case.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3649">Cria um <see cref="T:System.Linq.Expressions.SwitchCase" /> para uso em um <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3649">Creates a <see cref="T:System.Linq.Expressions.SwitchCase" /> for use in a <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3650">O <see cref="T:System.Linq.Expressions.SwitchCase" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3650">The created <see cref="T:System.Linq.Expressions.SwitchCase" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SymbolDocument">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-3651">Cria uma instância de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3651">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="ed4d0-3652">Uma <see cref="T:System.String" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3652">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3653">Cria uma instância de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3653">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3654">Um <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tem a propriedade <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3654">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string * Guid -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument (fileName, language)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="ed4d0-3655">Uma <see cref="T:System.String" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3655">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span>
          </span>
        </param>
        <param name="language">
          <span data-ttu-id="ed4d0-3656">Uma <see cref="T:System.Guid" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3656">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3657">Cria uma instância de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3657">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3658">Um <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tem as propriedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> e <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> definidas para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3658">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> properties set to the specified value.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid, languageVendor As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language, Guid languageVendor);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string * Guid * Guid -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument (fileName, language, languageVendor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="ed4d0-3659">Uma <see cref="T:System.String" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3659">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span>
          </span>
        </param>
        <param name="language">
          <span data-ttu-id="ed4d0-3660">Uma <see cref="T:System.Guid" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3660">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> equal to.</span>
          </span>
        </param>
        <param name="languageVendor">
          <span data-ttu-id="ed4d0-3661">Uma <see cref="T:System.Guid" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3661">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3662">Cria uma instância de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3662">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3663">Um <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tem as propriedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> e <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> definidas para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3663">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> properties set to the specified value.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor, valuetype System.Guid documentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid, languageVendor As Guid, documentType As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string * Guid * Guid * Guid -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument (fileName, language, languageVendor, documentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
        <Parameter Name="documentType" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="ed4d0-3664">Uma <see cref="T:System.String" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3664">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span>
          </span>
        </param>
        <param name="language">
          <span data-ttu-id="ed4d0-3665">Uma <see cref="T:System.Guid" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3665">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> equal to.</span>
          </span>
        </param>
        <param name="languageVendor">
          <span data-ttu-id="ed4d0-3666">Uma <see cref="T:System.Guid" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3666">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> equal to.</span>
          </span>
        </param>
        <param name="documentType">
          <span data-ttu-id="ed4d0-3667">Uma <see cref="T:System.Guid" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3667">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3668">Cria uma instância de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3668">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3669">Um <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tem as propriedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> e <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> definidas para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3669">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> properties set to the specified value.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Throw">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-3670">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma geração de uma exceção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3670">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a throwing of an exception.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Throw (value As Expression) As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Throw(System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Throw : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Throw value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="ed4d0-3671">Um <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3671">An <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3672">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma geração de uma exceção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3672">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a throwing of an exception.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3673">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a exceção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3673">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the exception.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ed4d0-3674">O exemplo a seguir demonstra como criar uma <xref:System.Linq.Expressions.TryExpression> objeto que usa o <xref:System.Linq.Expressions.Expression.Throw%2A> método.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3674">The following example demonstrates how to create a <xref:System.Linq.Expressions.TryExpression> object that uses the <xref:System.Linq.Expressions.Expression.Throw%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Throw(System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Throw : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Throw (value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="ed4d0-3675">Um <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3675">An <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="ed4d0-3676">O novo <see cref="T:System.Type" /> da expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3676">The new <see cref="T:System.Type" /> of the expression.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3677">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa um lançamento de uma exceção com um determinado tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3677">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a throwing of an exception with a given type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3678">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a exceção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3678">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the exception.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="expression.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-3679">Retorna uma representação textual de <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3679">Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3680">Uma representação textual de <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3680">A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatch (System.Linq.Expressions.Expression body, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatch(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCatch (body As Expression, ParamArray handlers As CatchBlock()) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryCatch(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberSignature Language="F#" Value="static member TryCatch : System.Linq.Expressions.Expression * System.Linq.Expressions.CatchBlock[] -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryCatch (body, handlers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="ed4d0-3681">O corpo do bloco try.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3681">The body of the try block.</span>
          </span>
        </param>
        <param name="handlers">
          <span data-ttu-id="ed4d0-3682">A matriz de zero ou mais expressões <see cref="T:System.Linq.Expressions.CatchBlock" /> representando as instruções catch a serem associados com o bloco try.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3682">The array of zero or more <see cref="T:System.Linq.Expressions.CatchBlock" /> expressions representing the catch statements to be associated with the try block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3683">Cria um <see cref="T:System.Linq.Expressions.TryExpression" /> representando um bloco try com qualquer número de instruções catch e nem um bloco fault nem finally.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3683">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with any number of catch statements and neither a fault nor finally block.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3684">O <see cref="T:System.Linq.Expressions.TryExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3684">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ed4d0-3685">O exemplo a seguir demonstra como criar um <xref:System.Linq.Expressions.TryExpression> objeto que contém uma instrução catch.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3685">The following example demonstrates how to create a <xref:System.Linq.Expressions.TryExpression> object that contains a catch statement.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatchFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatchFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatchFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCatchFinally (body As Expression, finally As Expression, ParamArray handlers As CatchBlock()) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryCatchFinally(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally, ... cli::array &lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberSignature Language="F#" Value="static member TryCatchFinally : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.CatchBlock[] -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryCatchFinally (body, finally, handlers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="ed4d0-3686">O corpo do bloco try.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3686">The body of the try block.</span>
          </span>
        </param>
        <param name="finally">
          <span data-ttu-id="ed4d0-3687">O corpo do bloco finally.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3687">The body of the finally block.</span>
          </span>
        </param>
        <param name="handlers">
          <span data-ttu-id="ed4d0-3688">A matriz de zero ou mais expressões <see cref="T:System.Linq.Expressions.CatchBlock" /> representando as instruções catch a serem associados com o bloco try.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3688">The array of zero or more <see cref="T:System.Linq.Expressions.CatchBlock" /> expressions representing the catch statements to be associated with the try block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3689">Cria uma <see cref="T:System.Linq.Expressions.TryExpression" /> representando um bloco try com qualquer número de instruções catch e um bloco finally.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3689">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with any number of catch statements and a finally block.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3690">O <see cref="T:System.Linq.Expressions.TryExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3690">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ed4d0-3691">O exemplo a seguir demonstra como criar um <xref:System.Linq.Expressions.TryExpression> objeto que contém uma instrução catch e uma instrução finally.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3691">The following example demonstrates how to create a <xref:System.Linq.Expressions.TryExpression> object that contains a catch statement and a finally statement.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#48)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#48)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFault">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFault (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression fault);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFault(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression fault) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFault (body As Expression, fault As Expression) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryFault(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ fault);" />
      <MemberSignature Language="F#" Value="static member TryFault : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryFault (body, fault)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="ed4d0-3692">O corpo do bloco try.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3692">The body of the try block.</span>
          </span>
        </param>
        <param name="fault">
          <span data-ttu-id="ed4d0-3693">O corpo do bloco de falha.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3693">The body of the fault block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3694">Cria uma <see cref="T:System.Linq.Expressions.TryExpression" /> representando um bloco try com um bloco fault e nenhuma instrução catch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3694">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with a fault block and no catch statements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3695">O <see cref="T:System.Linq.Expressions.TryExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3695">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFinally (body As Expression, finally As Expression) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryFinally(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally);" />
      <MemberSignature Language="F#" Value="static member TryFinally : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryFinally (body, finally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="ed4d0-3696">O corpo do bloco try.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3696">The body of the try block.</span>
          </span>
        </param>
        <param name="finally">
          <span data-ttu-id="ed4d0-3697">O corpo do bloco finally.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3697">The body of the finally block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3698">Cria uma <see cref="T:System.Linq.Expressions.TryExpression" /> representando um bloco try com um bloco finally e nenhuma instrução catch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3698">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with a finally block and no catch statements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3699">O <see cref="T:System.Linq.Expressions.TryExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3699">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetActionType">
      <MemberSignature Language="C#" Value="public static bool TryGetActionType (Type[] typeArgs, out Type actionType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetActionType(class System.Type[] typeArgs, [out] class System.Type&amp; actionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetActionType (typeArgs As Type(), ByRef actionType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetActionType(cli::array &lt;Type ^&gt; ^ typeArgs, [Runtime::InteropServices::Out] Type ^ % actionType);" />
      <MemberSignature Language="F#" Value="static member TryGetActionType : Type[] *  -&gt; bool" Usage="System.Linq.Expressions.Expression.TryGetActionType (typeArgs, actionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" />
        <Parameter Name="actionType" Type="System.Type" RefType="out" />
      </Parameters>
      <Docs>
        <param name="typeArgs">
          <span data-ttu-id="ed4d0-3700">Uma matriz de objetos Type que especifica os argumentos de tipo para o tipo de delegado System.Action.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3700">An array of Type objects that specify the type arguments for the System.Action delegate type.</span>
          </span>
        </param>
        <param name="actionType">
          <span data-ttu-id="ed4d0-3701">Quando esse método retorna, ele contém o tipo de delegado genérico System.Action, que tem argumentos de tipo específicos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3701">When this method returns, contains the generic System.Action delegate type that has specific type arguments.</span>
          </span>
          <span data-ttu-id="ed4d0-3702">Conterá null se não houver nenhum delegado System.Action genérico que corresponda ao <c>typeArgs</c>. Esse parâmetro é passado não inicializado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3702">Contains null if there is no generic System.Action delegate that matches the <c>typeArgs</c>.This parameter is passed uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3703">Cria um objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa um tipo de delegado genérico System.Action que tem argumentos de tipo específicos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3703">Creates a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic System.Action delegate type that has specific type arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3704">true se o tipo de delegado genérico System.Action foi criado para um <paramref name="typeArgs" /> específico; caso contrário, false.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3704">true if generic System.Action delegate type was created for specific <paramref name="typeArgs" />; false otherwise.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetFuncType">
      <MemberSignature Language="C#" Value="public static bool TryGetFuncType (Type[] typeArgs, out Type funcType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetFuncType(class System.Type[] typeArgs, [out] class System.Type&amp; funcType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetFuncType (typeArgs As Type(), ByRef funcType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetFuncType(cli::array &lt;Type ^&gt; ^ typeArgs, [Runtime::InteropServices::Out] Type ^ % funcType);" />
      <MemberSignature Language="F#" Value="static member TryGetFuncType : Type[] *  -&gt; bool" Usage="System.Linq.Expressions.Expression.TryGetFuncType (typeArgs, funcType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" />
        <Parameter Name="funcType" Type="System.Type" RefType="out" />
      </Parameters>
      <Docs>
        <param name="typeArgs">
          <span data-ttu-id="ed4d0-3705">Uma matriz de objetos Type que especifica os argumentos de tipo para o tipo de delegado System.Func.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3705">An array of Type objects that specify the type arguments for the System.Func delegate type.</span>
          </span>
        </param>
        <param name="funcType">
          <span data-ttu-id="ed4d0-3706">Quando esse método retorna, ele contém o tipo de delegado genérico System.Func, que tem argumentos de tipo específicos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3706">When this method returns, contains the generic System.Func delegate type that has specific type arguments.</span>
          </span>
          <span data-ttu-id="ed4d0-3707">Conterá null se não houver nenhum delegado System.Func genérico que corresponda ao <c>typeArgs</c>. Esse parâmetro é passado não inicializado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3707">Contains null if there is no generic System.Func delegate that matches the <c>typeArgs</c>.This parameter is passed uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3708">Cria um objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa um tipo de delegado genérico System.Func, que tem argumentos de tipo específicos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3708">Creates a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic System.Func delegate type that has specific type arguments.</span>
          </span>
          <span data-ttu-id="ed4d0-3709">O último argumento de tipo especifica o tipo de retorno do delegado criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3709">The last type argument specifies the return type of the created delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3710">true se o tipo de delegado genérico System.Func foi criado para um <paramref name="typeArgs" /> específico; caso contrário, false.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3710">true if generic System.Func delegate type was created for specific <paramref name="typeArgs" />; false otherwise.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public virtual Type Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type Type" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.Type" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Type As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ Type { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Type : Type" Usage="System.Linq.Expressions.Expression.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-3711">Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3711">Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" /> represents.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ed4d0-3712">O <see cref="T:System.Type" /> que representa o tipo estático da expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3712">The <see cref="T:System.Type" /> that represents the static type of the expression.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-3713">O <xref:System.Linq.Expressions.Expression.NodeType%2A> é o tipo de nó de árvore de expressão, enquanto o <xref:System.Linq.Expressions.Expression.Type%2A> representa o estático tipo common language runtime (CLR) da expressão que representa o nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3713">The <xref:System.Linq.Expressions.Expression.NodeType%2A> is the type of the expression tree node, whereas the <xref:System.Linq.Expressions.Expression.Type%2A> represents the static common language runtime (CLR) type of the expression that the node represents.</span></span> <span data-ttu-id="ed4d0-3714">Por exemplo, dois nós com diferentes tipos de nó podem ter o mesmo <xref:System.Linq.Expressions.Expression.Type%2A>, conforme mostrado no exemplo de código a seguir.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3714">For example, two nodes with different node types can have the same <xref:System.Linq.Expressions.Expression.Type%2A>, as shown in the following code example.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#36)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#36)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeAs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression TypeAs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression TypeAs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ TypeAs(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member TypeAs : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.TypeAs (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-3715">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3715">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="ed4d0-3716">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3716">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3717">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma conversão boxing ou de referência explícita em que <see langword="null" /> será fornecido se a conversão falhar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3717">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an explicit reference or boxing conversion where <see langword="null" /> is supplied if the conversion fails.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3718">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3718">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-3719">O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3719">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is `null`.</span></span> <span data-ttu-id="ed4d0-3720">O <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> propriedades estiverem `false`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3720">The <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> properties are both `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-3721">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.TypeAs%28System.Linq.Expressions.Expression%2CSystem.Type%29> método para criar um <xref:System.Linq.Expressions.UnaryExpression> que representa a conversão de referência de uma expressão de inteiro não nulo para o tipo de inteiro que permite valor nulo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3721">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.TypeAs%28System.Linq.Expressions.Expression%2CSystem.Type%29> method to create a <xref:System.Linq.Expressions.UnaryExpression> that represents the reference conversion of a non-nullable integer expression to the nullable integer type.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#11)]
 [!code-vb[System.Linq.Expressions.Expression#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-3722">
            <paramref name="expression" /> ou <paramref name="type" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3722">
              <paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TypeEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeEqual (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeEqual(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TypeBinaryExpression ^ TypeEqual(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member TypeEqual : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.TypeBinaryExpression" Usage="System.Linq.Expressions.Expression.TypeEqual (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-3723">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="T:System.Linq.Expressions.Expression" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3723">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="T:System.Linq.Expressions.Expression" /> property equal to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="ed4d0-3724">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3724">A <see cref="P:System.Linq.Expressions.Expression.Type" /> to set the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3725">Cria uma <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> que compara a identidade de tipo de tempo de execução.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3725">Creates a <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> that compares run-time type identity.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3726">Uma <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> para a qual a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> é igual a <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> e para a qual as propriedades <see cref="T:System.Linq.Expressions.Expression" /> e <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> estão definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3726">A <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> for which the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property is equal to <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> and for which the <see cref="T:System.Linq.Expressions.Expression" /> and <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> properties are set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeIs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeIs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeIs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TypeBinaryExpression ^ TypeIs(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member TypeIs : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.TypeBinaryExpression" Usage="System.Linq.Expressions.Expression.TypeIs (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-3727">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3727">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> property equal to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="ed4d0-3728">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3728">A <see cref="P:System.Linq.Expressions.Expression.Type" /> to set the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3729">Cria um <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3729">Creates a <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3730">Uma <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> para a qual a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> é igual a <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> e para a qual as propriedades <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> e <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> estão definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3730">A <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> for which the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property is equal to <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> and for which the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> and <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> properties are set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-3731">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> representa <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3731">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> represents <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ed4d0-3732">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.TypeIs%28System.Linq.Expressions.Expression%2CSystem.Type%29> método para criar um <xref:System.Linq.Expressions.TypeBinaryExpression> que representa um teste de tipo de um valor de cadeia de caracteres em relação a <xref:System.Int32> tipo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3732">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.TypeIs%28System.Linq.Expressions.Expression%2CSystem.Type%29> method to create a <xref:System.Linq.Expressions.TypeBinaryExpression> that represents a type test of a string value against the <xref:System.Int32> type.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#12)]
 [!code-vb[System.Linq.Expressions.Expression#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-3733">
            <paramref name="expression" /> ou <paramref name="type" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3733">
              <paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnaryPlus">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-3734">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação unária de adição.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3734">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a unary plus operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ UnaryPlus(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member UnaryPlus : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.UnaryPlus expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-3735">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3735">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3736">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação unária de adição.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3736">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a unary plus operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3737">Uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> e a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3737">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-3738">O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3738">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="ed4d0-3739">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3739">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-3740">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3740">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-3741">Caso contrário, eles são falsos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3741">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-3742">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3742">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-3743">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3743">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-3744">Se `expression`. Tipo é um tipo definido pelo usuário que define o operador unário de adição, o <xref:System.Reflection.MethodInfo> que representa que o método de implementação do operador é.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3744">If `expression`.Type is a user-defined type that defines the unary plus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-3745">Caso contrário, se `expression`. Tipo é um tipo numérico, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3745">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-3746">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3746">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-3747">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3747">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-3748">Se `expression`. O tipo é atribuível ao tipo de argumento do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3748">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-3749">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3749">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-3750">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3750">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-3751">`expression`. É um tipo de valor anulável e o tipo de valor não anulável correspondente é igual ao tipo de argumento do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3751">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-3752">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3752">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-3753">Se for o método de implementação `null`, o tipo de nó é `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3753">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="ed4d0-3754">Se `expression`. Tipo não anulável, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3754">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-3755">Caso contrário, o nó é eliminado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3755">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-3756">
            <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3756">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-3757">O operador de mais unário não foi definido para <paramref name="expression" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3757">The unary plus operator is not defined for <paramref name="expression" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ UnaryPlus(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member UnaryPlus : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.UnaryPlus (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-3758">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3758">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ed4d0-3759">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3759">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3760">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação unária de adição.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3760">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a unary plus operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3761">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3761">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-3762">O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3762">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="ed4d0-3763">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3763">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="ed4d0-3764">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3764">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="ed4d0-3765">Caso contrário, eles são falsos.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3765">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="ed4d0-3766">Implementando método</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3766">Implementing Method</span></span>  
 <span data-ttu-id="ed4d0-3767">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3767">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="ed4d0-3768">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que aceita um argumento, ele é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3768">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="ed4d0-3769">Se `expression`. Tipo é um tipo definido pelo usuário que define o operador unário de adição, o <xref:System.Reflection.MethodInfo> que representa que o método de implementação do operador é.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3769">If `expression`.Type is a user-defined type that defines the unary plus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-3770">Caso contrário, se `expression`. Tipo é um tipo numérico, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3770">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="ed4d0-3771">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3771">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="ed4d0-3772">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3772">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="ed4d0-3773">Se `expression`. O tipo é atribuível ao tipo de argumento do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3773">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-3774">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3774">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="ed4d0-3775">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3775">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="ed4d0-3776">`expression`. É um tipo de valor anulável e o tipo de valor não anulável correspondente é igual ao tipo de argumento do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3776">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="ed4d0-3777">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3777">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="ed4d0-3778">Se for o método de implementação `null`, o tipo de nó é `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3778">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="ed4d0-3779">Se `expression`. Tipo não anulável, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3779">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="ed4d0-3780">Caso contrário, o nó é eliminado.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3780">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ed4d0-3781">
            <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3781">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ed4d0-3782">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente um argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3782">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ed4d0-3783">
            <paramref name="method" /> é <see langword="null" /> e o operador unário de mais de não foi definido para <paramref name="expression" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3783">
              <paramref name="method" /> is <see langword="null" /> and the unary plus operator is not defined for <paramref name="expression" />.Type.</span>
          </span>
          <span data-ttu-id="ed4d0-3784">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3784">-or-</span>
          </span>
          <span data-ttu-id="ed4d0-3785">
            <paramref name="expression" />.Type (ou o respectivo tipo que não permite valor nulo correspondente se ele é um tipo que permite valor nulo) não é atribuível ao tipo de argumento do método representado por <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3785">
              <paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Unbox (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Unbox(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Unbox(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Unbox : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Unbox (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="ed4d0-3786">Um <see cref="T:System.Linq.Expressions.Expression" /> para realizar conversão unboxing.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3786">An <see cref="T:System.Linq.Expressions.Expression" /> to unbox.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="ed4d0-3787">O novo <see cref="T:System.Type" /> da expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3787">The new <see cref="T:System.Type" /> of the expression.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3788">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma conversão unboxing explícita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3788">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an explicit unboxing.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3789">Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3789">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Variable">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ed4d0-3790">Cria um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que pode ser usado para identificar um parâmetro ou uma variável em uma árvore de expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3790">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Variable(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Variable : Type -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Variable type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ed4d0-3791">O tipo do parâmetro ou da variável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3791">The type of the parameter or variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3792">Cria um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que pode ser usado para identificar um parâmetro ou uma variável em uma árvore de expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3792">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3793">Um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> com o nome e o tipo especificados</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3793">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> node with the specified name and type</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Variable(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Variable : Type * string -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Variable (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ed4d0-3794">O tipo do parâmetro ou da variável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3794">The type of the parameter or variable.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="ed4d0-3795">O nome do parâmetro ou da variável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3795">The name of the parameter or variable.</span>
          </span>
          <span data-ttu-id="ed4d0-3796">Esse nome é usado apenas para finalidades de depuração ou de impressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3796">This name is used for debugging or printing purpose only.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3797">Cria um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que pode ser usado para identificar um parâmetro ou uma variável em uma árvore de expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3797">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3798">Um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> com o nome e tipo especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3798">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> node with the specified name and type.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisitChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Linq.Expressions.Expression VisitChildren (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression VisitChildren(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function VisitChildren (visitor As ExpressionVisitor) As Expression" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Linq::Expressions::Expression ^ VisitChildren(System::Linq::Expressions::ExpressionVisitor ^ visitor);" />
      <MemberSignature Language="F#" Value="abstract member VisitChildren : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression&#xA;override this.VisitChildren : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression" Usage="expression.VisitChildren visitor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" />
      </Parameters>
      <Docs>
        <param name="visitor">
          <span data-ttu-id="ed4d0-3799">Uma instância de <see cref="T:System.Func`2" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3799">An instance of <see cref="T:System.Func`2" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ed4d0-3800">Reduz o nó e, em seguida, chama o delegado visitante na expressão reduzida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3800">Reduces the node and then calls the visitor delegate on the reduced expression.</span>
          </span>
          <span data-ttu-id="ed4d0-3801">O método gera uma exceção se o nó não é reduzível.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3801">The method throws an exception if the node is not reducible.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ed4d0-3802">A expressão que está sendo visitada ou uma expressão que deve substituí-la na árvore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ed4d0-3802">The expression being visited, or an expression which should replace it in the tree.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ed4d0-3803">Substitua este método para fornecer a lógica para percorrer os filhos do nó.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3803">Override this method to provide logic to walk the node's children.</span></span> <span data-ttu-id="ed4d0-3804">Uma implementação típica chamará o visitante. Visite em cada um dos seus filhos e se qualquer um dos-los de alteração, deve retornar uma nova cópia de si mesmo com os filhos modificados.</span><span class="sxs-lookup"><span data-stu-id="ed4d0-3804">A typical implementation will call visitor.Visit on each of its children, and if any of them change, should return a new copy of itself with the modified children.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>